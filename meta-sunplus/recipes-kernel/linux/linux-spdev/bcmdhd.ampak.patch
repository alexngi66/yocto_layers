diff -urN a/drivers/net/wireless/bcmdhd/bcmevent.c a/drivers/net/wireless/bcmdhd/bcmevent.c
--- a/drivers/net/wireless/bcmdhd/bcmevent.c	2020-01-13 17:57:01.268432667 +0300
+++ a/drivers/net/wireless/bcmdhd/bcmevent.c	2020-03-11 11:20:46.000000000 +0300
@@ -173,6 +173,9 @@
 #if defined(BT_WIFI_HANDOVER) || defined(WL_TBOW)
 	BCMEVENT_NAME(WLC_E_BT_WIFI_HANDOVER_REQ),
 #endif
+#ifdef WLFBT
+	BCMEVENT_NAME(WLC_E_FBT_AUTH_REQ_IND),
+#endif /* WLFBT */
 	BCMEVENT_NAME(WLC_E_AUTHORIZED),
 	BCMEVENT_NAME(WLC_E_PROBREQ_MSG_RX),
 	BCMEVENT_NAME(WLC_E_CSA_START_IND),
diff -urN a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
--- a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c	2020-01-13 17:57:01.269432667 +0300
+++ a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c	2020-01-20 18:12:48.000000000 +0300
@@ -84,6 +84,7 @@
 } bcmsdh_os_info_t;
 
 /* debugging macros */
+#define SDLX_ERR(x) printf x
 #define SDLX_MSG(x) printf x
 
 /**
@@ -146,12 +147,12 @@
 
 	bcmsdh = bcmsdh_attach(osh, sdioh, &regs);
 	if (bcmsdh == NULL) {
-		SDLX_MSG(("%s: bcmsdh_attach failed\n", __FUNCTION__));
+		SDLX_ERR(("%s: bcmsdh_attach failed\n", __FUNCTION__));
 		goto err;
 	}
 	bcmsdh_osinfo = MALLOC(osh, sizeof(bcmsdh_os_info_t));
 	if (bcmsdh_osinfo == NULL) {
-		SDLX_MSG(("%s: failed to allocate bcmsdh_os_info_t\n", __FUNCTION__));
+		SDLX_ERR(("%s: failed to allocate bcmsdh_os_info_t\n", __FUNCTION__));
 		goto err;
 	}
 	bzero((char *)bcmsdh_osinfo, sizeof(bcmsdh_os_info_t));
@@ -171,7 +172,7 @@
 	bcmsdh_osinfo->oob_irq_num = wifi_platform_get_irq_number(adapter_info,
 		&bcmsdh_osinfo->oob_irq_flags);
 	if  (bcmsdh_osinfo->oob_irq_num < 0) {
-		SDLX_MSG(("%s: Host OOB irq is not defined\n", __FUNCTION__));
+		SDLX_ERR(("%s: Host OOB irq is not defined\n", __FUNCTION__));
 		goto err;
 	}
 #endif /* defined(BCMLXSDMMC) */
@@ -182,7 +183,7 @@
 	bcmsdh_osinfo->context = drvinfo.probe((vendevid >> 16), (vendevid & 0xFFFF), bus_num,
 		slot_num, 0, bus_type, (void *)regs, osh, bcmsdh);
 	if (bcmsdh_osinfo->context == NULL) {
-		SDLX_MSG(("%s: device attach failed\n", __FUNCTION__));
+		SDLX_ERR(("%s: device attach failed\n", __FUNCTION__));
 		goto err;
 	}
 
@@ -285,7 +286,7 @@
 	SDLX_MSG(("%s: register client driver\n", __FUNCTION__));
 	error = bcmsdh_register_client_driver();
 	if (error)
-		SDLX_MSG(("%s: failed %d\n", __FUNCTION__, error));
+		SDLX_ERR(("%s: failed %d\n", __FUNCTION__, error));
 
 	return error;
 }
@@ -363,15 +364,15 @@
 	bcmsdh_os_info_t *bcmsdh_osinfo = bcmsdh->os_cxt;
 
 	if (bcmsdh_osinfo->oob_irq_registered) {
-		SDLX_MSG(("%s: irq is already registered\n", __FUNCTION__));
+		SDLX_ERR(("%s: irq is already registered\n", __FUNCTION__));
 		return -EBUSY;
 	}
 #ifdef HW_OOB
-	printf("%s: HW_OOB irq=%d flags=0x%X\n", __FUNCTION__,
-		(int)bcmsdh_osinfo->oob_irq_num, (int)bcmsdh_osinfo->oob_irq_flags);
+	SDLX_MSG(("%s: HW_OOB irq=%d flags=0x%X\n", __FUNCTION__,
+		(int)bcmsdh_osinfo->oob_irq_num, (int)bcmsdh_osinfo->oob_irq_flags));
 #else
-	printf("%s: SW_OOB irq=%d flags=0x%X\n", __FUNCTION__,
-		(int)bcmsdh_osinfo->oob_irq_num, (int)bcmsdh_osinfo->oob_irq_flags);
+	SDLX_MSG(("%s: SW_OOB irq=%d flags=0x%X\n", __FUNCTION__,
+		(int)bcmsdh_osinfo->oob_irq_num, (int)bcmsdh_osinfo->oob_irq_flags));
 #endif
 	bcmsdh_osinfo->oob_irq_handler = oob_irq_handler;
 	bcmsdh_osinfo->oob_irq_handler_context = oob_irq_handler_context;
@@ -385,7 +386,7 @@
 		bcmsdh_osinfo->oob_irq_flags, "bcmsdh_sdmmc", bcmsdh);
 #endif /* defined(CONFIG_ARCH_ODIN) */
 	if (err) {
-		SDLX_MSG(("%s: request_irq failed with %d\n", __FUNCTION__, err));
+		SDLX_ERR(("%s: request_irq failed with %d\n", __FUNCTION__, err));
 		bcmsdh_osinfo->oob_irq_enabled = FALSE;
 		bcmsdh_osinfo->oob_irq_registered = FALSE;
 		return err;
@@ -397,7 +398,7 @@
 #else
 	err = enable_irq_wake(bcmsdh_osinfo->oob_irq_num);
 	if (err)
-		SDLX_MSG(("%s: enable_irq_wake failed with %d\n", __FUNCTION__, err));
+		SDLX_ERR(("%s: enable_irq_wake failed with %d\n", __FUNCTION__, err));
 	else
 		bcmsdh_osinfo->oob_irq_wake_enabled = TRUE;
 #endif
diff -urN a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
--- a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c	2020-01-13 17:57:01.269432667 +0300
+++ a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c	2019-08-23 16:45:30.000000000 +0300
@@ -84,11 +84,6 @@
 static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, uint32 regaddr);
 #if defined(ENABLE_INSMOD_NO_FW_LOAD) && !defined(BUS_POWER_RESTORE)
 extern int sdio_reset_comm(struct mmc_card *card);
-#else
-int sdio_reset_comm(struct mmc_card *card)
-{
-	return 0;
-}
 #endif
 #ifdef GLOBAL_SDMMC_INSTANCE
 extern PBCMSDH_SDMMC_INSTANCE gInstance;
@@ -599,6 +594,7 @@
 		/* Now set it */
 		si->client_block_size[func] = blksize;
 
+#ifdef USE_DYNAMIC_F2_BLKSIZE
 		if (si->func[func] == NULL) {
 			sd_err(("%s: SDIO Device not present\n", __FUNCTION__));
 			bcmerror = BCME_NORESOURCE;
@@ -610,6 +606,7 @@
 			sd_err(("%s: Failed to set F%d blocksize to %d(%d)\n",
 				__FUNCTION__, func, blksize, bcmerror));
 		sdio_release_host(si->func[func]);
+#endif /* USE_DYNAMIC_F2_BLKSIZE */
 		break;
 	}
 
@@ -1603,11 +1600,13 @@
 		   2.6.27. The implementation prior to that is buggy, and needs broadcom's
 		   patch for it
 		*/
+#if defined(ENABLE_INSMOD_NO_FW_LOAD) && !defined(BUS_POWER_RESTORE)
 		if ((ret = sdio_reset_comm(sd->func[0]->card))) {
 			sd_err(("%s Failed, error = %d\n", __FUNCTION__, ret));
 			return ret;
-		}
-		else {
+		} else
+#endif
+		{
 			sd->num_funcs = 2;
 			sd->sd_blockmode = TRUE;
 			sd->use_client_ints = TRUE;
diff -urN a/drivers/net/wireless/bcmdhd/dhd_cdc.c a/drivers/net/wireless/bcmdhd/dhd_cdc.c
--- a/drivers/net/wireless/bcmdhd/dhd_cdc.c	2020-01-13 17:57:01.720432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_cdc.c	2019-08-20 14:28:14.000000000 +0300
@@ -116,7 +116,7 @@
 #endif /* BCMDBUS */
 
 #ifdef BCMDBUS
-	timeout = dhd_os_ioctl_resp_wait(dhd, &prot->ctl_completed, false);
+	timeout = dhd_os_ioctl_resp_wait(dhd, &prot->ctl_completed);
 	if ((!timeout) || (!prot->ctl_completed)) {
 		DHD_ERROR(("Txctl timeout %d ctl_completed %d\n",
 			timeout, prot->ctl_completed));
@@ -138,7 +138,7 @@
 			/* interrupt polling is sucessfully submitted. Wait for dongle to send
 			* interrupt
 			*/
-			timeout = dhd_os_ioctl_resp_wait(dhd, &prot->ctl_completed, false);
+			timeout = dhd_os_ioctl_resp_wait(dhd, &prot->ctl_completed);
 			if (!timeout) {
 				DHD_ERROR(("intr poll wait timed out\n"));
 			}
@@ -172,7 +172,7 @@
 			DHD_OS_IOCTL_RESP_UNLOCK(dhd);
 			goto done;
 		}
-		timeout = dhd_os_ioctl_resp_wait(dhd, &prot->ctl_completed, false);
+		timeout = dhd_os_ioctl_resp_wait(dhd, &prot->ctl_completed);
 		if ((!timeout) || (!prot->ctl_completed)) {
 			DHD_ERROR(("Rxctl timeout %d ctl_completed %d\n",
 				timeout, prot->ctl_completed));
diff -urN a/drivers/net/wireless/bcmdhd/dhd_common.c a/drivers/net/wireless/bcmdhd/dhd_common.c
--- a/drivers/net/wireless/bcmdhd/dhd_common.c	2020-01-13 17:57:01.724432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_common.c	2020-02-03 04:44:46.000000000 +0300
@@ -66,6 +66,8 @@
 #endif
 #ifdef PNO_SUPPORT
 #include <dhd_pno.h>
+#elif defined(WL_WIRELESS_EXT)
+#include <wl_iw.h>
 #endif
 #ifdef RTT_SUPPORT
 #include <dhd_rtt.h>
@@ -4226,6 +4228,8 @@
 		}
 	}
 
+	if (dhd->conf->suspend_bcn_li_dtim >= 0)
+		bcn_li_dtim = dhd->conf->suspend_bcn_li_dtim;
 	DHD_ERROR(("%s beacon=%d bcn_li_dtim=%d DTIM=%d Listen=%d\n",
 		__FUNCTION__, *bcn_interval, bcn_li_dtim, *dtim_period, CUSTOM_LISTEN_INTERVAL));
 
@@ -4270,7 +4274,6 @@
 		if (bcn_li_dtim == 0) {
 			bcn_li_dtim = 1;
 		}
-		bcn_li_dtim = MAX(dhd->suspend_bcn_li_dtim, bcn_li_dtim);
 	} else {
 		/* attemp to use platform defined dtim skip interval */
 		bcn_li_dtim = dhd->suspend_bcn_li_dtim;
@@ -5002,65 +5005,74 @@
 
 #if defined(DHD_8021X_DUMP)
 #define EAP_PRINT(x, args...) \
-	printk("[dhd-%s] ETHER_TYPE_802_1X[%s]: " x, ifname, direction ? "TX" : "RX", ## args);
+	do { \
+		if (dump_msg_level & DUMP_EAPOL_VAL) { \
+			printk("[dhd-%s] 802_1X " x " [%s] : (%s) %s (%s)\n", ifname, ## args, \
+			tx?"TX":"RX", tx?seabuf:deabuf, tx?"->":"<-", tx?deabuf:seabuf); \
+		} \
+	} while (0)
 #else
 #define EAP_PRINT(x, args...)
 #endif /* DHD_8021X_DUMP */
 /* Parse EAPOL 4 way handshake messages */
 void
 dhd_dump_eapol_4way_message(dhd_pub_t *dhd, char *ifname,
-	char *dump_data, bool direction)
+	char *dump_data, bool tx)
 {
 	unsigned char type;
 	int pair, ack, mic, kerr, req, sec, install;
 	unsigned short us_tmp, key_len;
+	char seabuf[ETHER_ADDR_STR_LEN]="";
+	char deabuf[ETHER_ADDR_STR_LEN]="";
+
+	bcm_ether_ntoa((struct ether_addr *)dump_data, deabuf);
+	bcm_ether_ntoa((struct ether_addr *)(dump_data+6), seabuf);
 
 	type = dump_data[15];
 	if (type == 0) {
 		if ((dump_data[22] == 1) && (dump_data[18] == 1)) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPS_REQID;
-			EAP_PRINT("EAP Packet, Request, Identity\n");
+			dhd->conf->eapol_status = EAPOL_STATUS_REQID;
+			EAP_PRINT("Request, Identity");
 		} else if ((dump_data[22] == 1) && (dump_data[18] == 2)) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPS_RSPID;
-			EAP_PRINT("EAP Packet, Response, Identity\n");
+			dhd->conf->eapol_status = EAPOL_STATUS_RSPID;
+			EAP_PRINT("Response, Identity");
 		} else if (dump_data[22] == 254) {
 			if (dump_data[30] == 1) {
-				dhd->conf->eapol_status = EAPOL_STATUS_WPS_WSC_START;
-				EAP_PRINT("EAP Packet, WSC Start\n");
+				dhd->conf->eapol_status = EAPOL_STATUS_WSC_START;
+				EAP_PRINT("WSC Start");
 			} else if (dump_data[30] == 4) {
 				if (dump_data[41] == 4) {
 					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M1;
-					EAP_PRINT("EAP Packet, WPS M1\n");
+					EAP_PRINT("WPS M1");
 				} else if (dump_data[41] == 5) {
 					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M2;
-					EAP_PRINT("EAP Packet, WPS M2\n");
+					EAP_PRINT("WPS M2");
 				} else if (dump_data[41] == 7) {
 					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M3;
-					EAP_PRINT("EAP Packet, WPS M3\n");
+					EAP_PRINT("WPS M3");
 				} else if (dump_data[41] == 8) {
 					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M4;
-					EAP_PRINT("EAP Packet, WPS M4\n");
+					EAP_PRINT("WPS M4");
 				} else if (dump_data[41] == 9) {
 					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M5;
-					EAP_PRINT("EAP Packet, WPS M5\n");
+					EAP_PRINT("WPS M5");
 				} else if (dump_data[41] == 10) {
 					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M6;
-					EAP_PRINT("EAP Packet, WPS M6\n");
+					EAP_PRINT("WPS M6");
 				} else if (dump_data[41] == 11) {
 					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M7;
-					EAP_PRINT("EAP Packet, WPS M7\n");
+					EAP_PRINT("WPS M7");
 				} else if (dump_data[41] == 12) {
 					dhd->conf->eapol_status = EAPOL_STATUS_WPS_M8;
-					EAP_PRINT("EAP Packet, WPS M8\n");
+					EAP_PRINT("WPS M8");
 				}
 			} else if (dump_data[30] == 5) {
-				dhd->conf->eapol_status = EAPOL_STATUS_WPS_DONE;
-				EAP_PRINT("EAP Packet, WSC Done\n");
+				dhd->conf->eapol_status = EAPOL_STATUS_WSC_DONE;
+				EAP_PRINT("WSC Done");
 			}
 		} else {
-			DHD_ERROR(("[dhd-%s] ETHER_TYPE_802_1X[%s]: ver %d, type %d, replay %d\n",
-				ifname, direction ? "TX" : "RX",
-				dump_data[14], dump_data[15], dump_data[30]));
+			EAP_PRINT("ver %d, type %d, replay %d",
+				dump_data[14], dump_data[15], dump_data[30]);
 		}
 	}
 	else if (type == 3 && dump_data[18] == 2) {
@@ -5074,22 +5086,20 @@
 		install  = 0 != (us_tmp & 0x40);
 
 		if (!req && !kerr && !sec && !mic && ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPA_M1;
-			EAP_PRINT("EAPOL Packet, WPA2 4-way handshake, M1(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M1;
+			EAP_PRINT("WPA2 4-way M1(0x%04x)", us_tmp);
 		} else if (!req && !kerr && !sec && mic && !ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPA_M2;
-			EAP_PRINT("EAPOL Packet, WPA2 4-way handshake, M2(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M2;
+			EAP_PRINT("WPA2 4-way M2(0x%04x)", us_tmp);
 		} else if (!req && !kerr && sec && mic && ack && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPA_M3;
-			EAP_PRINT("EAPOL Packet, WPA2 4-way handshake, M3(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M3;
+			EAP_PRINT("WPA2 4-way M3(0x%04x)", us_tmp);
 		} else if (!req && !kerr && sec && mic && !ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPA_M4;
-			EAP_PRINT("EAPOL Packet, WPA2 4-way handshake, M4(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M4;
+			EAP_PRINT("WPA2 4-way M4(0x%04x)", us_tmp);
 		} else {
-			DHD_ERROR(("[dhd-%s] ETHER_TYPE_802_1X[%s]: WPA2 ver %d, type %d, "
-				"key_type %d, key_info 0x%x, replay %d\n",
-				ifname, direction ? "TX" : "RX",
-				dump_data[14], dump_data[15], dump_data[18], us_tmp, dump_data[30]));
+			EAP_PRINT("ver %d, type %d, key_info 0x%x, replay %d",
+				dump_data[14], dump_data[15], us_tmp, dump_data[30]);
 		}
 	}
 	else if (type == 3 && dump_data[18] == 254) {
@@ -5104,31 +5114,30 @@
 		key_len = (dump_data[111] << 8) | dump_data[112];
 
 		if (!req && !kerr && !sec && !mic && ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPA_M1;
-			EAP_PRINT("EAPOL Packet, WPA 4-way handshake, M1(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M1;
+			EAP_PRINT("WPA 4-way M1(0x%04x)", us_tmp);
 		} else if (!req && !kerr && !sec && mic && !ack && !install && pair && key_len) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPA_M2;
-			EAP_PRINT("EAPOL Packet, WPA 4-way handshake, M2(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M2;
+			EAP_PRINT("WPA 4-way M2(0x%04x)", us_tmp);
 		} else if (!req && !kerr && !sec && mic && ack && install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPA_M3;
-			EAP_PRINT("EAPOL Packet, WPA 4-way handshake, M3(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M3;
+			EAP_PRINT("WPA 4-way M3(0x%04x)", us_tmp);
 		} else if (!req && !kerr && !sec && mic && !ack && !install && pair) {
-			dhd->conf->eapol_status = EAPOL_STATUS_WPA_M4;
-			EAP_PRINT("EAPOL Packet, WPA 4-way handshake, M4(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_M4;
+			EAP_PRINT("WPA 4-way M4(0x%04x)", us_tmp);
 		} else if (!req && !kerr && sec && mic && ack && !install && !pair) {
-			EAP_PRINT("EAPOL Packet, WPA 2-way handshake, M1(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_GROUPKEY_M1;
+			EAP_PRINT("GROUP Key M1(0x%04x)", us_tmp);
 		} else if (!req && !kerr && sec && mic && !ack && !install && !pair) {
-			EAP_PRINT("EAPOL Packet, WPA 2-way handshake, M2(0x%04x)\n", us_tmp);
+			dhd->conf->eapol_status = EAPOL_STATUS_GROUPKEY_M2;
+			EAP_PRINT("GROUP Key M2(0x%04x)", us_tmp);
 		} else {
-			DHD_ERROR(("[dhd-%s] ETHER_TYPE_802_1X[%s]: WPA ver %d, type %d, "
-				"key_type %d, key_info 0x%x, replay %d\n",
-				ifname, direction ? "TX" : "RX",
-				dump_data[14], dump_data[15], dump_data[18], us_tmp, dump_data[30]));
+			EAP_PRINT("ver %d, type %d, key_type %d, key_info 0x%x, replay %d",
+				dump_data[14], dump_data[15], dump_data[18], us_tmp, dump_data[30]);
 		}
 	} else {
-		DHD_ERROR(("[dhd-%s] ETHER_TYPE_802_1X[%s]: ver %d, type %d, key_type %d, replay %d\n",
-			ifname, direction ? "TX" : "RX",
-			dump_data[14], dump_data[15], dump_data[18], dump_data[30]));
+		EAP_PRINT("ver %d, type %d, replay %d",
+			dump_data[14], dump_data[15], dump_data[30]);
 	}
 }
 
diff -urN a/drivers/net/wireless/bcmdhd/dhd_config.c a/drivers/net/wireless/bcmdhd/dhd_config.c
--- a/drivers/net/wireless/bcmdhd/dhd_config.c	2020-01-13 17:57:01.726432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_config.c	2020-03-11 11:24:17.000000000 +0300
@@ -23,9 +23,10 @@
 /* message levels */
 #define CONFIG_ERROR_LEVEL	(1 << 0)
 #define CONFIG_TRACE_LEVEL	(1 << 1)
-#define CONFIG_MSG_LEVEL	(1 << 15)
+#define CONFIG_MSG_LEVEL	(1 << 0)
 
 uint config_msg_level = CONFIG_ERROR_LEVEL | CONFIG_MSG_LEVEL;
+uint dump_msg_level = 0;
 
 #define CONFIG_MSG(x, args...) \
 	do { \
@@ -46,8 +47,8 @@
 		} \
 	} while (0)
 
-#define MAXSZ_BUF		1000
-#define	MAXSZ_CONFIG	4096
+#define MAXSZ_BUF		4096
+#define MAXSZ_CONFIG	8192
 
 #ifndef WL_CFG80211
 #define htod32(i) i
@@ -95,6 +96,7 @@
 	{BCM43430_CHIP_ID,	2,	DONT_CARE,	"bcm43436b0",		""},
 	{BCM43012_CHIP_ID,	1,	FW_TYPE_G,	"bcm43013b0",		""},
 	{BCM43012_CHIP_ID,	1,	FW_TYPE_AG,	"bcm43013c0_ag",	""},
+	{BCM43012_CHIP_ID,	2,	DONT_CARE,	"bcm43013c1_ag",	""},
 	{BCM4334_CHIP_ID,	3,	DONT_CARE,	"bcm4334b1_ag",		""},
 	{BCM43340_CHIP_ID,	2,	DONT_CARE,	"bcm43341b0_ag",	""},
 	{BCM43341_CHIP_ID,	2,	DONT_CARE,	"bcm43341b0_ag",	""},
@@ -125,6 +127,18 @@
 #endif
 };
 
+void
+dhd_conf_free_chip_nv_path_list(wl_chip_nv_path_list_ctrl_t *chip_nv_list)
+{
+	CONFIG_TRACE("called\n");
+
+	if (chip_nv_list->m_chip_nv_path_head) {
+		CONFIG_TRACE("Free %p\n", chip_nv_list->m_chip_nv_path_head);
+		kfree(chip_nv_list->m_chip_nv_path_head);
+	}
+	chip_nv_list->count = 0;
+}
+
 #ifdef BCMSDIO
 void
 dhd_conf_free_mac_list(wl_mac_list_ctrl_t *mac_list)
@@ -145,18 +159,6 @@
 	mac_list->count = 0;
 }
 
-void
-dhd_conf_free_chip_nv_path_list(wl_chip_nv_path_list_ctrl_t *chip_nv_list)
-{
-	CONFIG_TRACE("called\n");
-
-	if (chip_nv_list->m_chip_nv_path_head) {
-		CONFIG_TRACE("Free %p\n", chip_nv_list->m_chip_nv_path_head);
-		kfree(chip_nv_list->m_chip_nv_path_head);
-	}
-	chip_nv_list->count = 0;
-}
-
 #if defined(HW_OOB) || defined(FORCE_WOWLAN)
 void
 dhd_conf_set_hw_oob_intr(bcmsdh_info_t *sdh, uint chip)
@@ -431,18 +433,37 @@
 #endif
 
 void
-dhd_conf_free_country_list(conf_country_list_t *country_list)
+dhd_conf_free_country_list(struct dhd_conf *conf)
 {
-	int i;
+	country_list_t *country = conf->country_head;
+	int count = 0;
 
 	CONFIG_TRACE("called\n");
-	for (i=0; i<country_list->count; i++) {
-		if (country_list->cspec[i]) {
-			CONFIG_TRACE("Free cspec %p\n", country_list->cspec[i]);
-			kfree(country_list->cspec[i]);
-		}
+	while (country) {
+		CONFIG_TRACE("Free cspec %s\n", country->cspec.country_abbrev);
+		conf->country_head = country->next;
+		kfree(country);
+		country = conf->country_head;
+		count++;
 	}
-	country_list->count = 0;
+	CONFIG_TRACE("%d country released\n", count);
+}
+
+void
+dhd_conf_free_mchan_list(struct dhd_conf *conf)
+{
+	mchan_params_t *mchan = conf->mchan;
+	int count = 0;
+
+	CONFIG_TRACE("called\n");
+	while (mchan) {
+		CONFIG_TRACE("Free cspec %p\n", mchan);
+		conf->mchan = mchan->next;
+		kfree(mchan);
+		mchan = conf->mchan;
+		count++;
+	}
+	CONFIG_TRACE("%d mchan released\n", count);
 }
 
 int
@@ -467,7 +488,7 @@
 		}
 	}
 #ifndef FW_PATH_AUTO_SELECT
-	return;
+	return DONT_CARE;
 #endif
 
 	/* find out the last '/' */
@@ -807,6 +828,110 @@
 	return ret;
 }
 
+static int
+dhd_conf_rsdb_mode(dhd_pub_t *dhd, char *buf)
+{
+	char *pch;
+	wl_config_t rsdb_mode_cfg = {1, 0};
+
+	pch = buf;
+	rsdb_mode_cfg.config = (int)simple_strtol(pch, NULL, 0);
+
+	if (pch) {
+		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "rsdb_mode", (char *)&rsdb_mode_cfg,
+			sizeof(rsdb_mode_cfg), TRUE);
+		CONFIG_MSG("rsdb_mode %d\n", rsdb_mode_cfg.config);
+	}
+
+	return 0;
+}
+
+typedef int (tpl_parse_t)(dhd_pub_t *dhd, char *buf);
+
+typedef struct iovar_tpl_t {
+	int cmd;
+	char *name;
+	tpl_parse_t *parse;
+} iovar_tpl_t;
+
+const iovar_tpl_t iovar_tpl_list[] = {
+	{WLC_SET_VAR,	"rsdb_mode",	dhd_conf_rsdb_mode},
+};
+
+static int iovar_tpl_parse(const iovar_tpl_t *tpl, int tpl_count,
+	dhd_pub_t *dhd, int cmd, char *name, char *buf)
+{
+	int i, ret = 0;
+
+	/* look for a matching code in the table */
+	for (i = 0; i < tpl_count; i++, tpl++) {
+		if (tpl->cmd == cmd && !strcmp(tpl->name, name))
+			break;
+	}
+	if (i < tpl_count && tpl->parse) {
+		ret = tpl->parse(dhd, buf);
+	} else {
+		ret = -1;
+	}
+
+	return ret;
+}
+
+bool
+dhd_conf_set_wl_cmd(dhd_pub_t *dhd, char *data, bool down)
+{
+	int cmd, val, ret = 0, len;
+	char name[32], *pch, *pick_tmp, *pick_tmp2, *pdata = NULL;
+
+	/* Process wl_preinit:
+	 * wl_preinit=[cmd]=[val], [cmd]=[val]
+	 * Ex: wl_preinit=86=0, mpc=0
+	 */
+
+	if (data == NULL)
+		return FALSE;
+
+	len = strlen(data);
+	pdata = kmalloc(len+1, GFP_KERNEL);
+	if (pdata == NULL) {
+		CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", len+1);
+		goto exit;
+	}
+	memset(pdata, 0, len+1);
+	strcpy(pdata, data);
+
+	pick_tmp = pdata;
+	while (pick_tmp && (pick_tmp2 = bcmstrtok(&pick_tmp, ",", 0)) != NULL) {
+		pch = bcmstrtok(&pick_tmp2, "=", 0);
+		if (!pch)
+			break;
+		if (*pch == ' ') {
+			pch++;
+		}
+		memset(name, 0 , sizeof (name));
+		cmd = (int)simple_strtol(pch, NULL, 0);
+		if (cmd == 0) {
+			cmd = WLC_SET_VAR;
+			strcpy(name, pch);
+		}
+		pch = bcmstrtok(&pick_tmp2, ",", 0);
+		if (!pch) {
+			break;
+		}
+		ret = iovar_tpl_parse(iovar_tpl_list, ARRAY_SIZE(iovar_tpl_list),
+			dhd, cmd, name, pch);
+		if (ret) {
+			val = (int)simple_strtol(pch, NULL, 0);
+			dhd_conf_set_intiovar(dhd, cmd, name, val, -1, down);
+		}
+	}
+
+exit:
+	if (pdata)
+		kfree(pdata);
+	return true;
+}
+
 int
 dhd_conf_get_band(dhd_pub_t *dhd)
 {
@@ -837,16 +962,24 @@
 int
 dhd_conf_map_country_list(dhd_pub_t *dhd, wl_country_t *cspec)
 {
-	int bcmerror = -1, i;
+	int bcmerror = -1;
 	struct dhd_conf *conf = dhd->conf;
-	conf_country_list_t *country_list = &conf->country_list;
+	country_list_t *country = conf->country_head;
 
-	for (i = 0; i < country_list->count; i++) {
-		if (!strncmp(cspec->country_abbrev, country_list->cspec[i]->country_abbrev, 2)) {
-			memcpy(cspec->ccode, country_list->cspec[i]->ccode, WLC_CNTRY_BUF_SZ);
-			cspec->rev = country_list->cspec[i]->rev;
+	while (country != NULL) {
+		if (!strncmp("**", country->cspec.country_abbrev, 2)) {
+			memcpy(cspec->ccode, country->cspec.ccode, WLC_CNTRY_BUF_SZ);
+			cspec->rev = country->cspec.rev;
 			bcmerror = 0;
+			break;
+		} else if (!strncmp(cspec->country_abbrev,
+				country->cspec.country_abbrev, 2)) {
+			memcpy(cspec->ccode, country->cspec.ccode, WLC_CNTRY_BUF_SZ);
+			cspec->rev = country->cspec.rev;
+			bcmerror = 0;
+			break;
 		}
+		country = country->next;
 	}
 
 	if (!bcmerror)
@@ -1209,18 +1342,19 @@
 void
 dhd_conf_set_mchan_bw(dhd_pub_t *dhd, int p2p_mode, int miracast_mode)
 {
-	int i;
 	struct dhd_conf *conf = dhd->conf;
+	mchan_params_t *mchan = conf->mchan;
 	bool set = true;
 
-	for (i=0; i<MCHAN_MAX_NUM; i++) {
+	while (mchan != NULL) {
 		set = true;
-		set &= (conf->mchan[i].bw >= 0);
-		set &= ((conf->mchan[i].p2p_mode == -1) | (conf->mchan[i].p2p_mode == p2p_mode));
-		set &= ((conf->mchan[i].miracast_mode == -1) | (conf->mchan[i].miracast_mode == miracast_mode));
+		set &= (mchan->bw >= 0);
+		set &= ((mchan->p2p_mode == -1) | (mchan->p2p_mode == p2p_mode));
+		set &= ((mchan->miracast_mode == -1) | (mchan->miracast_mode == miracast_mode));
 		if (set) {
-			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "mchan_bw", conf->mchan[i].bw, 0, FALSE);
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "mchan_bw", mchan->bw, 0, FALSE);
 		}
+		mchan = mchan->next;
 	}
 
 	return;
@@ -1326,8 +1460,7 @@
 			psleep = strstr(buf, "hostsleep");
 			if (psleep) {
 				*hostsleep_set = 1;
-				memcpy(hostsleep_val, psleep + strlen("hostsleep") + 1,
-					sizeof(int));
+				memcpy(hostsleep_val, psleep+strlen("hostsleep")+1, sizeof(int));
 			}
 		}
 		if (dhd->hostsleep && (!*hostsleep_set || *hostsleep_val)) {
@@ -1337,7 +1470,9 @@
 		} else if (*hostsleep_set && *hostsleep_val) {
 			CONFIG_TRACE("hostsleep %d => %d\n", dhd->hostsleep, *hostsleep_val);
 			dhd->hostsleep = *hostsleep_val;
-			dhd_txflowcontrol(dhd, ALL_INTERFACES, ON);
+			if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
+				dhd_txflowcontrol(dhd, ALL_INTERFACES, ON);
+			}
 			if (dhd->hostsleep == 2) {
 				*ret = 0;
 				goto exit;
@@ -1345,7 +1480,9 @@
 		} else if (dhd->hostsleep == 2 && !*hostsleep_val) {
 			CONFIG_TRACE("hostsleep %d => %d\n", dhd->hostsleep, *hostsleep_val);
 			dhd->hostsleep = *hostsleep_val;
-			dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+			if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
+				dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+			}
 			*ret = 0;
 			goto exit;
 		}
@@ -1365,18 +1502,21 @@
 			if (hostsleep_val && ret) {
 				CONFIG_TRACE("reset hostsleep %d => 0\n", dhd->hostsleep);
 				dhd->hostsleep = 0;
-				dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+				if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
+					dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+				}
 			} else if (!hostsleep_val && !ret) {
 				CONFIG_TRACE("set hostsleep %d => 0\n", dhd->hostsleep);
 				dhd->hostsleep = 0;
-				dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+				if (dhd->conf->insuspend & NO_TXDATA_IN_SUSPEND) {
+					dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+				}
 			}
 		}
 	}
 }
 
 #ifdef WL_EXT_WOWL
-extern int wl_pattern_atoh(char *src, char *dst);
 #define WL_WOWL_TCPFIN	(1 << 26)
 typedef struct wl_wowl_pattern2 {
 	char cmd[4];
@@ -1546,6 +1686,106 @@
 }
 #endif
 
+int
+dhd_conf_mkeep_alive(dhd_pub_t *dhd, int ifidx, int id, int period,
+	char *packet, bool bcast)
+{
+	wl_mkeep_alive_pkt_t *mkeep_alive_pktp;
+	int ret = 0, len_bytes=0, buf_len=0;
+	char *buf = NULL, *iovar_buf = NULL;
+	uint8 *pdata;
+
+	CONFIG_TRACE("id=%d, period=%d, packet=%s\n", id, period, packet);
+	if (period >= 0) {
+		buf = kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
+		if (buf == NULL) {
+			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
+			goto exit;
+		}
+		iovar_buf = kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
+		if (iovar_buf == NULL) {
+			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
+			goto exit;
+		}
+		mkeep_alive_pktp = (wl_mkeep_alive_pkt_t *)buf;
+		mkeep_alive_pktp->version = htod16(WL_MKEEP_ALIVE_VERSION);
+		mkeep_alive_pktp->length = htod16(WL_MKEEP_ALIVE_FIXED_LEN);
+		mkeep_alive_pktp->keep_alive_id = id;
+		buf_len += WL_MKEEP_ALIVE_FIXED_LEN;
+		mkeep_alive_pktp->period_msec = period;
+		if (packet && strlen(packet)) {
+			len_bytes = wl_pattern_atoh(packet, (char *)mkeep_alive_pktp->data);
+			buf_len += len_bytes;
+			if (bcast) {
+				memcpy(mkeep_alive_pktp->data, &ether_bcast, ETHER_ADDR_LEN);
+			}
+			ret = dhd_conf_get_iovar(dhd, ifidx, WLC_GET_VAR, "cur_etheraddr",
+				iovar_buf, WLC_IOCTL_SMLEN);
+			if (!ret) {
+				pdata = mkeep_alive_pktp->data;
+				memcpy(pdata+6, iovar_buf, ETHER_ADDR_LEN);
+			}
+		}
+		mkeep_alive_pktp->len_bytes = htod16(len_bytes);
+		ret = dhd_conf_set_bufiovar(dhd, ifidx, WLC_SET_VAR, "mkeep_alive",
+			buf, buf_len, FALSE);
+	}
+
+exit:
+	if (buf)
+		kfree(buf);
+	if (iovar_buf)
+		kfree(iovar_buf);
+	return ret;
+}
+
+#ifdef ARP_OFFLOAD_SUPPORT
+void
+dhd_conf_set_garp(dhd_pub_t *dhd, int ifidx, uint32 ipa, bool enable)
+{
+	int i, len = 0, total_len = WLC_IOCTL_SMLEN;
+	char *iovar_buf = NULL, *packet = NULL;
+
+	if (!dhd->conf->garp || ifidx != 0 || !(dhd->op_mode & DHD_FLAG_STA_MODE))
+		return;
+
+	CONFIG_TRACE("enable=%d\n", enable);
+
+	if (enable) {
+		iovar_buf = kmalloc(total_len, GFP_KERNEL);
+		if (iovar_buf == NULL) {
+			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", total_len);
+			goto exit;
+		}
+		packet = kmalloc(total_len, GFP_KERNEL);
+		if (packet == NULL) {
+			CONFIG_ERROR("Failed to allocate buffer of %d bytes\n", total_len);
+			goto exit;
+		}
+		dhd_conf_get_iovar(dhd, ifidx, WLC_GET_VAR, "cur_etheraddr", iovar_buf, total_len);
+
+		len += snprintf(packet+len, total_len, "0xffffffffffff");
+		for (i=0; i<ETHER_ADDR_LEN; i++)
+			len += snprintf(packet+len, total_len, "%02x", iovar_buf[i]);
+		len += snprintf(packet+len, total_len, "08060001080006040001");
+		for (i=0; i<ETHER_ADDR_LEN; i++)
+			len += snprintf(packet+len, total_len, "%02x", iovar_buf[i]);
+		len += snprintf(packet+len, total_len, "%02x%02x%02x%02x",
+			ipa&0xff, (ipa>>8)&0xff, (ipa>>16)&0xff, (ipa>>24)&0xff);
+		len += snprintf(packet+len, total_len, "ffffffffffffc0a80101000000000000000000000000000000000000");
+	}
+
+	dhd_conf_mkeep_alive(dhd, ifidx, 0, dhd->conf->keep_alive_period, packet, TRUE);
+
+exit:
+	if (iovar_buf)
+		kfree(iovar_buf);
+	if (packet)
+		kfree(packet);
+	return;
+}
+#endif
+
 uint
 dhd_conf_get_insuspend(dhd_pub_t *dhd, uint mask)
 {
@@ -1653,19 +1893,39 @@
 }
 #endif
 
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+static void
+dhd_conf_wait_event_complete(struct dhd_pub *dhd, int ifidx)
+{
+	s32 timeout = -1;
+
+	timeout = wait_event_interruptible_timeout(dhd->conf->event_complete,
+		wl_ext_event_complete(dhd, ifidx), msecs_to_jiffies(10000));
+	if (timeout <= 0 || !wl_ext_event_complete(dhd, ifidx)) {
+		wl_ext_event_complete(dhd, ifidx);
+		CONFIG_ERROR("timeout\n");
+	}
+}
+#endif
+
 int
 dhd_conf_set_suspend_resume(dhd_pub_t *dhd, int suspend)
 {
-	uint insuspend = 0;
 	struct dhd_conf *conf = dhd->conf;
+	uint insuspend = 0;
+	int pm;
+#ifdef BCMSDIO
+	uint32 intstatus = 0;
+	int ret = 0;
+#endif
 #ifdef WL_EXT_WOWL
 	int i;
 #endif
 
 	insuspend = dhd_conf_get_insuspend(dhd, ALL_IN_SUSPEND);
 	if (insuspend)
-		CONFIG_MSG("op_mode %d, suspend %d, suspended %d, insuspend 0x%x\n",
-			dhd->op_mode, suspend, conf->suspended, insuspend);
+		CONFIG_MSG("op_mode %d, suspend %d, suspended %d, insuspend 0x%x, suspend_mode=%d\n",
+			dhd->op_mode, suspend, conf->suspended, insuspend, conf->suspend_mode);
 
 	if (conf->suspended == suspend) {
 		return 0;
@@ -1673,6 +1933,10 @@
 
 	if (suspend) {
 		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_off",
+				dhd->conf->roam_off_suspend, 0, FALSE);
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bcn_li_dtim",
+				dhd->conf->suspend_bcn_li_dtim, 0, FALSE);
 			if (insuspend & ROAM_OFFLOAD_IN_SUSPEND)
 				dhd_conf_enable_roam_offload(dhd, 2);
 		} else if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
@@ -1680,14 +1944,36 @@
 				dhd_conf_set_intiovar(dhd, WLC_DOWN, "WLC_DOWN", 1, 0, FALSE);
 			}
 		}
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+		if (insuspend & (NO_EVENT_IN_SUSPEND|NO_TXCTL_IN_SUSPEND|WOWL_IN_SUSPEND)) {
+			if (conf->suspend_mode == PM_NOTIFIER)
+				dhd_conf_wait_event_complete(dhd, 0);
+		}
+#endif
+		if (insuspend & NO_TXDATA_IN_SUSPEND) {
+			dhd_txflowcontrol(dhd, ALL_INTERFACES, ON);
+		}
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+		if (insuspend & (NO_EVENT_IN_SUSPEND|NO_TXCTL_IN_SUSPEND|WOWL_IN_SUSPEND)) {
+			if (conf->suspend_mode == PM_NOTIFIER)
+				wl_ext_user_sync(dhd, 0, TRUE);
+		}
+#endif
 #ifdef SUSPEND_EVENT
 		if (insuspend & NO_EVENT_IN_SUSPEND) {
 			dhd_conf_set_suspend_event(dhd, suspend);
 		}
 #endif
-		if (insuspend & NO_TXDATA_IN_SUSPEND) {
-			dhd_txflowcontrol(dhd, ALL_INTERFACES, ON);
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			if (conf->pm_in_suspend >= 0)
+				pm = conf->pm_in_suspend;
+			else if (conf->pm >= 0)
+				pm = conf->pm;
+			else
+				pm = PM_FAST;
+			dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", pm, 0, FALSE);
 		}
+		dhd_conf_set_wl_cmd(dhd, conf->wl_suspend, FALSE);
 #ifdef WL_EXT_WOWL
 		if ((insuspend & WOWL_IN_SUSPEND) && dhd_master_mode) {
 			dhd_conf_wowl_pattern(dhd, FALSE, "clr");
@@ -1698,10 +1984,18 @@
 			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "wowl_activate", 1, 0, FALSE);
 			dhd_conf_wowl_wakeind(dhd, TRUE);
 			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "hostsleep", 1, 0, FALSE);
+#ifdef BCMSDIO
+			ret = dhd_bus_sleep(dhd, TRUE, &intstatus);
+			CONFIG_TRACE("ret = %d, intstatus = 0x%x\n", ret, intstatus);
+#endif
 		} else
 #endif
 		if (insuspend & NO_TXCTL_IN_SUSPEND) {
 			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "hostsleep", 2, 0, FALSE);
+#ifdef BCMSDIO
+			ret = dhd_bus_sleep(dhd, TRUE, &intstatus);
+			CONFIG_TRACE("ret = %d, intstatus = 0x%x\n", ret, intstatus);
+#endif
 		}
 		conf->suspended = TRUE;
 	} else {
@@ -1716,21 +2010,40 @@
 			dhd_conf_wowl_pattern(dhd, FALSE, "clr");
 		}
 #endif
+		dhd_conf_set_wl_cmd(dhd, conf->wl_resume, FALSE);
+		dhd_conf_get_iovar(dhd, 0, WLC_GET_PM, "WLC_GET_PM", (char *)&pm, sizeof(pm));
+		CONFIG_TRACE("PM in suspend = %d\n", pm);
 #ifdef SUSPEND_EVENT
 		if (insuspend & NO_EVENT_IN_SUSPEND) {
 			dhd_conf_set_suspend_event(dhd, suspend);
 		}
 #endif
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+		if (insuspend & (NO_EVENT_IN_SUSPEND|NO_TXCTL_IN_SUSPEND|WOWL_IN_SUSPEND)) {
+			if (conf->suspend_mode == PM_NOTIFIER)
+				wl_ext_user_sync(dhd, 0, FALSE);
+		}
+#endif
+		if (insuspend & NO_TXDATA_IN_SUSPEND) {
+			dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+		}
 		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
 			if (insuspend & ROAM_OFFLOAD_IN_SUSPEND)
 				dhd_conf_enable_roam_offload(dhd, 0);
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "bcn_li_dtim", 0, 0, FALSE);
+			dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "roam_off",
+				dhd->conf->roam_off, 0, FALSE);
 		} else if (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {
 			if (insuspend & AP_DOWN_IN_SUSPEND) {
 				dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
 			}
 		}
-		if (insuspend & NO_TXDATA_IN_SUSPEND) {
-			dhd_txflowcontrol(dhd, ALL_INTERFACES, OFF);
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			if (conf->pm >= 0)
+				pm = conf->pm;
+			else
+				pm = PM_FAST;
+			dhd_conf_set_intiovar(dhd, WLC_SET_PM, "WLC_SET_PM", pm, 0, FALSE);
 		}
 		conf->suspended = FALSE;
 	}
@@ -1789,7 +2102,7 @@
 #endif
 
 uint
-pick_config_vars(char *varbuf, uint len, uint start_pos, char *pickbuf)
+pick_config_vars(char *varbuf, uint len, uint start_pos, char *pickbuf, int picklen)
 {
 	bool findNewline, changenewline=FALSE, pick=FALSE;
 	int column;
@@ -1842,6 +2155,8 @@
 		if (pick) {
 			if (varbuf[n] == 0x9)
 				continue;
+			if (pick_column >= picklen)
+				break;
 			pickbuf[pick_column] = varbuf[n];
 			pick_column++;
 		}
@@ -1857,6 +2172,10 @@
 	char *data = full_param+len_param, *pick_tmp, *pch;
 	uint chip = 0, rev = 0;
 
+	/* Process chip, regrev:
+	 * chip=[chipid], rev==[rev]
+	 * Ex: chip=0x4359, rev=9
+	 */
 	if (!strncmp("chip=", full_param, len_param)) {
 		chip = (int)simple_strtol(data, NULL, 0);
 		pick_tmp = data;
@@ -1883,6 +2202,10 @@
 		dhd_msg_level = (int)simple_strtol(data, NULL, 0);
 		CONFIG_MSG("dhd_msg_level = 0x%X\n", dhd_msg_level);
 	}
+	else if (!strncmp("dump_msg_level=", full_param, len_param)) {
+		dump_msg_level = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("dump_msg_level = 0x%X\n", dump_msg_level);
+	}
 #ifdef BCMSDIO
 	else if (!strncmp("sd_msglevel=", full_param, len_param)) {
 		sd_msglevel = (int)simple_strtol(data, NULL, 0);
@@ -2028,6 +2351,7 @@
 	 */
 
 	if (!strncmp("fw_by_mac=", full_param, len_param)) {
+		dhd_conf_free_mac_list(&conf->fw_by_mac);
 		pick_tmp = data;
 		pch = bcmstrtok(&pick_tmp, " ", 0);
 		conf->fw_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
@@ -2084,6 +2408,7 @@
 	 * [nv_by_mac]: The same format as fw_by_mac
 	 */
 	if (!strncmp("nv_by_mac=", full_param, len_param)) {
+		dhd_conf_free_mac_list(&conf->nv_by_mac);
 		pick_tmp = data;
 		pch = bcmstrtok(&pick_tmp, " ", 0);
 		conf->nv_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
@@ -2143,6 +2468,7 @@
 	 *  43430 0 nvram_ap6212.txt 43430 1 nvram_ap6212a.txt \
 	 */
 	if (!strncmp("nv_by_chip=", full_param, len_param)) {
+		dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
 		pick_tmp = data;
 		pch = bcmstrtok(&pick_tmp, " ", 0);
 		conf->nv_by_chip.count = (uint32)simple_strtol(pch, NULL, 0);
@@ -2212,24 +2538,33 @@
 }
 
 bool
-dhd_conf_read_country_list(dhd_pub_t *dhd, char *full_param, uint len_param)
+dhd_conf_read_country(dhd_pub_t *dhd, char *full_param, uint len_param)
 {
-	int i;
-	char *pch, *pick_tmp, *pick_tmp2;
 	struct dhd_conf *conf = dhd->conf;
+	country_list_t *country_next = NULL, *country;
+	int i, count = 0;
+	char *pch, *pick_tmp, *pick_tmp2;
 	char *data = full_param+len_param;
-	wl_country_t *cspec;
-	conf_country_list_t *country_list = NULL;
+	uint len_data = strlen(data);
 
 	/* Process country_list:
 	 * country_list=[country1]:[ccode1]/[regrev1],
 	 * [country2]:[ccode2]/[regrev2] \
 	 * Ex: country_list=US:US/0, TW:TW/1
 	 */
-	if (!strncmp("country_list=", full_param, len_param)) {
-		country_list = &dhd->conf->country_list;
+	if (!strncmp("ccode=", full_param, len_param)) {
+		len_data = min((uint)WLC_CNTRY_BUF_SZ, len_data);
+		memset(&conf->cspec, 0, sizeof(wl_country_t));
+		memcpy(conf->cspec.country_abbrev, data, len_data);
+		memcpy(conf->cspec.ccode, data, len_data);
+		CONFIG_MSG("ccode = %s\n", conf->cspec.ccode);
+	}
+	else if (!strncmp("regrev=", full_param, len_param)) {
+		conf->cspec.rev = (int32)simple_strtol(data, NULL, 10);
+		CONFIG_MSG("regrev = %d\n", conf->cspec.rev);
 	}
-	if (country_list) {
+	else if (!strncmp("country_list=", full_param, len_param)) {
+		dhd_conf_free_country_list(conf);
 		pick_tmp = data;
 		for (i=0; i<CONFIG_COUNTRY_LIST_SIZE; i++) {
 			pick_tmp2 = bcmstrtok(&pick_tmp, ", ", 0);
@@ -2238,34 +2573,38 @@
 			pch = bcmstrtok(&pick_tmp2, ":", 0);
 			if (!pch)
 				break;
-			cspec = NULL;
-			if (!(cspec = kmalloc(sizeof(wl_country_t), GFP_KERNEL))) {
+			country = NULL;
+			if (!(country = kmalloc(sizeof(country_list_t), GFP_KERNEL))) {
 				CONFIG_ERROR("kmalloc failed\n");
 				break;
 			}
-			memset(cspec, 0, sizeof(wl_country_t));
+			memset(country, 0, sizeof(country_list_t));
 
-			strcpy(cspec->country_abbrev, pch);
+			memcpy(country->cspec.country_abbrev, pch, 2);
 			pch = bcmstrtok(&pick_tmp2, "/", 0);
 			if (!pch) {
-				kfree(cspec);
+				kfree(country);
 				break;
 			}
-			memcpy(cspec->ccode, pch, 2);
+			memcpy(country->cspec.ccode, pch, 2);
 			pch = bcmstrtok(&pick_tmp2, "/", 0);
 			if (!pch) {
-				kfree(cspec);
+				kfree(country);
 				break;
 			}
-			cspec->rev = (int32)simple_strtol(pch, NULL, 10);
-			country_list->count++;
-			country_list->cspec[i] = cspec;
-			CONFIG_TRACE("country_list abbrev=%s, ccode=%s, regrev=%d\n",
-				cspec->country_abbrev, cspec->ccode, cspec->rev);
-		}
-		if (!strncmp("country_list=", full_param, len_param)) {
-			CONFIG_MSG("%d country in list\n", conf->country_list.count);
+			country->cspec.rev = (int32)simple_strtol(pch, NULL, 10);
+			count++;
+			if (!conf->country_head) {
+				conf->country_head = country;
+				country_next = country;
+			} else {
+				country_next->next = country;
+				country_next = country;
+			}
+			CONFIG_TRACE("abbrev=%s, ccode=%s, regrev=%d\n",
+				country->cspec.country_abbrev, country->cspec.ccode, country->cspec.rev);
 		}
+		CONFIG_MSG("%d country in list\n", count);
 	}
 	else
 		return false;
@@ -2279,6 +2618,7 @@
 	int i;
 	char *pch, *pick_tmp, *pick_tmp2;
 	struct dhd_conf *conf = dhd->conf;
+	mchan_params_t *mchan_next = NULL, *mchan;
 	char *data = full_param+len_param;
 
 	/* Process mchan_bw:
@@ -2286,51 +2626,65 @@
 	 * Ex: mchan_bw=80/go/source, 30/gc/sink
 	 */
 	if (!strncmp("mchan_bw=", full_param, len_param)) {
+		dhd_conf_free_mchan_list(conf);
 		pick_tmp = data;
 		for (i=0; i<MCHAN_MAX_NUM; i++) {
 			pick_tmp2 = bcmstrtok(&pick_tmp, ", ", 0);
 			if (!pick_tmp2)
 				break;
 			pch = bcmstrtok(&pick_tmp2, "/", 0);
-			if (!pch) {
+			if (!pch)
+				break;
+
+			mchan = NULL;
+			if (!(mchan = kmalloc(sizeof(mchan_params_t), GFP_KERNEL))) {
+				CONFIG_ERROR("kmalloc failed\n");
+				break;
+			}
+			memset(mchan, 0, sizeof(mchan_params_t));
+
+			mchan->bw = (int)simple_strtol(pch, NULL, 0);
+			if (mchan->bw < 0 || mchan->bw > 100) {
+				CONFIG_ERROR("wrong bw %d\n", mchan->bw);
+				kfree(mchan);
 				break;
-			} else {
-				conf->mchan[i].bw = (int)simple_strtol(pch, NULL, 0);
-				if (conf->mchan[i].bw < 0 || conf->mchan[i].bw > 100) {
-					CONFIG_ERROR("wrong bw %d\n", conf->mchan[i].bw);
-					conf->mchan[i].bw = 0;
-					break;
-				}
 			}
+
 			pch = bcmstrtok(&pick_tmp2, "/", 0);
 			if (!pch) {
+				kfree(mchan);
 				break;
 			} else {
 				if (bcmstrstr(pch, "any")) {
-					conf->mchan[i].p2p_mode = -1;
+					mchan->p2p_mode = -1;
 				} else if (bcmstrstr(pch, "go")) {
-					conf->mchan[i].p2p_mode = WL_P2P_IF_GO;
+					mchan->p2p_mode = WL_P2P_IF_GO;
 				} else if (bcmstrstr(pch, "gc")) {
-					conf->mchan[i].p2p_mode = WL_P2P_IF_CLIENT;
+					mchan->p2p_mode = WL_P2P_IF_CLIENT;
 				}
 			}
 			pch = bcmstrtok(&pick_tmp2, "/", 0);
 			if (!pch) {
+				kfree(mchan);
 				break;
 			} else {
 				if (bcmstrstr(pch, "any")) {
-					conf->mchan[i].miracast_mode = -1;
+					mchan->miracast_mode = -1;
 				} else if (bcmstrstr(pch, "source")) {
-					conf->mchan[i].miracast_mode = MIRACAST_SOURCE;
+					mchan->miracast_mode = MIRACAST_SOURCE;
 				} else if (bcmstrstr(pch, "sink")) {
-					conf->mchan[i].miracast_mode = MIRACAST_SINK;
+					mchan->miracast_mode = MIRACAST_SINK;
 				}
 			}
-		}
-		for (i=0; i<MCHAN_MAX_NUM; i++) {
-			if (conf->mchan[i].bw >= 0)
-				CONFIG_MSG("mchan_bw=%d/%d/%d\n", conf->mchan[i].bw,
-					conf->mchan[i].p2p_mode, conf->mchan[i].miracast_mode);
+			if (!conf->mchan) {
+				conf->mchan = mchan;
+				mchan_next = mchan;
+			} else {
+				mchan_next->next = mchan;
+				mchan_next = mchan;
+			}
+			CONFIG_TRACE("mchan_bw=%d/%d/%d\n", mchan->bw,mchan->p2p_mode,
+				mchan->miracast_mode);
 		}
 	}
 	else
@@ -2390,6 +2744,10 @@
 		printf("\n");
 	}
 	else if (!strncmp("magic_pkt_filter_add=", full_param, len_param)) {
+		if (conf->magic_pkt_filter_add) {
+			kfree(conf->magic_pkt_filter_add);
+			conf->magic_pkt_filter_add = NULL;
+		}
 		if (!(conf->magic_pkt_filter_add = kmalloc(MAGIC_PKT_FILTER_LEN, GFP_KERNEL))) {
 			CONFIG_ERROR("kmalloc failed\n");
 		} else {
@@ -2532,10 +2890,6 @@
 		conf->txinrx_thres = (int)simple_strtol(data, NULL, 10);
 		CONFIG_MSG("txinrx_thres = %d\n", conf->txinrx_thres);
 	}
-	else if (!strncmp("sd_f2_blocksize=", full_param, len_param)) {
-		conf->sd_f2_blocksize = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("sd_f2_blocksize = %d\n", conf->sd_f2_blocksize);
-	}
 #if defined(HW_OOB)
 	else if (!strncmp("oob_enabled_later=", full_param, len_param)) {
 		if (!strncmp(data, "0", 1))
@@ -2669,6 +3023,12 @@
 		conf->pm_in_suspend = (int)simple_strtol(data, NULL, 10);
 		CONFIG_MSG("pm_in_suspend = %d\n", conf->pm_in_suspend);
 	}
+	else if (!strncmp("suspend_mode=", full_param, len_param)) {
+		conf->suspend_mode = (int)simple_strtol(data, NULL, 0);
+		CONFIG_MSG("suspend_mode = %d\n", conf->suspend_mode);
+		if (conf->suspend_mode == PM_NOTIFIER)
+			conf->insuspend |= (NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND);
+	}
 	else if (!strncmp("suspend_bcn_li_dtim=", full_param, len_param)) {
 		conf->suspend_bcn_li_dtim = (int)simple_strtol(data, NULL, 10);
 		CONFIG_MSG("suspend_bcn_li_dtim = %d\n", conf->suspend_bcn_li_dtim);
@@ -2719,7 +3079,6 @@
 {
 	struct dhd_conf *conf = dhd->conf;
 	char *data = full_param+len_param;
-	uint len_data = strlen(data);
 	char *pch, *pick_tmp;
 	int i;
 #ifdef GET_CUSTOM_MAC_FROM_CONFIG
@@ -2771,17 +3130,6 @@
 			CONFIG_MSG("bw_cap 5g = %d\n", conf->bw_cap[1]);
 		}
 	}
-	else if (!strncmp("ccode=", full_param, len_param)) {
-		len_data = min((uint)WLC_CNTRY_BUF_SZ, len_data);
-		memset(&conf->cspec, 0, sizeof(wl_country_t));
-		memcpy(conf->cspec.country_abbrev, data, len_data);
-		memcpy(conf->cspec.ccode, data, len_data);
-		CONFIG_MSG("ccode = %s\n", conf->cspec.ccode);
-	}
-	else if (!strncmp("regrev=", full_param, len_param)) {
-		conf->cspec.rev = (int32)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("regrev = %d\n", conf->cspec.rev);
-	}
 	else if (!strncmp("channels=", full_param, len_param)) {
 		pick_tmp = data;
 		pch = bcmstrtok(&pick_tmp, " ,.-", 0);
@@ -2801,10 +3149,15 @@
 		conf->keep_alive_period = (uint)simple_strtol(data, NULL, 10);
 		CONFIG_MSG("keep_alive_period = %d\n", conf->keep_alive_period);
 	}
-	else if (!strncmp("phy_oclscdenable=", full_param, len_param)) {
-		conf->phy_oclscdenable = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("phy_oclscdenable = %d\n", conf->phy_oclscdenable);
+#ifdef ARP_OFFLOAD_SUPPORT
+	else if (!strncmp("garp=", full_param, len_param)) {
+		if (!strncmp(data, "0", 1))
+			conf->garp = FALSE;
+		else
+			conf->garp = TRUE;
+		CONFIG_MSG("garp = %d\n", conf->garp);
 	}
+#endif
 	else if (!strncmp("srl=", full_param, len_param)) {
 		conf->srl = (int)simple_strtol(data, NULL, 10);
 		CONFIG_MSG("srl = %d\n", conf->srl);
@@ -2817,10 +3170,6 @@
 		conf->bcn_timeout= (uint)simple_strtol(data, NULL, 10);
 		CONFIG_MSG("bcn_timeout = %d\n", conf->bcn_timeout);
 	}
-	else if (!strncmp("txbf=", full_param, len_param)) {
-		conf->txbf = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("txbf = %d\n", conf->txbf);
-	}
 	else if (!strncmp("frameburst=", full_param, len_param)) {
 		conf->frameburst = (int)simple_strtol(data, NULL, 10);
 		CONFIG_MSG("frameburst = %d\n", conf->frameburst);
@@ -2861,20 +3210,15 @@
 		conf->ctrl_resched = (int)simple_strtol(data, NULL, 10);
 		CONFIG_MSG("ctrl_resched = %d\n", conf->ctrl_resched);
 	}
-	else if (!strncmp("dhd_ioctl_timeout_msec=", full_param, len_param)) {
-		conf->dhd_ioctl_timeout_msec = (int)simple_strtol(data, NULL, 10);
-		CONFIG_MSG("dhd_ioctl_timeout_msec = %d\n",
-			conf->dhd_ioctl_timeout_msec);
-	}
 	else if (!strncmp("in4way=", full_param, len_param)) {
 		conf->in4way = (int)simple_strtol(data, NULL, 0);
 		CONFIG_MSG("in4way = 0x%x\n", conf->in4way);
 	}
-	else if (!strncmp("max_wait_gc_time=", full_param, len_param)) {
-		conf->max_wait_gc_time = (int)simple_strtol(data, NULL, 0);
-		CONFIG_MSG("max_wait_gc_time = %d\n", conf->max_wait_gc_time);
-	}
 	else if (!strncmp("wl_preinit=", full_param, len_param)) {
+		if (conf->wl_preinit) {
+			kfree(conf->wl_preinit);
+			conf->wl_preinit = NULL;
+		}
 		if (!(conf->wl_preinit = kmalloc(len_param+1, GFP_KERNEL))) {
 			CONFIG_ERROR("kmalloc failed\n");
 		} else {
@@ -2883,6 +3227,32 @@
 			CONFIG_MSG("wl_preinit = %s\n", conf->wl_preinit);
 		}
 	}
+	else if (!strncmp("wl_suspend=", full_param, len_param)) {
+		if (conf->wl_suspend) {
+			kfree(conf->wl_suspend);
+			conf->wl_suspend = NULL;
+		}
+		if (!(conf->wl_suspend = kmalloc(len_param+1, GFP_KERNEL))) {
+			CONFIG_ERROR("kmalloc failed\n");
+		} else {
+			memset(conf->wl_suspend, 0, len_param+1);
+			strcpy(conf->wl_suspend, data);
+			CONFIG_MSG("wl_suspend = %s\n", conf->wl_suspend);
+		}
+	}
+	else if (!strncmp("wl_resume=", full_param, len_param)) {
+		if (conf->wl_resume) {
+			kfree(conf->wl_resume);
+			conf->wl_resume = NULL;
+		}
+		if (!(conf->wl_resume = kmalloc(len_param+1, GFP_KERNEL))) {
+			CONFIG_ERROR("kmalloc failed\n");
+		} else {
+			memset(conf->wl_resume, 0, len_param+1);
+			strcpy(conf->wl_resume, data);
+			CONFIG_MSG("wl_resume = %s\n", conf->wl_resume);
+		}
+	}
 #ifdef GET_CUSTOM_MAC_FROM_CONFIG
 	else if (!strncmp("mac=", full_param, len_param)) {
 		if (!bcm_ether_atoe(data, &ea_addr)) {
@@ -2918,9 +3288,9 @@
 dhd_conf_read_config(dhd_pub_t *dhd, char *conf_path)
 {
 	int bcmerror = -1, chip_match = -1;
-	uint len = 0, start_pos=0;
-	void * image = NULL;
-	char * memblock = NULL;
+	uint len = 0, start_pos=0, end_pos=0;
+	void *image = NULL;
+	char *memblock = NULL;
 	char *bufp, *pick = NULL, *pch;
 	bool conf_file_exists;
 	uint len_param;
@@ -2961,7 +3331,10 @@
 
 		while (start_pos < len) {
 			memset(pick, 0, MAXSZ_BUF);
-			start_pos = pick_config_vars(bufp, len, start_pos, pick);
+			end_pos = pick_config_vars(bufp, len, start_pos, pick, MAXSZ_BUF);
+			if (end_pos - start_pos >= MAXSZ_BUF)
+				CONFIG_ERROR("out of buf to read MAXSIZ_BUF=%d\n", MAXSZ_BUF);
+			start_pos = end_pos;
 			pch = strchr(pick, '=');
 			if (pch != NULL) {
 				len_param = pch-pick+1;
@@ -2992,7 +3365,7 @@
 #endif
 			else if (dhd_conf_read_nv_by_chip(dhd, pick, len_param))
 				continue;
-			else if (dhd_conf_read_country_list(dhd, pick, len_param))
+			else if (dhd_conf_read_country(dhd, pick, len_param))
 				continue;
 			else if (dhd_conf_read_mchan_params(dhd, pick, len_param))
 				continue;
@@ -3109,94 +3482,6 @@
 }
 #endif
 
-static int
-dhd_conf_rsdb_mode(dhd_pub_t *dhd, char *buf)
-{
-	char *pch;
-	wl_config_t rsdb_mode_cfg = {1, 0};
-
-	pch = buf;
-	rsdb_mode_cfg.config = (int)simple_strtol(pch, NULL, 0);
-
-	if (pch) {
-		dhd_conf_set_bufiovar(dhd, 0, WLC_SET_VAR, "rsdb_mode", (char *)&rsdb_mode_cfg,
-			sizeof(rsdb_mode_cfg), TRUE);
-		CONFIG_MSG("rsdb_mode %d\n", rsdb_mode_cfg.config);
-	}
-
-	return 0;
-}
-
-typedef int (tpl_parse_t)(dhd_pub_t *dhd, char *buf);
-
-typedef struct iovar_tpl_t {
-	int cmd;
-	char *name;
-	tpl_parse_t *parse;
-} iovar_tpl_t;
-
-const iovar_tpl_t iovar_tpl_list[] = {
-	{WLC_SET_VAR,	"rsdb_mode",	dhd_conf_rsdb_mode},
-};
-
-static int iovar_tpl_parse(const iovar_tpl_t *tpl, int tpl_count,
-	dhd_pub_t *dhd, int cmd, char *name, char *buf)
-{
-	int i, ret = 0;
-
-	/* look for a matching code in the table */
-	for (i = 0; i < tpl_count; i++, tpl++) {
-		if (tpl->cmd == cmd && !strcmp(tpl->name, name))
-			break;
-	}
-	if (i < tpl_count && tpl->parse) {
-		ret = tpl->parse(dhd, buf);
-	} else {
-		ret = -1;
-	}
-
-	return ret;
-}
-
-bool
-dhd_conf_set_wl_preinit(dhd_pub_t *dhd, char *data)
-{
-	int cmd, val, ret = 0;
-	char name[32], *pch, *pick_tmp, *pick_tmp2;
-
-	/* Process wl_preinit:
-	 * wl_preinit=[cmd]=[val], [cmd]=[val]
-	 * Ex: wl_preinit=86=0, mpc=0
-	 */
-	pick_tmp = data;
-	while (pick_tmp && (pick_tmp2 = bcmstrtok(&pick_tmp, ",", 0)) != NULL) {
-		pch = bcmstrtok(&pick_tmp2, "=", 0);
-		if (!pch)
-			break;
-		if (*pch == ' ') {
-			pch++;
-		}
-		memset(name, 0 , sizeof (name));
-		cmd = (int)simple_strtol(pch, NULL, 0);
-		if (cmd == 0) {
-			cmd = WLC_SET_VAR;
-			strcpy(name, pch);
-		}
-		pch = bcmstrtok(&pick_tmp2, ",", 0);
-		if (!pch) {
-			break;
-		}
-		ret = iovar_tpl_parse(iovar_tpl_list, ARRAY_SIZE(iovar_tpl_list),
-			dhd, cmd, name, pch);
-		if (ret) {
-			val = (int)simple_strtol(pch, NULL, 0);
-			dhd_conf_set_intiovar(dhd, cmd, name, val, -1, TRUE);
-		}
-	}
-
-	return true;
-}
-
 void
 dhd_conf_postinit_ioctls(dhd_pub_t *dhd)
 {
@@ -3238,18 +3523,22 @@
 			conf->dhcpd_enable, 0, FALSE);
 	}
 #endif
-	dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "txbf", conf->txbf, 0, FALSE);
 	dhd_conf_set_intiovar(dhd, WLC_SET_FAKEFRAG, "WLC_SET_FAKEFRAG",
 		conf->frameburst, 0, FALSE);
 
-	dhd_conf_set_wl_preinit(dhd, wl_preinit);
+	dhd_conf_set_wl_cmd(dhd, wl_preinit, TRUE);
 #if defined(BCMSDIO)
 	{
 		char ampdu_mpdu[] = "ampdu_mpdu=16";
-		dhd_conf_set_wl_preinit(dhd, ampdu_mpdu);
+		dhd_conf_set_wl_cmd(dhd, ampdu_mpdu, TRUE);
 	}
 #endif
-	dhd_conf_set_wl_preinit(dhd, conf->wl_preinit);
+	if (conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
+			conf->chip == BCM4371_CHIP_ID || conf->chip == BCM4359_CHIP_ID ||
+			conf->chip == BCM43569_CHIP_ID) {
+		dhd_conf_set_intiovar(dhd, WLC_SET_VAR, "txbf", 1, 0, FALSE);
+	}
+	dhd_conf_set_wl_cmd(dhd, conf->wl_preinit, TRUE);
 
 #ifndef WL_CFG80211
 	dhd_conf_set_intiovar(dhd, WLC_UP, "WLC_UP", 0, 0, FALSE);
@@ -3261,16 +3550,16 @@
 dhd_conf_preinit(dhd_pub_t *dhd)
 {
 	struct dhd_conf *conf = dhd->conf;
-	int i;
 
 	CONFIG_TRACE("Enter\n");
 
 #ifdef BCMSDIO
 	dhd_conf_free_mac_list(&conf->fw_by_mac);
 	dhd_conf_free_mac_list(&conf->nv_by_mac);
-	dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
 #endif
-	dhd_conf_free_country_list(&conf->country_list);
+	dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
+	dhd_conf_free_country_list(conf);
+	dhd_conf_free_mchan_list(conf);
 	if (conf->magic_pkt_filter_add) {
 		kfree(conf->magic_pkt_filter_add);
 		conf->magic_pkt_filter_add = NULL;
@@ -3279,7 +3568,14 @@
 		kfree(conf->wl_preinit);
 		conf->wl_preinit = NULL;
 	}
-	memset(&conf->country_list, 0, sizeof(conf_country_list_t));
+	if (conf->wl_suspend) {
+		kfree(conf->wl_suspend);
+		conf->wl_suspend = NULL;
+	}
+	if (conf->wl_resume) {
+		kfree(conf->wl_resume);
+		conf->wl_resume = NULL;
+	}
 	conf->band = -1;
 	memset(&conf->bw_cap, -1, sizeof(conf->bw_cap));
 	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID) {
@@ -3301,34 +3597,20 @@
 	memset(&conf->channels, 0, sizeof(wl_channel_list_t));
 	conf->roam_off = 1;
 	conf->roam_off_suspend = 1;
-#ifdef CUSTOM_ROAM_TRIGGER_SETTING
-	conf->roam_trigger[0] = CUSTOM_ROAM_TRIGGER_SETTING;
-#else
 	conf->roam_trigger[0] = -65;
-#endif
 	conf->roam_trigger[1] = WLC_BAND_ALL;
 	conf->roam_scan_period[0] = 10;
 	conf->roam_scan_period[1] = WLC_BAND_ALL;
-#ifdef CUSTOM_ROAM_DELTA_SETTING
-	conf->roam_delta[0] = CUSTOM_ROAM_DELTA_SETTING;
-#else
-	conf->roam_delta[0] = 15;
-#endif
+	conf->roam_delta[0] = 10;
 	conf->roam_delta[1] = WLC_BAND_ALL;
-#ifdef FULL_ROAMING_SCAN_PERIOD_60_SEC
-	conf->fullroamperiod = 60;
-#else /* FULL_ROAMING_SCAN_PERIOD_60_SEC */
-	conf->fullroamperiod = 120;
-#endif /* FULL_ROAMING_SCAN_PERIOD_60_SEC */
-#ifdef CUSTOM_KEEP_ALIVE_SETTING
-	conf->keep_alive_period = CUSTOM_KEEP_ALIVE_SETTING;
-#else
-	conf->keep_alive_period = 28000;
+	conf->fullroamperiod = 20;
+	conf->keep_alive_period = 30000;
+#ifdef ARP_OFFLOAD_SUPPORT
+	conf->garp = FALSE;
 #endif
 	conf->force_wme_ac = 0;
 	memset(&conf->wme_sta, 0, sizeof(wme_param_t));
 	memset(&conf->wme_ap, 0, sizeof(wme_param_t));
-	conf->phy_oclscdenable = -1;
 #ifdef PKT_FILTER_SUPPORT
 	memset(&conf->pkt_filter_add, 0, sizeof(conf_pkt_filter_add_t));
 	memset(&conf->pkt_filter_del, 0, sizeof(conf_pkt_filter_del_t));
@@ -3336,7 +3618,6 @@
 	conf->srl = -1;
 	conf->lrl = -1;
 	conf->bcn_timeout = 16;
-	conf->txbf = -1;
 	conf->disable_proptx = -1;
 	conf->dhd_poll = -1;
 #ifdef BCMSDIO
@@ -3346,15 +3627,12 @@
 	conf->tx_max_offset = 0;
 	conf->txglomsize = SDPCM_DEFGLOM_SIZE;
 	conf->txctl_tmo_fix = 300;
-	//conf->txglom_mode = SDPCM_TXGLOM_MDESC;
 	conf->txglom_mode = SDPCM_TXGLOM_CPY;
 	conf->deferred_tx_len = 0;
 	conf->dhd_txminmax = 1;
 	conf->txinrx_thres = -1;
-	conf->sd_f2_blocksize = 0;
 #if defined(SDIO_ISR_THREAD)
-  //conf->intr_extn = FALSE;
-	conf->intr_extn = TRUE;
+	conf->intr_extn = FALSE;
 #endif
 #ifdef BCMSDIO_RXLIM_POST
 	conf->rxlim_en = TRUE;
@@ -3372,14 +3650,16 @@
 	conf->deepsleep = FALSE;
 	conf->pm = -1;
 	conf->pm_in_suspend = -1;
+	conf->insuspend = 0;
+	conf->suspend_mode = EARLY_SUSPEND;
 	conf->suspend_bcn_li_dtim = -1;
 #ifdef WL_EXT_WOWL
 	dhd_master_mode = TRUE;
 	conf->wowl = WL_WOWL_NET|WL_WOWL_DIS|WL_WOWL_BCN;
-	conf->insuspend = WOWL_IN_SUSPEND | NO_TXDATA_IN_SUSPEND;
-#else
-	conf->insuspend = 0;
+	conf->insuspend |= (WOWL_IN_SUSPEND | NO_TXDATA_IN_SUSPEND);
 #endif
+	if (conf->suspend_mode == PM_NOTIFIER)
+		conf->insuspend |= (NO_TXDATA_IN_SUSPEND | NO_TXCTL_IN_SUSPEND);
 	conf->suspended = FALSE;
 #ifdef SUSPEND_EVENT
 	memset(&conf->resume_eventmask, 0, sizeof(conf->resume_eventmask));
@@ -3408,17 +3688,22 @@
 #endif
 	conf->pktprio8021x = -1;
 	conf->ctrl_resched = 2;
-	conf->dhd_ioctl_timeout_msec = 0;
 	conf->in4way = NO_SCAN_IN4WAY | WAIT_DISCONNECTED;
-	conf->max_wait_gc_time = 300;
 #ifdef ISAM_PREINIT
 	memset(conf->isam_init, 0, sizeof(conf->isam_init));
 	memset(conf->isam_config, 0, sizeof(conf->isam_config));
 	memset(conf->isam_enable, 0, sizeof(conf->isam_enable));
 #endif
-	for (i=0; i<MCHAN_MAX_NUM; i++) {
-		memset(&conf->mchan[i], -1, sizeof(mchan_params_t));
+#if defined(SDIO_ISR_THREAD)
+	if (conf->chip == BCM43012_CHIP_ID ||
+			conf->chip == BCM4335_CHIP_ID || conf->chip == BCM4339_CHIP_ID ||
+			conf->chip == BCM43454_CHIP_ID || conf->chip == BCM4345_CHIP_ID ||
+			conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
+			conf->chip == BCM4345_CHIP_ID || conf->chip == BCM4371_CHIP_ID ||
+			conf->chip == BCM4359_CHIP_ID) {
+		conf->intr_extn = TRUE;
 	}
+#endif
 	if ((conf->chip == BCM43430_CHIP_ID && conf->chiprev == 2) ||
 			conf->chip == BCM43012_CHIP_ID ||
 			conf->chip == BCM4335_CHIP_ID || conf->chip == BCM4339_CHIP_ID ||
@@ -3435,12 +3720,10 @@
 		dhd_rxbound = 128;
 		dhd_txbound = 64;
 #endif
-		conf->txbf = 1;
 		conf->frameburst = 1;
 #ifdef BCMSDIO
 		conf->dhd_txminmax = -1;
 		conf->txinrx_thres = 128;
-		conf->sd_f2_blocksize = CUSTOM_SDIO_F2_BLKSIZE;
 #endif
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 		conf->orphan_move = 1;
@@ -3471,6 +3754,7 @@
 	if (conf->txglomsize > SDPCM_MAXGLOM_SIZE)
 		conf->txglomsize = SDPCM_MAXGLOM_SIZE;
 #endif
+	init_waitqueue_head(&conf->event_complete);
 
 	return 0;
 }
@@ -3478,21 +3762,32 @@
 int
 dhd_conf_reset(dhd_pub_t *dhd)
 {
+	struct dhd_conf *conf = dhd->conf;
+
 #ifdef BCMSDIO
-	dhd_conf_free_mac_list(&dhd->conf->fw_by_mac);
-	dhd_conf_free_mac_list(&dhd->conf->nv_by_mac);
-	dhd_conf_free_chip_nv_path_list(&dhd->conf->nv_by_chip);
+	dhd_conf_free_mac_list(&conf->fw_by_mac);
+	dhd_conf_free_mac_list(&conf->nv_by_mac);
 #endif
-	dhd_conf_free_country_list(&dhd->conf->country_list);
-	if (dhd->conf->magic_pkt_filter_add) {
-		kfree(dhd->conf->magic_pkt_filter_add);
-		dhd->conf->magic_pkt_filter_add = NULL;
+	dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
+	dhd_conf_free_country_list(conf);
+	dhd_conf_free_mchan_list(conf);
+	if (conf->magic_pkt_filter_add) {
+		kfree(conf->magic_pkt_filter_add);
+		conf->magic_pkt_filter_add = NULL;
+	}
+	if (conf->wl_preinit) {
+		kfree(conf->wl_preinit);
+		conf->wl_preinit = NULL;
 	}
-	if (dhd->conf->wl_preinit) {
-		kfree(dhd->conf->wl_preinit);
-		dhd->conf->wl_preinit = NULL;
+	if (conf->wl_suspend) {
+		kfree(conf->wl_suspend);
+		conf->wl_suspend = NULL;
+	}
+	if (conf->wl_resume) {
+		kfree(conf->wl_resume);
+		conf->wl_resume = NULL;
 	}
-	memset(dhd->conf, 0, sizeof(dhd_conf_t));
+	memset(conf, 0, sizeof(dhd_conf_t));
 	return 0;
 }
 
@@ -3527,24 +3822,34 @@
 void
 dhd_conf_detach(dhd_pub_t *dhd)
 {
-	CONFIG_TRACE("Enter\n");
+	struct dhd_conf *conf = dhd->conf;
 
+	CONFIG_TRACE("Enter\n");
 	if (dhd->conf) {
 #ifdef BCMSDIO
-		dhd_conf_free_mac_list(&dhd->conf->fw_by_mac);
-		dhd_conf_free_mac_list(&dhd->conf->nv_by_mac);
-		dhd_conf_free_chip_nv_path_list(&dhd->conf->nv_by_chip);
-#endif
-		dhd_conf_free_country_list(&dhd->conf->country_list);
-		if (dhd->conf->magic_pkt_filter_add) {
-			kfree(dhd->conf->magic_pkt_filter_add);
-			dhd->conf->magic_pkt_filter_add = NULL;
-		}
-		if (dhd->conf->wl_preinit) {
-			kfree(dhd->conf->wl_preinit);
-			dhd->conf->wl_preinit = NULL;
+		dhd_conf_free_mac_list(&conf->fw_by_mac);
+		dhd_conf_free_mac_list(&conf->nv_by_mac);
+#endif
+		dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
+		dhd_conf_free_country_list(conf);
+		dhd_conf_free_mchan_list(conf);
+		if (conf->magic_pkt_filter_add) {
+			kfree(conf->magic_pkt_filter_add);
+			conf->magic_pkt_filter_add = NULL;
+		}
+		if (conf->wl_preinit) {
+			kfree(conf->wl_preinit);
+			conf->wl_preinit = NULL;
+		}
+		if (conf->wl_suspend) {
+			kfree(conf->wl_suspend);
+			conf->wl_suspend = NULL;
+		}
+		if (conf->wl_resume) {
+			kfree(conf->wl_resume);
+			conf->wl_resume = NULL;
 		}
-		MFREE(dhd->osh, dhd->conf, sizeof(dhd_conf_t));
+		MFREE(dhd->osh, conf, sizeof(dhd_conf_t));
 	}
 	dhd->conf = NULL;
 }
diff -urN a/drivers/net/wireless/bcmdhd/dhd_config.h a/drivers/net/wireless/bcmdhd/dhd_config.h
--- a/drivers/net/wireless/bcmdhd/dhd_config.h	2020-01-13 17:57:01.726432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_config.h	2020-02-05 09:22:51.000000000 +0300
@@ -85,17 +85,18 @@
 } conf_pkt_filter_del_t;
 #endif
 
-#define CONFIG_COUNTRY_LIST_SIZE 100
-typedef struct conf_country_list {
-	uint32 count;
-	wl_country_t *cspec[CONFIG_COUNTRY_LIST_SIZE];
-} conf_country_list_t;
+#define CONFIG_COUNTRY_LIST_SIZE 500
+typedef struct country_list {
+	struct country_list *next;
+	wl_country_t cspec;
+} country_list_t;
 
 /* mchan_params */
 #define MCHAN_MAX_NUM 4
 #define MIRACAST_SOURCE	1
 #define MIRACAST_SINK	2
 typedef struct mchan_params {
+	struct mchan_params *next;
 	int bw;
 	int p2p_mode;
 	int miracast_mode;
@@ -119,11 +120,16 @@
 	ALL_IN_SUSPEND 			= 0xFFFFFFFF,
 };
 
+enum in_suspend_mode {
+	EARLY_SUSPEND = 0,
+	PM_NOTIFIER = 1
+};
+
 enum eapol_status {
 	EAPOL_STATUS_NONE = 0,
-	EAPOL_STATUS_WPS_REQID = 1,
-	EAPOL_STATUS_WPS_RSPID = 2,
-	EAPOL_STATUS_WPS_WSC_START = 3,
+	EAPOL_STATUS_REQID = 1,
+	EAPOL_STATUS_RSPID = 2,
+	EAPOL_STATUS_WSC_START = 3,
 	EAPOL_STATUS_WPS_M1 = 4,
 	EAPOL_STATUS_WPS_M2 = 5,
 	EAPOL_STATUS_WPS_M3 = 6,
@@ -132,23 +138,27 @@
 	EAPOL_STATUS_WPS_M6 = 9,
 	EAPOL_STATUS_WPS_M7 = 10,
 	EAPOL_STATUS_WPS_M8 = 11,
-	EAPOL_STATUS_WPS_DONE = 12,
-	EAPOL_STATUS_WPA_START = 13,
-	EAPOL_STATUS_WPA_M1 = 14,
-	EAPOL_STATUS_WPA_M2 = 15,
-	EAPOL_STATUS_WPA_M3 = 16,
-	EAPOL_STATUS_WPA_M4 = 17,
-	EAPOL_STATUS_WPA_END = 18
+	EAPOL_STATUS_WSC_DONE = 12,
+	EAPOL_STATUS_4WAY_START = 13,
+	EAPOL_STATUS_4WAY_M1 = 14,
+	EAPOL_STATUS_4WAY_M2 = 15,
+	EAPOL_STATUS_4WAY_M3 = 16,
+	EAPOL_STATUS_4WAY_M4 = 17,
+	EAPOL_STATUS_GROUPKEY_M1 = 18,
+	EAPOL_STATUS_GROUPKEY_M2 = 19,
+	EAPOL_STATUS_4WAY_DONE = 20
 };
 
 typedef struct dhd_conf {
 	uint chip;
 	uint chiprev;
 	int fw_type;
+#ifdef BCMSDIO
 	wl_mac_list_ctrl_t fw_by_mac;
 	wl_mac_list_ctrl_t nv_by_mac;
+#endif
 	wl_chip_nv_path_list_ctrl_t nv_by_chip;
-	conf_country_list_t country_list;
+	country_list_t *country_head;
 	int band;
 	int bw_cap[2];
 	wl_country_t cspec;
@@ -160,10 +170,12 @@
 	int roam_delta[2];
 	int fullroamperiod;
 	uint keep_alive_period;
+#ifdef ARP_OFFLOAD_SUPPORT
+	bool garp;
+#endif
 	int force_wme_ac;
 	wme_param_t wme_sta;
 	wme_param_t wme_ap;
-	int phy_oclscdenable;
 #ifdef PKT_FILTER_SUPPORT
 	conf_pkt_filter_add_t pkt_filter_add;
 	conf_pkt_filter_del_t pkt_filter_del;
@@ -172,7 +184,6 @@
 	int srl;
 	int lrl;
 	uint bcn_timeout;
-	int txbf;
 	int disable_proptx;
 	int dhd_poll;
 #ifdef BCMSDIO
@@ -196,9 +207,10 @@
 	int txglom_bucket_size;
 	int txinrx_thres;
 	int dhd_txminmax; // -1=DATABUFCNT(bus)
-	uint sd_f2_blocksize;
 	bool oob_enabled_later;
+#if defined(SDIO_ISR_THREAD)
 	bool intr_extn;
+#endif
 #ifdef BCMSDIO_RXLIM_POST
 	bool rxlim_en;
 #endif
@@ -212,6 +224,7 @@
 	bool deepsleep;
 	int pm;
 	int pm_in_suspend;
+	int suspend_mode;
 	int suspend_bcn_li_dtim;
 #ifdef DHDTCPACK_SUPPRESS
 	uint8 tcpack_sup_mode;
@@ -238,20 +251,21 @@
 	char isam_enable[50];
 #endif
 	int ctrl_resched;
-	int dhd_ioctl_timeout_msec;
-	struct mchan_params mchan[MCHAN_MAX_NUM];
+	mchan_params_t *mchan;
 	char *wl_preinit;
+	char *wl_suspend;
+	char *wl_resume;
 	int tsq;
 	int orphan_move;
 	uint eapol_status;
 	uint in4way;
-	uint max_wait_gc_time;
 #ifdef WL_EXT_WOWL
 	uint wowl;
 #endif
 #ifdef GET_CUSTOM_MAC_FROM_CONFIG
 	char hw_ether[62];
 #endif
+	wait_queue_head_t event_complete;
 } dhd_conf_t;
 
 #ifdef BCMSDIO
@@ -286,6 +300,11 @@
 	int *hostsleep_set, int *hostsleep_val, int *ret);
 void dhd_conf_get_hostsleep(dhd_pub_t *dhd,
 	int hostsleep_set, int hostsleep_val, int ret);
+int dhd_conf_mkeep_alive(dhd_pub_t *dhd, int ifidx, int id, int period,
+	char *packet, bool bcast);
+#ifdef ARP_OFFLOAD_SUPPORT
+void dhd_conf_set_garp(dhd_pub_t *dhd, int ifidx, uint32 ipa, bool enable);
+#endif
 #ifdef PROP_TXSTATUS
 int dhd_conf_get_disable_proptx(dhd_pub_t *dhd);
 #endif
@@ -297,4 +316,8 @@
 int dhd_conf_attach(dhd_pub_t *dhd);
 void dhd_conf_detach(dhd_pub_t *dhd);
 void *dhd_get_pub(struct net_device *dev);
+int wl_pattern_atoh(char *src, char *dst);
+#ifdef BCMSDIO
+extern int dhd_bus_sleep(dhd_pub_t *dhdp, bool sleep, uint32 *intstatus);
+#endif
 #endif /* _dhd_config_ */
diff -urN a/drivers/net/wireless/bcmdhd/dhd_debug_linux.c a/drivers/net/wireless/bcmdhd/dhd_debug_linux.c
--- a/drivers/net/wireless/bcmdhd/dhd_debug_linux.c	2020-01-13 17:57:01.730432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_debug_linux.c	2020-01-14 08:36:09.000000000 +0300
@@ -221,7 +221,11 @@
 	ring_info = &os_priv[ring_id];
 	ring_info->log_level = log_level;
 	if (ring_id == FW_VERBOSE_RING_ID || ring_id == FW_EVENT_RING_ID) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36))
 		ring_info->tsoffset = local_clock();
+#else
+		ring_info->tsoffset = sched_clock();
+#endif
 		if (dhd_wl_ioctl_get_intiovar(dhdp, "rte_timesync", &ms, WLC_GET_VAR,
 				FALSE, 0))
 			DHD_ERROR(("%s rte_timesync failed\n", __FUNCTION__));
@@ -350,7 +354,11 @@
 		msg_hdr.type = DBG_RING_ENTRY_EVENT_TYPE;
 		msg_hdr.flags |= DBG_RING_ENTRY_FLAGS_HAS_TIMESTAMP;
 		msg_hdr.flags |= DBG_RING_ENTRY_FLAGS_HAS_BINARY;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36))
 		msg_hdr.timestamp = local_clock();
+#else
+		msg_hdr.timestamp = sched_clock();
+#endif
 		/* convert to ms */
 		do_div(msg_hdr.timestamp, 1000000);
 		msg_hdr.len = data_len;
diff -urN a/drivers/net/wireless/bcmdhd/dhd.h a/drivers/net/wireless/bcmdhd/dhd.h
--- a/drivers/net/wireless/bcmdhd/dhd.h	2020-01-13 17:57:01.719432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd.h	2019-11-04 04:45:12.000000000 +0300
@@ -371,7 +371,7 @@
 	DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX = 16,
 	DHD_PREALLOC_DHD_PKTLOG_DUMP_BUF = 17,
 	DHD_PREALLOC_STAT_REPORT_BUF = 18,
-	DHD_PREALLOC_WL_WEXT_INFO = 19,
+	DHD_PREALLOC_WL_ESCAN = 19,
 	DHD_PREALLOC_FW_VERBOSE_RING = 20,
 	DHD_PREALLOC_FW_EVENT_RING = 21,
 	DHD_PREALLOC_DHD_EVENT_RING = 22,
@@ -1045,6 +1045,9 @@
 #ifdef BCMDBUS
 	bool dhd_remove;
 #endif /* BCMDBUS */
+#ifdef WL_ESCAN
+	struct wl_escan_info *escan;
+#endif
 #if defined(WL_WIRELESS_EXT)
 	void *wext_info;
 #endif
@@ -1537,7 +1540,7 @@
 extern void dhd_os_dhdiovar_unlock(dhd_pub_t *pub);
 extern int dhd_os_proto_block(dhd_pub_t * pub);
 extern int dhd_os_proto_unblock(dhd_pub_t * pub);
-extern int dhd_os_ioctl_resp_wait(dhd_pub_t * pub, uint * condition, bool resched);
+extern int dhd_os_ioctl_resp_wait(dhd_pub_t * pub, uint * condition);
 extern int dhd_os_ioctl_resp_wake(dhd_pub_t * pub);
 extern unsigned int dhd_os_get_ioctl_resp_timeout(void);
 extern void dhd_os_set_ioctl_resp_timeout(unsigned int timeout_msec);
@@ -1879,6 +1882,7 @@
 extern uint android_msg_level;
 extern uint config_msg_level;
 extern uint sd_msglevel;
+extern uint dump_msg_level;
 #ifdef BCMDBUS
 extern uint dbus_msglevel;
 #endif /* BCMDBUS */
diff -urN a/drivers/net/wireless/bcmdhd/dhd_ip.c a/drivers/net/wireless/bcmdhd/dhd_ip.c
--- a/drivers/net/wireless/bcmdhd/dhd_ip.c	2020-01-13 17:57:01.732432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_ip.c	2019-09-19 16:27:22.000000000 +0300
@@ -127,7 +127,7 @@
 	int ifidx;
 	uint8 supp_cnt;
 	dhd_pub_t *dhdp;
-	struct timer_list timer;
+	timer_list_compat_t timer;
 } tcpack_info_t;
 
 typedef struct _tdata_psh_info_t {
@@ -287,20 +287,10 @@
 	return;
 }
 
-static void dhd_tcpack_send(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	ulong data
-#endif
-)
+static void dhd_tcpack_send(ulong data)
 {
 	tcpack_sup_module_t *tcpack_sup_mod;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	tcpack_info_t *cur_tbl = from_timer(cur_tbl, t, timer);
-#else
 	tcpack_info_t *cur_tbl = (tcpack_info_t *)data;
-#endif
 	dhd_pub_t *dhdp;
 	int ifidx;
 	void* pkt;
@@ -474,13 +464,7 @@
 				tcpack_info_t *tcpack_info_tbl =
 					&tcpack_sup_module->tcpack_info_tbl[i];
 				tcpack_info_tbl->dhdp = dhdp;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-				timer_setup(&tcpack_info_tbl->timer, dhd_tcpack_send, 0);
-#else
-				init_timer(&tcpack_info_tbl->timer);
-				tcpack_info_tbl->timer.data = (ulong)tcpack_info_tbl;
-				tcpack_info_tbl->timer.function = dhd_tcpack_send;
-#endif
+				init_timer_compat(&tcpack_info_tbl->timer, dhd_tcpack_send, tcpack_info_tbl);
 			}
 			break;
 	}
diff -urN a/drivers/net/wireless/bcmdhd/dhd_linux.c a/drivers/net/wireless/bcmdhd/dhd_linux.c
--- a/drivers/net/wireless/bcmdhd/dhd_linux.c	2020-01-13 17:57:01.757432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_linux.c	2020-02-05 09:24:50.000000000 +0300
@@ -84,6 +84,9 @@
 #include <dhd_bus.h>
 #include <dhd_proto.h>
 #include <dhd_config.h>
+#ifdef WL_ESCAN
+#include <wl_escan.h>
+#endif
 #include <dhd_dbg.h>
 #include <dhd_debug.h>
 #ifdef CONFIG_HAS_WAKELOCK
@@ -346,6 +349,7 @@
 DEFINE_MUTEX(_dhd_mutex_lock_);
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */
 #endif 
+static int dhd_suspend_resume_helper(struct dhd_info *dhd, int val, int force);
 
 #ifdef CONFIG_BCM_DETECT_CONSECUTIVE_HANG
 #define MAX_CONSECUTIVE_HANG_COUNTS 5
@@ -372,8 +376,10 @@
 extern void dhd_wlfc_plat_init(void *dhd);
 extern void dhd_wlfc_plat_deinit(void *dhd);
 #endif /* PROP_TXSTATUS */
+#ifdef USE_DYNAMIC_F2_BLKSIZE
 extern uint sd_f2_blocksize;
 extern int dhdsdio_func_blocksize(dhd_pub_t *dhd, int function_num, int block_size);
+#endif /* USE_DYNAMIC_F2_BLKSIZE */
 
 #if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 15)
 const char *
@@ -631,10 +637,10 @@
 	wait_queue_head_t dhd_bus_busy_state_wait;
 	uint32	default_wd_interval;
 
-	struct timer_list timer;
+	timer_list_compat_t timer;
 	bool wd_timer_valid;
 #ifdef DHD_PCIE_RUNTIMEPM
-	struct timer_list rpm_timer;
+	timer_list_compat_t rpm_timer;
 	bool rpm_timer_valid;
 	tsk_ctl_t	  thr_rpm_ctl;
 #endif /* DHD_PCIE_RUNTIMEPM */
@@ -710,7 +716,7 @@
 #ifdef BCM_FD_AGGR
 	void *rpc_th;
 	void *rpc_osh;
-	struct timer_list rpcth_timer;
+	timer_list_compat_t rpcth_timer;
 	bool rpcth_timer_active;
 	uint8 fdaggr;
 #endif
@@ -740,11 +746,11 @@
 #endif /* DHD_WET */
 #ifdef DHD_DEBUG
 	dhd_dump_t *dump;
-	struct timer_list join_timer;
+	timer_list_compat_t join_timer;
 	u32 join_timeout_val;
 	bool join_timer_active;
 	uint scan_time_count;
-	struct timer_list scan_timer;
+	timer_list_compat_t scan_timer;
 	bool scan_timer_active;
 #endif
 #if defined(DHD_LB)
@@ -884,7 +890,7 @@
 #ifdef SHOW_LOGTRACE
 	struct sk_buff_head   evt_trace_queue     ____cacheline_aligned;
 #endif
-	struct timer_list timesync_timer;
+	timer_list_compat_t timesync_timer;
 #if defined(BT_OVER_SDIO)
 	char btfw_path[PATH_MAX];
 #endif /* defined (BT_OVER_SDIO) */
@@ -2009,15 +2015,27 @@
 		break;
 	}
 
-#if defined(SUPPORT_P2P_GO_PS) && defined(PROP_TXSTATUS)
+	printf("%s: action=%ld, suspend=%d, suspend_mode=%d\n",
+		__FUNCTION__, action, suspend, dhdinfo->pub.conf->suspend_mode);
 	if (suspend) {
 		DHD_OS_WAKE_LOCK_WAIVE(&dhdinfo->pub);
+		if (dhdinfo->pub.conf->suspend_mode == PM_NOTIFIER)
+			dhd_suspend_resume_helper(dhdinfo, suspend, 0);
+#if defined(SUPPORT_P2P_GO_PS) && defined(PROP_TXSTATUS)
 		dhd_wlfc_suspend(&dhdinfo->pub);
+#endif /* defined(SUPPORT_P2P_GO_PS) && defined(PROP_TXSTATUS) */
+		if (dhdinfo->pub.conf->suspend_mode == PM_NOTIFIER)
+			dhd_conf_set_suspend_resume(&dhdinfo->pub, suspend);
 		DHD_OS_WAKE_LOCK_RESTORE(&dhdinfo->pub);
 	} else {
+		if (dhdinfo->pub.conf->suspend_mode == PM_NOTIFIER)
+			dhd_conf_set_suspend_resume(&dhdinfo->pub, suspend);
+#if defined(SUPPORT_P2P_GO_PS) && defined(PROP_TXSTATUS)
 		dhd_wlfc_resume(&dhdinfo->pub);
-	}
 #endif /* defined(SUPPORT_P2P_GO_PS) && defined(PROP_TXSTATUS) */
+		if (dhdinfo->pub.conf->suspend_mode == PM_NOTIFIER)
+			dhd_suspend_resume_helper(dhdinfo, suspend, 0);
+	}
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && (LINUX_VERSION_CODE <= \
 	KERNEL_VERSION(2, 6, 39))
@@ -3377,7 +3395,9 @@
 
 static int dhd_set_suspend(int value, dhd_pub_t *dhd)
 {
+#ifndef SUPPORT_PM2_ONLY
 	int power_mode = PM_MAX;
+#endif /* SUPPORT_PM2_ONLY */
 #ifdef SUPPORT_SENSORHUB
 	shub_control_t shub_ctl;
 #endif /* SUPPORT_SENSORHUB */
@@ -3392,7 +3412,7 @@
 	int roam_time_thresh = 0;   /* (ms) */
 #endif /* CUSTOM_ROAM_TIME_THRESH_IN_SUSPEND */
 #ifndef ENABLE_FW_ROAM_SUSPEND
-	uint roamvar = dhd->conf->roam_off_suspend;
+	uint roamvar = 1;
 #endif /* ENABLE_FW_ROAM_SUSPEND */
 #ifdef ENABLE_BCN_LI_BCN_WAKEUP
 	int bcn_li_bcn;
@@ -3443,12 +3463,6 @@
 	/* set specific cpucore */
 	dhd_set_cpucore(dhd, TRUE);
 #endif /* CUSTOM_SET_CPUCORE */
-
-	if (dhd->conf->pm >= 0)
-		power_mode = dhd->conf->pm;
-	else
-		power_mode = PM_FAST;
-
 	if (dhd->up) {
 		if (value && dhd->in_suspend) {
 #ifdef PKT_FILTER_SUPPORT
@@ -3457,10 +3471,10 @@
 			/* Kernel suspended */
 			DHD_ERROR(("%s: force extra suspend setting\n", __FUNCTION__));
 
-			if (dhd->conf->pm_in_suspend >= 0)
-				power_mode = dhd->conf->pm_in_suspend;
+#ifndef SUPPORT_PM2_ONLY
 			dhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode,
 				sizeof(power_mode), TRUE, 0);
+#endif /* SUPPORT_PM2_ONLY */
 
 #ifdef PKT_FILTER_SUPPORT
 			/* Enable packet filter,
@@ -3613,9 +3627,7 @@
 			}
 #endif /* DYNAMIC_SWOOB_DURATION */
 #endif /* DHD_USE_EARLYSUSPEND */
-			dhd_conf_set_suspend_resume(dhd, value);
 		} else {
-			dhd_conf_set_suspend_resume(dhd, value);
 #ifdef PKT_FILTER_SUPPORT
 			dhd->early_suspended = 0;
 #endif
@@ -3646,8 +3658,11 @@
 				DHD_ERROR(("failed to set intr_width (%d)\n", ret));
 			}
 #endif /* DYNAMIC_SWOOB_DURATION */
+#ifndef SUPPORT_PM2_ONLY
+			power_mode = PM_FAST;
 			dhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode,
 				sizeof(power_mode), TRUE, 0);
+#endif /* SUPPORT_PM2_ONLY */
 #ifdef PKT_FILTER_SUPPORT
 			/* disable pkt filter */
 			dhd_enable_packet_filter(0, dhd);
@@ -3777,8 +3792,10 @@
 	struct dhd_info *dhd = container_of(h, struct dhd_info, early_suspend);
 	DHD_TRACE_HW4(("%s: enter\n", __FUNCTION__));
 
-	if (dhd)
+	if (dhd && dhd->pub.conf->suspend_mode == EARLY_SUSPEND) {
 		dhd_suspend_resume_helper(dhd, 1, 0);
+		dhd_conf_set_suspend_resume(&dhd->pub, 1);
+	}
 }
 
 static void dhd_late_resume(struct early_suspend *h)
@@ -3786,8 +3803,10 @@
 	struct dhd_info *dhd = container_of(h, struct dhd_info, early_suspend);
 	DHD_TRACE_HW4(("%s: enter\n", __FUNCTION__));
 
-	if (dhd)
+	if (dhd && dhd->pub.conf->suspend_mode == EARLY_SUSPEND) {
+		dhd_conf_set_suspend_resume(&dhd->pub, 0);
 		dhd_suspend_resume_helper(dhd, 0, 0);
+	}
 }
 #endif /* CONFIG_HAS_EARLYSUSPEND && DHD_USE_EARLYSUSPEND */
 
@@ -6354,19 +6373,9 @@
 	complete_and_exit(&tsk->completed, 0);
 }
 
-static void dhd_watchdog(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	ulong data
-#endif
-)
+static void dhd_watchdog(ulong data)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	dhd_info_t *dhd = from_timer(dhd, t, timer);
-#else
 	dhd_info_t *dhd = (dhd_info_t *)data;
-#endif
 	unsigned long flags;
 
 	if (dhd->pub.dongle_reset) {
@@ -6446,19 +6455,9 @@
 	complete_and_exit(&tsk->completed, 0);
 }
 
-static void dhd_runtimepm(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	ulong data
-#endif
-)
+static void dhd_runtimepm(ulong data)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	dhd_info_t *dhd = from_timer(dhd, t, rpm_timer);
-#else
 	dhd_info_t *dhd = (dhd_info_t *)data;
-#endif
 
 	if (dhd->pub.dongle_reset) {
 		return;
@@ -8298,18 +8297,26 @@
 		wl_iw_down(net, &dhd->pub);
 	}
 #endif /* defined(WL_WIRELESS_EXT) */
+#ifdef WL_ESCAN
+	if (ifidx == 0) {
+		wl_escan_down(net, &dhd->pub);
+	}
+#endif /* WL_ESCAN */
 	if (ifidx == 0 && !dhd_download_fw_on_driverload) {
 #if defined(BT_OVER_SDIO)
 		dhd_bus_put(&dhd->pub, WLAN_MODULE);
 		wl_android_set_wifi_on_flag(FALSE);
 #else
 		wl_android_wifi_off(net, TRUE);
-#if defined(WL_EXT_IAPSTA) || defined(USE_IW)
-		wl_ext_event_dettach_netdev(net, ifidx);
-#endif
+#if defined(WL_EXT_IAPSTA) || defined(USE_IW) || defined(WL_ESCAN)
 #ifdef WL_EXT_IAPSTA
 		wl_ext_iapsta_dettach_netdev(net, ifidx);
-#endif
+#endif /* WL_EXT_IAPSTA */
+#ifdef WL_ESCAN
+			wl_escan_event_dettach(net, &dhd->pub);
+#endif /* WL_ESCAN */
+			wl_ext_event_dettach_netdev(net, ifidx);
+#endif /* WL_EXT_IAPSTA || USE_IW || WL_ESCAN */
 	} else {
 		if (dhd->pub.conf->deepsleep)
 			dhd_deepsleep(dhd, 1);
@@ -8428,6 +8435,7 @@
 			DHD_ERROR(("%s: WLAN interface is not brought down\n", __FUNCTION__));
 			dhd_stop(net);
 		} else {
+			DHD_MUTEX_UNLOCK();
 			return -1;
 		}
 	}
@@ -8480,12 +8488,15 @@
 		atomic_set(&dhd->pend_8021x_cnt, 0);
 		if (!dhd_download_fw_on_driverload) {
 			DHD_ERROR(("\n%s\n", dhd_version));
-#if defined(WL_EXT_IAPSTA) || defined(USE_IW)
+#if defined(WL_EXT_IAPSTA) || defined(USE_IW) || defined(WL_ESCAN)
 			wl_ext_event_attach_netdev(net, ifidx, dhd->iflist[ifidx]->bssidx);
-#endif
+#ifdef WL_ESCAN
+			wl_escan_event_attach(net, &dhd->pub);
+#endif /* WL_ESCAN */
 #ifdef WL_EXT_IAPSTA
 			wl_ext_iapsta_attach_netdev(net, ifidx, dhd->iflist[ifidx]->bssidx);
-#endif
+#endif /* WL_EXT_IAPSTA */
+#endif /* WL_EXT_IAPSTA || USE_IW || WL_ESCAN */
 #if defined(USE_INITIAL_SHORT_DWELL_TIME)
 			g_first_broadcast_scan = TRUE;
 #endif 
@@ -8667,11 +8678,18 @@
 #endif /* WL_CFG80211 */
 #if defined(WL_WIRELESS_EXT)
 		if (unlikely(wl_iw_up(net, &dhd->pub))) {
-			DHD_ERROR(("%s: failed to bring up escan\n", __FUNCTION__));
+			DHD_ERROR(("%s: failed to bring up wext\n", __FUNCTION__));
 			ret = -1;
 			goto exit;
 		}
 #endif
+#ifdef WL_ESCAN
+		if (unlikely(wl_escan_up(net, &dhd->pub))) {
+			DHD_ERROR(("%s: failed to bring up escan\n", __FUNCTION__));
+			ret = -1;
+			goto exit;
+		}
+#endif /* WL_ESCAN */
 #if defined(ISAM_PREINIT)
 		if (!dhd_download_fw_on_driverload) {
 			if (dhd->pub.conf) {
@@ -9014,12 +9032,15 @@
 					unregister_netdev(ifp->net);
 				else
 					unregister_netdevice(ifp->net);
-#if defined(WL_EXT_IAPSTA) || defined(USE_IW)
-				wl_ext_event_dettach_netdev(ifp->net, ifidx);
-#endif
+#if defined(WL_EXT_IAPSTA) || defined(USE_IW) || defined(WL_ESCAN)
 #ifdef WL_EXT_IAPSTA
 				wl_ext_iapsta_dettach_netdev(ifp->net, ifidx);
-#endif
+#endif /* WL_EXT_IAPSTA */
+#ifdef WL_ESCAN
+				wl_escan_event_dettach(ifp->net, dhdpub);
+#endif /* WL_ESCAN */
+				wl_ext_event_dettach_netdev(ifp->net, ifidx);
+#endif /* WL_EXT_IAPSTA || USE_IW || WL_ESCAN */
 			}
 			ifp->net = NULL;
 		}
@@ -9602,12 +9623,25 @@
 #ifdef DHD_LOG_DUMP
 	dhd_log_dump_init(&dhd->pub);
 #endif /* DHD_LOG_DUMP */
-#if defined(WL_EXT_IAPSTA) || defined(USE_IW)
+#if defined(WL_EXT_IAPSTA) || defined(USE_IW) || defined(WL_ESCAN)
 	if (wl_ext_event_attach(net, &dhd->pub) != 0) {
 		DHD_ERROR(("wl_ext_event_attach failed\n"));
 		goto fail;
 	}
-#endif
+#ifdef WL_ESCAN
+	/* Attach and link in the escan */
+	if (wl_escan_attach(net, &dhd->pub) != 0) {
+		DHD_ERROR(("wl_escan_attach failed\n"));
+		goto fail;
+	}
+#endif /* WL_ESCAN */
+#ifdef WL_EXT_IAPSTA
+	if (wl_ext_iapsta_attach(&dhd->pub) != 0) {
+		DHD_ERROR(("wl_ext_iapsta_attach failed\n"));
+		goto fail;
+	}
+#endif /* WL_EXT_IAPSTA */
+#endif /* WL_EXT_IAPSTA || USE_IW || WL_ESCAN */
 #if defined(WL_WIRELESS_EXT)
 	/* Attach and link in the iw */
 	if (wl_iw_attach(net, &dhd->pub) != 0) {
@@ -9616,12 +9650,6 @@
 	}
 	dhd_state |= DHD_ATTACH_STATE_WL_ATTACH;
 #endif /* defined(WL_WIRELESS_EXT) */
-#ifdef WL_EXT_IAPSTA
-	if (wl_ext_iapsta_attach(&dhd->pub) != 0) {
-		DHD_ERROR(("wl_ext_iapsta_attach failed\n"));
-		goto fail;
-	}
-#endif
 
 #ifdef SHOW_LOGTRACE
 	ret = dhd_init_logstrs_array(osh, &dhd->event_data);
@@ -9660,13 +9688,7 @@
 
 #ifndef BCMDBUS
 	/* Set up the watchdog timer */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	timer_setup(&dhd->timer, dhd_watchdog, 0);
-#else
-	init_timer(&dhd->timer);
-	dhd->timer.data = (ulong)dhd;
-	dhd->timer.function = dhd_watchdog;
-#endif
+	init_timer_compat(&dhd->timer, dhd_watchdog, dhd);
 	dhd->default_wd_interval = dhd_watchdog_ms;
 
 	if (dhd_watchdog_prio >= 0) {
@@ -9682,13 +9704,7 @@
 
 #ifdef DHD_PCIE_RUNTIMEPM
 	/* Setup up the runtime PM Idlecount timer */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	timer_setup(&dhd->rpm_timer, dhd_runtimepm, 0);
-#else
-	init_timer(&dhd->rpm_timer);
-	dhd->rpm_timer.data = (ulong)dhd;
-	dhd->rpm_timer.function = dhd_runtimepm;
-#endif
+	init_timer_compat(&dhd->rpm_timer, dhd_runtimepm, dhd);
 	dhd->rpm_timer_valid = FALSE;
 
 	dhd->thr_rpm_ctl.thr_pid = DHD_PID_KT_INVALID;
@@ -11172,10 +11188,6 @@
 	(void)concurrent_mode;
 #endif 
 	}
-#ifdef BCMSDIO
-	if (dhd->conf->sd_f2_blocksize)
-		dhdsdio_func_blocksize(dhd, 2, dhd->conf->sd_f2_blocksize);
-#endif
 
 #if defined(RSDB_MODE_FROM_FILE)
 	(void)dhd_rsdb_mode_from_file(dhd);
@@ -11834,20 +11846,29 @@
 	memset(buf, 0, sizeof(buf));
 	ret = dhd_iovar(dhd, 0, "clmver", NULL, 0, buf, sizeof(buf), FALSE);
 	if (ret < 0)
-		DHD_ERROR(("%s failed %d\n", __FUNCTION__, ret));
+		DHD_ERROR(("%s clmver failed %d\n", __FUNCTION__, ret));
 	else {
-		char *clmver_temp_buf = NULL;
+		char *ver_temp_buf = NULL, *ver_date_buf = NULL;
+		int len;
 
-		if ((clmver_temp_buf = bcmstrstr(buf, "Data:")) == NULL) {
+		if ((ver_temp_buf = bcmstrstr(buf, "Data:")) == NULL) {
 			DHD_ERROR(("Couldn't find \"Data:\"\n"));
 		} else {
-			ptr = (clmver_temp_buf + strlen("Data:"));
-			if ((clmver_temp_buf = bcmstrtok(&ptr, "\n", 0)) == NULL) {
+			ver_date_buf = bcmstrstr(buf, "Creation:");
+			ptr = (ver_temp_buf + strlen("Data:"));
+			if ((ver_temp_buf = bcmstrtok(&ptr, "\n", 0)) == NULL) {
 				DHD_ERROR(("Couldn't find New line character\n"));
 			} else {
 				memset(clm_version, 0, CLM_VER_STR_LEN);
-				strncpy(clm_version, clmver_temp_buf,
-					MIN(strlen(clmver_temp_buf), CLM_VER_STR_LEN - 1));
+				len = snprintf(clm_version, CLM_VER_STR_LEN - 1, "%s", ver_temp_buf);
+				if (ver_date_buf) {
+					ptr = (ver_date_buf + strlen("Creation:"));
+					ver_date_buf = bcmstrtok(&ptr, "\n", 0);
+					if (ver_date_buf)
+						snprintf(clm_version+len, CLM_VER_STR_LEN-1-len,
+							" (%s)", ver_date_buf);
+				}
+				DHD_INFO(("CLM version = %s\n", clm_version));
 			}
 		}
 	}
@@ -12348,6 +12369,7 @@
 				__FUNCTION__));
 			aoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, TRUE, idx);
 #endif /* AOE_IP_ALIAS_SUPPORT */
+			dhd_conf_set_garp(dhd_pub, idx, ifa->ifa_address, TRUE);
 			break;
 
 		case NETDEV_DOWN:
@@ -12366,6 +12388,7 @@
 				dhd_aoe_hostip_clr(&dhd->pub, idx);
 				dhd_aoe_arp_clr(&dhd->pub, idx);
 			}
+			dhd_conf_set_garp(dhd_pub, idx, ifa->ifa_address, FALSE);
 			break;
 
 		default:
@@ -12621,14 +12644,9 @@
 	if (ifidx == 0)
 		printf("%s\n", dhd_version);
 	else {
-#if defined(WL_EXT_IAPSTA) || defined(USE_IW)
-		wl_ext_event_attach_netdev(net, ifidx, ifp->bssidx);
-#endif
 #ifdef WL_EXT_IAPSTA
-		wl_ext_iapsta_attach_netdev(net, ifidx, ifp->bssidx);
-#endif
-	}
-	if (ifidx != 0) {
+		wl_ext_iapsta_update_net_device(net, ifidx);
+#endif /* WL_EXT_IAPSTA */
 		if (_dhd_set_mac_address(dhd, ifidx, net->dev_addr) == 0)
 			DHD_INFO(("%s: MACID is overwritten\n", __FUNCTION__));
 		else
@@ -12644,17 +12662,16 @@
 		DHD_ERROR(("couldn't register the net device [%s], err %d\n", net->name, err));
 		goto fail;
 	}
-	if (ifidx == 0) {
-#if defined(WL_EXT_IAPSTA) || defined(USE_IW)
-		wl_ext_event_attach_netdev(net, ifidx, ifp->bssidx);
-#endif
-#ifdef WL_EXT_IAPSTA
-		wl_ext_iapsta_attach_netdev(net, ifidx, ifp->bssidx);
-#endif
-	}
+#if defined(WL_EXT_IAPSTA) || defined(USE_IW) || defined(WL_ESCAN)
+	wl_ext_event_attach_netdev(net, ifidx, ifp->bssidx);
+#ifdef WL_ESCAN
+	wl_escan_event_attach(net, dhdp);
+#endif /* WL_ESCAN */
 #ifdef WL_EXT_IAPSTA
+	wl_ext_iapsta_attach_netdev(net, ifidx, ifp->bssidx);
 	wl_ext_iapsta_attach_name(net, ifidx);
-#endif
+#endif /* WL_EXT_IAPSTA */
+#endif /* WL_EXT_IAPSTA || USE_IW || WL_ESCAN */
 
 
 
@@ -12875,12 +12892,15 @@
 		wl_iw_detach(dev, dhdp);
 	}
 #endif /* defined(WL_WIRELESS_EXT) */
+#if defined(WL_EXT_IAPSTA) || defined(USE_IW) || defined(WL_ESCAN)
 #ifdef WL_EXT_IAPSTA
 	wl_ext_iapsta_dettach(dhdp);
-#endif
-#if defined(WL_EXT_IAPSTA) || defined(USE_IW)
+#endif /* WL_EXT_IAPSTA */
+#ifdef WL_ESCAN
+	wl_escan_detach(dev, dhdp);
+#endif /* WL_ESCAN */
 	wl_ext_event_dettach(dhdp);
-#endif
+#endif /* WL_EXT_IAPSTA || USE_IW || WL_ESCAN */
 
 #ifdef DHD_ULP
 	dhd_ulp_deinit(dhd->pub.osh, dhdp);
@@ -13433,15 +13453,10 @@
 }
 
 int
-dhd_os_ioctl_resp_wait(dhd_pub_t *pub, uint *condition, bool resched)
+dhd_os_ioctl_resp_wait(dhd_pub_t *pub, uint *condition)
 {
 	dhd_info_t * dhd = (dhd_info_t *)(pub->info);
-	int timeout, timeout_tmp = dhd_ioctl_timeout_msec;
-
-	if (!resched && pub->conf->ctrl_resched>0 && pub->conf->dhd_ioctl_timeout_msec>0) {
-		timeout_tmp = dhd_ioctl_timeout_msec;
-		dhd_ioctl_timeout_msec = pub->conf->dhd_ioctl_timeout_msec;
-	}
+	int timeout;
 
 	/* Convert timeout in millsecond to jiffies */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
@@ -13454,10 +13469,6 @@
 
 	timeout = wait_event_timeout(dhd->ioctl_resp_wait, (*condition), timeout);
 
-	if (!resched && pub->conf->ctrl_resched>0 && pub->conf->dhd_ioctl_timeout_msec>0) {
-		dhd_ioctl_timeout_msec = timeout_tmp;
-	}
-
 	DHD_PERIM_LOCK(pub);
 
 	return timeout;
@@ -14225,7 +14236,9 @@
 	int ret = 0;
 	dhd_info_t *dhd = DHD_DEV_INFO(dev);
 
-	if (dhd) {
+	if (dhd && dhd->pub.conf->suspend_mode == EARLY_SUSPEND) {
+		if (!val)
+			dhd_conf_set_suspend_resume(&dhd->pub, val);
 #ifdef CONFIG_MACH_UNIVERSAL7420
 #endif /* CONFIG_MACH_UNIVERSAL7420 */
 #if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)
@@ -14236,6 +14249,8 @@
 #ifdef WL_CFG80211
 		wl_cfg80211_update_power_mode(dev);
 #endif
+		if (val)
+			dhd_conf_set_suspend_resume(&dhd->pub, val);
 	}
 	return ret;
 }
@@ -18649,26 +18664,18 @@
 #ifdef DHD_ARP_DUMP
 #define ARP_PRINT(str) \
 	do { \
-		if (tx) { \
-			DHD_ERROR(("[dhd-%s] "str " [TX] : %s(%s) %s %s(%s)\n", \
-				ifname, tx?sabuf:dabuf, tx?seabuf:deabuf, \
-				tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf)); \
-		} else { \
-			DHD_ERROR(("[dhd-%s] "str " [RX] : %s(%s) %s %s(%s)\n", \
-				ifname, tx?sabuf:dabuf, tx?seabuf:deabuf, \
-				tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf)); \
-		} \
-	} while (0) \
+		DHD_ERROR(("[dhd-%s] " str " [%s] : %s(%s) %s %s(%s)\n", \
+			ifname, tx?"TX":"RX", \
+			tx?sabuf:dabuf, tx?seabuf:deabuf, \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf)); \
+	} while (0)
 
 #define ARP_PRINT_OTHER(str) \
 	do { \
-		if (tx) { \
-			DHD_ERROR(("[dhd-%s] "str " [TX] op_code=%d\n", \
-				ifname, opcode)); \
-		} else { \
-			DHD_ERROR(("[dhd-%s] "str " [RX] op_code=%d\n", \
-				ifname, opcode)); \
-		} \
+		DHD_ERROR(("[dhd-%s] " str " [%s] : %s(%s) %s %s(%s) op_code=%d\n", \
+			ifname, tx?"TX":"RX", \
+			tx?sabuf:dabuf, tx?seabuf:deabuf, \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf, opcode)); \
 	} while (0)
 
 static void
@@ -18681,6 +18688,9 @@
 	char seabuf[ETHER_ADDR_STR_LEN]="";
 	char deabuf[ETHER_ADDR_STR_LEN]="";
 
+	if (!(dump_msg_level & DUMP_ARP_VAL))
+		return;
+
 	/* validation check */
 	if (arph->htype != hton16(HTYPE_ETHERNET) ||
 		arph->hlen != ETHER_ADDR_LEN ||
@@ -18704,6 +18714,14 @@
 #endif /* DHD_ARP_DUMP */
 
 #ifdef DHD_DHCP_DUMP
+#define DHCP_PRINT(str) \
+	do { \
+		DHD_ERROR(("[dhd-%s] " str " %8s, %8s [%s] : %s(%s) %s %s(%s)\n", \
+			ifname, dhcp_types[dhcp_type], dhcp_ops[b->op], \
+			tx?"TX":"RX", \
+			tx?sabuf:dabuf, tx?seabuf:deabuf, \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf)); \
+	} while (0)
 static void
 dhd_dhcp_dump(char *ifname, uint8 *pktdata, bool tx)
 {
@@ -18716,6 +18734,9 @@
 	char seabuf[ETHER_ADDR_STR_LEN]="";
 	char deabuf[ETHER_ADDR_STR_LEN]="";
 
+	if (!(dump_msg_level & DUMP_DHCP_VAL))
+		return;
+
 	/* check IP header */
 	if (h->ihl != 5 || h->version != 4 || h->protocol != IPPROTO_UDP) {
 		return;
@@ -18758,11 +18779,7 @@
 			if (*opt == 53) {
 				if (opt[1]) {
 					dhcp_type = opt[2];
-					DHD_ERROR(("[dhd-%s] DHCP[%s] %8s, %8s : %s(%s) %s %s(%s)\n",
-						ifname, tx ? "TX" : "RX",
-						dhcp_types[dhcp_type], dhcp_ops[b->op],
-						tx?sabuf:dabuf, tx?seabuf:deabuf,
-						tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf));
+					DHCP_PRINT("DHCP");
 					break;
 				}
 			}
@@ -18772,6 +18789,23 @@
 #endif /* DHD_DHCP_DUMP */
 
 #ifdef DHD_ICMP_DUMP
+#define ICMP_TYPE_ECHO_REQUEST	8	/* ICMP type echo request */
+#define ICMP_TYPE_ECHO_REPLY		0	/* ICMP type echo reply */
+#define ICMP_TYPE_DEST_UNREACH		3
+#define ICMP_ECHO_SEQ_OFFSET		6
+#define ICMP_ECHO_SEQ(h) (*(uint16 *)((uint8 *)(h) + (ICMP_ECHO_SEQ_OFFSET)))
+#define ICMP_PING_PRINT(str) \
+	do { \
+		DHD_ERROR(("[dhd-%s] " str " [%2s] : %s(%s) %s %s(%s) SEQNUM=%d\n", \
+			ifname, tx?"TX":"RX", tx?sabuf:dabuf, tx?seabuf:deabuf, \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf, seqnum)); \
+	} while (0)
+#define ICMP_PRINT(str) \
+	do { \
+		DHD_ERROR(("[dhd-%s] " str " [%2s] : %s(%s) %s %s(%s)\n", \
+			ifname, tx?"TX":"RX", tx?sabuf:dabuf, tx?seabuf:deabuf, \
+			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf)); \
+	} while (0)
 static void
 dhd_icmp_dump(char *ifname, uint8 *pktdata, bool tx)
 {
@@ -18782,6 +18816,10 @@
 	char sabuf[20]="", dabuf[20]="";
 	char seabuf[ETHER_ADDR_STR_LEN]="";
 	char deabuf[ETHER_ADDR_STR_LEN]="";
+	uint16 seqnum, type, code;
+
+	if (!(dump_msg_level & DUMP_ICMP_VAL))
+		return;
 
 	/* check IP header */
 	if (iph->ihl != 5 || iph->version != 4 || iph->protocol != IP_PROT_ICMP) {
@@ -18789,27 +18827,25 @@
 	}
 
 	icmph = (struct icmphdr *)((uint8 *)pkt + sizeof(struct iphdr));
+	seqnum = 0;
+	type = icmph->type;
+	code = icmph->code;
 	ip_saddr = iph->saddr;
 	ip_daddr = iph->daddr;
 	bcm_ip_ntoa((struct ipv4_addr *)&ip_saddr, sabuf);
 	bcm_ip_ntoa((struct ipv4_addr *)&ip_daddr, dabuf);
 	bcm_ether_ntoa((struct ether_addr *)pktdata, deabuf);
 	bcm_ether_ntoa((struct ether_addr *)(pktdata+6), seabuf);
-	if (icmph->type == ICMP_ECHO) {
-		DHD_ERROR(("[dhd-%s] PING REQUEST[%s] : %s(%s) %s %s(%s) SEQNUM=%d\n",
-			ifname, tx ? "TX" : "RX", tx?sabuf:dabuf, tx?seabuf:deabuf,
-			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf,
-			ntoh16(icmph->un.echo.sequence)));
-	} else if (icmph->type == ICMP_ECHOREPLY) {
-		DHD_ERROR(("[dhd-%s] PING REPLY  [%s] : %s(%s) %s %s(%s) SEQNUM=%d\n",
-			ifname, tx ? "TX" : "RX", tx?sabuf:dabuf, tx?seabuf:deabuf,
-			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf,
-			ntoh16(icmph->un.echo.sequence)));
+	if (type == ICMP_TYPE_ECHO_REQUEST) {
+		seqnum = ntoh16(ICMP_ECHO_SEQ(icmph));
+		ICMP_PING_PRINT("PING REQUEST");
+	} else if (type == ICMP_TYPE_ECHO_REPLY) {
+		seqnum = ntoh16(ICMP_ECHO_SEQ(icmph));
+		ICMP_PING_PRINT("PING REPLY  ");
+	} else if (type == ICMP_TYPE_DEST_UNREACH) {
+		ICMP_PRINT("ICMP DEST UNREACH");
 	} else {
-		DHD_ERROR(("[dhd-%s] ICMP[%s] : %s(%s) %s %s(%s) TYPE=%d, CODE=%d\n",
-			ifname, tx ? "TX" : "RX", tx?sabuf:dabuf, tx?seabuf:deabuf,
-			tx?"->":"<-", tx?dabuf:sabuf, tx?deabuf:seabuf,
-			icmph->type, icmph->code));
+		ICMP_PRINT("ICMP OTHER");
 	}
 }
 #endif /* DHD_ICMP_DUMP */
diff -urN a/drivers/net/wireless/bcmdhd/dhd_linux.h a/drivers/net/wireless/bcmdhd/dhd_linux.h
--- a/drivers/net/wireless/bcmdhd/dhd_linux.h	2020-01-13 17:57:01.758432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_linux.h	2019-12-22 19:33:24.000000000 +0300
@@ -97,6 +97,7 @@
 
 #define WLAN_PLAT_NODFS_FLAG	0x01
 #define WLAN_PLAT_AP_FLAG	0x02
+#if !defined(CONFIG_WIFI_CONTROL_FUNC)
 struct wifi_platform_data {
 #ifdef BUS_POWER_RESTORE
 	int (*set_power)(int val, wifi_adapter_info_t *adapter);
@@ -107,12 +108,13 @@
 	int (*set_carddetect)(int val);
 	void *(*mem_prealloc)(int section, unsigned long size);
 	int (*get_mac_addr)(unsigned char *buf);
-#if defined(CUSTOM_COUNTRY_CODE)
+#ifdef CUSTOM_FORCE_NODFS_FLAG
 	void *(*get_country_code)(char *ccode, u32 flags);
-#else /* defined (CUSTOM_COUNTRY_CODE) */
+#else /* defined (CUSTOM_FORCE_NODFS_FLAG) */
 	void *(*get_country_code)(char *ccode);
 #endif
 };
+#endif
 
 typedef struct bcmdhd_wifi_platdata {
 	uint				num_adapters;
diff -urN a/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c a/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c
--- a/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c	2020-01-13 17:57:01.758432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c	2019-12-22 19:33:29.000000000 +0300
@@ -307,7 +307,7 @@
 
 	DHD_TRACE(("%s\n", __FUNCTION__));
 	if (plat_data->get_country_code) {
-#ifdef CUSTOM_COUNTRY_CODE
+#ifdef CUSTOM_FORCE_NODFS_FLAG
 		return plat_data->get_country_code(ccode, flags);
 #else
 		return plat_data->get_country_code(ccode);
@@ -333,8 +333,11 @@
 	ASSERT(dhd_wifi_platdata != NULL);
 	ASSERT(dhd_wifi_platdata->num_adapters == 1);
 	adapter = &dhd_wifi_platdata->adapters[0];
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
+	adapter->wifi_plat_data = (struct wifi_platform_data *)(pdev->dev.platform_data);
+#else
 	adapter->wifi_plat_data = (void *)&dhd_wlan_control;
-//	adapter->wifi_plat_data = (struct wifi_platform_data *)(pdev->dev.platform_data);
+#endif
 
 	resource = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "bcmdhd_wlan_irq");
 	if (resource == NULL)
diff -urN a/drivers/net/wireless/bcmdhd/dhd_msgbuf.c a/drivers/net/wireless/bcmdhd/dhd_msgbuf.c
--- a/drivers/net/wireless/bcmdhd/dhd_msgbuf.c	2020-01-13 17:57:01.765432662 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_msgbuf.c	2019-08-20 14:36:16.000000000 +0300
@@ -6023,7 +6023,7 @@
 		goto out;
 	}
 
-	timeleft = dhd_os_ioctl_resp_wait(dhd, (uint *)&prot->ioctl_received, false);
+	timeleft = dhd_os_ioctl_resp_wait(dhd, (uint *)&prot->ioctl_received);
 
 #ifdef DHD_RECOVER_TIMEOUT
 	if (prot->ioctl_received == 0) {
@@ -6068,7 +6068,7 @@
 				dhd->bus->ipend = TRUE;
 				dhd->bus->dpc_sched = TRUE;
 				dhd_sched_dpc(dhd);
-				timeleft = dhd_os_ioctl_resp_wait(dhd, &prot->ioctl_received, true);
+				timeleft = dhd_os_ioctl_resp_wait(dhd, &prot->ioctl_received);
 			}
 		}
 	} else {
diff -urN a/drivers/net/wireless/bcmdhd/dhd_pcie_linux.c a/drivers/net/wireless/bcmdhd/dhd_pcie_linux.c
--- a/drivers/net/wireless/bcmdhd/dhd_pcie_linux.c	2020-01-13 17:57:02.250432657 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_pcie_linux.c	2019-09-20 10:53:29.000000000 +0300
@@ -139,7 +139,7 @@
 	dhdpcie_info_t *pc;
 	spinlock_t lock;
 	wait_queue_head_t intr_wait_queue;
-	struct timer_list tuning_timer;
+	timer_list_compat_t tuning_timer;
 	int tuning_timer_exp;
 	atomic_t timer_enab;
 	struct tasklet_struct tuning_tasklet;
@@ -884,12 +884,13 @@
 int __devinit
 dhdpcie_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
+	int err = 0;
 	DHD_MUTEX_LOCK();
 
 	if (dhdpcie_chipmatch (pdev->vendor, pdev->device)) {
 		DHD_ERROR(("%s: chipmatch failed!!\n", __FUNCTION__));
-		DHD_MUTEX_UNLOCK();
-		return -ENODEV;
+		err = -ENODEV;
+		goto exit;
 	}
 	printf("PCI_PROBE:  bus %X, slot %X,vendor %X, device %X"
 		"(good PCI location)\n", pdev->bus->number,
@@ -897,8 +898,8 @@
 
 	if (dhdpcie_init (pdev)) {
 		DHD_ERROR(("%s: PCIe Enumeration failed\n", __FUNCTION__));
-		DHD_MUTEX_UNLOCK();
-		return -ENODEV;
+		err = -ENODEV;
+		goto exit;
 	}
 
 #ifdef BCMPCIE_DISABLE_ASYNC_SUSPEND
@@ -907,8 +908,10 @@
 #endif /* BCMPCIE_DISABLE_ASYNC_SUSPEND */
 
 	DHD_TRACE(("%s: PCIe Enumeration done!!\n", __FUNCTION__));
+
+exit:
 	DHD_MUTEX_UNLOCK();
-	return 0;
+	return err;
 }
 
 int
@@ -1205,7 +1208,8 @@
 	}
 
 }
-#endif /* CONFIG_ARCH_MSM || (EXYNOS_PCIE_LINKDOWN_RECOVERY &&
+#endif
+/* CONFIG_ARCH_MSM || (EXYNOS_PCIE_LINKDOWN_RECOVERY &&
 	* (CONFIG_SOC_EXYNOS8890 || CONFIG_SOC_EXYNOS8895))
 	*/
 #endif /* SUPPORT_LINKDOWN_RECOVERY */
diff -urN a/drivers/net/wireless/bcmdhd/dhd_sdio.c a/drivers/net/wireless/bcmdhd/dhd_sdio.c
--- a/drivers/net/wireless/bcmdhd/dhd_sdio.c	2020-01-13 17:57:02.270432657 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_sdio.c	2019-11-04 04:45:14.000000000 +0300
@@ -189,7 +189,7 @@
 
 /* Device console log buffer state */
 #define CONSOLE_LINE_MAX	192
-#define CONSOLE_BUFFER_MAX	2024
+#define CONSOLE_BUFFER_MAX	8192
 typedef struct dhd_console {
 	uint		count;			/* Poll interval msec counter */
 	uint		log_addr;		/* Log struct address (fixed) */
@@ -1895,6 +1895,7 @@
 }
 #endif /* BT_OVER_SDIO */
 
+#ifdef USE_DYNAMIC_F2_BLKSIZE
 int dhdsdio_func_blocksize(dhd_pub_t *dhd, int function_num, int block_size)
 {
 	int func_blk_size = function_num;
@@ -1910,7 +1911,7 @@
 	}
 
 	if (result != block_size) {
-		DHD_ERROR(("%s: F%d Block size set from %d to %d\n",
+		DHD_TRACE_HW4(("%s: F%d Block size set from %d to %d\n",
 			__FUNCTION__, function_num, result, block_size));
 		func_blk_size = function_num << 16 | block_size;
 		bcmerr = dhd_bus_iovar_op(dhd, "sd_blocksize", NULL,
@@ -1923,6 +1924,7 @@
 
 	return BCME_OK;
 }
+#endif /* USE_DYNAMIC_F2_BLKSIZE */
 
 #if defined(OOB_INTR_ONLY) || defined(FORCE_WOWLAN)
 void
@@ -2933,7 +2935,7 @@
 		return -EIO;
 
 	/* Wait until control frame is available */
-	timeleft = dhd_os_ioctl_resp_wait(bus->dhd, &bus->rxlen, false);
+	timeleft = dhd_os_ioctl_resp_wait(bus->dhd, &bus->rxlen);
 
 	dhd_os_sdlock(bus->dhd);
 	rxlen = bus->rxlen;
@@ -2954,7 +2956,7 @@
 				dhd_sched_dpc(bus->dhd);
 
 				/* Wait until control frame is available */
-				timeleft = dhd_os_ioctl_resp_wait(bus->dhd, &bus->rxlen, true);
+				timeleft = dhd_os_ioctl_resp_wait(bus->dhd, &bus->rxlen);
 
 				dhd_os_sdlock(bus->dhd);
 				rxlen = bus->rxlen;
@@ -7599,6 +7601,8 @@
 		goto done;
 
 	if (!DATAOK(bus)) {
+		DHD_CTL(("%s: No bus credit bus->tx_max %d, bus->tx_seq %d, pktq_len %d\n",
+			__FUNCTION__, bus->tx_max, bus->tx_seq, pktq_len(&bus->txq)));
 		rv = BCME_NOTREADY;
 		goto done;
 	}
@@ -10078,3 +10082,31 @@
 	return bcmsdh_set_get_wake(dhd->bus->sdh, 0);
 }
 #endif /* DHD_WAKE_STATUS */
+
+int
+dhd_bus_sleep(dhd_pub_t *dhdp, bool sleep, uint32 *intstatus)
+{
+	dhd_bus_t *bus = dhdp->bus;
+	uint32 retry = 0;
+	int ret = 0;
+
+	if (bus) {
+		dhd_os_sdlock(dhdp);
+		BUS_WAKE(bus);
+		R_SDREG(*intstatus, &bus->regs->intstatus, retry);
+		if (sleep) {
+			if (SLPAUTO_ENAB(bus)) {
+				ret = dhdsdio_bussleep(bus, sleep);
+				if (ret != BCME_BUSY)
+					dhd_os_wd_timer(bus->dhd, 0);
+			} else
+				dhdsdio_clkctl(bus, CLK_NONE, FALSE);
+		}
+		dhd_os_sdunlock(dhdp);
+	} else {
+		DHD_ERROR(("bus is NULL\n"));
+		ret = -1;
+	}
+
+	return ret;
+}
\ В конце файла нет новой строки
diff -urN a/drivers/net/wireless/bcmdhd/dhd_static_buf.c a/drivers/net/wireless/bcmdhd/dhd_static_buf.c
--- a/drivers/net/wireless/bcmdhd/dhd_static_buf.c	2020-01-13 17:57:02.270432657 +0300
+++ a/drivers/net/wireless/bcmdhd/dhd_static_buf.c	2019-09-20 10:53:43.000000000 +0300
@@ -35,7 +35,7 @@
 	DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX = 16,
 	DHD_PREALLOC_DHD_PKTLOG_DUMP_BUF = 17,
 	DHD_PREALLOC_STAT_REPORT_BUF = 18,
-	DHD_PREALLOC_WL_WEXT_INFO = 19,
+	DHD_PREALLOC_WL_ESCAN = 19,
 	DHD_PREALLOC_FW_VERBOSE_RING = 20,
 	DHD_PREALLOC_FW_EVENT_RING = 21,
 	DHD_PREALLOC_DHD_EVENT_RING = 22,
@@ -54,7 +54,7 @@
 #define DHD_PREALLOC_DHD_INFO_SIZE	(32 * 1024)
 #define DHD_PREALLOC_MEMDUMP_RAM_SIZE	(810 * 1024)
 #define DHD_PREALLOC_DHD_WLFC_HANGER_SIZE	(73 * 1024)
-#define DHD_PREALLOC_WL_WEXT_INFO_SIZE	(70 * 1024)
+#define DHD_PREALLOC_WL_ESCAN_SIZE	(70 * 1024)
 #ifdef CONFIG_64BIT
 #define DHD_PREALLOC_IF_FLOW_LKUP_SIZE	(20 * 1024 * 2)
 #else
@@ -191,10 +191,10 @@
 		}
 		return wlan_static_dhd_wlfc_hanger_buf;
 	}
-	if (section == DHD_PREALLOC_WL_WEXT_INFO) {
-		if (size > DHD_PREALLOC_WL_WEXT_INFO_SIZE) {
-			pr_err("request DHD_PREALLOC_WL_WEXT_INFO_SIZE(%lu) > %d\n",
-				size, DHD_PREALLOC_WL_WEXT_INFO_SIZE);
+	if (section == DHD_PREALLOC_WL_ESCAN) {
+		if (size > DHD_PREALLOC_WL_ESCAN_SIZE) {
+			pr_err("request DHD_PREALLOC_WL_ESCAN_SIZE(%lu) > %d\n",
+				size, DHD_PREALLOC_WL_ESCAN_SIZE);
 			return NULL;
 		}
 
@@ -343,11 +343,11 @@
 	pr_err("%s: sectoin %d, size=%d\n", __func__,
 		DHD_PREALLOC_DHD_WLFC_HANGER, DHD_PREALLOC_DHD_WLFC_HANGER_SIZE);
 
-	wlan_static_wl_escan_info_buf = kmalloc(DHD_PREALLOC_WL_WEXT_INFO_SIZE, GFP_KERNEL);
+	wlan_static_wl_escan_info_buf = kmalloc(DHD_PREALLOC_WL_ESCAN_SIZE, GFP_KERNEL);
 	if (!wlan_static_wl_escan_info_buf)
 		goto err_mem_alloc;
 	pr_err("%s: sectoin %d, size=%d\n", __func__,
-		DHD_PREALLOC_WL_WEXT_INFO, DHD_PREALLOC_WL_WEXT_INFO_SIZE);
+		DHD_PREALLOC_WL_ESCAN, DHD_PREALLOC_WL_ESCAN_SIZE);
 
 	wlan_static_fw_verbose_ring_buf = kmalloc(FW_VERBOSE_RING_SIZE, GFP_KERNEL);
 	if (!wlan_static_fw_verbose_ring_buf)
diff -urN a/drivers/net/wireless/bcmdhd/include/802.11.h a/drivers/net/wireless/bcmdhd/include/802.11.h
--- a/drivers/net/wireless/bcmdhd/include/802.11.h	2020-01-13 17:57:02.286432657 +0300
+++ a/drivers/net/wireless/bcmdhd/include/802.11.h	2020-03-11 11:19:32.000000000 +0300
@@ -4353,6 +4353,8 @@
 #define RSN_AKM_SHA256_1X	5	/* SHA256 key derivation, using 802.1X */
 #define RSN_AKM_SHA256_PSK	6	/* SHA256 key derivation, using Pre-shared Key */
 #define RSN_AKM_TPK		7	/* TPK(TDLS Peer Key) handshake */
+#define RSN_AKM_SAE_PSK         8       /* AKM for SAE with 4-way handshake */
+#define RSN_AKM_SAE_FBT         9       /* AKM for SAE with FBT */
 #define RSN_AKM_FILS_SHA256	14	/* SHA256 key derivation, using FILS */
 #define RSN_AKM_FILS_SHA384	15	/* SHA384 key derivation, using FILS */
 
diff -urN a/drivers/net/wireless/bcmdhd/include/brcm_nl80211.h a/drivers/net/wireless/bcmdhd/include/brcm_nl80211.h
--- a/drivers/net/wireless/bcmdhd/include/brcm_nl80211.h	2020-01-13 17:57:02.301432657 +0300
+++ a/drivers/net/wireless/bcmdhd/include/brcm_nl80211.h	2019-11-05 12:07:33.000000000 +0300
@@ -35,9 +35,13 @@
 #define OUI_GOOGLE  0x001A11
 
 enum wl_vendor_subcmd {
-	BRCM_VENDOR_SCMD_UNSPEC,
-	BRCM_VENDOR_SCMD_PRIV_STR,
-	BRCM_VENDOR_SCMD_BCM_STR
+	BRCM_VENDOR_SCMD_UNSPEC		= 0,
+	BRCM_VENDOR_SCMD_PRIV_STR	= 1,
+	BRCM_VENDOR_SCMD_BCM_STR	= 2,
+	BRCM_VENDOR_SCMD_BCM_PSK	= 3,
+	BRCM_VENDOR_SCMD_SET_PMK	= 4,
+	BRCM_VENDOR_SCMD_GET_FEATURES	= 5,
+	BRCM_VENDOR_SCMD_MAX		= 6
 };
 
 
diff -urN a/drivers/net/wireless/bcmdhd/include/dhdioctl.h a/drivers/net/wireless/bcmdhd/include/dhdioctl.h
--- a/drivers/net/wireless/bcmdhd/include/dhdioctl.h	2020-01-13 17:57:02.303432657 +0300
+++ a/drivers/net/wireless/bcmdhd/include/dhdioctl.h	2019-11-05 12:07:36.000000000 +0300
@@ -113,6 +113,12 @@
 #define DHD_IW_VAL	0x20000
 #define DHD_CFG_VAL	0x40000
 #define DHD_CONFIG_VAL	0x80000
+#define DUMP_EAPOL_VAL	0x0001
+#define DUMP_ARP_VAL	0x0002
+#define DUMP_DHCP_VAL	0x0004
+#define DUMP_ICMP_VAL	0x0008
+#define DUMP_DNS_VAL	0x0010
+#define DUMP_TRX_VAL	0x0080
 
 #ifdef SDTEST
 /* For pktgen iovar */
diff -urN a/drivers/net/wireless/bcmdhd/include/epivers.h a/drivers/net/wireless/bcmdhd/include/epivers.h
--- a/drivers/net/wireless/bcmdhd/include/epivers.h	2020-01-13 17:57:02.304432657 +0300
+++ a/drivers/net/wireless/bcmdhd/include/epivers.h	2020-02-05 12:12:50.000000000 +0300
@@ -46,6 +46,6 @@
 #define EPI_VERSION_DEV		1.579.77.41
 
 /* Driver Version String, ASCII, 32 chars max */
-#define	EPI_VERSION_STR		"1.579.77.41.18 (r-20190719-1)"
+#define	EPI_VERSION_STR		"1.579.77.41.24 (r-20200205-5)"
 
 #endif /* _epivers_h_ */
diff -urN a/drivers/net/wireless/bcmdhd/include/linuxver.h a/drivers/net/wireless/bcmdhd/include/linuxver.h
--- a/drivers/net/wireless/bcmdhd/include/linuxver.h	2020-01-13 17:57:02.316432657 +0300
+++ a/drivers/net/wireless/bcmdhd/include/linuxver.h	2020-03-11 11:19:42.000000000 +0300
@@ -347,6 +347,42 @@
 
 #endif /* DMA mapping */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+
+typedef struct timer_list timer_list_compat_t;
+
+#define init_timer_compat(timer_compat, cb, priv) \
+	init_timer(timer_compat); \
+	(timer_compat)->data = (ulong)priv; \
+	(timer_compat)->function = cb
+#define timer_set_private(timer_compat, priv) (timer_compat)->data = (ulong)priv
+#define timer_expires(timer_compat) (timer_compat)->expires
+
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0) */
+
+typedef struct timer_list_compat {
+	struct timer_list timer;
+	void *arg;
+	void (*callback)(ulong arg);
+} timer_list_compat_t;
+
+extern void timer_cb_compat(struct timer_list *tl);
+
+#define init_timer_compat(timer_compat, cb, priv) \
+	(timer_compat)->arg = priv; \
+	(timer_compat)->callback = cb; \
+	timer_setup(&(timer_compat)->timer, timer_cb_compat, 0);
+#define timer_set_private(timer_compat, priv) (timer_compat)->arg = priv
+#define timer_expires(timer_compat) (timer_compat)->timer.expires
+
+#define del_timer(t) del_timer(&((t)->timer))
+#define del_timer_sync(t) del_timer_sync(&((t)->timer))
+#define timer_pending(t) timer_pending(&((t)->timer))
+#define add_timer(t) add_timer(&((t)->timer))
+#define mod_timer(t, j) mod_timer(&((t)->timer), j)
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0) */
+
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 43))
 
 #define dev_kfree_skb_any(a)		dev_kfree_skb(a)
diff -urN a/drivers/net/wireless/bcmdhd/include/wlioctl_defs.h a/drivers/net/wireless/bcmdhd/include/wlioctl_defs.h
--- a/drivers/net/wireless/bcmdhd/include/wlioctl_defs.h	2020-01-13 17:57:02.378432656 +0300
+++ a/drivers/net/wireless/bcmdhd/include/wlioctl_defs.h	2019-12-22 19:30:16.000000000 +0300
@@ -436,6 +436,7 @@
 #define WL_IBSS_PEER_GROUP_KEY	(1 << 6)	/* Indicates a group key for a IBSS PEER */
 
 /* wireless security bitvec */
+#define WSEC_NONE		0x0
 #define WEP_ENABLED		0x0001
 #define TKIP_ENABLED		0x0002
 #define AES_ENABLED		0x0004
@@ -507,6 +508,7 @@
 #define WPA2_AUTH_TPK		0x2000	/* TDLS Peer Key */
 #define WPA2_AUTH_FT		0x4000	/* Fast Transition. */
 #define WPA2_AUTH_PSK_SHA256	0x8000	/* PSK with SHA256 key derivation */
+#define WPA3_AUTH_SAE_PSK	0x40000 /* SAE with 4-way handshake */
 /* WPA2_AUTH_SHA256 not used anymore. Just kept here to avoid build issue in DINGO */
 #define WPA2_AUTH_SHA256	0x8000
 #define WPA_AUTH_PFN_ANY	0xffffffff	/* for PFN, match only ssid */
diff -urN a/drivers/net/wireless/bcmdhd/include/wlioctl.h a/drivers/net/wireless/bcmdhd/include/wlioctl.h
--- a/drivers/net/wireless/bcmdhd/include/wlioctl.h	2020-01-13 17:57:02.376432656 +0300
+++ a/drivers/net/wireless/bcmdhd/include/wlioctl.h	2019-11-05 12:07:47.000000000 +0300
@@ -1081,6 +1081,8 @@
 
 #define WSEC_MIN_PSK_LEN	8
 #define WSEC_MAX_PSK_LEN	64
+/* Max length of supported passphrases for SAE */
+#define WSEC_MAX_PASSPHRASE_LEN 256u
 
 /** Flag for key material needing passhash'ing */
 #define WSEC_PASSPHRASE		(1<<0)
@@ -1092,6 +1094,23 @@
 	uint8	key[WSEC_MAX_PSK_LEN];	/**< PMK material */
 } wsec_pmk_t;
 
+#define WL_AUTH_EVENT_DATA_V1		0x1
+
+/* tlv ids for auth event */
+#define WL_AUTH_PMK_TLV_ID	1
+#define WL_AUTH_PMKID_TLV_ID	2
+/* AUTH event data
+* pmk and pmkid in case of SAE auth
+* xtlvs will be 32 bit alligned
+*/
+typedef struct wl_auth_event {
+	uint16 version;
+	uint16 length;
+	uint8 xtlvs[];
+} wl_auth_event_t;
+
+#define WL_AUTH_EVENT_FIXED_LEN_V1	OFFSETOF(wl_auth_event_t, xtlvs)
+
 typedef struct _pmkid {
 	struct ether_addr	BSSID;
 	uint8			PMKID[WPA2_PMKID_LEN];
diff -urN a/drivers/net/wireless/bcmdhd/linux_osl.c a/drivers/net/wireless/bcmdhd/linux_osl.c
--- a/drivers/net/wireless/bcmdhd/linux_osl.c	2020-01-13 17:57:02.379432656 +0300
+++ a/drivers/net/wireless/bcmdhd/linux_osl.c	2020-01-14 08:35:39.000000000 +0300
@@ -2698,6 +2698,15 @@
 /* timer apis */
 /* Note: All timer api's are thread unsafe and should be protected with locks by caller */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+void
+timer_cb_compat(struct timer_list *tl)
+{
+	timer_list_compat_t *t = container_of(tl, timer_list_compat_t, timer);
+	t->callback((ulong)t->arg);
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0) */
+
 #ifdef REPORT_FATAL_TIMEOUTS
 osl_timer_t *
 osl_timer_init(osl_t *osh, const char *name, void (*fn)(void *arg), void *arg)
@@ -2809,14 +2818,25 @@
 void
 osl_get_monotonic_boottime(struct osl_timespec *ts)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
 	struct timespec curtime;
+#else
+	struct timeval curtime;
+#endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
 	curtime = ktime_to_timespec(ktime_get_boottime());
 #else
 	get_monotonic_boottime(&curtime);
 #endif
 	ts->tv_sec = curtime.tv_sec;
-	ts->tv_nsec = curtime.tv_nsec;
 	ts->tv_usec = curtime.tv_nsec / 1000;
+	ts->tv_nsec = curtime.tv_nsec;
+#else
+	do_gettimeofday(&curtime);
+	ts->tv_sec = curtime.tv_sec;
+	ts->tv_usec = curtime.tv_usec;
+	ts->tv_nsec = curtime.tv_usec * 1000;
+#endif
 }
\ В конце файла нет новой строки
diff -urN a/drivers/net/wireless/bcmdhd/Makefile a/drivers/net/wireless/bcmdhd/Makefile
--- a/drivers/net/wireless/bcmdhd/Makefile	2020-01-13 17:57:01.148432668 +0300
+++ a/drivers/net/wireless/bcmdhd/Makefile	2020-03-11 11:20:40.000000000 +0300
@@ -1,7 +1,6 @@
 # bcmdhd
-# 1. WL_IFACE_COMB_NUM_CHANNELS must be added if Android version is 4.4 with Kernel version 3.0~3.4,
-#    otherwise please remove it.
 
+MODULE_NAME := bcmdhd
 #CONFIG_BCMDHD := m
 #CONFIG_BCMDHD_SDIO := y
 #CONFIG_BCMDHD_PCIE := y
@@ -20,25 +19,26 @@
 	-DBCMDONGLEHOST -DUNRELEASEDCHIP -DBCMDMA32 -DBCMFILEIMAGE            \
 	-DDHDTHREAD -DDHD_DEBUG -DSHOW_EVENTS -DBCMDBG -DGET_OTP_MAC_ENABLE   \
 	-DWIFI_ACT_FRAME -DARP_OFFLOAD_SUPPORT -DSUPPORT_PM2_ONLY             \
-	-DKEEP_ALIVE -DPKT_FILTER_SUPPORT -DPNO_SUPPORT -DDHDTCPACK_SUPPRESS  \
+	-DKEEP_ALIVE -DPKT_FILTER_SUPPORT -DDHDTCPACK_SUPPRESS                \
 	-DDHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT                           \
-	-DMULTIPLE_SUPPLICANT -DTSQ_MULTIPLIER -DMFP                          \
-	-DWL_EXT_IAPSTA                                                       \
+	-DMULTIPLE_SUPPLICANT -DTSQ_MULTIPLIER -DMFP -DDHD_8021X_DUMP         \
+	-DWL_EXT_IAPSTA -DWL_ESCAN                                            \
 	-Idrivers/net/wireless/bcmdhd -Idrivers/net/wireless/bcmdhd/include
+#	-DENABLE_INSMOD_NO_FW_LOAD                                            \
 
 DHDOFILES = aiutils.o siutils.o sbutils.o bcmutils.o bcmwifi_channels.o   \
 	dhd_linux.o dhd_linux_platdev.o dhd_linux_sched.o dhd_pno.o           \
 	dhd_common.o dhd_ip.o dhd_linux_wq.o dhd_custom_gpio.o                \
-	bcmevent.o hndpmu.o linux_osl.o wldev_common.o wl_android.o           \
+	bcmevent.o hndpmu.o linux_osl.o wldev_common.o wl_android.o bcmxtlv.o \
 	dhd_debug_linux.o dhd_debug.o dhd_mschdbg.o hnd_pktq.o hnd_pktpool.o  \
-	dhd_config.o wl_event.o wl_android_ext.o
+	dhd_config.o wl_event.o wl_android_ext.o wl_escan.o
 
 #BCMDHD_SDIO
 ifneq ($(CONFIG_BCMDHD_SDIO),)
 DHDCFLAGS += -DBCMSDIO -DMMC_SDIO_ABORT -DBCMLXSDMMC -DUSE_SDIOFIFO_IOVAR \
 	-DSDTEST -DBDC -DDHD_USE_IDLECOUNT -DCUSTOM_SDIO_F2_BLKSIZE=256       \
 	-DBCMSDIOH_TXGLOM -DBCMSDIOH_TXGLOM_EXT -DRXFRAME_THREAD              \
-	-DBCMSDIO_RXLIM_POST
+	-DDHDENABLE_TAILPAD -DSUPPORT_P2P_GO_PS -DBCMSDIO_RXLIM_POST
 ifeq ($(CONFIG_BCMDHD_OOB),y)
 	DHDCFLAGS += -DOOB_INTR_ONLY -DCUSTOMER_OOB -DHW_OOB
 ifeq ($(CONFIG_BCMDHD_DISABLE_WOWLAN),y)
@@ -47,7 +47,6 @@
 else
 	DHDCFLAGS += -DSDIO_ISR_THREAD
 endif
-
 DHDOFILES += bcmsdh.o bcmsdh_linux.o bcmsdh_sdmmc.o bcmsdh_sdmmc_linux.o  \
 	dhd_sdio.o dhd_cdc.o dhd_wlfc.o
 endif
@@ -60,7 +59,9 @@
 ifneq ($(CONFIG_PCI_MSI),)
 	DHDCFLAGS += -DDHD_USE_MSI
 endif
-
+ifeq ($(CONFIG_BCMDHD_OOB),y)
+	DHDCFLAGS += -DCUSTOMER_OOB -DBCMPCIE_OOB_HOST_WAKE
+endif
 DHDOFILES += dhd_pcie.o dhd_pcie_linux.o pcie_core.o dhd_flowring.o       \
 	dhd_msgbuf.o
 endif
@@ -75,7 +76,6 @@
 	DHDCFLAGS += -DBCMUSBDEV_COMPOSITE
 	DHDCFLAGS :=$(filter-out -DENABLE_INSMOD_NO_FW_LOAD,$(DHDCFLAGS))
 endif
-
 DHDOFILES += dbus.o dbus_usb.o dbus_usb_linux.o dhd_cdc.o dhd_wlfc.o
 endif
 
@@ -95,12 +95,11 @@
 #VTS_SUPPORT
 ifeq ($(CONFIG_VTS_SUPPORT),y)
 ifneq ($(CONFIG_CFG80211),)
-DHDCFLAGS += -DGSCAN_SUPPORT -DRTT_SUPPORT -DCUSTOM_FORCE_NODFS_FLAG      \
-	-DLINKSTAT_SUPPORT -DDEBUGABILITY -DDBG_PKT_MON                       \
-	-DAPF -DNDO_CONFIG_SUPPORT -DRSSI_MONITOR_SUPPORT -DDHD_WAKE_STATUS   \
-	-DCUSTOM_COUNTRY_CODE -DDHD_FW_COREDUMP -DEXPLICIT_DISCIF_CLEANUP
-
-DHDOFILES += bcmxtlv.o dhd_rtt.o bcm_app_utils.o
+DHDCFLAGS += -DGSCAN_SUPPORT -DRTT_SUPPORT -DLINKSTAT_SUPPORT             \
+	-DCUSTOM_COUNTRY_CODE                                                 \
+	-DDEBUGABILITY -DDBG_PKT_MON -DDHD_FW_COREDUMP                        \
+	-DAPF -DNDO_CONFIG_SUPPORT -DRSSI_MONITOR_SUPPORT -DDHD_WAKE_STATUS
+DHDOFILES += dhd_rtt.o bcm_app_utils.o
 endif
 endif
 
@@ -118,8 +117,8 @@
 	DHDCFLAGS :=$(filter-out -DSET_RANDOM_MAC_SOFTAP,$(DHDCFLAGS))
 endif
 
-obj-$(CONFIG_BCMDHD) += bcmdhd.o
-bcmdhd-objs += $(DHDOFILES)
+obj-$(CONFIG_BCMDHD) += $(MODULE_NAME).o
+$(MODULE_NAME)-objs += $(DHDOFILES)
 
 ifeq ($(CONFIG_MACH_PLATFORM),y)
 	DHDOFILES += dhd_gpio.o
@@ -142,17 +141,14 @@
 endif
 
 ifneq ($(CONFIG_WIRELESS_EXT),)
-	DHDOFILES += wl_iw.o wl_escan.o
-	DHDCFLAGS += -DSOFTAP -DWL_WIRELESS_EXT -DUSE_IW -DWL_ESCAN
+	DHDOFILES += wl_iw.o
+	DHDCFLAGS += -DSOFTAP -DWL_WIRELESS_EXT -DUSE_IW
 endif
 ifneq ($(CONFIG_CFG80211),)
 	DHDOFILES += wl_cfg80211.o wl_cfgp2p.o wl_linux_mon.o wl_cfg_btcoex.o wl_cfgvendor.o
 	DHDOFILES += dhd_cfg80211.o
 	DHDCFLAGS += -DWL_CFG80211 -DWLP2P -DWL_CFG80211_STA_EVENT -DWL_ENABLE_P2P_IF
 	DHDCFLAGS += -DWL_IFACE_COMB_NUM_CHANNELS
-	DHDCFLAGS += -DCUSTOM_ROAM_TRIGGER_SETTING=-65
-	DHDCFLAGS += -DCUSTOM_ROAM_DELTA_SETTING=15
-	DHDCFLAGS += -DCUSTOM_KEEP_ALIVE_SETTING=28000
 	DHDCFLAGS += -DCUSTOM_PNO_EVENT_LOCK_xTIME=7
 	DHDCFLAGS += -DWL_SUPPORT_AUTO_CHANNEL
 	DHDCFLAGS += -DWL_SUPPORT_BACKPORTED_KPATCHES
@@ -160,6 +156,8 @@
 	DHDCFLAGS += -DVSDB -DWL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
 	DHDCFLAGS += -DWLTDLS -DMIRACAST_AMPDU_SIZE=8
 	DHDCFLAGS += -DWL_VIRTUAL_APSTA
+	DHDCFLAGS += -DPNO_SUPPORT -DEXPLICIT_DISCIF_CLEANUP
+#	DHDCFLAGS += -DWL_SAE
 endif
 EXTRA_CFLAGS = $(DHDCFLAGS)
 ifeq ($(CONFIG_BCMDHD),m)
diff -urN a/drivers/net/wireless/bcmdhd/wl_android.c a/drivers/net/wireless/bcmdhd/wl_android.c
--- a/drivers/net/wireless/bcmdhd/wl_android.c	2020-01-13 17:57:02.384432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_android.c	2020-01-10 12:58:15.000000000 +0300
@@ -66,6 +66,9 @@
 #if defined(STAT_REPORT)
 #include <wl_statreport.h>
 #endif /* STAT_REPORT */
+#ifdef WL_ESCAN
+#include <wl_escan.h>
+#endif
 
 #ifndef WL_CFG80211
 #define htod32(i) i
@@ -148,6 +151,9 @@
 #define CMD_ULB_MODE "ULB_MODE"
 #define CMD_ULB_BW "ULB_BW"
 #endif /* WL11ULB */
+#ifdef WLFBT
+#define CMD_GET_FTKEY      "GET_FTKEY"
+#endif
 
 #if defined(WL_SUPPORT_AUTO_CHANNEL)
 #define CMD_GET_BEST_CHANNELS	"GET_BEST_CHANNELS"
@@ -1588,7 +1594,7 @@
 	}
 
 	dhd_net_if_lock(dev);
-	printf("%s in: g_wifi_on=%d\n", __FUNCTION__, g_wifi_on);
+	WL_MSG(dev->name, "in g_wifi_on=%d\n", g_wifi_on);
 	if (!g_wifi_on) {
 		do {
 			if (!dhd_net_wifi_platform_set_power(dev, TRUE, WIFI_TURNON_DELAY)) {
@@ -1633,7 +1639,7 @@
 	}
 
 exit:
-	printf("%s: Success\n", __FUNCTION__);
+	WL_MSG(dev->name, "Success\n");
 	dhd_net_if_unlock(dev);
 	return ret;
 
@@ -1644,7 +1650,7 @@
 	dhd_net_bus_suspend(dev);
 #endif /* BCMSDIO */
 	dhd_net_wifi_platform_set_power(dev, FALSE, WIFI_TURNOFF_DELAY);
-	printf("%s: Failed\n", __FUNCTION__);
+	WL_MSG(dev->name, "Failed\n");
 	dhd_net_if_unlock(dev);
 	return ret;
 #endif /* BCMSDIO || BCMDBUS */
@@ -1667,7 +1673,7 @@
 	}
 #endif	/* BCMPCIE && DHD_DEBUG_UART */
 	dhd_net_if_lock(dev);
-	printf("%s in: g_wifi_on=%d, on_failure=%d\n", __FUNCTION__, g_wifi_on, on_failure);
+	WL_MSG(dev->name, "in g_wifi_on=%d, on_failure=%d\n", g_wifi_on, on_failure);
 	if (g_wifi_on || on_failure) {
 #if defined(BCMSDIO) || defined(BCMPCIE) || defined(BCMDBUS)
 		ret = dhd_net_bus_devreset(dev, TRUE);
@@ -1678,7 +1684,7 @@
 		dhd_net_wifi_platform_set_power(dev, FALSE, WIFI_TURNOFF_DELAY);
 		g_wifi_on = FALSE;
 	}
-	printf("%s out\n", __FUNCTION__);
+	WL_MSG(dev->name, "out\n");
 	dhd_net_if_unlock(dev);
 
 	return ret;
@@ -2501,6 +2507,7 @@
 #define APCS_MAX_RETRY		10
 #define APCS_DEFAULT_2G_CH	1
 #define APCS_DEFAULT_5G_CH	149
+
 static int
 wl_android_set_auto_channel(struct net_device *dev, const char* cmd_str,
 	char* command, int total_len)
@@ -2511,18 +2518,16 @@
 	int ret = 0;
 	int spect = 0;
 	u8 *reqbuf = NULL;
-	uint32 band = WLC_BAND_2G;
+	uint32 band = WLC_BAND_2G, sta_band = WLC_BAND_2G;
 	uint32 buf_size;
-	char *pos = command;
-	int band_new, band_cur;
 
 	if (cmd_str) {
 		ANDROID_INFO(("Command: %s len:%d \n", cmd_str, (int)strlen(cmd_str)));
-		if (strncmp(cmd_str, APCS_BAND_AUTO, strlen(APCS_BAND_AUTO)) == 0) {
+		if (strnicmp(cmd_str, APCS_BAND_AUTO, strlen(APCS_BAND_AUTO)) == 0) {
 			band = WLC_BAND_AUTO;
-		} else if (strncmp(cmd_str, APCS_BAND_5G, strlen(APCS_BAND_5G)) == 0) {
+		} else if (strnicmp(cmd_str, APCS_BAND_5G, strlen(APCS_BAND_5G)) == 0) {
 			band = WLC_BAND_5G;
-		} else if (strncmp(cmd_str, APCS_BAND_2G, strlen(APCS_BAND_2G)) == 0) {
+		} else if (strnicmp(cmd_str, APCS_BAND_2G, strlen(APCS_BAND_2G)) == 0) {
 			band = WLC_BAND_2G;
 		} else {
 			/*
@@ -2534,22 +2539,53 @@
 				(channel == APCS_BAND_2G_LEGACY2)) {
 				band = WLC_BAND_2G;
 			} else {
-				ANDROID_ERROR(("%s: Invalid argument\n", __FUNCTION__));
+				ANDROID_ERROR(("Invalid argument\n"));
 				return -EINVAL;
 			}
 		}
 	} else {
 		/* If no argument is provided, default to 2G */
-		ANDROID_ERROR(("%s: No argument given default to 2.4G scan\n", __FUNCTION__));
+		ANDROID_ERROR(("No argument given default to 2.4G scan\n"));
 		band = WLC_BAND_2G;
 	}
-	ANDROID_INFO(("%s : HAPD_AUTO_CHANNEL = %d, band=%d \n", __FUNCTION__, channel, band));
+	ANDROID_INFO(("HAPD_AUTO_CHANNEL = %d, band=%d \n", channel, band));
+
+	/* If STA is connected, return is STA channel, else ACS can be issued,
+	 * set spect to 0 and proceed with ACS
+	 */
+	channel = wl_cfg80211_get_sta_channel(dev);
+	if (channel) {
+		sta_band = WL_GET_BAND(channel);
+		switch (sta_band) {
+			case (WL_CHANSPEC_BAND_5G): {
+				if (band == WLC_BAND_2G || band == WLC_BAND_AUTO) {
+					channel = APCS_DEFAULT_2G_CH;
+				}
+				break;
+			}
+			case (WL_CHANSPEC_BAND_2G): {
+				if (band == WLC_BAND_5G) {
+					channel = APCS_DEFAULT_5G_CH;
+				}
+				break;
+			}
+			default:
+				/* Intentional fall through to use same sta channel for softap */
+				break;
+		}
+		WL_MSG(dev->name, "band=%d, sta_band=%d, channel=%d\n", band, sta_band, channel);
+		goto done2;
+	}
 
-	ret = wldev_ioctl_set(dev, WLC_GET_BAND, &band_cur, sizeof(band_cur));
+	channel = wl_ext_autochannel(dev, ACS_FW_BIT|ACS_DRV_BIT, band);
+	if (channel)
+		goto done2;
+	else
+		goto done;
 
 	if ((ret =
 	     wldev_ioctl_get(dev, WLC_GET_SPECT_MANAGMENT, &spect, sizeof(spect))) < 0) {
-		ANDROID_ERROR(("%s: ACS: error getting the spect\n", __FUNCTION__));
+		ANDROID_ERROR(("ACS: error getting the spect\n"));
 		goto done;
 	}
 
@@ -2571,19 +2607,15 @@
 
 	reqbuf = kzalloc(CHANSPEC_BUF_SIZE, GFP_KERNEL);
 	if (reqbuf == NULL) {
-		ANDROID_ERROR(("%s: failed to allocate chanspec buffer\n", __FUNCTION__));
+		ANDROID_ERROR(("failed to allocate chanspec buffer\n"));
 		return -ENOMEM;
 	}
 
 	if (band == WLC_BAND_AUTO) {
-		ANDROID_INFO(("%s: ACS full channel scan \n", __func__));
+		ANDROID_INFO(("ACS full channel scan \n"));
 		reqbuf[0] = htod32(0);
 	} else if (band == WLC_BAND_5G) {
-		band_new = band_cur==WLC_BAND_2G ? band_cur : WLC_BAND_5G;
-		ret = wldev_ioctl_set(dev, WLC_SET_BAND, &band_new, sizeof(band_new));
-		if (ret < 0)
-			WL_ERR(("WLC_SET_BAND error %d\n", ret));
-		ANDROID_INFO(("%s: ACS 5G band scan \n", __func__));
+		ANDROID_INFO(("ACS 5G band scan \n"));
 		if ((ret = wl_cfg80211_get_chanspecs_5g(dev, reqbuf, CHANSPEC_BUF_SIZE)) < 0) {
 			ANDROID_ERROR(("ACS 5g chanspec retreival failed! \n"));
 			goto done;
@@ -2593,7 +2625,7 @@
 		 * If channel argument is not provided/ argument 20 is provided,
 		 * Restrict channel to 2GHz, 20MHz BW, No SB
 		 */
-		ANDROID_INFO(("%s: ACS 2G band scan \n", __func__));
+		ANDROID_INFO(("ACS 2G band scan \n"));
 		if ((ret = wl_cfg80211_get_chanspecs_2g(dev, reqbuf, CHANSPEC_BUF_SIZE)) < 0) {
 			ANDROID_ERROR(("ACS 2g chanspec retreival failed! \n"));
 			goto done;
@@ -2603,12 +2635,11 @@
 		goto done2;
 	}
 
-	buf_size = CHANSPEC_BUF_SIZE;
+	buf_size = (band == WLC_BAND_AUTO) ? sizeof(int) : CHANSPEC_BUF_SIZE;
 	ret = wldev_ioctl_set(dev, WLC_START_CHANNEL_SEL, (void *)reqbuf,
 		buf_size);
 	if (ret < 0) {
-		ANDROID_ERROR(("%s: can't start auto channel scan, err = %d\n",
-			__FUNCTION__, ret));
+		ANDROID_ERROR(("can't start auto channel scan, err = %d\n", ret));
 		channel = 0;
 		goto done;
 	}
@@ -2634,18 +2665,6 @@
 			chosen = dtoh32(chosen);
 		}
 
-		if ((ret == 0) && (dtoh32(chosen) != 0)) {
-			uint chip;
-			chip = dhd_conf_get_chip(dhd_get_pub(dev));
-			if (chip != BCM43143_CHIP_ID) {
-				u32 chanspec = 0;
-				chanspec = wl_chspec_driver_to_host(chosen);
-				ANDROID_INFO(("%s: selected chanspec = 0x%x\n", __FUNCTION__, chanspec));
-				chosen = wf_chspec_ctlchan(chanspec);
-				ANDROID_INFO(("%s: selected chosen = 0x%x\n", __FUNCTION__, chosen));
-			}
-		}
-
 		if (chosen) {
 			int chosen_band;
 			int apcs_band;
@@ -2660,15 +2679,12 @@
 #endif /* D11AC_IOTYPES */
 			apcs_band = (band == WLC_BAND_AUTO) ? WLC_BAND_2G : band;
 			chosen_band = (channel <= CH_MAX_2G_CHANNEL) ? WLC_BAND_2G : WLC_BAND_5G;
-			if (band == WLC_BAND_AUTO) {
-				printf("%s: selected channel = %d\n", __FUNCTION__, channel);
-				break;
-			} else if (apcs_band == chosen_band) {
-				printf("%s: selected channel = %d\n", __FUNCTION__, channel);
+			if (apcs_band == chosen_band) {
+				WL_MSG(dev->name, "selected channel = %d\n", channel);
 				break;
 			}
 		}
-		ANDROID_INFO(("%s: %d tried, ret = %d, chosen = 0x%x\n", __FUNCTION__,
+		ANDROID_INFO(("%d tried, ret = %d, chosen = 0x%x\n",
 			(APCS_MAX_RETRY - retry), ret, chosen));
 		OSL_SLEEP(250);
 	}
@@ -2681,16 +2697,12 @@
 		} else {
 			channel = APCS_DEFAULT_2G_CH;
 		}
-		ANDROID_ERROR(("%s: ACS failed."
-			" Fall back to default channel (%d) \n", __FUNCTION__, channel));
+		ANDROID_ERROR(("ACS failed. Fall back to default channel (%d) \n", channel));
 	}
 done2:
-	ret = wldev_ioctl_set(dev, WLC_SET_BAND, &band_cur, sizeof(band_cur));
-	if (ret < 0)
-		WL_ERR(("WLC_SET_BAND error %d\n", ret));
 	if (spect > 0) {
 		if ((ret = wl_cfg80211_set_spect(dev, spect) < 0)) {
-			ANDROID_ERROR(("%s: ACS: error while setting spect\n", __FUNCTION__));
+			ANDROID_ERROR(("ACS: error while setting spect\n"));
 		}
 	}
 
@@ -2699,12 +2711,8 @@
 	}
 
 	if (channel) {
-		if (channel < 15)
-			pos += snprintf(pos, total_len, "2g=");
-		else
-			pos += snprintf(pos, total_len, "5g=");
-		pos += snprintf(pos, total_len, "%d", channel);
-		ANDROID_INFO(("%s: command result is %s \n", __FUNCTION__, command));
+		snprintf(command, 4, "%d", channel);
+		ANDROID_INFO(("command result is %s \n", command));
 		return strlen(command);
 	} else {
 		return ret;
@@ -3342,6 +3350,7 @@
 	return wl_cfg80211_set_ulb_bw(dev, bw, ifname);
 }
 #endif /* WL11ULB */
+
 static int
 wl_android_set_miracast(struct net_device *dev, char *command, int total_len)
 {
@@ -3443,6 +3452,7 @@
 }
 #endif
 
+#ifdef WL_RELMCAST
 #define NETLINK_OXYGEN     30
 #define AIBSS_BEACON_TIMEOUT	10
 
@@ -3528,7 +3538,7 @@
 nlmsg_failure:
 	return ret;
 }
-
+#endif /* WL_RELMCAST */
 
 int wl_keep_alive_set(struct net_device *dev, char* extra, int total_len)
 {
@@ -4766,8 +4776,8 @@
 			command[0] = '\0';
 		}
 		if (bytes_written >= priv_cmd.total_len) {
-			ANDROID_ERROR(("%s: err. bytes_written:%d >= buf_size:%d \n",
-				__FUNCTION__, bytes_written, buf_size));
+			ANDROID_ERROR(("%s: err. bytes_written:%d >= total_len:%d, buf_size:%d\n",
+				__FUNCTION__, bytes_written, priv_cmd.total_len, buf_size));
 			ret = BCME_BUFTOOSHORT;
 			goto exit;
 		}
@@ -5027,6 +5037,11 @@
 		bytes_written = wl_cfg80211_set_wps_p2p_ie(net, command + skip,
 			priv_cmd.total_len - skip, *(command + skip - 2) - '0');
 	}
+#ifdef WLFBT
+	else if (strnicmp(command, CMD_GET_FTKEY, strlen(CMD_GET_FTKEY)) == 0) {
+		bytes_written = wl_cfg80211_get_fbt_key(net, command, priv_cmd.total_len);
+	}
+#endif /* WLFBT */
 #endif /* WL_CFG80211 */
 #if defined(WL_SUPPORT_AUTO_CHANNEL)
 	else if (strnicmp(command, CMD_GET_BEST_CHANNELS,
@@ -5437,7 +5452,9 @@
 		bcm_strncpy_s(iface_name, IFNAMSIZ, "wlan", IFNAMSIZ);
 	}
 
+#ifdef WL_RELMCAST
 	wl_netlink_init();
+#endif /* WL_RELMCAST */
 
 	return ret;
 }
@@ -5447,7 +5464,9 @@
 	int ret = 0;
 	struct io_cfg *cur, *q;
 
+#ifdef WL_RELMCAST
 	wl_netlink_deinit();
+#endif
 
 #if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__)
 #pragma GCC diagnostic push
diff -urN a/drivers/net/wireless/bcmdhd/wl_android_ext.c a/drivers/net/wireless/bcmdhd/wl_android_ext.c
--- a/drivers/net/wireless/bcmdhd/wl_android_ext.c	2020-01-13 17:57:02.387432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_android_ext.c	2020-02-05 09:04:57.000000000 +0300
@@ -16,7 +16,7 @@
 #include <linux/wireless.h>
 #if defined(WL_WIRELESS_EXT)
 #include <wl_iw.h>
-#endif
+#endif /* WL_WIRELESS_EXT */
 #include <wldev_common.h>
 #include <wlioctl.h>
 #include <bcmutils.h>
@@ -27,7 +27,10 @@
 #include <dhd_config.h>
 #ifdef WL_CFG80211
 #include <wl_cfg80211.h>
-#endif
+#endif /* WL_CFG80211 */
+#ifdef WL_ESCAN
+#include <wl_escan.h>
+#endif /* WL_ESCAN */
 
 #define AEXT_ERROR(name, arg1, args...) \
 	do { \
@@ -47,6 +50,12 @@
 			printk(KERN_ERR "[dhd-%s] AEXT-INFO) %s : " arg1, name, __func__, ## args); \
 		} \
 	} while (0)
+#define AEXT_DBG(name, arg1, args...) \
+	do { \
+		if (android_msg_level & ANDROID_DBG_LEVEL) { \
+			printk(KERN_ERR "[dhd-%s] AEXT-DBG) %s : " arg1, name, __func__, ## args); \
+		} \
+	} while (0)
 
 #ifndef WL_CFG80211
 #define htod32(i) i
@@ -60,7 +69,7 @@
 #define WL_SCAN_JOIN_PROBE_INTERVAL_MS 		20
 #define WL_SCAN_JOIN_ACTIVE_DWELL_TIME_MS 	320
 #define WL_SCAN_JOIN_PASSIVE_DWELL_TIME_MS 	400
-#endif
+#endif /* WL_CFG80211 */
 #define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
 
 #ifndef IW_CUSTOM_MAX
@@ -85,13 +94,14 @@
 #define CMD_ISAM_ENABLE			"ISAM_ENABLE"
 #define CMD_ISAM_DISABLE		"ISAM_DISABLE"
 #define CMD_ISAM_STATUS			"ISAM_STATUS"
+#define CMD_ISAM_PARAM			"ISAM_PARAM"
 #ifdef PROP_TXSTATUS
 #ifdef PROP_TXSTATUS_VSDB
 #include <dhd_wlfc.h>
 extern int disable_proptx;
 #endif /* PROP_TXSTATUS_VSDB */
-#endif
-#endif
+#endif /* PROP_TXSTATUS */
+#endif /* WL_EXT_IAPSTA */
 #define CMD_AUTOCHANNEL		"AUTOCHANNEL"
 #define CMD_WL		"WL"
 
@@ -105,9 +115,9 @@
 	IDUALAP_MODE = 6,
 	ISTAAPAP_MODE = 7,
 	IMESHONLY_MODE = 8,
-	IMESHSTA_MODE = 9,
+	ISTAMESH_MODE = 9,
 	IMESHAP_MODE = 10,
-	IMESHAPSTA_MODE = 11,
+	ISTAAPMESH_MODE = 11,
 	IMESHAPAP_MODE = 12
 } apstamode_t;
 
@@ -153,7 +163,7 @@
 	PRIO_AP,
 	PRIO_MESH,
 	PRIO_STA
-}wl_prio_t;
+} wl_prio_t;
 
 typedef struct wl_if_info {
 	struct net_device *dev;
@@ -173,6 +183,10 @@
 	authmode_t amode;
 	encmode_t emode;
 	char key[100];
+#if defined(WLMESH) && defined(WL_ESCAN)
+	struct wl_escan_info *escan;
+	timer_list_compat_t delay_scan;
+#endif /* WLMESH && WL_ESCAN */
 } wl_if_info_t;
 
 #define CSA_FW_BIT		(1<<0)
@@ -183,11 +197,18 @@
 	struct dhd_pub *dhd;
 	int ioctl_ver;
 	bool init;
-	bool rsdb;
+	int rsdb;
 	bool vsdb;
 	uint csa;
+	uint acs;
+	bool radar;
 	apstamode_t apstamode;
 	wait_queue_head_t netif_change_event;
+	struct mutex usr_sync;
+#if defined(WLMESH) && defined(WL_ESCAN)
+	int macs;
+	struct wl_mesh_params mesh_info;
+#endif /* WLMESH && WL_ESCAN */
 } wl_apsta_params_t;
 
 #define MAX_AP_LINK_WAIT_TIME   3000
@@ -210,8 +231,12 @@
 #define wl_chg_isam_status(cur_if, stat) \
 	(change_bit(ISAM_STATUS_ ## stat, &(cur_if)->status))
 
-static int wl_ext_enable_iface(struct net_device *dev, char *ifname);
-#endif
+static int wl_ext_enable_iface(struct net_device *dev, char *ifname, int wait_up);
+static int wl_ext_disable_iface(struct net_device *dev, char *ifname);
+#if defined(WLMESH) && defined(WL_ESCAN)
+static int wl_mesh_escan_attach(dhd_pub_t *dhd, struct wl_if_info *cur_if);
+#endif /* WLMESH && WL_ESCAN */
+#endif /* WL_EXT_IAPSTA */
 
 #ifdef IDHCP
 typedef struct dhcpc_parameter {
@@ -219,7 +244,7 @@
 	uint32 ip_serv;
 	uint32 lease_time;
 } dhcpc_para_t;
-#endif
+#endif /* IDHCP */
 
 #ifdef WL_EXT_WOWL
 #define WL_WOWL_TCPFIN	(1 << 26)
@@ -227,7 +252,7 @@
 	char cmd[4];
 	wl_wowl_pattern_t wowl_pattern;
 } wl_wowl_pattern2_t;
-#endif
+#endif /* WL_EXT_WOWL */
 
 #ifdef WL_EXT_TCPKA
 typedef struct tcpka_conn {
@@ -259,12 +284,12 @@
 	uint32 seq;
 	uint32 ack;
 } tcpka_conn_sess_info_t;
-#endif
+#endif /* WL_EXT_TCPKA */
 
-extern int wl_pattern_atoh(char *src, char *dst);
 static int wl_ext_wl_iovar(struct net_device *dev, char *command, int total_len);
 
-int wl_ext_ioctl(struct net_device *dev, u32 cmd, void *arg, u32 len, u32 set)
+static int
+wl_ext_ioctl(struct net_device *dev, u32 cmd, void *arg, u32 len, u32 set)
 {
 	int ret;
 
@@ -274,7 +299,8 @@
 	return ret;
 }
 
-int wl_ext_iovar_getint(struct net_device *dev, s8 *iovar, s32 *val)
+static int
+wl_ext_iovar_getint(struct net_device *dev, s8 *iovar, s32 *val)
 {
 	int ret;
 
@@ -285,7 +311,8 @@
 	return ret;
 }
 
-int wl_ext_iovar_setint(struct net_device *dev, s8 *iovar, s32 val)
+static int
+wl_ext_iovar_setint(struct net_device *dev, s8 *iovar, s32 val)
 {
 	int ret;
 
@@ -296,7 +323,8 @@
 	return ret;
 }
 
-int wl_ext_iovar_getbuf(struct net_device *dev, s8 *iovar_name,
+static int
+wl_ext_iovar_getbuf(struct net_device *dev, s8 *iovar_name,
 	void *param, s32 paramlen, void *buf, s32 buflen, struct mutex* buf_sync)
 {
 	int ret;
@@ -308,7 +336,8 @@
 	return ret;
 }
 
-int wl_ext_iovar_setbuf(struct net_device *dev, s8 *iovar_name,
+static int
+wl_ext_iovar_setbuf(struct net_device *dev, s8 *iovar_name,
 	void *param, s32 paramlen, void *buf, s32 buflen, struct mutex* buf_sync)
 {
 	int ret;
@@ -320,7 +349,8 @@
 	return ret;
 }
 
-static int wl_ext_iovar_setbuf_bsscfg(struct net_device *dev, s8 *iovar_name,
+static int
+wl_ext_iovar_setbuf_bsscfg(struct net_device *dev, s8 *iovar_name,
 	void *param, s32 paramlen, void *buf, s32 buflen, s32 bsscfg_idx,
 	struct mutex* buf_sync)
 {
@@ -334,9 +364,6 @@
 	return ret;
 }
 
-/* Return a legacy chanspec given a new chanspec
- * Returns INVCHANSPEC on error
- */
 static chanspec_t
 wl_ext_chspec_to_legacy(chanspec_t chspec)
 {
@@ -380,10 +407,6 @@
 	return lchspec;
 }
 
-/* given a chanspec value, do the endian and chanspec version conversion to
- * a chanspec_t value
- * Returns INVCHANSPEC on error
- */
 static chanspec_t
 wl_ext_chspec_host_to_driver(int ioctl_ver, chanspec_t chanspec)
 {
@@ -427,9 +450,6 @@
 
 		join_params->params.chanspec_num =
 			htod32(join_params->params.chanspec_num);
-		AEXT_ERROR("wlan", "join_params->params.chanspec_list[0]= %X, %d channels\n",
-			join_params->params.chanspec_list[0],
-			join_params->params.chanspec_num);
 	}
 }
 
@@ -479,7 +499,107 @@
 
 	return chanspec;
 }
+#endif /* WL_EXT_IAPSTA || WL_CFG80211 || WL_ESCAN */
+
+bool
+wl_ext_check_scan(struct net_device *dev, dhd_pub_t *dhdp)
+{
+#ifdef WL_CFG80211
+	struct bcm_cfg80211 *cfg = wl_get_cfg(dev);
+#endif /* WL_CFG80211 */
+#ifdef WL_ESCAN
+	struct wl_escan_info *escan = dhdp->escan;
+#endif /* WL_ESCAN */
+
+#ifdef WL_CFG80211
+	if (wl_get_drv_status_all(cfg, SCANNING)) {
+		AEXT_ERROR(dev->name, "cfg80211 scanning...\n");
+		return TRUE;
+	}
+#endif /* WL_CFG80211 */
+
+#ifdef WL_ESCAN
+	if (escan->escan_state == ESCAN_STATE_SCANING) {
+		AEXT_ERROR(dev->name, "escan scanning...\n");
+		return TRUE;
+	}
+#endif /* WL_ESCAN */
+
+	return FALSE;
+}
+
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+void
+wl_ext_user_sync(struct dhd_pub *dhd, int ifidx, bool lock)
+{
+	struct net_device *dev = dhd_idx2net(dhd, ifidx);
+#ifdef WL_CFG80211
+	struct bcm_cfg80211 *cfg = wl_get_cfg(dev);
+#endif /* WL_CFG80211 */
+#ifdef WL_ESCAN
+	struct wl_escan_info *escan = dhd->escan;
+#endif /* WL_ESCAN */
+
+	AEXT_INFO(dev->name, "lock=%d\n", lock);
+
+	if (lock) {
+#if defined(WL_CFG80211)
+		mutex_lock(&cfg->usr_sync);
+#endif
+#if defined(WL_ESCAN)
+		mutex_lock(&escan->usr_sync);
+#endif
+	} else {
+#if defined(WL_CFG80211)
+		mutex_unlock(&cfg->usr_sync);
 #endif
+#if defined(WL_ESCAN)
+		mutex_unlock(&escan->usr_sync);
+#endif
+	}
+}
+
+bool
+wl_ext_event_complete(struct dhd_pub *dhd, int ifidx)
+{
+	struct net_device *dev = dhd_idx2net(dhd, ifidx);
+#ifdef WL_CFG80211
+	struct bcm_cfg80211 *cfg = wl_get_cfg(dev);
+#endif /* WL_CFG80211 */
+#ifdef WL_ESCAN
+	struct wl_escan_info *escan = dhd->escan;
+#endif /* WL_ESCAN */
+	bool complete = TRUE;
+
+#ifdef WL_CFG80211
+	if (wl_get_drv_status_all(cfg, SCANNING)) {
+		AEXT_INFO(dev->name, "SCANNING\n");
+		complete = FALSE;
+	}
+	if (wl_get_drv_status_all(cfg, CONNECTING)) {
+		AEXT_INFO(dev->name, "CONNECTING\n");
+		complete = FALSE;
+	}
+	if (wl_get_drv_status_all(cfg, DISCONNECTING)) {
+		AEXT_INFO(dev->name, "DISCONNECTING\n");
+		complete = FALSE;
+	}
+#endif /* WL_CFG80211 */
+#ifdef WL_ESCAN
+	if (escan->escan_state == ESCAN_STATE_SCANING) {
+		AEXT_INFO(dev->name, "ESCAN_STATE_SCANING\n");
+		complete = FALSE;
+	}
+#endif /* WL_ESCAN */
+	if (dhd->conf->eapol_status >= EAPOL_STATUS_4WAY_START &&
+			dhd->conf->eapol_status < EAPOL_STATUS_4WAY_DONE) {
+		AEXT_INFO(dev->name, "4-WAY handshaking\n");
+		complete = FALSE;
+	}
+
+	return complete;
+}
+#endif /* WL_CFG80211 && WL_ESCAN */
 
 static int
 wl_ext_get_ioctl_ver(struct net_device *dev, int *ioctl_ver)
@@ -559,7 +679,7 @@
 			if ((err = wl_ext_iovar_setint(dev, "chanspec", fw_chspec)) == BCME_BADCHAN) {
 				if (bw == WL_CHANSPEC_BW_80)
 					goto change_bw;
-				wl_ext_ioctl(dev, WLC_SET_CHANNEL, &_chan, sizeof(_chan), 1);
+				err = wl_ext_ioctl(dev, WLC_SET_CHANNEL, &_chan, sizeof(_chan), 1);
 				WL_MSG(dev->name, "channel %d\n", _chan);
 			} else if (err) {
 				AEXT_ERROR(dev->name, "failed to set chanspec error %d\n", err);
@@ -587,7 +707,7 @@
 	return err;
 }
 
-int
+static int
 wl_ext_channel(struct net_device *dev, char* command, int total_len)
 {
 	int ret;
@@ -620,7 +740,7 @@
 	return ret;
 }
 
-int
+static int
 wl_ext_channels(struct net_device *dev, char* command, int total_len)
 {
 	int ret, i;
@@ -650,7 +770,7 @@
 	return ret;
 }
 
-int
+static int
 wl_ext_roam_trigger(struct net_device *dev, char* command, int total_len)
 {
 	int ret = 0;
@@ -685,7 +805,7 @@
 	return ret;
 }
 
-int
+static int
 wl_ext_pm(struct net_device *dev, char *command, int total_len)
 {
 	int pm=-1, ret = -1;
@@ -747,19 +867,31 @@
 s32
 wl_ext_connect(struct net_device *dev, struct wl_conn_info *conn_info)
 {
-	wl_extjoin_params_t *ext_join_params;
+	struct dhd_pub *dhd = dhd_get_pub(dev);
+	wl_extjoin_params_t *ext_join_params = NULL;
 	struct wl_join_params join_params;
 	size_t join_params_size;
 	s32 err = 0;
 	u32 chan_cnt = 0;
-	s8 iovar_buf[WLC_IOCTL_SMLEN];
+	s8 *iovar_buf = NULL;
 	int ioctl_ver = 0;
 	char sec[32];
 
+	wl_ext_get_ioctl_ver(dev, &ioctl_ver);
+
+	if (dhd->conf->chip == BCM43362_CHIP_ID)
+		goto set_ssid;
+
 	if (conn_info->channel) {
 		chan_cnt = 1;
 	}
 
+	iovar_buf = kzalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
+	if (iovar_buf == NULL) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
 	/*
 	 *	Join with specific BSSID and cached SSID
 	 *	If SSID is zero join based on BSSID only
@@ -771,7 +903,6 @@
 		err = -ENOMEM;
 		goto exit;
 	}
-	wl_ext_get_ioctl_ver(dev, &ioctl_ver);
 	ext_join_params->ssid.SSID_len = min((uint32)sizeof(ext_join_params->ssid.SSID),
 		conn_info->ssid.SSID_len);
 	memcpy(&ext_join_params->ssid.SSID, conn_info->ssid.SSID, ext_join_params->ssid.SSID_len);
@@ -814,9 +945,8 @@
 		&ext_join_params->assoc.bssid, conn_info->channel,
 		ext_join_params->ssid.SSID, ext_join_params->ssid.SSID_len, sec);
 	err = wl_ext_iovar_setbuf_bsscfg(dev, "join", ext_join_params,
-		join_params_size, iovar_buf, WLC_IOCTL_SMLEN, conn_info->bssidx, NULL);
+		join_params_size, iovar_buf, WLC_IOCTL_MAXLEN, conn_info->bssidx, NULL);
 
-	kfree(ext_join_params);
 	if (err) {
 		if (err == BCME_UNSUPPORTED) {
 			AEXT_TRACE(dev->name, "join iovar is not supported\n");
@@ -832,7 +962,8 @@
 	memset(&join_params, 0, sizeof(join_params));
 	join_params_size = sizeof(join_params.ssid);
 
-	join_params.ssid.SSID_len = min((uint32)sizeof(join_params.ssid.SSID), conn_info->ssid.SSID_len);
+	join_params.ssid.SSID_len = min((uint32)sizeof(join_params.ssid.SSID),
+		conn_info->ssid.SSID_len);
 	memcpy(&join_params.ssid.SSID, conn_info->ssid.SSID, join_params.ssid.SSID_len);
 	join_params.ssid.SSID_len = htod32(join_params.ssid.SSID_len);
 	if (memcmp(&ether_null, &conn_info->bssid, ETHER_ADDR_LEN))
@@ -847,9 +978,18 @@
 		AEXT_INFO(dev->name, "ssid \"%s\", len (%d)\n", join_params.ssid.SSID,
 			join_params.ssid.SSID_len);
 	}
-	err = wl_ext_ioctl(dev, WLC_SET_SSID, &join_params,join_params_size, 1);
+	wl_ext_get_sec(dev, 0, sec, sizeof(sec));
+	WL_MSG(dev->name,
+		"Connecting with %pM channel (%d) ssid \"%s\", len (%d), sec=%s\n\n",
+		&join_params.params.bssid, conn_info->channel,
+		join_params.ssid.SSID, join_params.ssid.SSID_len, sec);
+	err = wl_ext_ioctl(dev, WLC_SET_SSID, &join_params, join_params_size, 1);
 
 exit:
+	if (iovar_buf)
+		kfree(iovar_buf);
+	if (ext_join_params)
+		kfree(ext_join_params);
 	return err;
 
 }
@@ -857,63 +997,186 @@
 void
 wl_ext_get_sec(struct net_device *dev, int ifmode, char *sec, int total_len)
 {
-	int auth=-1, wpa_auth=-1, wsec=0;
+	int auth=0, wpa_auth=0, wsec=0, mfp=0;
 	int bytes_written=0;
 
 	memset(sec, 0, total_len);
 	wl_ext_iovar_getint(dev, "auth", &auth);
 	wl_ext_iovar_getint(dev, "wpa_auth", &wpa_auth);
 	wl_ext_iovar_getint(dev, "wsec", &wsec);
+	wldev_iovar_getint(dev, "mfp", &mfp);
 
-#if defined(WL_EXT_IAPSTA) && defined(WLMESH)
+#ifdef WL_EXT_IAPSTA
 	if (ifmode == IMESH_MODE) {
-		if (auth == 0 && wpa_auth == 0) {
+		if (auth == WL_AUTH_OPEN_SYSTEM && wpa_auth == WPA_AUTH_DISABLED) {
 			bytes_written += snprintf(sec+bytes_written, total_len, "open");
-		} else if (auth == 0 && wpa_auth == 128) {
+		} else if (auth == WL_AUTH_OPEN_SYSTEM && wpa_auth == WPA2_AUTH_PSK) {
 			bytes_written += snprintf(sec+bytes_written, total_len, "sae");
 		} else {
-			bytes_written += snprintf(sec+bytes_written, total_len, "unknown");
+			bytes_written += snprintf(sec+bytes_written, total_len, "%d/0x%x",
+				auth, wpa_auth);
 		}
 	} else
-#endif
-	if (auth == 0 && wpa_auth == 0) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "open");
-	} else if (auth == 1 && wpa_auth == 0) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "shared");
-	} else if (auth == 0 && wpa_auth == 4) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "wpapsk");
-	} else if (auth == 0 && wpa_auth == 128) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "wpa2psk");
-	} else if (auth == 0 && wpa_auth == 132) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "wpawpa2psk");
+#endif /* WL_EXT_IAPSTA */
+	{
+		if (auth == WL_AUTH_OPEN_SYSTEM && wpa_auth == WPA_AUTH_DISABLED) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "open");
+		} else if (auth == WL_AUTH_SHARED_KEY && wpa_auth == WPA_AUTH_DISABLED) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "shared");
+		} else if (auth == WL_AUTH_OPEN_SYSTEM && wpa_auth == WPA_AUTH_PSK) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "wpapsk");
+		} else if (auth == WL_AUTH_OPEN_SYSTEM && wpa_auth == WPA2_AUTH_PSK) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "wpa2psk");
+		} else if (auth == WL_AUTH_OPEN_SHARED && wpa_auth == WPA3_AUTH_SAE_PSK) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "wpa3");
+		} else {
+			bytes_written += snprintf(sec+bytes_written, total_len, "%d/0x%x",
+				auth, wpa_auth);
+		}
+	}
+
+	if (mfp == WL_MFP_NONE) {
+		bytes_written += snprintf(sec+bytes_written, total_len, "/mfpn");
+	} else if (mfp == WL_MFP_CAPABLE) {
+		bytes_written += snprintf(sec+bytes_written, total_len, "/mfpc");
+	} else if (mfp == WL_MFP_REQUIRED) {
+		bytes_written += snprintf(sec+bytes_written, total_len, "/mfpr");
 	} else {
-		bytes_written += snprintf(sec+bytes_written, total_len, "(%d/%d)",
-			auth, wpa_auth);
+		bytes_written += snprintf(sec+bytes_written, total_len, "/%d", mfp);
 	}
 
-#if defined(WL_EXT_IAPSTA) && defined(WLMESH)
+#ifdef WL_EXT_IAPSTA
 	if (ifmode == IMESH_MODE) {
-		if (wsec == 0) {
+		if (wsec == WSEC_NONE) {
 			bytes_written += snprintf(sec+bytes_written, total_len, "/none");
 		} else {
-			bytes_written += snprintf(sec+bytes_written, total_len, "/sae");
+			bytes_written += snprintf(sec+bytes_written, total_len, "/aes");
 		}
 	} else
-#endif
-	if (wsec == 0) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "/none");
-	} else if (wsec == 1) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "/wep");
-	} else if (wsec == 2 || wsec == 10) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "/tkip");
-	} else if (wsec == 4 || wsec == 12) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "/aes");
-	} else if (wsec == 6 || wsec == 14) {
-		bytes_written += snprintf(sec+bytes_written, total_len, "/tkipaes");
-	} else {
-		bytes_written += snprintf(sec+bytes_written, total_len, "/%d", wsec);
+#endif /* WL_EXT_IAPSTA */
+	{
+		if (wsec == WSEC_NONE) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "/none");
+		} else if (wsec == WEP_ENABLED) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "/wep");
+		} else if (wsec == (TKIP_ENABLED|AES_ENABLED) ||
+				wsec == (WSEC_SWFLAG|TKIP_ENABLED|AES_ENABLED)) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "/tkipaes");
+		} else if (wsec == TKIP_ENABLED || wsec == (WSEC_SWFLAG|TKIP_ENABLED)) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "/tkip");
+		} else if (wsec == AES_ENABLED || wsec == (WSEC_SWFLAG|AES_ENABLED)) {
+			bytes_written += snprintf(sec+bytes_written, total_len, "/aes");
+		} else {
+			bytes_written += snprintf(sec+bytes_written, total_len, "/0x%x", wsec);
+		}
+	}
+
+}
+
+static bool
+wl_ext_dfs_chan(uint16 chan)
+{
+	if (chan >= 52 && chan <= 144)
+		return TRUE;
+	return FALSE;
+}
+
+static uint16
+wl_ext_get_default_chan(struct net_device *dev,
+	uint16 *chan_2g, uint16 *chan_5g, bool nodfs)
+{
+	struct dhd_pub *dhd = dhd_get_pub(dev);
+	uint16 chan_tmp = 0, chan = 0;
+	wl_uint32_list_t *list;
+	u8 valid_chan_list[sizeof(u32)*(WL_NUMCHANNELS + 1)];
+	s32 ret = BCME_OK;
+	int i;
+
+	*chan_2g = 0;
+	*chan_5g = 0;
+	memset(valid_chan_list, 0, sizeof(valid_chan_list));
+	list = (wl_uint32_list_t *)(void *) valid_chan_list;
+	list->count = htod32(WL_NUMCHANNELS);
+	ret = wl_ext_ioctl(dev, WLC_GET_VALID_CHANNELS, valid_chan_list,
+		sizeof(valid_chan_list), 0);
+	if (ret == 0) {
+		for (i=0; i<dtoh32(list->count); i++) {
+			chan_tmp = dtoh32(list->element[i]);
+			if (!dhd_conf_match_channel(dhd, chan_tmp))
+				continue;
+			if (chan_tmp <= 13) {
+				*chan_2g = chan_tmp;
+			} else {
+				if (wl_ext_dfs_chan(chan_tmp) && nodfs)
+					continue;
+				else if (chan_tmp >= 36 && chan_tmp <= 161)
+					*chan_5g = chan_tmp;
+			}
+		}
+	}
+
+	return chan;
+}
+
+#if defined(SENDPROB) || (defined(WLMESH) && defined(WL_ESCAN))
+static int
+wl_ext_add_del_ie(struct net_device *dev, uint pktflag, char *ie_data, const char* add_del_cmd)
+{
+	vndr_ie_setbuf_t *vndr_ie = NULL;
+	char iovar_buf[WLC_IOCTL_SMLEN]="\0";
+	int ie_data_len = 0, tot_len = 0, iecount;
+	int err = -1;
+
+	if (!strlen(ie_data)) {
+		AEXT_ERROR(dev->name, "wrong ie %s\n", ie_data);
+		goto exit;
+	}
+
+	tot_len = (int)(sizeof(vndr_ie_setbuf_t) + ((strlen(ie_data)-2)/2));
+	vndr_ie = (vndr_ie_setbuf_t *) kzalloc(tot_len, GFP_KERNEL);
+	if (!vndr_ie) {
+		AEXT_ERROR(dev->name, "IE memory alloc failed\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	/* Copy the vndr_ie SET command ("add"/"del") to the buffer */
+	strncpy(vndr_ie->cmd, add_del_cmd, VNDR_IE_CMD_LEN - 1);
+	vndr_ie->cmd[VNDR_IE_CMD_LEN - 1] = '\0';
+
+	/* Set the IE count - the buffer contains only 1 IE */
+	iecount = htod32(1);
+	memcpy((void *)&vndr_ie->vndr_ie_buffer.iecount, &iecount, sizeof(s32));
+
+	/* Set packet flag to indicate that BEACON's will contain this IE */
+	pktflag = htod32(pktflag);
+	memcpy((void *)&vndr_ie->vndr_ie_buffer.vndr_ie_list[0].pktflag, &pktflag,
+		sizeof(u32));
+
+	/* Set the IE ID */
+	vndr_ie->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.id = (uchar)DOT11_MNG_VS_ID;
+
+	/* Set the IE LEN */
+	vndr_ie->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.len = (strlen(ie_data)-2)/2;
+
+	/* Set the IE OUI and DATA */
+	ie_data_len = wl_pattern_atoh(ie_data,
+		(char *)vndr_ie->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.oui);
+	if (ie_data_len <= 0) {
+		AEXT_ERROR(dev->name, "wrong ie_data_len %d\n", (int)strlen(ie_data)-2);
+		goto exit;
+	}
+
+	err = wl_ext_iovar_setbuf(dev, "vndr_ie", vndr_ie, tot_len, iovar_buf,
+		sizeof(iovar_buf), NULL);
+
+exit:
+	if (vndr_ie) {
+		kfree(vndr_ie);
 	}
+	return err;
 }
+#endif /* SENDPROB || (WLMESH && WL_ESCAN) */
 
 #ifdef WL_EXT_IAPSTA
 static int
@@ -1035,35 +1298,35 @@
 #ifdef WLMESH
 	if (cur_if->ifmode == IMESH_MODE) {
 		if (amode == AUTH_SAE) {
-			auth = 0;
-			wpa_auth = 128;
+			auth = WL_AUTH_OPEN_SYSTEM;
+			wpa_auth = WPA2_AUTH_PSK;
 			AEXT_INFO(dev->name, "SAE\n");
 		} else {
-			auth = 0;
-			wpa_auth = 0;
+			auth = WL_AUTH_OPEN_SYSTEM;
+			wpa_auth = WPA_AUTH_DISABLED;
 			AEXT_INFO(dev->name, "Open System\n");
 		}
 	} else
-#endif
+#endif /* WLMESH */
 	if (amode == AUTH_OPEN) {
-		auth = 0;
-		wpa_auth = 0;
+		auth = WL_AUTH_OPEN_SYSTEM;
+		wpa_auth = WPA_AUTH_DISABLED;
 		AEXT_INFO(dev->name, "Open System\n");
 	} else if (amode == AUTH_SHARED) {
-		auth = 1;
-		wpa_auth = 0;
+		auth = WL_AUTH_SHARED_KEY;
+		wpa_auth = WPA_AUTH_DISABLED;
 		AEXT_INFO(dev->name, "Shared Key\n");
 	} else if (amode == AUTH_WPAPSK) {
-		auth = 0;
-		wpa_auth = 4;
+		auth = WL_AUTH_OPEN_SYSTEM;
+		wpa_auth = WPA_AUTH_PSK;
 		AEXT_INFO(dev->name, "WPA-PSK\n");
 	} else if (amode == AUTH_WPA2PSK) {
-		auth = 0;
-		wpa_auth = 128;
+		auth = WL_AUTH_OPEN_SYSTEM;
+		wpa_auth = WPA2_AUTH_PSK;
 		AEXT_INFO(dev->name, "WPA2-PSK\n");
 	} else if (amode == AUTH_WPAWPA2PSK) {
-		auth = 0;
-		wpa_auth = 132;
+		auth = WL_AUTH_OPEN_SYSTEM;
+		wpa_auth = WPA2_AUTH_PSK | WPA_AUTH_PSK;
 		AEXT_INFO(dev->name, "WPA/WPA2-PSK\n");
 	}
 #ifdef WLMESH
@@ -1071,7 +1334,7 @@
 		s32 val = WL_BSSTYPE_MESH;
 		wl_ext_ioctl(dev, WLC_SET_INFRA, &val, sizeof(val), 1);
 	} else
-#endif
+#endif /* WLMESH */
 	if (cur_if->ifmode == ISTA_MODE) {
 		s32 val = WL_BSSTYPE_INFRA;
 		wl_ext_ioctl(dev, WLC_SET_INFRA, &val, sizeof(val), 1);
@@ -1102,33 +1365,33 @@
 #ifdef WLMESH
 	if (cur_if->ifmode == IMESH_MODE) {
 		if (amode == AUTH_SAE) {
-			wsec = 4;
+			wsec = AES_ENABLED;
 		} else {
-			wsec = 0;
+			wsec = WSEC_NONE;
 		}
 	} else
-#endif
+#endif /* WLMESH */
 	if (emode == ENC_NONE) {
-		wsec = 0;
+		wsec = WSEC_NONE;
 		AEXT_INFO(dev->name, "No securiy\n");
 	} else if (emode == ENC_WEP) {
-		wsec = 1;
+		wsec = WEP_ENABLED;
 		wl_ext_parse_wep(key, &wsec_key);
 		AEXT_INFO(dev->name, "WEP key \"%s\"\n", wsec_key.data);
 	} else if (emode == ENC_TKIP) {
-		wsec = 2;
+		wsec = TKIP_ENABLED;
 		psk.key_len = strlen(key);
 		psk.flags = WSEC_PASSPHRASE;
 		memcpy(psk.key, key, strlen(key));
 		AEXT_INFO(dev->name, "TKIP key \"%s\"\n", psk.key);
 	} else if (emode == ENC_AES || amode == AUTH_SAE) {
-		wsec = 4;
+		wsec = AES_ENABLED;
 		psk.key_len = strlen(key);
 		psk.flags = WSEC_PASSPHRASE;
 		memcpy(psk.key, key, strlen(key));
 		AEXT_INFO(dev->name, "AES key \"%s\"\n", psk.key);
 	} else if (emode == ENC_TKIPAES) {
-		wsec = 6;
+		wsec = TKIP_ENABLED | AES_ENABLED;
 		psk.key_len = strlen(key);
 		psk.flags = WSEC_PASSPHRASE;
 		memcpy(psk.key, key, strlen(key));
@@ -1136,7 +1399,7 @@
 	}
 	if (dhd->conf->chip == BCM43430_CHIP_ID && cur_if->ifidx > 0 && wsec >= 2 &&
 			apsta_params->apstamode == ISTAAP_MODE) {
-		wsec |= 0x8; // terence 20180628: fix me, this is a workaround
+		wsec |= WSEC_SWFLAG; // terence 20180628: fix me, this is a workaround
 	}
 
 	wl_ext_iovar_setint(dev, "wsec", wsec);
@@ -1145,7 +1408,7 @@
 	if (cur_if->ifmode == IMESH_MODE) {
 		if (amode == AUTH_SAE) {
 			s8 iovar_buf[WLC_IOCTL_SMLEN];
-			AEXT_INFO(dev->name, "SAE key \"%s\"\n", key);
+			AEXT_INFO(dev->name, "AES key \"%s\"\n", key);
 			wl_ext_iovar_setint(dev, "mesh_auth_proto", 1);
 			wl_ext_iovar_setint(dev, "mfp", WL_MFP_REQUIRED);
 			wl_ext_iovar_setbuf(dev, "sae_password", key, strlen(key),
@@ -1156,7 +1419,7 @@
 			wl_ext_iovar_setint(dev, "mfp", WL_MFP_NONE);
 		}
 	} else
-#endif
+#endif /* WLMESH */
 	if (emode == ENC_WEP) {
 		wl_ext_ioctl(dev, WLC_SET_KEY, &wsec_key, sizeof(wsec_key), 1);
 	} else if (emode == ENC_TKIP || emode == ENC_AES || emode == ENC_TKIPAES) {
@@ -1279,6 +1542,20 @@
 	return fw_chspec;
 }
 
+static bool
+wl_ext_radar_detect(struct net_device *dev)
+{
+	int ret = BCME_OK;
+	bool radar = FALSE;
+	s32 val = 0;
+
+	if ((ret = wldev_ioctl(dev, WLC_GET_RADAR, &val, sizeof(int), false) == 0)) {
+		radar = TRUE;
+	}
+
+	return radar;
+}
+
 static void
 wl_ext_wait_netif_change(struct wl_apsta_params *apsta_params,
 	struct wl_if_info *cur_if)
@@ -1290,67 +1567,114 @@
 	rtnl_lock();
 }
 
-bool
-wl_ext_check_mesh_creating(struct net_device *net)
+static void
+wl_ext_interface_create(struct net_device *dev, struct wl_apsta_params *apsta_params,
+	struct wl_if_info *cur_if, int iftype, u8 *addr)
 {
-	struct dhd_pub *dhd = dhd_get_pub(net);
-	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
-	struct wl_if_info *cur_if;
-	int i;
+	wl_interface_create_t iface;
+	u8 iovar_buf[WLC_IOCTL_SMLEN];
 
-	if (apsta_params) {
-		for (i=0; i<MAX_IF_NUM; i++) {
-			cur_if = &apsta_params->if_info[i];
-			if (cur_if->ifmode==IMESH_MODE && wl_get_isam_status(cur_if, IF_ADDING))
-				return TRUE;
-		}
-	}
-	return FALSE;
+	bzero(&iface, sizeof(iface));
+	if (addr) {
+		iftype |= WL_INTERFACE_MAC_USE;
+	}
+	iface.ver = WL_INTERFACE_CREATE_VER;
+	iface.flags = iftype;
+	if (addr) {
+		memcpy(&iface.mac_addr.octet, addr, ETH_ALEN);
+	}
+	wl_set_isam_status(cur_if, IF_ADDING);
+	wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
+		iovar_buf, WLC_IOCTL_SMLEN, NULL);
+	wl_ext_wait_netif_change(apsta_params, cur_if);
 }
 
-bool
-wl_ext_check_other_enabling(struct wl_apsta_params *apsta_params,
-	struct wl_if_info *cur_if)
+static void
+wl_ext_iapsta_intf_add(struct net_device *dev, struct wl_apsta_params *apsta_params)
 {
-	struct wl_if_info *tmp_if;
-	bool enabling = FALSE;
-	u32 timeout = 1;
-	int i;
+	struct dhd_pub *dhd;
+	apstamode_t apstamode = apsta_params->apstamode;
+	struct wl_if_info *cur_if;
+	wlc_ssid_t ssid = { 0, {0} };
+	s8 iovar_buf[WLC_IOCTL_SMLEN];
+	wl_p2p_if_t ifreq;
+	struct ether_addr mac_addr;
 
-	for (i=0; i<MAX_IF_NUM; i++) {
-		tmp_if = &apsta_params->if_info[i];
-		if (tmp_if->dev && tmp_if->dev != cur_if->dev) {
-			if (tmp_if->ifmode == ISTA_MODE)
-				enabling = wl_get_isam_status(tmp_if, STA_CONNECTING);
-			else if (tmp_if->ifmode == IAP_MODE || tmp_if->ifmode == IMESH_MODE)
-				enabling = wl_get_isam_status(tmp_if, AP_CREATING);
-			if (enabling)
-				WL_MSG(cur_if->ifname, "waiting for %s[%c] enabling...\n",
-					tmp_if->ifname, tmp_if->prefix);
-			if (enabling && tmp_if->ifmode == ISTA_MODE) {
-				timeout = wait_event_interruptible_timeout(
-					apsta_params->netif_change_event,
-					!wl_get_isam_status(tmp_if, STA_CONNECTING),
-					msecs_to_jiffies(MAX_STA_LINK_WAIT_TIME));
-			} else if (enabling &&
-					(tmp_if->ifmode == IAP_MODE || tmp_if->ifmode == IMESH_MODE)) {
-				timeout = wait_event_interruptible_timeout(
-					apsta_params->netif_change_event,
-					!wl_get_isam_status(tmp_if, AP_CREATING),
-					msecs_to_jiffies(MAX_STA_LINK_WAIT_TIME));
-			}
-			if (tmp_if->ifmode == ISTA_MODE)
-				enabling = wl_get_isam_status(tmp_if, STA_CONNECTING);
-			else if (tmp_if->ifmode == IAP_MODE || tmp_if->ifmode == IMESH_MODE)
-				enabling = wl_get_isam_status(tmp_if, AP_CREATING);
-			if (timeout <= 0 || enabling) {
-				WL_MSG(cur_if->ifname, "%s[%c] is still enabling...\n",
-					tmp_if->ifname, tmp_if->prefix);
-			}
+	dhd = dhd_get_pub(dev);
+	bzero(&mac_addr, sizeof(mac_addr));
+
+	if (apstamode == ISTAAP_MODE) {
+		cur_if = &apsta_params->if_info[IF_VIF];
+		if (FW_SUPPORTED(dhd, rsdb)) {
+			wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP, NULL);
+		} else {
+			wl_set_isam_status(cur_if, IF_ADDING);
+			wl_ext_iovar_setbuf_bsscfg(dev, "ssid", &ssid, sizeof(ssid),
+				iovar_buf, WLC_IOCTL_SMLEN, 1, NULL);
+			wl_ext_wait_netif_change(apsta_params, cur_if);
 		}
 	}
+	else if (apstamode == ISTAGO_MODE) {
+		bzero(&ifreq, sizeof(wl_p2p_if_t));
+		ifreq.type = htod32(WL_P2P_IF_GO);
+		cur_if = &apsta_params->if_info[IF_VIF];
+		wl_set_isam_status(cur_if, IF_ADDING);
+		wl_ext_iovar_setbuf(dev, "p2p_ifadd", &ifreq, sizeof(ifreq),
+			iovar_buf, WLC_IOCTL_SMLEN, NULL);
+		wl_ext_wait_netif_change(apsta_params, cur_if);
+	}
+	else if (apstamode == ISTASTA_MODE) {
+		cur_if = &apsta_params->if_info[IF_VIF];
+		memcpy(&mac_addr, dev->dev_addr, ETHER_ADDR_LEN);
+		mac_addr.octet[0] |= 0x02;
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_STA,
+			(u8*)&mac_addr);
+	}
+	else if (apstamode == IDUALAP_MODE) {
+		cur_if = &apsta_params->if_info[IF_VIF];
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP, NULL);
+	}
+	else if (apstamode == ISTAAPAP_MODE) {
+		u8 rand_bytes[2] = {0, };
+		get_random_bytes(&rand_bytes, sizeof(rand_bytes));
+		cur_if = &apsta_params->if_info[IF_VIF];
+		memcpy(&mac_addr, dev->dev_addr, ETHER_ADDR_LEN);
+		mac_addr.octet[0] |= 0x02;
+		mac_addr.octet[5] += 0x01;
+		memcpy(&mac_addr.octet[3], rand_bytes, sizeof(rand_bytes));
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP,
+			(u8*)&mac_addr);
+		cur_if = &apsta_params->if_info[IF_VIF2];
+		memcpy(&mac_addr, dev->dev_addr, ETHER_ADDR_LEN);
+		mac_addr.octet[0] |= 0x02;
+		mac_addr.octet[5] += 0x02;
+		memcpy(&mac_addr.octet[3], rand_bytes, sizeof(rand_bytes));
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP,
+			(u8*)&mac_addr);
+	}
+#ifdef WLMESH
+	else if (apstamode == ISTAMESH_MODE) {
+		cur_if = &apsta_params->if_info[IF_VIF];
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_STA, NULL);
+	}
+	else if (apstamode == IMESHAP_MODE) {
+		cur_if = &apsta_params->if_info[IF_VIF];
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP, NULL);
+	}
+	else if (apstamode == ISTAAPMESH_MODE) {
+		cur_if = &apsta_params->if_info[IF_VIF];
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP, NULL);
+		cur_if = &apsta_params->if_info[IF_VIF2];
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_STA, NULL);
+	}
+	else if (apstamode == IMESHAPAP_MODE) {
+		cur_if = &apsta_params->if_info[IF_VIF];
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP, NULL);
+		cur_if = &apsta_params->if_info[IF_VIF2];
+		wl_ext_interface_create(dev, apsta_params, cur_if, WL_INTERFACE_CREATE_AP, NULL);
+	}
+#endif /* WLMESH */
 
-	return enabling;
 }
 
 static void
@@ -1358,14 +1682,10 @@
 {
 	struct dhd_pub *dhd;
 	apstamode_t apstamode = apsta_params->apstamode;
-	wl_interface_create_t iface;
 	struct wl_if_info *cur_if;
-	wlc_ssid_t ssid = { 0, {0} };
 	s8 iovar_buf[WLC_IOCTL_SMLEN];
-	wl_country_t cspec = {{0}, 0, {0}};
-	wl_p2p_if_t ifreq;
 	s32 val = 0;
-	int i, dfs = 1;
+	int i;
 
 	dhd = dhd_get_pub(dev);
 
@@ -1385,7 +1705,6 @@
 			cur_if->prio = PRIO_AP;
 			cur_if->prefix = 'A';
 			snprintf(cur_if->ssid, DOT11_MAX_SSID_LEN, "ttt_ap");
-			dfs = 0;
 #ifdef WLMESH
 		} else if (cur_if->ifmode == IMESH_MODE) {
 			cur_if->channel = 1;
@@ -1393,35 +1712,25 @@
 			cur_if->prio = PRIO_MESH;
 			cur_if->prefix = 'M';
 			snprintf(cur_if->ssid, DOT11_MAX_SSID_LEN, "ttt_mesh");
-			dfs = 0;
-#endif
-		}
-	}
-
-	if (!dfs && !apsta_params->vsdb) {
-		dhd_conf_get_country(dhd, &cspec);
-		if (!dhd_conf_map_country_list(dhd, &cspec)) {
-			dhd_conf_set_country(dhd, &cspec);
-			dhd_bus_country_set(dev, &cspec, TRUE);
+#ifdef WL_ESCAN
+			if (i == 0 && apsta_params->macs)
+				wl_mesh_escan_attach(dhd, cur_if);
+#endif /* WL_ESCAN */
+#endif /* WLMESH */
 		}
-		wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
-		wl_ext_iovar_setint(dev, "dfs_chan_disable", 1);
-		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
 	}
 
 	if (FW_SUPPORTED(dhd, rsdb)) {
 		if (apstamode == IDUALAP_MODE)
-			apsta_params->rsdb = TRUE;
+			apsta_params->rsdb = -1;
 		else if (apstamode == ISTAAPAP_MODE)
-			apsta_params->rsdb = FALSE;
-		if (apstamode == ISTAAP_MODE || apstamode == ISTAAPAP_MODE ||
-			apstamode == IDUALAP_MODE ||
-			apstamode == IMESHONLY_MODE || apstamode == IMESHSTA_MODE ||
-			apstamode == IMESHAP_MODE || apstamode == IMESHAPSTA_MODE ||
-			apstamode == IMESHAPAP_MODE) {
+			apsta_params->rsdb = 0;
+		if (apstamode == ISTAAPAP_MODE || apstamode == IDUALAP_MODE ||
+				apstamode == IMESHONLY_MODE || apstamode == ISTAMESH_MODE ||
+				apstamode == IMESHAP_MODE || apstamode == ISTAAPMESH_MODE ||
+				apstamode == IMESHAPAP_MODE) {
 			wl_config_t rsdb_mode_cfg = {0, 0};
-			if (apsta_params->rsdb)
-				rsdb_mode_cfg.config = 1;
+			rsdb_mode_cfg.config = apsta_params->rsdb;
 			AEXT_INFO(dev->name, "set rsdb_mode %d\n", rsdb_mode_cfg.config);
 			wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
 			wl_ext_iovar_setbuf(dev, "rsdb_mode", &rsdb_mode_cfg,
@@ -1429,7 +1738,7 @@
 			wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
 		}
 	} else {
-		apsta_params->rsdb = FALSE;
+		apsta_params->rsdb = 0;
 	}
 
 	if (apstamode == ISTAONLY_MODE) {
@@ -1450,7 +1759,7 @@
 		wl_ext_ioctl(dev, WLC_SET_AP, &val, sizeof(val), 1);
 #ifdef PROP_TXSTATUS_VSDB
 #if defined(BCMSDIO)
-		if (!apsta_params->rsdb && !disable_proptx) {
+		if (!(FW_SUPPORTED(dhd, rsdb)) && !disable_proptx) {
 			bool enabled;
 			dhd_wlfc_get_enable(dhd, &enabled);
 			if (!enabled) {
@@ -1458,7 +1767,7 @@
 				wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
 			}
 		}
-#endif
+#endif /* BCMSDIO */
 #endif /* PROP_TXSTATUS_VSDB */
 	}
 	else if (apstamode == ISTAAP_MODE) {
@@ -1466,43 +1775,13 @@
 		wl_ext_iovar_setint(dev, "mpc", 0);
 		wl_ext_iovar_setint(dev, "apsta", 1);
 		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
-		cur_if = &apsta_params->if_info[IF_VIF];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		if (apsta_params->rsdb) {
-			bzero(&iface, sizeof(wl_interface_create_t));
-			iface.ver = WL_INTERFACE_CREATE_VER;
-			iface.flags = WL_INTERFACE_CREATE_AP;
-			wl_ext_iovar_getbuf(dev, "interface_create", &iface,
-				sizeof(iface), iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		} else {
-			wl_ext_iovar_setbuf_bsscfg(dev, "ssid", &ssid, sizeof(ssid),
-				iovar_buf, WLC_IOCTL_SMLEN, 1, NULL);
-		}
-		wl_ext_wait_netif_change(apsta_params, cur_if);
 	}
 	else if (apstamode == ISTAGO_MODE) {
 		wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
 		wl_ext_iovar_setint(dev, "apsta", 1);
 		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
-		bzero(&ifreq, sizeof(wl_p2p_if_t));
-		ifreq.type = htod32(WL_P2P_IF_GO);
-		cur_if = &apsta_params->if_info[IF_VIF];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_setbuf(dev, "p2p_ifadd", &ifreq, sizeof(ifreq),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
 	}
 	else if (apstamode == ISTASTA_MODE) {
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_STA | WL_INTERFACE_MAC_USE;
-		memcpy(&iface.mac_addr, dev->dev_addr, ETHER_ADDR_LEN);
-		iface.mac_addr.octet[0] |= 0x02;
-		cur_if = &apsta_params->if_info[IF_VIF];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface,
-			sizeof(iface), iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
 	}
 	else if (apstamode == IDUALAP_MODE) {
 		wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
@@ -1518,139 +1797,31 @@
 		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
 		val = 1;
 		wl_ext_ioctl(dev, WLC_SET_AP, &val, sizeof(val), 1);
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_AP;
-		cur_if = &apsta_params->if_info[IF_VIF];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
 	}
 	else if (apstamode == ISTAAPAP_MODE) {
-		u8 rand_bytes[2] = {0, };
-		get_random_bytes(&rand_bytes, sizeof(rand_bytes));
 		wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
 		wl_ext_iovar_setint(dev, "mpc", 0);
 		wl_ext_iovar_setint(dev, "mbss", 1);
 		wl_ext_iovar_setint(dev, "apsta", 1); // keep 1 as we set in dhd_preinit_ioctls
 		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
 		// don't set WLC_SET_AP to 0, some parameters will be reset, such as bcn_timeout and roam_off
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_AP | WL_INTERFACE_MAC_USE;
-		memcpy(&iface.mac_addr, dev->dev_addr, ETHER_ADDR_LEN);
-		iface.mac_addr.octet[0] |= 0x02;
-		iface.mac_addr.octet[5] += 0x01;
-		memcpy(&iface.mac_addr.octet[3], rand_bytes, sizeof(rand_bytes));
-		cur_if = &apsta_params->if_info[IF_VIF];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_AP | WL_INTERFACE_MAC_USE;
-		memcpy(&iface.mac_addr, dev->dev_addr, ETHER_ADDR_LEN);
-		iface.mac_addr.octet[0] |= 0x02;
-		iface.mac_addr.octet[5] += 0x02;
-		memcpy(&iface.mac_addr.octet[3], rand_bytes, sizeof(rand_bytes));
-		cur_if = &apsta_params->if_info[IF_VIF2];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
 	}
 #ifdef WLMESH
-	else if (apstamode == IMESHONLY_MODE) {
+	else if (apstamode == IMESHONLY_MODE || apstamode == ISTAMESH_MODE ||
+			apstamode == IMESHAP_MODE || apstamode == ISTAAPMESH_MODE ||
+			apstamode == IMESHAPAP_MODE) {
 		int pm = 0;
 		wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
 		wl_ext_iovar_setint(dev, "mpc", 0);
-		wl_ext_iovar_setint(dev, "apsta", 1); // keep 1 as we set in dhd_preinit_ioctls
-		wl_ext_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm), 1);
-		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
-		// don't set WLC_SET_AP to 0, some parameters will be reset, such as bcn_timeout and roam_off
-	}
-	else if (apstamode == IMESHSTA_MODE) {
-		wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
-		wl_ext_iovar_setint(dev, "mpc", 0);
-		wl_ext_iovar_setint(dev, "mbcn", 1);
-		wl_ext_iovar_setint(dev, "apsta", 1);
-		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_STA;
-		cur_if = &apsta_params->if_info[IF_VIF];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
-	}
-	else if (apstamode == IMESHAP_MODE) {
-		wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
-		wl_ext_iovar_setint(dev, "mpc", 0);
-		wl_ext_iovar_setint(dev, "mbcn", 1);
-		wl_ext_iovar_setint(dev, "apsta", 1); // keep 1 as we set in dhd_preinit_ioctls
-		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
-		// don't set WLC_SET_AP to 0, some parameters will be reset, such as bcn_timeout and roam_off
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_STA;
-		cur_if = &apsta_params->if_info[IF_VIF];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
-	}
-	else if (apstamode == IMESHAPSTA_MODE) {
-		wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
-		wl_ext_iovar_setint(dev, "mpc", 0);
-		wl_ext_iovar_setint(dev, "mbcn", 1);
+		if (apstamode == IMESHONLY_MODE)
+			wl_ext_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm), 1);
+		else
+			wl_ext_iovar_setint(dev, "mbcn", 1);
 		wl_ext_iovar_setint(dev, "apsta", 1); // keep 1 as we set in dhd_preinit_ioctls
 		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
 		// don't set WLC_SET_AP to 0, some parameters will be reset, such as bcn_timeout and roam_off
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_AP;
-		cur_if = &apsta_params->if_info[IF_VIF];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_STA;
-		cur_if = &apsta_params->if_info[IF_VIF2];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
 	}
-	else if (apstamode == IMESHAPAP_MODE) {
-		wl_ext_ioctl(dev, WLC_DOWN, NULL, 0, 1);
-		wl_ext_iovar_setint(dev, "mpc", 0);
-		wl_ext_iovar_setint(dev, "mbcn", 1);
-		wl_ext_iovar_setint(dev, "apsta", 1); // keep 1 as we set in dhd_preinit_ioctls
-		wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
-		// don't set WLC_SET_AP to 0, some parameters will be reset, such as bcn_timeout and roam_off
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_AP;
-		cur_if = &apsta_params->if_info[IF_VIF];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
-		bzero(&iface, sizeof(wl_interface_create_t));
-		iface.ver = WL_INTERFACE_CREATE_VER;
-		iface.flags = WL_INTERFACE_CREATE_AP;
-		cur_if = &apsta_params->if_info[IF_VIF2];
-		wl_set_isam_status(cur_if, IF_ADDING);
-		wl_ext_iovar_getbuf(dev, "interface_create", &iface, sizeof(iface),
-			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-		wl_ext_wait_netif_change(apsta_params, cur_if);
-	}
-#endif
+#endif /* WLMESH */
 
 	wl_ext_get_ioctl_ver(dev, &apsta_params->ioctl_ver);
 	apsta_params->init = TRUE;
@@ -1659,6 +1830,39 @@
 }
 
 static int
+wl_ext_isam_param(struct net_device *dev, char *command, int total_len)
+{
+	struct dhd_pub *dhd = dhd_get_pub(dev);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	int ret = -1;
+	char *pick_tmp, *data, *param;
+	int bytes_written=-1;
+
+	AEXT_TRACE(dev->name, "command=%s, len=%d\n", command, total_len);
+
+	pick_tmp = command;
+	param = bcmstrtok(&pick_tmp, " ", 0); // pick isam_param
+	param = bcmstrtok(&pick_tmp, " ", 0); // pick cmd
+	while (param != NULL) {
+		data = bcmstrtok(&pick_tmp, " ", 0); // pick data
+		if (!strcmp(param, "acs")) {
+			if (data) {
+				apsta_params->acs = simple_strtol(data, NULL, 0);
+				ret = 0;
+			} else {
+				bytes_written = snprintf(command, total_len, "%d", apsta_params->acs);
+				ret = bytes_written;
+				goto exit;
+			}
+		}
+		param = bcmstrtok(&pick_tmp, " ", 0); // pick cmd
+	}
+
+exit:
+	return ret;
+}
+
+static int
 wl_ext_isam_init(struct net_device *dev, char *command, int total_len)
 {
 	struct dhd_pub *dhd = dhd_get_pub(dev);
@@ -1676,124 +1880,104 @@
 	param = bcmstrtok(&pick_tmp, " ", 0); // skip iapsta_init
 	param = bcmstrtok(&pick_tmp, " ", 0);
 	while (param != NULL) {
+		pick_tmp2 = bcmstrtok(&pick_tmp, " ", 0);
+		if (!pick_tmp2) {
+			AEXT_ERROR(dev->name, "wrong param %s\n", param);
+			return -1;
+		}
 		if (!strcmp(param, "mode")) {
 			pch = NULL;
-			pick_tmp2 = bcmstrtok(&pick_tmp, " ", 0);
-			if (pick_tmp2) {
-				if (!strcmp(pick_tmp2, "sta")) {
-					apsta_params->apstamode = ISTAONLY_MODE;
-				} else if (!strcmp(pick_tmp2, "ap")) {
-					apsta_params->apstamode = IAPONLY_MODE;
-				} else if (!strcmp(pick_tmp2, "sta-ap")) {
-					apsta_params->apstamode = ISTAAP_MODE;
-				} else if (!strcmp(pick_tmp2, "sta-sta")) {
-					apsta_params->apstamode = ISTASTA_MODE;
-					apsta_params->vsdb = TRUE;
-				} else if (!strcmp(pick_tmp2, "ap-ap")) {
-					apsta_params->apstamode = IDUALAP_MODE;
-				} else if (!strcmp(pick_tmp2, "sta-ap-ap")) {
-					apsta_params->apstamode = ISTAAPAP_MODE;
-#ifdef WLMESH
-				} else if (!strcmp(pick_tmp2, "mesh")) {
-					apsta_params->apstamode = IMESHONLY_MODE;
-				} else if (!strcmp(pick_tmp2, "mesh-sta") ||
-						!strcmp(pick_tmp2, "sta-mesh")) {
-					apsta_params->apstamode = IMESHSTA_MODE;
-				} else if (!strcmp(pick_tmp2, "mesh-ap") ||
-						!strcmp(pick_tmp2, "ap-mesh")) {
-					apsta_params->apstamode = IMESHAP_MODE;
-				} else if (!strcmp(pick_tmp2, "mesh-ap-sta") ||
-						!strcmp(pick_tmp2, "sta-ap-mesh") ||
-						!strcmp(pick_tmp2, "sta-mesh-ap")) {
-					apsta_params->apstamode = IMESHAPSTA_MODE;
-				} else if (!strcmp(pick_tmp2, "mesh-ap-ap") ||
-						!strcmp(pick_tmp2, "ap-ap-mesh")) {
-					apsta_params->apstamode = IMESHAPAP_MODE;
-#endif
-				} else if (!strcmp(pick_tmp2, "apsta")) {
-					apsta_params->apstamode = ISTAAP_MODE;
-					apsta_params->if_info[IF_PIF].ifmode = ISTA_MODE;
-					apsta_params->if_info[IF_VIF].ifmode = IAP_MODE;
-				} else if (!strcmp(pick_tmp2, "dualap")) {
-					apsta_params->apstamode = IDUALAP_MODE;
-					apsta_params->if_info[IF_PIF].ifmode = IAP_MODE;
-					apsta_params->if_info[IF_VIF].ifmode = IAP_MODE;
-				} else if (!strcmp(pick_tmp2, "gosta")) {
-					if (!FW_SUPPORTED(dhd, p2p)) {
-						return -1;
-					}
-					apsta_params->apstamode = ISTAGO_MODE;
-					apsta_params->if_info[IF_PIF].ifmode = ISTA_MODE;
-					apsta_params->if_info[IF_VIF].ifmode = IAP_MODE;
-				} else {
-					AEXT_ERROR(dev->name, "mode [sta|ap|sta-ap|ap-ap]\n");
+			if (!strcmp(pick_tmp2, "sta")) {
+				apsta_params->apstamode = ISTAONLY_MODE;
+			} else if (!strcmp(pick_tmp2, "ap")) {
+				apsta_params->apstamode = IAPONLY_MODE;
+			} else if (!strcmp(pick_tmp2, "sta-ap")) {
+				apsta_params->apstamode = ISTAAP_MODE;
+			} else if (!strcmp(pick_tmp2, "sta-sta")) {
+				apsta_params->apstamode = ISTASTA_MODE;
+				apsta_params->vsdb = TRUE;
+			} else if (!strcmp(pick_tmp2, "ap-ap")) {
+				apsta_params->apstamode = IDUALAP_MODE;
+			} else if (!strcmp(pick_tmp2, "sta-ap-ap")) {
+				apsta_params->apstamode = ISTAAPAP_MODE;
+			} else if (!strcmp(pick_tmp2, "apsta")) {
+				apsta_params->apstamode = ISTAAP_MODE;
+				apsta_params->if_info[IF_PIF].ifmode = ISTA_MODE;
+				apsta_params->if_info[IF_VIF].ifmode = IAP_MODE;
+			} else if (!strcmp(pick_tmp2, "dualap")) {
+				apsta_params->apstamode = IDUALAP_MODE;
+				apsta_params->if_info[IF_PIF].ifmode = IAP_MODE;
+				apsta_params->if_info[IF_VIF].ifmode = IAP_MODE;
+			} else if (!strcmp(pick_tmp2, "sta-go") ||
+					!strcmp(pick_tmp2, "gosta")) {
+				if (!FW_SUPPORTED(dhd, p2p)) {
 					return -1;
 				}
-				pch = bcmstrtok(&pick_tmp2, " -", 0);
-				for (i=0; i<MAX_IF_NUM && pch; i++) {
-					if (!strcmp(pch, "sta"))
-						apsta_params->if_info[i].ifmode = ISTA_MODE;
-					else if (!strcmp(pch, "ap"))
-						apsta_params->if_info[i].ifmode = IAP_MODE;
+				apsta_params->apstamode = ISTAGO_MODE;
+				apsta_params->if_info[IF_PIF].ifmode = ISTA_MODE;
+				apsta_params->if_info[IF_VIF].ifmode = IAP_MODE;
 #ifdef WLMESH
-					else if (!strcmp(pch, "mesh")) {
-						if (dhd->conf->fw_type != FW_TYPE_MESH) {
-							AEXT_ERROR(dev->name, "wrong fw type\n");
-							return -1;
-						}
-						apsta_params->if_info[i].ifmode = IMESH_MODE;
+			} else if (!strcmp(pick_tmp2, "mesh")) {
+				apsta_params->apstamode = IMESHONLY_MODE;
+			} else if (!strcmp(pick_tmp2, "sta-mesh")) {
+				apsta_params->apstamode = ISTAMESH_MODE;
+			} else if (!strcmp(pick_tmp2, "sta-ap-mesh")) {
+				apsta_params->apstamode = ISTAAPMESH_MODE;
+			} else if (!strcmp(pick_tmp2, "mesh-ap")) {
+				apsta_params->apstamode = IMESHAP_MODE;
+			} else if (!strcmp(pick_tmp2, "mesh-ap-ap")) {
+				apsta_params->apstamode = IMESHAPAP_MODE;
+#endif /* WLMESH */
+			} else {
+				AEXT_ERROR(dev->name, "mode [sta|ap|sta-ap|ap-ap]\n");
+				return -1;
+			}
+			pch = bcmstrtok(&pick_tmp2, " -", 0);
+			for (i=0; i<MAX_IF_NUM && pch; i++) {
+				if (!strcmp(pch, "sta"))
+					apsta_params->if_info[i].ifmode = ISTA_MODE;
+				else if (!strcmp(pch, "ap"))
+					apsta_params->if_info[i].ifmode = IAP_MODE;
+#ifdef WLMESH
+				else if (!strcmp(pch, "mesh")) {
+					if (dhd->conf->fw_type != FW_TYPE_MESH) {
+						AEXT_ERROR(dev->name, "wrong fw type\n");
+						return -1;
 					}
-#endif
-					pch = bcmstrtok(&pick_tmp2, " -", 0);
+					apsta_params->if_info[i].ifmode = IMESH_MODE;
 				}
+#endif /* WLMESH */
+				pch = bcmstrtok(&pick_tmp2, " -", 0);
 			}
 		}
 		else if (!strcmp(param, "rsdb")) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			if (pch) {
-				if (!strcmp(pch, "y")) {
-					apsta_params->rsdb = TRUE;
-				} else if (!strcmp(pch, "n")) {
-					apsta_params->rsdb = FALSE;
-				} else {
-					AEXT_ERROR(dev->name, "rsdb [y|n]\n");
-					return -1;
-				}
-			}
+			apsta_params->rsdb = (int)simple_strtol(pick_tmp2, NULL, 0);
 		} else if (!strcmp(param, "vsdb")) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			if (pch) {
-				if (!strcmp(pch, "y")) {
-					apsta_params->vsdb = TRUE;
-				} else if (!strcmp(pch, "n")) {
-					apsta_params->vsdb = FALSE;
-				} else {
-					AEXT_ERROR(dev->name, "vsdb [y|n]\n");
-					return -1;
-				}
+			if (!strcmp(pick_tmp2, "y")) {
+				apsta_params->vsdb = TRUE;
+			} else if (!strcmp(pick_tmp2, "n")) {
+				apsta_params->vsdb = FALSE;
+			} else {
+				AEXT_ERROR(dev->name, "vsdb [y|n]\n");
+				return -1;
 			}
 		} else if (!strcmp(param, "csa")) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			if (pch) {
-				apsta_params->csa = (int)simple_strtol(pch, NULL, 0);
-			}
+			apsta_params->csa = (int)simple_strtol(pick_tmp2, NULL, 0);
+		} else if (!strcmp(param, "acs")) {
+			apsta_params->acs = (int)simple_strtol(pick_tmp2, NULL, 0);
+#if defined(WLMESH) && defined(WL_ESCAN)
+		} else if (!strcmp(param, "macs")) {
+			apsta_params->macs = (int)simple_strtol(pick_tmp2, NULL, 0);
+#endif /* WLMESH && WL_ESCAN */
 		} else if (!strcmp(param, "ifname")) {
 			pch = NULL;
-			pick_tmp2 = bcmstrtok(&pick_tmp, " ", 0);
-			if (pick_tmp2)
-				pch = bcmstrtok(&pick_tmp2, " -", 0);
+			pch = bcmstrtok(&pick_tmp2, " -", 0);
 			for (i=0; i<MAX_IF_NUM && pch; i++) {
 				strcpy(apsta_params->if_info[i].ifname, pch);
 				pch = bcmstrtok(&pick_tmp2, " -", 0);
 			}
 		} else if (!strcmp(param, "vifname")) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			if (pch)
-				strcpy(apsta_params->if_info[IF_VIF].ifname, pch);
-			else {
-				AEXT_ERROR(dev->name, "vifname [wlan1]\n");
-				return -1;
-			}
+			strcpy(apsta_params->if_info[IF_VIF].ifname, pick_tmp2);
 		}
 		param = bcmstrtok(&pick_tmp, " ", 0);
 	}
@@ -1804,6 +1988,7 @@
 	}
 
 	wl_ext_iapsta_preinit(dev, apsta_params);
+	wl_ext_iapsta_intf_add(dev, apsta_params);
 
 	return 0;
 }
@@ -2012,6 +2197,8 @@
 	pick_tmp = command;
 	param = bcmstrtok(&pick_tmp, " ", 0); // skip iapsta_config
 
+	mutex_lock(&apsta_params->usr_sync);
+
 	while (pick_tmp != NULL) {
 		memset(ifname, 0, IFNAMSIZ+1);
 		if (!strncmp(pick_tmp, "ifname ", strlen("ifname "))) {
@@ -2021,7 +2208,8 @@
 				strncpy(ifname, pch, pch2-pch);
 			} else {
 				AEXT_ERROR(dev->name, "ifname [wlanX]\n");
-				return -1;
+				ret = -1;
+				break;
 			}
 			for (i=0; i<MAX_IF_NUM; i++) {
 				tmp_if = &apsta_params->if_info[i];
@@ -2033,20 +2221,49 @@
 			if (!cur_if) {
 				AEXT_ERROR(dev->name, "wrong ifname=%s in apstamode=%d\n",
 					ifname, apsta_params->apstamode);
-				return -1;
+				ret = -1;
+				break;
 			}
 			ret = wl_ext_parse_config(cur_if, pick_tmp, &pick_next);
 			if (ret)
-				return -1;
+				break;
 			pick_tmp = pick_next;
 		} else {
 			AEXT_ERROR(dev->name, "first arg must be ifname\n");
-			return -1;
+			ret = -1;
+			break;
 		}
 
 	}
 
-	return 0;
+	mutex_unlock(&apsta_params->usr_sync);
+
+	return ret;
+}
+
+static int
+wl_ext_assoclist(struct net_device *dev, char *data, char *command,
+	int total_len)
+{
+	int ret = 0, i, maxassoc = 0, bytes_written = 0;
+	char mac_buf[MAX_NUM_OF_ASSOCLIST *
+		sizeof(struct ether_addr) + sizeof(uint)] = {0};
+	struct maclist *assoc_maclist = (struct maclist *)mac_buf;
+
+	assoc_maclist->count = htod32(MAX_NUM_OF_ASSOCLIST);
+	ret = wl_ext_ioctl(dev, WLC_GET_ASSOCLIST, assoc_maclist, sizeof(mac_buf), 0);
+	if (ret)
+		return -1;
+	maxassoc = dtoh32(assoc_maclist->count);
+	bytes_written += snprintf(command+bytes_written, total_len,
+		"%2s: %12s",
+		"no", "------addr------");
+	for (i=0; i<maxassoc; i++) {
+		bytes_written += snprintf(command+bytes_written, total_len,
+			"\n%2d: %pM", i, &assoc_maclist->ea[i]);
+	}
+
+	return bytes_written;
 }
 
 #ifdef WLMESH
@@ -2125,11 +2342,6 @@
 	int peer_len = WLC_IOCTL_MAXLEN;
 	int dump_written = 0, ret;
 
-	if (apsta_params->init == FALSE) {
-		AEXT_ERROR(dev->name, "please init first\n");
-		return -1;
-	}
-
 	if (!data) {
 		peer_buf = kmalloc(peer_len, GFP_KERNEL);
 		if (peer_buf == NULL) {
@@ -2139,7 +2351,7 @@
 		}
 		for (i=0; i<MAX_IF_NUM; i++) {
 			cur_if = &apsta_params->if_info[i];
-			if (dev == cur_if->dev && cur_if->ifmode == IMESH_MODE) {
+			if (cur_if && dev == cur_if->dev && cur_if->ifmode == IMESH_MODE) {
 				memset(peer_buf, 0, peer_len);
 				ret = wl_mesh_get_peer_results(dev, peer_buf, peer_len);
 				if (ret >= 0) {
@@ -2149,7 +2361,7 @@
 						peer_results->count, command+dump_written,
 						total_len-dump_written);
 				}
-			} else if (dev == cur_if->dev) {
+			} else if (cur_if && dev == cur_if->dev) {
 				AEXT_ERROR(dev->name, "[%s][%c] is not mesh interface\n",
 					cur_if->ifname, cur_if->prefix);
 			}
@@ -2160,7 +2372,386 @@
 		kfree(peer_buf);
 	return dump_written;
 }
-#endif
+
+#ifdef WL_ESCAN
+#define WL_MESH_DELAY_SCAN_MS	3000
+static void
+wl_mesh_timer(unsigned long data)
+{
+	wl_event_msg_t msg;
+	struct wl_if_info *mesh_if = (struct wl_if_info *)data;
+	struct dhd_pub *dhd;
+
+	if (!mesh_if) {
+		AEXT_ERROR("wlan", "mesh_if is not ready\n");
+		return;
+	}
+
+	if (!mesh_if->dev) {
+		AEXT_ERROR("wlan", "ifidx %d is not ready\n", mesh_if->ifidx);
+		return;
+	}
+	dhd = dhd_get_pub(mesh_if->dev);
+
+	bzero(&msg, sizeof(wl_event_msg_t));
+	AEXT_TRACE(mesh_if->dev->name, "timer expired\n");
+
+	msg.ifidx = mesh_if->ifidx;
+	msg.event_type = hton32(WLC_E_RESERVED);
+	msg.reason = 0xFFFFFFFF;
+	wl_ext_event_send(dhd->event_params, &msg, NULL);
+}
+
+static void
+wl_mesh_set_timer(struct wl_if_info *mesh_if, uint timeout)
+{
+	AEXT_TRACE(mesh_if->dev->name, "timeout=%d\n", timeout);
+
+	if (timer_pending(&mesh_if->delay_scan))
+		del_timer_sync(&mesh_if->delay_scan);
+
+	if (timeout) {
+		if (timer_pending(&mesh_if->delay_scan))
+			del_timer_sync(&mesh_if->delay_scan);
+		mod_timer(&mesh_if->delay_scan, jiffies + msecs_to_jiffies(timeout));
+	}
+}
+
+static struct wl_if_info *
+wl_ext_if_enabled(struct wl_apsta_params *apsta_params, ifmode_t ifmode)
+{
+	struct wl_if_info *tmp_if, *target_if = NULL;
+	int i;
+
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if && tmp_if->ifmode == ifmode &&
+				wl_get_isam_status(tmp_if, IF_READY)) {
+			if (wl_ext_get_chan(apsta_params, tmp_if->dev)) {
+				target_if = tmp_if;
+				break;
+			}
+		}
+	}
+
+	return target_if;
+}
+
+static int
+wl_mesh_clear_vndr_ie(struct net_device *dev, uchar *oui)
+{
+	char *vndr_ie_buf = NULL;
+	vndr_ie_setbuf_t *vndr_ie = NULL;
+	ie_getbuf_t vndr_ie_tmp;
+	char *iovar_buf = NULL;
+	int err = -1, i;
+	vndr_ie_buf_t *vndr_ie_dump = NULL;
+	uchar *iebuf;
+	vndr_ie_info_t *ie_info;
+	vndr_ie_t *ie;
+
+	vndr_ie_buf = kzalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
+	if (!vndr_ie_buf) {
+		AEXT_ERROR(dev->name, "IE memory alloc failed\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	iovar_buf = kzalloc(WLC_IOCTL_MEDLEN, GFP_KERNEL);
+	if (!iovar_buf) {
+		AEXT_ERROR(dev->name, "iovar_buf alloc failed\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	memset(iovar_buf, 0, WLC_IOCTL_MEDLEN);
+	vndr_ie_tmp.pktflag = (uint32) -1;
+	vndr_ie_tmp.id = (uint8) DOT11_MNG_PROPR_ID;
+	err = wl_ext_iovar_getbuf(dev, "vndr_ie", &vndr_ie_tmp, sizeof(vndr_ie_tmp),
+		iovar_buf, WLC_IOCTL_MEDLEN, NULL);
+	if (err)
+		goto exit;
+
+	vndr_ie_dump = (vndr_ie_buf_t *)iovar_buf;
+	if (!vndr_ie_dump->iecount)
+		goto exit;
+
+	iebuf = (uchar *)&vndr_ie_dump->vndr_ie_list[0];
+	for (i=0; i<vndr_ie_dump->iecount; i++) {
+		ie_info = (vndr_ie_info_t *) iebuf;
+		ie = &ie_info->vndr_ie_data;
+		if (memcmp(ie->oui, oui, 3))
+			memset(ie->oui, 0, 3);
+		iebuf += sizeof(uint32) + ie->len + VNDR_IE_HDR_LEN;
+	}
+
+	vndr_ie = (vndr_ie_setbuf_t *) vndr_ie_buf;
+	strncpy(vndr_ie->cmd, "del", VNDR_IE_CMD_LEN - 1);
+	vndr_ie->cmd[VNDR_IE_CMD_LEN - 1] = '\0';
+	memcpy(&vndr_ie->vndr_ie_buffer, vndr_ie_dump, WLC_IOCTL_SMLEN-VNDR_IE_CMD_LEN-1);
+
+	memset(iovar_buf, 0, WLC_IOCTL_MEDLEN);
+	err = wl_ext_iovar_setbuf(dev, "vndr_ie", vndr_ie, WLC_IOCTL_SMLEN, iovar_buf,
+		WLC_IOCTL_MEDLEN, NULL);
+
+exit:
+	if (vndr_ie) {
+		kfree(vndr_ie);
+	}
+	if (iovar_buf) {
+		kfree(iovar_buf);
+	}
+	return err;
+}
+
+static int
+wl_mesh_clear_mesh_info(struct wl_apsta_params *apsta_params,
+	struct wl_if_info *mesh_if, bool scan)
+{
+	struct wl_mesh_params *mesh_info = &apsta_params->mesh_info;
+	uchar mesh_oui[]={0x00, 0x22, 0xf4};
+	int ret;
+
+	AEXT_TRACE(mesh_if->dev->name, "Enter\n");
+
+	ret = wl_mesh_clear_vndr_ie(mesh_if->dev, mesh_oui);
+	memset(mesh_info, 0, sizeof(struct wl_mesh_params));
+	if (scan) {
+		mesh_info->scan_channel = wl_ext_get_chan(apsta_params, mesh_if->dev);
+		wl_mesh_set_timer(mesh_if, 100);
+	}
+
+	return ret;
+}
+
+static int
+wl_mesh_update_vndr_ie(struct wl_apsta_params *apsta_params,
+	struct wl_if_info *mesh_if)
+{
+	struct wl_mesh_params *mesh_info = &apsta_params->mesh_info;
+	char vndr_ie[64];
+	uchar mesh_oui[]={0x00, 0x22, 0xf4};
+	int bytes_written = 0;
+	int ret;
+
+	wl_mesh_clear_vndr_ie(mesh_if->dev, mesh_oui);
+
+	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
+		"0x%02x%02x%02x", mesh_oui[0], mesh_oui[1], mesh_oui[2]);
+
+	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
+		"%02d%02d%02x%02x%02x%02x%02x%02x", MESH_INFO_MASTER_BSSID, ETHER_ADDR_LEN,
+		((u8 *)(&mesh_info->master_bssid))[0], ((u8 *)(&mesh_info->master_bssid))[1],
+		((u8 *)(&mesh_info->master_bssid))[2], ((u8 *)(&mesh_info->master_bssid))[3],
+		((u8 *)(&mesh_info->master_bssid))[4], ((u8 *)(&mesh_info->master_bssid))[5]);
+
+	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
+		"%02x%02x%02x", MESH_INFO_MASTER_CHANNEL, 1, mesh_info->master_channel);
+
+	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
+		"%02x%02x%02x", MESH_INFO_HOP_CNT, 1, mesh_info->hop_cnt);
+
+	bytes_written += snprintf(vndr_ie+bytes_written, sizeof(vndr_ie),
+		"%02d%02d%02x%02x%02x%02x%02x%02x", MESH_INFO_PEER_BSSID, ETHER_ADDR_LEN,
+		((u8 *)(&mesh_info->peer_bssid))[0], ((u8 *)(&mesh_info->peer_bssid))[1],
+		((u8 *)(&mesh_info->peer_bssid))[2], ((u8 *)(&mesh_info->peer_bssid))[3],
+		((u8 *)(&mesh_info->peer_bssid))[4], ((u8 *)(&mesh_info->peer_bssid))[5]);
+
+	ret = wl_ext_add_del_ie(mesh_if->dev, VNDR_IE_BEACON_FLAG|VNDR_IE_PRBRSP_FLAG,
+		vndr_ie, "add");
+	if (!ret) {
+		AEXT_INFO(mesh_if->dev->name, "mbssid=%pM, mchannel=%d, hop=%d, pbssid=%pM\n",
+			&mesh_info->master_bssid, mesh_info->master_channel, mesh_info->hop_cnt,
+			&mesh_info->peer_bssid); 
+	}
+
+	return ret;
+}
+
+static bool
+wl_mesh_update_master_info(struct wl_apsta_params *apsta_params,
+	struct wl_if_info *mesh_if)
+{
+	struct wl_mesh_params *mesh_info = &apsta_params->mesh_info;
+	struct wl_if_info *sta_if = NULL;
+	bool updated = FALSE;
+
+	sta_if = wl_ext_if_enabled(apsta_params, ISTA_MODE);
+	if (sta_if) {
+		wldev_ioctl(mesh_if->dev, WLC_GET_BSSID, &mesh_info->master_bssid,
+			ETHER_ADDR_LEN, 0);
+		mesh_info->master_channel = wl_ext_get_chan(apsta_params, mesh_if->dev);
+		mesh_info->hop_cnt = 1;
+		memcpy(&mesh_info->peer_bssid, &mesh_info->master_bssid, ETHER_ADDR_LEN);
+		wl_mesh_update_vndr_ie(apsta_params, mesh_if);
+		updated = TRUE;
+	}
+
+	return updated;
+}
+
+static uint
+wl_mesh_update_mesh_info(struct wl_apsta_params *apsta_params,
+	struct wl_if_info *mesh_if)
+{
+	struct wl_mesh_params *mesh_info = &apsta_params->mesh_info, peer_mesh_info;
+	uint32 count = 0;
+	char *dump_buf = NULL;
+	mesh_peer_info_dump_t *peer_results;
+	mesh_peer_info_ext_t *mpi_ext;
+	struct ether_addr bssid;
+	bool updated = FALSE;
+	uint16 cur_chan;
+
+	dump_buf = kmalloc(WLC_IOCTL_MAXLEN, GFP_KERNEL);
+	if (dump_buf == NULL) {
+		AEXT_ERROR(mesh_if->dev->name, "Failed to allocate buffer of %d bytes\n",
+			WLC_IOCTL_MAXLEN); 
+		return FALSE;
+	}
+	count = wl_mesh_get_peer_results(mesh_if->dev, dump_buf, WLC_IOCTL_MAXLEN);
+	if (count > 0) {
+		memset(&bssid, 0 , ETHER_ADDR_LEN);
+		wldev_ioctl(mesh_if->dev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, 0);
+		peer_results = (mesh_peer_info_dump_t *)dump_buf;
+		mpi_ext = (mesh_peer_info_ext_t *)peer_results->mpi_ext;
+		for (count = 0; count < peer_results->count; count++) {
+			if (mpi_ext->entry_state != MESH_SELF_PEER_ENTRY_STATE_TIMEDOUT &&
+					mpi_ext->peer_info.state == MESH_PEERING_ESTAB) {
+				memset(&peer_mesh_info, 0 , sizeof(struct wl_mesh_params));
+				wl_escan_mesh_info(mesh_if->dev, mesh_if->escan,
+					&mpi_ext->ea, &peer_mesh_info);
+				if ((memcmp(&peer_mesh_info.peer_bssid, &bssid, ETHER_ADDR_LEN)) &&
+						peer_mesh_info.hop_cnt && (mesh_info->hop_cnt == 0 ||
+						peer_mesh_info.hop_cnt <= mesh_info->hop_cnt)) {
+					memcpy(&mesh_info->master_bssid, &peer_mesh_info.master_bssid,
+						ETHER_ADDR_LEN);
+					mesh_info->master_channel = peer_mesh_info.master_channel;
+					mesh_info->hop_cnt = peer_mesh_info.hop_cnt+1;
+					memcpy(&mesh_info->peer_bssid, &mpi_ext->ea, ETHER_ADDR_LEN);
+					mesh_info->channel = peer_mesh_info.channel;
+					updated = TRUE;
+				}
+			}
+			mpi_ext++;
+		}
+		if (updated)
+			wl_mesh_update_vndr_ie(apsta_params, mesh_if);
+	}
+
+	if (!mesh_info->hop_cnt) {
+		wlc_ssid_t cur_ssid;
+		char sec[32];
+		bool sae = FALSE;
+		memset(&peer_mesh_info, 0, sizeof(struct wl_mesh_params));
+		wl_ext_ioctl(mesh_if->dev, WLC_GET_SSID, &cur_ssid, sizeof(cur_ssid), 0);
+		wl_ext_get_sec(mesh_if->dev, mesh_if->ifmode, sec, sizeof(sec));
+		if (strnicmp(sec, "sae/sae", strlen("sae/sae")) == 0)
+			sae = TRUE;
+		cur_chan = wl_ext_get_chan(apsta_params, mesh_if->dev);
+		wl_escan_mesh_peer(mesh_if->dev, mesh_if->escan, &cur_ssid, cur_chan,
+			sae, &peer_mesh_info);
+
+		if (peer_mesh_info.hop_cnt && peer_mesh_info.channel &&
+				(cur_chan != peer_mesh_info.channel)) {
+			WL_MSG(mesh_if->ifname, "moving channel %d -> %d\n",
+				cur_chan, peer_mesh_info.channel);
+			wl_ext_disable_iface(mesh_if->dev, mesh_if->ifname);
+			mesh_if->channel = peer_mesh_info.channel;
+			wl_ext_enable_iface(mesh_if->dev, mesh_if->ifname, 500);
+		}
+	}
+
+	if (dump_buf)
+		kfree(dump_buf);
+	return mesh_info->hop_cnt;
+}
+
+static void
+wl_mesh_event_handler(	struct wl_apsta_params *apsta_params,
+	struct wl_if_info *mesh_if, const wl_event_msg_t *e, void *data)
+{
+	struct wl_mesh_params *mesh_info = &apsta_params->mesh_info;
+	uint32 event_type = ntoh32(e->event_type);
+	uint32 status = ntoh32(e->status);
+	uint32 reason = ntoh32(e->reason);
+	wlc_ssid_t ssid;
+	int ret;
+
+	if (wl_get_isam_status(mesh_if, AP_CREATED) &&
+			((event_type == WLC_E_SET_SSID && status == WLC_E_STATUS_SUCCESS) ||
+			(event_type == WLC_E_LINK && status == WLC_E_STATUS_SUCCESS &&
+			reason == WLC_E_REASON_INITIAL_ASSOC))) {
+		if (!wl_mesh_update_master_info(apsta_params, mesh_if)) {
+			mesh_info->scan_channel = wl_ext_get_chan(apsta_params, mesh_if->dev);
+			wl_mesh_set_timer(mesh_if, WL_MESH_DELAY_SCAN_MS);
+		}
+	}
+	else if ((event_type == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS) ||
+			(event_type == WLC_E_LINK && status == WLC_E_STATUS_SUCCESS &&
+			reason == WLC_E_REASON_DEAUTH)) {
+		wl_mesh_clear_mesh_info(apsta_params, mesh_if, FALSE);
+	}
+	else if (wl_get_isam_status(mesh_if, AP_CREATED) &&
+			(event_type == WLC_E_ASSOC_IND || event_type == WLC_E_REASSOC_IND) &&
+			reason == DOT11_SC_SUCCESS) {
+		mesh_info->scan_channel = wl_ext_get_chan(apsta_params, mesh_if->dev);
+		wl_mesh_set_timer(mesh_if, 100);
+	}
+	else if (event_type == WLC_E_DISASSOC_IND || event_type == WLC_E_DEAUTH_IND ||
+			(event_type == WLC_E_DEAUTH && reason != DOT11_RC_RESERVED)) {
+		if (!memcmp(&mesh_info->peer_bssid, &e->addr, ETHER_ADDR_LEN))
+			wl_mesh_clear_mesh_info(apsta_params, mesh_if, TRUE);
+	}
+	else if (wl_get_isam_status(mesh_if, AP_CREATED) &&
+			event_type == WLC_E_RESERVED && reason == 0xFFFFFFFF) {
+		if (!wl_mesh_update_master_info(apsta_params, mesh_if)) {
+			wl_ext_ioctl(mesh_if->dev, WLC_GET_SSID, &ssid, sizeof(ssid), 0);
+			ret = wl_escan_set_scan(mesh_if->dev, apsta_params->dhd, &ssid,
+				mesh_info->scan_channel, FALSE);
+			if (ret)
+				wl_mesh_set_timer(mesh_if, WL_MESH_DELAY_SCAN_MS);
+		}
+	}
+	else if (wl_get_isam_status(mesh_if, AP_CREATED) &&
+			((event_type == WLC_E_ESCAN_RESULT && status == WLC_E_STATUS_SUCCESS) ||
+			(event_type == WLC_E_ESCAN_RESULT &&
+			(status == WLC_E_STATUS_ABORT || status == WLC_E_STATUS_NEWSCAN ||
+			status == WLC_E_STATUS_11HQUIET || status == WLC_E_STATUS_CS_ABORT ||
+			status == WLC_E_STATUS_NEWASSOC || status == WLC_E_STATUS_TIMEOUT)))) {
+		if (!wl_mesh_update_master_info(apsta_params, mesh_if)) {
+			if (!wl_mesh_update_mesh_info(apsta_params, mesh_if)) {
+				mesh_info->scan_channel = 0;
+				wl_mesh_set_timer(mesh_if, WL_MESH_DELAY_SCAN_MS);
+			}
+		}
+	}
+}
+
+static void
+wl_mesh_escan_detach(dhd_pub_t *dhd, struct wl_if_info *mesh_if)
+{
+	AEXT_TRACE(mesh_if->dev->name, "Enter\n");
+
+	del_timer_sync(&mesh_if->delay_scan);
+
+	if (mesh_if->escan) {
+		mesh_if->escan = NULL;
+	}
+}
+
+static int
+wl_mesh_escan_attach(dhd_pub_t *dhd, struct wl_if_info *mesh_if)
+{
+	AEXT_TRACE(mesh_if->dev->name, "Enter\n");
+
+	mesh_if->escan = dhd->escan;
+	init_timer_compat(&mesh_if->delay_scan, wl_mesh_timer, mesh_if);
+
+	return 0;
+}
+#endif /* WL_ESCAN */
+#endif /* WLMESH */
 
 static int
 wl_ext_isam_status(struct net_device *dev, char *command, int total_len)
@@ -2168,7 +2759,6 @@
 	struct dhd_pub *dhd = dhd_get_pub(dev);
 	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
 	int i;
-	bool now_if;
 	struct wl_if_info *tmp_if;
 	uint16 chan = 0;
 	wlc_ssid_t ssid = { 0, {0} };
@@ -2195,13 +2785,10 @@
 		dump_written += snprintf(dump_buf+dump_written, dump_len,
 			"apstamode=%d", apsta_params->apstamode);
 		for (i=0; i<MAX_IF_NUM; i++) {
-			now_if = FALSE;
 			memset(&ssid, 0, sizeof(ssid));
 			memset(&bssid, 0, sizeof(bssid));
 			memset(&scb_val, 0, sizeof(scb_val));
 			tmp_if = &apsta_params->if_info[i];
-			if (dev == tmp_if->dev)
-				now_if = TRUE;
 			if (tmp_if->dev) {
 				chan = wl_ext_get_chan(apsta_params, tmp_if->dev);
 				if (chan) {
@@ -2212,23 +2799,28 @@
 					chanspec = wl_ext_get_chanspec(apsta_params, tmp_if->dev);
 					wl_ext_get_sec(tmp_if->dev, tmp_if->ifmode, sec, sizeof(sec));
 					dump_written += snprintf(dump_buf+dump_written, dump_len,
-						"\n[dhd-%s][%c-%c%s]: bssid=%pM, chan=%3d(0x%x), "
+						"\n[dhd-%s-%c]: bssid=%pM, chan=%3d(0x%x %sMHz), "
 						"rssi=%3d, sec=%-15s, SSID=\"%s\"",
-						tmp_if->ifname, tmp_if->prefix, chan?'E':'D',
-						now_if?"*":" ", &bssid, chan, chanspec,
+						tmp_if->ifname, tmp_if->prefix, &bssid, chan, chanspec,
+						CHSPEC_IS20(chanspec)?"20":
+						CHSPEC_IS40(chanspec)?"40":
+						CHSPEC_IS80(chanspec)?"80":"160",
 						dtoh32(scb_val.val), sec, ssid.SSID);
+					if (tmp_if->ifmode == IAP_MODE) {
+						dump_written += snprintf(dump_buf+dump_written, dump_len, "\n");
+						dump_written += wl_ext_assoclist(tmp_if->dev, NULL,
+							dump_buf+dump_written, dump_len-dump_written);
+					}
 #ifdef WLMESH
-					if (tmp_if->ifmode == IMESH_MODE) {
+					else if (tmp_if->ifmode == IMESH_MODE) {
 						dump_written += snprintf(dump_buf+dump_written, dump_len, "\n");
 						dump_written += wl_ext_mesh_peer_status(tmp_if->dev, NULL,
 							dump_buf+dump_written, dump_len-dump_written);
 					}
-#endif
+#endif /* WLMESH */
 				} else {
 					dump_written += snprintf(dump_buf+dump_written, dump_len,
-						"\n[dhd-%s][%c-%c%s]:",
-						tmp_if->ifname, tmp_if->prefix, chan?'E':'D',
-						now_if?"*":" ");
+						"\n[dhd-%s-%c]:", tmp_if->ifname, tmp_if->prefix);
 				}
 			}
 		}
@@ -2240,6 +2832,15 @@
 	return dump_written;
 }
 
+static bool
+wl_ext_master_if(struct wl_if_info *cur_if)
+{
+	if (cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE)
+		return TRUE;
+	else
+		return FALSE;
+}
+
 static int
 wl_ext_if_down(struct wl_apsta_params *apsta_params, struct wl_if_info *cur_if)
 {
@@ -2285,16 +2886,21 @@
 	apstamode_t apstamode = apsta_params->apstamode;
 	chanspec_t fw_chspec;
 	u32 timeout;
+	wlc_ssid_t ssid = { 0, {0} };
+	uint16 chan = 0;
 
 	if (cur_if->ifmode != IAP_MODE) {
 		AEXT_ERROR(cur_if->ifname, "Wrong ifmode\n");
 		return 0;
 	}
 
-	if (cur_if->channel >= 52 && cur_if->channel <= 148) {
+	if (wl_ext_dfs_chan(cur_if->channel) && !apsta_params->radar) {
 		WL_MSG(cur_if->ifname, "[%c] skip DFS channel %d\n",
 			cur_if->prefix, cur_if->channel);
 		return 0;
+	} else if (!cur_if->channel) {
+		WL_MSG(cur_if->ifname, "[%c] no valid channel\n", cur_if->prefix);
+		return 0;
 	}
 
 	WL_MSG(cur_if->ifname, "[%c] Turning on...\n", cur_if->prefix);
@@ -2321,8 +2927,10 @@
 		WL_MSG(cur_if->ifname, "[%c] failed to up with SSID: \"%s\"\n",
 			cur_if->prefix, cur_if->ssid);
 	} else {
-		WL_MSG(cur_if->ifname, "[%c] enabled with SSID: \"%s\"\n",
-			cur_if->prefix, cur_if->ssid);
+		wl_ext_ioctl(cur_if->dev, WLC_GET_SSID, &ssid, sizeof(ssid), 0);
+		chan = wl_ext_get_chan(apsta_params, cur_if->dev);
+		WL_MSG(cur_if->ifname, "[%c] enabled with SSID: \"%s\" on channel %d\n",
+			cur_if->prefix, ssid.SSID, chan);
 	}
 	wl_clr_isam_status(cur_if, AP_CREATING);
 
@@ -2359,6 +2967,7 @@
 		return -1;
 	}
 
+	mutex_lock(&apsta_params->usr_sync);
 	WL_MSG(ifname, "[%c] Disabling...\n", cur_if->prefix);
 
 	if (cur_if->ifmode == ISTA_MODE) {
@@ -2394,7 +3003,7 @@
 				dhd_wlfc_deinit(dhd);
 			}
 		}
-#endif 
+#endif /* BCMSDIO */
 #endif /* PROP_TXSTATUS_VSDB */
 	}
 	else if (apstamode == IDUALAP_MODE) {
@@ -2403,19 +3012,19 @@
 		wl_ext_iovar_setbuf(cur_if->dev, "bss", &bss_setbuf, sizeof(bss_setbuf),
 			iovar_buf, WLC_IOCTL_SMLEN, NULL);
 #ifdef WLMESH
-	} else if (apstamode == IMESHSTA_MODE || apstamode == IMESHAP_MODE ||
-			apstamode == IMESHAPSTA_MODE || apstamode == IMESHAPAP_MODE ||
+	} else if (apstamode == ISTAMESH_MODE || apstamode == IMESHAP_MODE ||
+			apstamode == ISTAAPMESH_MODE || apstamode == IMESHAPAP_MODE ||
 			apstamode == ISTAAPAP_MODE) {
 		bss_setbuf.cfg = 0xffffffff;
 		bss_setbuf.val = htod32(0);
 		wl_ext_iovar_setbuf(cur_if->dev, "bss", &bss_setbuf, sizeof(bss_setbuf),
 			iovar_buf, WLC_IOCTL_SMLEN, NULL);
-#endif
+#endif /* WLMESH */
 	}
 #ifdef WLMESH
 	if ((cur_if->ifmode == IMESH_MODE) &&
-			(apstamode == IMESHSTA_MODE || apstamode == IMESHAP_MODE ||
-			apstamode == IMESHAPSTA_MODE || apstamode == IMESHAPAP_MODE)) {
+			(apstamode == ISTAMESH_MODE || apstamode == IMESHAP_MODE ||
+			apstamode == ISTAAPMESH_MODE || apstamode == IMESHAPAP_MODE)) {
 		int scan_assoc_time = DHD_SCAN_ASSOC_ACTIVE_TIME;
 		for (i=0; i<MAX_IF_NUM; i++) {
 			tmp_if = &apsta_params->if_info[i];
@@ -2425,11 +3034,12 @@
 			}
 		}
 	}
-#endif
+#endif /* WLMESH */
 
 	wl_clr_isam_status(cur_if, AP_CREATED);
 
 	WL_MSG(ifname, "[%c] Exit\n", cur_if->prefix);
+	mutex_unlock(&apsta_params->usr_sync);
 	return 0;
 }
 
@@ -2476,6 +3086,34 @@
 }
 
 static uint16
+wl_ext_same_band(struct wl_apsta_params *apsta_params,
+	struct wl_if_info *cur_if, bool nodfs)
+{
+	struct wl_if_info *tmp_if;
+	uint16 tmp_chan, target_chan = 0;
+	wl_prio_t max_prio;
+	int i;
+
+	// find the max prio
+	max_prio = cur_if->prio;
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (cur_if != tmp_if && wl_get_isam_status(tmp_if, IF_READY) &&
+				tmp_if->prio > max_prio) {
+			tmp_chan = wl_ext_get_chan(apsta_params, tmp_if->dev);
+			if (wl_ext_dfs_chan(tmp_chan) && nodfs)
+				continue;
+			if (tmp_chan && !wl_ext_diff_band(cur_if->channel, tmp_chan)) {
+				target_chan = tmp_chan;
+				max_prio = tmp_if->prio;
+			}
+		}
+	}
+
+	return target_chan;
+}
+
+static uint16
 wl_ext_get_vsdb_chan(struct wl_apsta_params *apsta_params,
 	struct wl_if_info *cur_if, struct wl_if_info *target_if)
 {
@@ -2532,12 +3170,10 @@
 	s8 iovar_buf[WLC_IOCTL_SMLEN];
 	bool core_conflict = FALSE;
 
-	if (apsta_params->csa & CSA_DRV_BIT &&
-			(cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE)) {
+	if (wl_ext_master_if(cur_if) && (apsta_params->csa & CSA_DRV_BIT)) {
 		if (!cur_if->channel) {
-			WL_MSG(cur_if->ifname, "[%c] skip channel %d\n",
-				cur_if->prefix, cur_if->channel);
-		} else if (cur_if->channel >= 52 && cur_if->channel <= 148) {
+			WL_MSG(cur_if->ifname, "[%c] no valid channel\n", cur_if->prefix);
+		} else if (wl_ext_dfs_chan(cur_if->channel) && !apsta_params->radar) {
 			WL_MSG(cur_if->ifname, "[%c] skip DFS channel %d\n",
 				cur_if->prefix, cur_if->channel);
 			wl_ext_if_down(apsta_params, cur_if);
@@ -2550,7 +3186,7 @@
 				cur_if->channel);
 			core_conflict = wl_ext_rsdb_core_conflict(apsta_params, cur_if);
 			if (core_conflict) {
-				AEXT_INFO(cur_if->ifname, "[%c] Skip CSA due to rsdb core conflict\n",
+				WL_MSG(cur_if->ifname, "[%c] Skip CSA due to rsdb core conflict\n",
 					cur_if->prefix);
 			} else if (csa_arg.chspec) {
 				WL_MSG(cur_if->ifname, "[%c] Trigger CSA to channel %d(0x%x)\n",
@@ -2570,9 +3206,139 @@
 	return 0;
 }
 
+static void
+wl_ext_move_cur_dfs_channel(struct wl_apsta_params *apsta_params,
+	struct wl_if_info *cur_if)
+{
+	uint16 other_chan = 0, cur_chan = cur_if->channel;
+	uint16 chan_2g = 0, chan_5g = 0;
+	uint32 auto_band = WLC_BAND_2G;
+
+	if (wl_ext_master_if(cur_if) && wl_ext_dfs_chan(cur_if->channel) &&
+			!apsta_params->radar) {
+
+		wl_ext_get_default_chan(cur_if->dev, &chan_2g, &chan_5g, TRUE);
+		if (!chan_2g && !chan_5g) {
+			cur_if->channel = 0;
+			WL_MSG(cur_if->ifname, "[%c] no valid channel\n", cur_if->prefix);
+			return;
+		}
+
+		if (apsta_params->vsdb) {
+			if (chan_5g) {
+				cur_if->channel = chan_5g;
+				auto_band = WLC_BAND_5G;
+				other_chan = wl_ext_same_band(apsta_params, cur_if, TRUE);
+			} else {
+				cur_if->channel = chan_2g;
+				auto_band = WLC_BAND_2G;
+				other_chan = wl_ext_same_band(apsta_params, cur_if, TRUE);
+			}
+			if (!other_chan) {
+				other_chan = wl_ext_autochannel(cur_if->dev, ACS_FW_BIT|ACS_DRV_BIT,
+					auto_band);
+			}
+			if (other_chan)
+				cur_if->channel = other_chan;
+		} else if (apsta_params->rsdb) {
+			if (chan_5g) {
+				cur_if->channel = chan_5g;
+				auto_band = WLC_BAND_5G;
+				other_chan = wl_ext_same_band(apsta_params, cur_if, FALSE);
+				if (wl_ext_dfs_chan(other_chan) && chan_2g) {
+					cur_if->channel = chan_2g;
+					auto_band = WLC_BAND_2G;
+					other_chan = wl_ext_same_band(apsta_params, cur_if, TRUE);
+				}
+			} else {
+				cur_if->channel = chan_2g;
+				auto_band = WLC_BAND_2G;
+				other_chan = wl_ext_same_band(apsta_params, cur_if, TRUE);
+			}
+			if (!other_chan) {
+				other_chan = wl_ext_autochannel(cur_if->dev, ACS_FW_BIT|ACS_DRV_BIT,
+					auto_band);
+			}
+			if (other_chan)
+				cur_if->channel = other_chan;
+		} else {
+			cur_if->channel = chan_5g;
+			auto_band = WLC_BAND_5G;
+			other_chan = wl_ext_same_band(apsta_params, cur_if, FALSE);
+			if (wl_ext_dfs_chan(other_chan)) {
+				cur_if->channel = 0;
+			}
+			else if (!other_chan) {
+				other_chan = wl_ext_autochannel(cur_if->dev, ACS_FW_BIT|ACS_DRV_BIT,
+					auto_band);
+			}
+			if (other_chan)
+				cur_if->channel = other_chan;
+		}
+		WL_MSG(cur_if->ifname, "[%c] move channel %d => %d\n",
+			cur_if->prefix, cur_chan, cur_if->channel);
+	}
+}
+
+static void
+wl_ext_move_other_dfs_channel(struct wl_apsta_params *apsta_params,
+	struct wl_if_info *cur_if)
+{
+	uint16 other_chan = 0, cur_chan = cur_if->channel;
+	uint16 chan_2g = 0, chan_5g = 0;
+	uint32 auto_band = WLC_BAND_2G;
+
+	if (wl_ext_master_if(cur_if) && wl_ext_dfs_chan(cur_if->channel) &&
+			!apsta_params->radar) {
+
+		wl_ext_get_default_chan(cur_if->dev, &chan_2g, &chan_5g, TRUE);
+		if (!chan_2g && !chan_5g) {
+			cur_if->channel = 0;
+			WL_MSG(cur_if->ifname, "[%c] no valid channel\n", cur_if->prefix);
+			return;
+		}
+
+		if (apsta_params->vsdb) {
+			if (chan_5g) {
+				cur_if->channel = chan_5g;
+				auto_band = WLC_BAND_5G;
+				other_chan = wl_ext_same_band(apsta_params, cur_if, TRUE);
+			} else {
+				cur_if->channel = chan_2g;
+				auto_band = WLC_BAND_2G;
+				other_chan = wl_ext_same_band(apsta_params, cur_if, TRUE);
+			}
+			if (!other_chan) {
+				other_chan = wl_ext_autochannel(cur_if->dev, ACS_FW_BIT|ACS_DRV_BIT,
+					auto_band);
+			}
+			if (other_chan)
+				cur_if->channel = other_chan;
+		} else if (apsta_params->rsdb) {
+			if (chan_2g) {
+				cur_if->channel = chan_2g;
+				auto_band = WLC_BAND_2G;
+				other_chan = wl_ext_same_band(apsta_params, cur_if, TRUE);
+				if (!other_chan) {
+					other_chan = wl_ext_autochannel(cur_if->dev, ACS_FW_BIT|ACS_DRV_BIT,
+						auto_band);
+				}
+			} else {
+				cur_if->channel = 0;
+			}
+			if (other_chan)
+				cur_if->channel = other_chan;
+		} else {
+			cur_if->channel = 0;
+		}
+		WL_MSG(cur_if->ifname, "[%c] move channel %d => %d\n",
+			cur_if->prefix, cur_chan, cur_if->channel);
+	}
+}
+
 static uint16
 wl_ext_move_cur_channel(struct wl_apsta_params *apsta_params,
-	struct net_device *dev, struct wl_if_info *cur_if)
+	struct wl_if_info *cur_if)
 {
 	struct wl_if_info *tmp_if, *target_if = NULL;
 	uint16 tmp_chan, target_chan = 0;
@@ -2598,6 +3364,7 @@
 			}
 		}
 	}
+
 	if (target_chan) {
 		tmp_chan = wl_ext_get_chan(apsta_params, cur_if->dev);
 		if (apsta_params->rsdb && tmp_chan &&
@@ -2612,20 +3379,16 @@
 			cur_if->channel = target_chan;
 		}
 	}
+
 exit:
-	if ((cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE) &&
-			(cur_if->channel >= 52 && cur_if->channel <= 148)) {
-		WL_MSG(cur_if->ifname, "[%c] skip DFS channel %d\n",
-			cur_if->prefix, cur_if->channel);
-		cur_if->channel = 0;
-	}
+	wl_ext_move_cur_dfs_channel(apsta_params, cur_if);
 
 	return cur_if->channel;
 }
 
 static void
 wl_ext_move_other_channel(struct wl_apsta_params *apsta_params,
-	struct net_device *dev, struct wl_if_info *cur_if)
+	struct wl_if_info *cur_if)
 {
 	struct wl_if_info *tmp_if, *target_if=NULL;
 	uint16 tmp_chan, target_chan = 0;
@@ -2655,11 +3418,12 @@
 		WL_MSG(target_if->ifname, "channel=%d => %s channel=%d\n",
 			target_chan, cur_if->ifname, cur_if->channel);
 		target_if->channel = cur_if->channel;
+		wl_ext_move_other_dfs_channel(apsta_params, target_if);
 		if (apsta_params->csa == 0) {
 			wl_ext_if_down(apsta_params, target_if);
-			wl_ext_move_other_channel(apsta_params, dev, target_if);
+			wl_ext_move_other_channel(apsta_params, cur_if);
 			if (target_if->ifmode == ISTA_MODE || target_if->ifmode == IMESH_MODE) {
-				wl_ext_enable_iface(target_if->dev, target_if->ifname);
+				wl_ext_enable_iface(target_if->dev, target_if->ifname, 0);
 			} else if (target_if->ifmode == IAP_MODE) {
 				wl_ext_if_up(apsta_params, target_if);
 			}
@@ -2670,8 +3434,53 @@
 
 }
 
+static bool
+wl_ext_wait_other_enabling(struct wl_apsta_params *apsta_params,
+	struct wl_if_info *cur_if)
+{
+	struct wl_if_info *tmp_if;
+	bool enabling = FALSE;
+	u32 timeout = 1;
+	int i;
+
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if->dev && tmp_if->dev != cur_if->dev) {
+			if (tmp_if->ifmode == ISTA_MODE)
+				enabling = wl_get_isam_status(tmp_if, STA_CONNECTING);
+			else if (tmp_if->ifmode == IAP_MODE || tmp_if->ifmode == IMESH_MODE)
+				enabling = wl_get_isam_status(tmp_if, AP_CREATING);
+			if (enabling)
+				WL_MSG(cur_if->ifname, "waiting for %s[%c] enabling...\n",
+					tmp_if->ifname, tmp_if->prefix);
+			if (enabling && tmp_if->ifmode == ISTA_MODE) {
+				timeout = wait_event_interruptible_timeout(
+					apsta_params->netif_change_event,
+					!wl_get_isam_status(tmp_if, STA_CONNECTING),
+					msecs_to_jiffies(MAX_STA_LINK_WAIT_TIME));
+			} else if (enabling &&
+					(tmp_if->ifmode == IAP_MODE || tmp_if->ifmode == IMESH_MODE)) {
+				timeout = wait_event_interruptible_timeout(
+					apsta_params->netif_change_event,
+					!wl_get_isam_status(tmp_if, AP_CREATING),
+					msecs_to_jiffies(MAX_STA_LINK_WAIT_TIME));
+			}
+			if (tmp_if->ifmode == ISTA_MODE)
+				enabling = wl_get_isam_status(tmp_if, STA_CONNECTING);
+			else if (tmp_if->ifmode == IAP_MODE || tmp_if->ifmode == IMESH_MODE)
+				enabling = wl_get_isam_status(tmp_if, AP_CREATING);
+			if (timeout <= 0 || enabling) {
+				WL_MSG(cur_if->ifname, "%s[%c] is still enabling...\n",
+					tmp_if->ifname, tmp_if->prefix);
+			}
+		}
+	}
+
+	return enabling;
+}
+
 static int
-wl_ext_enable_iface(struct net_device *dev, char *ifname)
+wl_ext_enable_iface(struct net_device *dev, char *ifname, int wait_up)
 {
 	struct dhd_pub *dhd = dhd_get_pub(dev);
 	int i, ret = 0;
@@ -2701,6 +3510,8 @@
 		return -1;
 	}
 
+	mutex_lock(&apsta_params->usr_sync);
+
 	if (cur_if->ifmode == ISTA_MODE) {
 		wl_set_isam_status(cur_if, STA_CONNECTING);
 	} else if (cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE) {
@@ -2710,10 +3521,29 @@
 	wl_ext_isam_status(cur_if->dev, NULL, 0);
 	WL_MSG(ifname, "[%c] Enabling...\n", cur_if->prefix);
 
-	wl_ext_check_other_enabling(apsta_params, cur_if);
+	wl_ext_wait_other_enabling(apsta_params, cur_if);
+
+	if (wl_ext_master_if(cur_if) && apsta_params->acs) {
+		uint16 chan_2g, chan_5g;
+		uint auto_band;
+		auto_band = WL_GET_BAND(cur_if->channel);
+		wl_ext_get_default_chan(cur_if->dev, &chan_2g, &chan_5g, TRUE);
+		if ((chan_2g && auto_band == WLC_BAND_2G) ||
+				(chan_5g && auto_band == WLC_BAND_5G)) {
+			cur_if->channel = wl_ext_autochannel(cur_if->dev, apsta_params->acs,
+				auto_band);
+		} else {
+			AEXT_ERROR(ifname, "invalid channel\n");
+			ret = -1;
+			goto exit;
+		}
+	}
 
-	wl_ext_move_cur_channel(apsta_params, dev, cur_if);
-	if (!cur_if->channel && cur_if->ifmode != ISTA_MODE) {
+	wl_ext_move_cur_channel(apsta_params, cur_if);
+
+	if (wl_ext_master_if(cur_if) && !cur_if->channel) {
+		AEXT_ERROR(ifname, "skip channel 0\n");
+		ret = -1;
 		goto exit;
 	}
 
@@ -2731,7 +3561,7 @@
 		wl_clr_isam_status(cur_if, AP_CREATED);
 	}
 
-	wl_ext_move_other_channel(apsta_params, dev, cur_if);
+	wl_ext_move_other_channel(apsta_params, cur_if);
 
 	if (cur_if->ifidx > 0) {
 		wl_ext_iovar_setbuf(cur_if->dev, "cur_etheraddr", (u8 *)cur_if->dev->dev_addr,
@@ -2751,33 +3581,15 @@
 		}
 	}
 
-	if (cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE) {
+	if (wl_ext_master_if(cur_if)) {
 		wl_ext_set_bgnmode(cur_if);
 		if (!cur_if->channel) {
-#ifdef WL_CFG80211
-			char *pick_tmp, *param;
-			char cmd[128];
-			uint16 cur_chan;
-			cur_chan = 1;
-			snprintf(cmd, 128, "get_best_channels");
-			wl_cfg80211_get_best_channels(dev, cmd, strlen(cmd));
-			pick_tmp = cmd;
-			param = bcmstrtok(&pick_tmp, " ", 0);
-			while (param != NULL) {
-				if (!strnicmp(param, "2g=", strlen("2g="))) {
-					cur_chan = (int)simple_strtol(param+strlen("2g="), NULL, 10);
-				} else if (!strnicmp(param, "5g=", strlen("5g="))) {
-					cur_chan = (int)simple_strtol(param+strlen("5g="), NULL, 10);
-				}
-				param = bcmstrtok(&pick_tmp, " ", 0);
-			}
-			cur_if->channel = cur_chan;
-#else
 			cur_if->channel = 1;
-#endif
 		}
-		wl_ext_set_chanspec(cur_if->dev, apsta_params->ioctl_ver, cur_if->channel,
-			&fw_chspec);
+		ret = wl_ext_set_chanspec(cur_if->dev, apsta_params->ioctl_ver,
+			cur_if->channel, &fw_chspec);
+		if (ret)
+			goto exit;
 	}
 
 	wl_ext_set_amode(cur_if);
@@ -2811,7 +3623,7 @@
 		if (cur_if->ifmode == ISTA_MODE) {
 			wl_ext_connect(cur_if->dev, &conn_info);
 		} else {
-			if (apsta_params->rsdb) {
+			if (FW_SUPPORTED(dhd, rsdb)) {
 				wl_ext_ioctl(cur_if->dev, WLC_SET_SSID, &ssid, sizeof(ssid), 1);
 			} else {
 				bss_setbuf.cfg = htod32(cur_if->bssidx);
@@ -2826,7 +3638,7 @@
 #endif /* ARP_OFFLOAD_SUPPORT */
 #ifdef PROP_TXSTATUS_VSDB
 #if defined(BCMSDIO)
-			if (!apsta_params->rsdb && !disable_proptx) {
+			if (!(FW_SUPPORTED(dhd, rsdb)) && !disable_proptx) {
 				bool enabled;
 				dhd_wlfc_get_enable(dhd, &enabled);
 				if (!enabled) {
@@ -2834,7 +3646,7 @@
 					wl_ext_ioctl(dev, WLC_UP, NULL, 0, 1);
 				}
 			}
-#endif
+#endif /* BCMSDIO */
 #endif /* PROP_TXSTATUS_VSDB */
 		}
 	}
@@ -2850,8 +3662,8 @@
 		}
 #ifdef WLMESH
 	} else if (apstamode == IMESHONLY_MODE ||
-			apstamode == IMESHSTA_MODE || apstamode == IMESHAP_MODE ||
-			apstamode == IMESHAPSTA_MODE || apstamode == IMESHAPAP_MODE) {
+			apstamode == ISTAMESH_MODE || apstamode == IMESHAP_MODE ||
+			apstamode == ISTAAPMESH_MODE || apstamode == IMESHAPAP_MODE) {
 		if (cur_if->ifmode == ISTA_MODE) {
 			wl_ext_connect(cur_if->dev, &conn_info);
 		} else if (cur_if->ifmode == IAP_MODE) {
@@ -2868,14 +3680,17 @@
 		} else {
 			AEXT_ERROR(cur_if->ifname, "wrong ifmode %d\n", cur_if->ifmode);
 		}
-#endif
+#endif /* WLMESH */
 	}
 
-	if (cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE) {
+	if (wait_up) {
+		OSL_SLEEP(wait_up);
+	} else if (cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE) {
 		timeout = wait_event_interruptible_timeout(apsta_params->netif_change_event,
 			wl_get_isam_status(cur_if, AP_CREATED),
 			msecs_to_jiffies(MAX_AP_LINK_WAIT_TIME));
 		if (timeout <= 0 || !wl_get_isam_status(cur_if, AP_CREATED)) {
+			mutex_unlock(&apsta_params->usr_sync);
 			wl_ext_disable_iface(dev, cur_if->ifname);
 			WL_MSG(ifname, "[%c] failed to enable with SSID: \"%s\"\n",
 				cur_if->prefix, cur_if->ssid);
@@ -2886,8 +3701,8 @@
 	if (wl_get_isam_status(cur_if, AP_CREATED) &&
 			(cur_if->ifmode == IMESH_MODE || cur_if->ifmode == IAP_MODE) &&
 			(apstamode == ISTAAP_MODE || apstamode == ISTAAPAP_MODE ||
-			apstamode == IMESHSTA_MODE || apstamode == IMESHAP_MODE ||
-			apstamode == IMESHAPSTA_MODE || apstamode == IMESHAPAP_MODE)) {
+			apstamode == ISTAMESH_MODE || apstamode == IMESHAP_MODE ||
+			apstamode == ISTAAPMESH_MODE || apstamode == IMESHAPAP_MODE)) {
 		int scan_assoc_time = 80;
 		for (i=0; i<MAX_IF_NUM; i++) {
 			tmp_if = &apsta_params->if_info[i];
@@ -2904,7 +3719,8 @@
 	if (cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE) {
 		wl_clr_isam_status(cur_if, AP_CREATING);
 	}
-	WL_MSG(ifname, "[%c] Exit\n", cur_if->prefix);
+	WL_MSG(ifname, "[%c] Exit ret=%d\n", cur_if->prefix, ret);
+	mutex_unlock(&apsta_params->usr_sync);
 	return ret;
 }
 
@@ -2925,7 +3741,7 @@
 			pch = bcmstrtok(&pick_tmp, " ", 0);
 			if (pch) {
 				strcpy(ifname, pch);
-				ret = wl_ext_enable_iface(dev, ifname);
+				ret = wl_ext_enable_iface(dev, ifname, 0);
 				if (ret)
 					return ret;
 			} else {
@@ -2939,98 +3755,20 @@
 	return ret;
 }
 
-int
-wl_ext_iapsta_alive_preinit(struct net_device *dev)
-{
-	struct dhd_pub *dhd = dhd_get_pub(dev);
-	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
-
-	if (apsta_params->init == TRUE) {
-		AEXT_ERROR(dev->name, "don't init twice\n");
-		return -1;
-	}
-
-	AEXT_TRACE(dev->name, "Enter\n");
-
-	apsta_params->init = TRUE;
-
-	return 0;
-}
-
-int
-wl_ext_iapsta_alive_postinit(struct net_device *dev)
-{
-	struct dhd_pub *dhd = dhd_get_pub(dev);
-	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
-	s32 apsta = 0;
-	struct wl_if_info *cur_if;
-	int i;
-
-	wl_ext_iovar_getint(dev, "apsta", &apsta);
-	if (apsta == 1) {
-		apsta_params->apstamode = ISTAONLY_MODE;
-		apsta_params->if_info[IF_PIF].ifmode = ISTA_MODE;
-		op_mode = DHD_FLAG_STA_MODE;
-	} else {
-		apsta_params->apstamode = IAPONLY_MODE;
-		apsta_params->if_info[IF_PIF].ifmode = IAP_MODE;
-		op_mode = DHD_FLAG_HOSTAP_MODE;
-	}
-	// fix me: how to check it's ISTAAP_MODE or IDUALAP_MODE?
-
-	wl_ext_get_ioctl_ver(dev, &apsta_params->ioctl_ver);
-	WL_MSG(dev->name, "apstamode=%d\n", apsta_params->apstamode);
-
-	for (i=0; i<MAX_IF_NUM; i++) {
-		cur_if = &apsta_params->if_info[i];
-		if (i == 1 && !strlen(cur_if->ifname))
-			strcpy(cur_if->ifname, "wlan1");
-		if (i == 2 && !strlen(cur_if->ifname))
-			strcpy(cur_if->ifname, "wlan2");
-		if (cur_if->ifmode == ISTA_MODE) {
-			cur_if->channel = 0;
-			cur_if->maxassoc = -1;
-			wl_set_isam_status(cur_if, IF_READY);
-			cur_if->prio = PRIO_STA;
-			cur_if->prefix = 'S';
-			snprintf(cur_if->ssid, DOT11_MAX_SSID_LEN, "ttt_sta");
-		} else if (cur_if->ifmode == IAP_MODE) {
-			cur_if->channel = 1;
-			cur_if->maxassoc = -1;
-			wl_set_isam_status(cur_if, IF_READY);
-			cur_if->prio = PRIO_AP;
-			cur_if->prefix = 'A';
-			snprintf(cur_if->ssid, DOT11_MAX_SSID_LEN, "ttt_ap");
-#ifdef WLMESH
-		} else if (cur_if->ifmode == IMESH_MODE) {
-			cur_if->channel = 1;
-			cur_if->maxassoc = -1;
-			wl_set_isam_status(cur_if, IF_READY);
-			cur_if->prio = PRIO_MESH;
-			cur_if->prefix = 'M';
-			snprintf(cur_if->ssid, DOT11_MAX_SSID_LEN, "ttt_mesh");
-#endif
-		}
-	}
-
-	return op_mode;
-}
-
-int
+static int
 wl_ext_iapsta_event(struct net_device *dev,
 	struct wl_apsta_params *apsta_params, wl_event_msg_t *e, void* data)
 {
 	struct wl_if_info *cur_if = NULL, *tmp_if = NULL;
+#if defined(WLMESH) && defined(WL_ESCAN)
+	struct wl_if_info *mesh_if = NULL;
+#endif /* WLMESH && WL_ESCAN */
 	int i;
 	uint32 event_type = ntoh32(e->event_type);
 	uint32 status =  ntoh32(e->status);
 	uint32 reason =  ntoh32(e->reason);
 	uint16 flags =  ntoh16(e->flags);
 
-	if (!apsta_params->init) {
-		return -1;
-	}
-
 	for (i=0; i<MAX_IF_NUM; i++) {
 		tmp_if = &apsta_params->if_info[i];
 		if (tmp_if->dev == dev) {
@@ -3038,8 +3776,17 @@
 			break;
 		}
 	}
+#if defined(WLMESH) && defined(WL_ESCAN)
+	for (i=0; i<MAX_IF_NUM; i++) {
+		tmp_if = &apsta_params->if_info[i];
+		if (tmp_if->dev && tmp_if->ifmode == IMESH_MODE) {
+			mesh_if = tmp_if;
+			break;
+		}
+	}
+#endif /* WLMESH && WL_ESCAN */
 	if (!cur_if || !cur_if->dev) {
-		AEXT_ERROR(dev->name, "ifidx %d is not ready\n", e->ifidx);
+		AEXT_DBG(dev->name, "ifidx %d is not ready\n", e->ifidx);
 		return -1;
 	}
 
@@ -3051,10 +3798,18 @@
 					cur_if->prefix, &e->addr, bcmevent_get_name(event_type),
 					event_type, reason);
 				wl_clr_isam_status(cur_if, STA_CONNECTED);
+#if defined(WLMESH) && defined(WL_ESCAN)
+				if (mesh_if && apsta_params->macs)
+					wl_mesh_clear_mesh_info(apsta_params, mesh_if, TRUE);
+#endif /* WLMESH && WL_ESCAN */
 			} else {
 				WL_MSG(cur_if->ifname, "[%c] Link UP with %pM\n",
 					cur_if->prefix, &e->addr);
 				wl_set_isam_status(cur_if, STA_CONNECTED);
+#if defined(WLMESH) && defined(WL_ESCAN)
+				if (mesh_if && apsta_params->macs)
+					wl_mesh_update_master_info(apsta_params, mesh_if);
+#endif /* WLMESH && WL_ESCAN */
 			}
 			wl_clr_isam_status(cur_if, STA_CONNECTING);
 			wake_up_interruptible(&apsta_params->netif_change_event);
@@ -3064,11 +3819,19 @@
 				event_type, reason, status);
 			wl_clr_isam_status(cur_if, STA_CONNECTING);
 			wake_up_interruptible(&apsta_params->netif_change_event);
+#if defined(WLMESH) && defined(WL_ESCAN)
+			if (mesh_if && apsta_params->macs)
+				wl_mesh_clear_mesh_info(apsta_params, mesh_if, TRUE);
+#endif /* WLMESH && WL_ESCAN */
 		} else if (event_type == WLC_E_DEAUTH || event_type == WLC_E_DEAUTH_IND ||
 				event_type == WLC_E_DISASSOC || event_type == WLC_E_DISASSOC_IND) {
 			WL_MSG(cur_if->ifname, "[%c] Link down with %pM, %s(%d), reason %d\n",
 				cur_if->prefix, &e->addr, bcmevent_get_name(event_type),
 				event_type, reason);
+#if defined(WLMESH) && defined(WL_ESCAN)
+			if (mesh_if && apsta_params->macs)
+				wl_mesh_clear_mesh_info(apsta_params, mesh_if, TRUE);
+#endif /* WLMESH && WL_ESCAN */
 		}
 	}
 	else if (cur_if->ifmode == IAP_MODE || cur_if->ifmode == IMESH_MODE) {
@@ -3081,10 +3844,12 @@
 				wl_set_isam_status(cur_if, AP_CREATED);
 				wake_up_interruptible(&apsta_params->netif_change_event);
 			} else {
+				wl_set_isam_status(cur_if, AP_CREATED);
 				WL_MSG(cur_if->ifname, "[%c] Link up w/o creating? (etype=%d)\n",
 					cur_if->prefix, event_type);
 			}
-		} else if ((event_type == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS) ||
+		}
+		else if ((event_type == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS) ||
 				(event_type == WLC_E_LINK && status == WLC_E_STATUS_SUCCESS &&
 				reason == WLC_E_REASON_DEAUTH)) {
 			wl_clr_isam_status(cur_if, AP_CREATED);
@@ -3096,7 +3861,8 @@
 			WL_MSG(cur_if->ifname, "[%c] connected device %pM\n",
 				cur_if->prefix, &e->addr);
 			wl_ext_isam_status(cur_if->dev, NULL, 0);
-		} else if (event_type == WLC_E_DISASSOC_IND ||
+		}
+		else if (event_type == WLC_E_DISASSOC_IND ||
 				event_type == WLC_E_DEAUTH_IND ||
 				(event_type == WLC_E_DEAUTH && reason != DOT11_RC_RESERVED)) {
 			WL_MSG(cur_if->ifname,
@@ -3105,11 +3871,16 @@
 				event_type, reason);
 			wl_ext_isam_status(cur_if->dev, NULL, 0);
 		}
+#if defined(WLMESH) && defined(WL_ESCAN)
+		if (cur_if->ifmode == IMESH_MODE && apsta_params->macs)
+			wl_mesh_event_handler(apsta_params, cur_if, e, data);
+#endif /* WLMESH && WL_ESCAN */
 	}
 
 	return 0;
 }
 
+#ifdef WL_CFG80211
 u32
 wl_ext_iapsta_update_channel(dhd_pub_t *dhd, struct net_device *dev,
 	u32 channel)
@@ -3127,20 +3898,185 @@
 	}
 
 	if (cur_if) {
-		if (cur_if->ifmode == ISTA_MODE)
-			wl_set_isam_status(cur_if, STA_CONNECTING);
 		wl_ext_isam_status(cur_if->dev, NULL, 0);
 		cur_if->channel = channel;
-		channel = wl_ext_move_cur_channel(apsta_params,
-			apsta_params->if_info[IF_PIF].dev, cur_if);
+		if (wl_ext_master_if(cur_if) && apsta_params->acs) {
+			uint auto_band = WL_GET_BAND(channel);
+			cur_if->channel = wl_ext_autochannel(cur_if->dev, apsta_params->acs,
+				auto_band);
+		}
+		channel = wl_ext_move_cur_channel(apsta_params, cur_if);
 		if (channel)
-			wl_ext_move_other_channel(apsta_params,
-				apsta_params->if_info[IF_PIF].dev, cur_if);
+			wl_ext_move_other_channel(apsta_params, cur_if);
+		if (cur_if->ifmode == ISTA_MODE)
+			wl_set_isam_status(cur_if, STA_CONNECTING);
 	}
 
 	return channel;
 }
 
+void
+wl_ext_iapsta_update_iftype(struct net_device *net, int ifidx, int wl_iftype)
+{
+	struct dhd_pub *dhd = dhd_get_pub(net);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *cur_if = NULL;
+
+	AEXT_TRACE(net->name, "ifidx=%d, wl_iftype=%d\n", ifidx, wl_iftype);
+
+	if (ifidx < MAX_IF_NUM) {
+		cur_if = &apsta_params->if_info[ifidx];
+	}
+
+	if (cur_if) {
+		if (wl_iftype == WLC_E_IF_ROLE_STA) {
+			cur_if->ifmode = ISTA_MODE;
+			cur_if->prio = PRIO_STA;
+			cur_if->prefix = 'S';
+		} else if (wl_iftype == WLC_E_IF_ROLE_AP && cur_if->ifmode != IMESH_MODE) {
+			cur_if->ifmode = IAP_MODE;
+			cur_if->prio = PRIO_AP;
+			cur_if->prefix = 'A';
+		}
+	}
+}
+
+void
+wl_ext_iapsta_ifadding(struct net_device *net, int ifidx)
+{
+	struct dhd_pub *dhd = dhd_get_pub(net);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *cur_if = NULL;
+
+	AEXT_TRACE(net->name, "ifidx=%d\n", ifidx);
+	if (ifidx < MAX_IF_NUM) {
+		cur_if = &apsta_params->if_info[ifidx];
+		wl_set_isam_status(cur_if, IF_ADDING);
+	}
+}
+
+bool
+wl_ext_iapsta_mesh_creating(struct net_device *net)
+{
+	struct dhd_pub *dhd = dhd_get_pub(net);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *cur_if;
+	int i;
+
+	if (apsta_params) {
+		for (i=0; i<MAX_IF_NUM; i++) {
+			cur_if = &apsta_params->if_info[i];
+			if (cur_if->ifmode==IMESH_MODE && wl_get_isam_status(cur_if, IF_ADDING))
+				return TRUE;
+		}
+	}
+	return FALSE;
+}
+#endif /* WL_CFG80211 */
+
+int
+wl_ext_iapsta_alive_preinit(struct net_device *dev)
+{
+	struct dhd_pub *dhd = dhd_get_pub(dev);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+
+	if (apsta_params->init == TRUE) {
+		AEXT_ERROR(dev->name, "don't init twice\n");
+		return -1;
+	}
+
+	AEXT_TRACE(dev->name, "Enter\n");
+
+	apsta_params->init = TRUE;
+
+	return 0;
+}
+
+int
+wl_ext_iapsta_alive_postinit(struct net_device *dev)
+{
+	struct dhd_pub *dhd = dhd_get_pub(dev);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	s32 apsta = 0, ap = 0;
+	struct wl_if_info *cur_if;
+	int i;
+
+	wl_ext_iovar_getint(dev, "apsta", &apsta);
+	wl_ext_ioctl(dev, WLC_GET_AP, &ap, sizeof(ap), 0);
+	if (apsta == 1 || ap == 0) {
+		apsta_params->apstamode = ISTAONLY_MODE;
+		apsta_params->if_info[IF_PIF].ifmode = ISTA_MODE;
+		op_mode = DHD_FLAG_STA_MODE;
+	} else {
+		apsta_params->apstamode = IAPONLY_MODE;
+		apsta_params->if_info[IF_PIF].ifmode = IAP_MODE;
+		op_mode = DHD_FLAG_HOSTAP_MODE;
+	}
+	// fix me: how to check it's ISTAAP_MODE or IDUALAP_MODE?
+
+	wl_ext_get_ioctl_ver(dev, &apsta_params->ioctl_ver);
+	WL_MSG(dev->name, "apstamode=%d\n", apsta_params->apstamode);
+
+	for (i=0; i<MAX_IF_NUM; i++) {
+		cur_if = &apsta_params->if_info[i];
+		if (i == 1 && !strlen(cur_if->ifname))
+			strcpy(cur_if->ifname, "wlan1");
+		if (i == 2 && !strlen(cur_if->ifname))
+			strcpy(cur_if->ifname, "wlan2");
+		if (cur_if->ifmode == ISTA_MODE) {
+			cur_if->channel = 0;
+			cur_if->maxassoc = -1;
+			wl_set_isam_status(cur_if, IF_READY);
+			cur_if->prio = PRIO_STA;
+			cur_if->prefix = 'S';
+			snprintf(cur_if->ssid, DOT11_MAX_SSID_LEN, "ttt_sta");
+		} else if (cur_if->ifmode == IAP_MODE) {
+			cur_if->channel = 1;
+			cur_if->maxassoc = -1;
+			wl_set_isam_status(cur_if, IF_READY);
+			cur_if->prio = PRIO_AP;
+			cur_if->prefix = 'A';
+			snprintf(cur_if->ssid, DOT11_MAX_SSID_LEN, "ttt_ap");
+#ifdef WLMESH
+		} else if (cur_if->ifmode == IMESH_MODE) {
+			cur_if->channel = 1;
+			cur_if->maxassoc = -1;
+			wl_set_isam_status(cur_if, IF_READY);
+			cur_if->prio = PRIO_MESH;
+			cur_if->prefix = 'M';
+			snprintf(cur_if->ssid, DOT11_MAX_SSID_LEN, "ttt_mesh");
+#endif /* WLMESH */
+		}
+	}
+
+	return op_mode;
+}
+
+static int
+wl_ext_iapsta_get_rsdb(struct net_device *net, struct dhd_pub *dhd)
+{
+	s8 iovar_buf[WLC_IOCTL_SMLEN];
+	wl_config_t *rsdb_p;
+	int ret = 0, rsdb = 0;
+
+	if (dhd->conf->chip == BCM4359_CHIP_ID) {
+		ret = wldev_iovar_getbuf(net, "rsdb_mode", NULL, 0,
+			iovar_buf, WLC_IOCTL_SMLEN, NULL);
+		if (!ret) {
+			if (dhd->conf->fw_type == FW_TYPE_MESH) {
+				rsdb = 1;
+			} else {
+				rsdb_p = (wl_config_t *) iovar_buf;
+				rsdb = rsdb_p->config;
+			}
+		}
+	}
+
+	AEXT_INFO(net->name, "rsdb_mode=%d\n", rsdb);
+
+	return rsdb;
+}
+
 static void
 wl_ext_iapsta_postinit(struct net_device *net, struct wl_if_info *cur_if)
 {
@@ -3150,12 +4086,14 @@
 
 	AEXT_TRACE(cur_if->ifname, "ifidx=%d\n", cur_if->ifidx);
 	if (cur_if->ifidx == 0) {
+		apsta_params->rsdb = wl_ext_iapsta_get_rsdb(net, dhd);
+		apsta_params->vsdb = FALSE;
+		apsta_params->csa = 0;
+		apsta_params->acs = 0;
+		apsta_params->radar = wl_ext_radar_detect(net);
 		if (dhd->conf->fw_type == FW_TYPE_MESH) {
-			apsta_params->rsdb = TRUE;
-			apsta_params->csa = CSA_FW_BIT | CSA_DRV_BIT;
+			apsta_params->csa |= (CSA_FW_BIT | CSA_DRV_BIT);
 		}
-		if (dhd->conf->chip == BCM4330_CHIP_ID)
-			apsta_params->csa |= CSA_FW_BIT;
 	} else {
 		if (cur_if->ifmode == ISTA_MODE) {
 			wl_ext_iovar_setint(cur_if->dev, "roam_off", dhd->conf->roam_off);
@@ -3166,12 +4104,13 @@
 				pm = PM_FAST;
 			wl_ext_ioctl(cur_if->dev, WLC_SET_PM, &pm, sizeof(pm), 1);
 			wl_ext_iovar_setint(cur_if->dev, "assoc_retry_max", 30);
+		}
 #ifdef WLMESH
-		} else if (cur_if->ifmode == IMESH_MODE) {
+		else if (cur_if->ifmode == IMESH_MODE) {
 			pm = 0;
 			wl_ext_ioctl(cur_if->dev, WLC_SET_PM, &pm, sizeof(pm), 1);
-#endif
 		}
+#endif /* WLMESH */
 	}
 
 }
@@ -3203,6 +4142,39 @@
 }
 
 int
+wl_ext_iapsta_update_net_device(struct net_device *net, int ifidx)
+{
+	struct dhd_pub *dhd = dhd_get_pub(net);
+	struct wl_apsta_params *apsta_params = dhd->iapsta_params;
+	struct wl_if_info *cur_if = NULL, *primary_if;
+
+	AEXT_TRACE(net->name, "ifidx=%d\n", ifidx);
+	if (ifidx < MAX_IF_NUM) {
+		cur_if = &apsta_params->if_info[ifidx];
+	}
+	if (cur_if && wl_get_isam_status(cur_if, IF_ADDING)) {
+		primary_if = &apsta_params->if_info[IF_PIF];
+		if (strlen(cur_if->ifname)) {
+			memset(net->name, 0, sizeof(IFNAMSIZ));
+			strcpy(net->name, cur_if->ifname);
+			net->name[IFNAMSIZ-1] = '\0';
+		}
+		if (apsta_params->apstamode != ISTAAPAP_MODE &&
+				apsta_params->apstamode != ISTASTA_MODE) {
+			memcpy(net->dev_addr, primary_if->dev->dev_addr, ETHER_ADDR_LEN);
+			net->dev_addr[0] |= 0x02;
+			if (ifidx >= 2) {
+				net->dev_addr[4] ^= 0x80;
+				net->dev_addr[4] += ifidx;
+				net->dev_addr[5] += (ifidx-1);
+			}
+		}
+	}
+
+	return 0;
+}
+
+int
 wl_ext_iapsta_attach_netdev(struct net_device *net, int ifidx, uint8 bssidx)
 {
 	struct dhd_pub *dhd = dhd_get_pub(net);
@@ -3216,15 +4188,17 @@
 	if (ifidx == 0) {
 		memset(apsta_params, 0, sizeof(struct wl_apsta_params));
 		apsta_params->dhd = dhd;
-		apsta_params->vsdb = FALSE;
 		cur_if->dev = net;
 		cur_if->ifidx = ifidx;
 		cur_if->bssidx = bssidx;
-		cur_if->prefix = 'X';
+		cur_if->ifmode = ISTA_MODE;
+		cur_if->prio = PRIO_STA;
+		cur_if->prefix = 'S';
 		wl_ext_event_register(net, dhd, WLC_E_LAST, wl_ext_iapsta_event,
 			apsta_params, PRIO_EVENT_IAPSTA);
 		strcpy(cur_if->ifname, net->name);
 		init_waitqueue_head(&apsta_params->netif_change_event);
+		mutex_init(&apsta_params->usr_sync);
 	} else if (cur_if && wl_get_isam_status(cur_if, IF_ADDING)) {
 		primary_if = &apsta_params->if_info[IF_PIF];
 		cur_if->dev = net;
@@ -3232,21 +4206,11 @@
 		cur_if->bssidx = bssidx;
 		wl_ext_event_register(net, dhd, WLC_E_LAST, wl_ext_iapsta_event,
 			apsta_params, PRIO_EVENT_IAPSTA);
-		if (strlen(cur_if->ifname)) {
-			memset(net->name, 0, sizeof(IFNAMSIZ));
-			strcpy(net->name, cur_if->ifname);
-			net->name[IFNAMSIZ-1] = '\0';
-		}
-		if (apsta_params->apstamode != ISTAAPAP_MODE &&
-				apsta_params->apstamode != ISTASTA_MODE) {
-			memcpy(net->dev_addr, primary_if->dev->dev_addr, ETHER_ADDR_LEN);
-			net->dev_addr[0] |= 0x02;
-			if (ifidx >= 2) {
-				net->dev_addr[4] ^= 0x80;
-				net->dev_addr[4] += ifidx;
-				net->dev_addr[5] += (ifidx-1);
-			}
+#if defined(WLMESH) && defined(WL_ESCAN)
+		if (cur_if->ifmode == IMESH_MODE && apsta_params->macs) {
+			wl_mesh_escan_attach(dhd, cur_if);
 		}
+#endif /* WLMESH && WL_ESCAN */
 	}
 
 	return 0;
@@ -3269,16 +4233,28 @@
 
 	if (ifidx == 0) {
 		wl_ext_event_deregister(net, dhd, WLC_E_LAST, wl_ext_iapsta_event);
+#if defined(WLMESH) && defined(WL_ESCAN)
+		if (cur_if->ifmode == IMESH_MODE && apsta_params->macs) {
+			wl_mesh_escan_detach(dhd, cur_if);
+		}
+#endif /* WLMESH && WL_ESCAN */
 		memset(apsta_params, 0, sizeof(struct wl_apsta_params));
-	} else if (cur_if && wl_get_isam_status(cur_if, IF_READY)) {
+	} else if (cur_if && (wl_get_isam_status(cur_if, IF_READY) ||
+			wl_get_isam_status(cur_if, IF_ADDING))) {
 		wl_ext_event_deregister(net, dhd, WLC_E_LAST, wl_ext_iapsta_event);
+#if defined(WLMESH) && defined(WL_ESCAN)
+		if (cur_if->ifmode == IMESH_MODE && apsta_params->macs) {
+			wl_mesh_escan_detach(dhd, cur_if);
+		}
+#endif /* WLMESH && WL_ESCAN */
 		memset(cur_if, 0, sizeof(struct wl_if_info));
 	}
 
 	return 0;
 }
 
-int wl_ext_iapsta_attach(dhd_pub_t *pub)
+int
+wl_ext_iapsta_attach(dhd_pub_t *pub)
 {
 	struct wl_apsta_params *iapsta_params;
 
@@ -3292,14 +4268,15 @@
 	return 0;
 }
 
-void wl_ext_iapsta_dettach(dhd_pub_t *pub)
+void
+wl_ext_iapsta_dettach(dhd_pub_t *pub)
 {
 	if (pub->iapsta_params) {
 		kfree(pub->iapsta_params);
 		pub->iapsta_params = NULL;
 	}
 }
-#endif
+#endif /* WL_EXT_IAPSTA */
 
 #ifdef IDHCP
 /*
@@ -3307,7 +4284,7 @@
 dhd_priv wl dhcpc_dump
 dhd_priv wl dhcpc_param <client ip> <server ip> <lease time>
 */
-int
+static int
 wl_ext_dhcpc_dump(struct net_device *dev, char *data, char *command,
 	int total_len)
 {
@@ -3407,55 +4384,40 @@
 	exit:
 		return ret;
 }
-#endif
+#endif /* IDHCP */
 
 int
 wl_ext_mkeep_alive(struct net_device *dev, char *data, char *command,
 	int total_len)
 {
+	struct dhd_pub *dhd = dhd_get_pub(dev);
 	wl_mkeep_alive_pkt_t *mkeep_alive_pktp;
-	int ret = -1, i;
-	int	id, period=-1, len_bytes=0, buf_len=0;
-	char packet[200]="\0";
-	char buf[WLC_IOCTL_SMLEN]="\0", iovar_buf[WLC_IOCTL_SMLEN]="\0";
+	int ret = -1, i, ifidx, id, period=-1;
+	char *packet = NULL, *buf = NULL;
 	int bytes_written = 0;
-	struct ether_addr bssid;
-	uint8 *pdata;
 
 	if (data) {
+		buf = kmalloc(total_len, GFP_KERNEL);
+		if (buf == NULL) {
+			AEXT_ERROR(dev->name, "Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
+			goto exit;
+		}
+		packet = kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
+		if (packet == NULL) {
+			AEXT_ERROR(dev->name, "Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
+			goto exit;
+		}
 		AEXT_TRACE(dev->name, "cmd %s", command);
 		sscanf(data, "%d %d %s", &id, &period, packet);
 		AEXT_TRACE(dev->name, "id=%d, period=%d, packet=%s", id, period, packet);
 		if (period >= 0) {
-			mkeep_alive_pktp = (wl_mkeep_alive_pkt_t *)buf;
-			mkeep_alive_pktp->version = htod16(WL_MKEEP_ALIVE_VERSION);
-			mkeep_alive_pktp->length = htod16(WL_MKEEP_ALIVE_FIXED_LEN);
-			mkeep_alive_pktp->keep_alive_id = id;
-			buf_len += WL_MKEEP_ALIVE_FIXED_LEN;
-			mkeep_alive_pktp->period_msec = period;
-			if (strlen(packet)) {
-				len_bytes = wl_pattern_atoh(packet,
-					(char *)mkeep_alive_pktp->data);
-				buf_len += len_bytes;
-			}
-			mkeep_alive_pktp->len_bytes = htod16(len_bytes);
-			ret = wldev_ioctl(dev, WLC_GET_BSSID, &bssid, sizeof(bssid), 0);
-			if (ret != BCME_NOTASSOCIATED && memcmp(&ether_null, &bssid,
-					ETHER_ADDR_LEN))
-				memcpy(mkeep_alive_pktp->data, &bssid, ETHER_ADDR_LEN);
-			ret = wl_ext_iovar_getbuf(dev, "cur_etheraddr", &bssid, sizeof(bssid),
-				iovar_buf, WLC_IOCTL_SMLEN, NULL);
-			if (!ret) {
-				pdata = mkeep_alive_pktp->data;
-				memcpy(pdata+6, iovar_buf, ETHER_ADDR_LEN);
-			}
-			ret = wl_ext_iovar_setbuf(dev, "mkeep_alive", buf, buf_len,
-				iovar_buf, sizeof(iovar_buf), NULL);
+			ifidx = dhd_net2idx(dhd->info, dev);
+			ret = dhd_conf_mkeep_alive(dhd, ifidx, id, period, packet, FALSE);
 		} else {
 			if (id < 0)
 				id = 0;
 			ret = wl_ext_iovar_getbuf(dev, "mkeep_alive", &id, sizeof(id), buf,
-				sizeof(buf), NULL);
+				total_len, NULL);
 			if (!ret) {
 				mkeep_alive_pktp = (wl_mkeep_alive_pkt_t *) buf;
 				bytes_written += snprintf(command+bytes_written, total_len,
@@ -3476,6 +4438,11 @@
 		}
 	}
 
+exit:
+	if (buf)
+		kfree(buf);
+	if (packet)
+		kfree(packet);
 	return ret;
 }
 
@@ -3613,7 +4580,7 @@
 
 	return ret;
 }
-#endif
+#endif /* WL_EXT_TCPKA */
 
 static int
 wl_ext_rsdb_mode(struct net_device *dev, char *data, char *command,
@@ -3946,68 +4913,10 @@
 
 	return err;
 }
-#endif
+#endif /* PKT_FILTER_SUPPORT */
 
 #ifdef SENDPROB
 static int
-wl_ext_add_del_ie(struct net_device *dev, uint pktflag, char *ie_data, const char* add_del_cmd)
-{
-	vndr_ie_setbuf_t *vndr_ie = NULL;
-	char iovar_buf[WLC_IOCTL_SMLEN]="\0";
-	int ie_data_len = 0, tot_len = 0, iecount;
-	int err = -1;
-
-	if (!strlen(ie_data)) {
-		AEXT_ERROR(dev->name, "wrong ie %s\n", ie_data);
-		goto exit;
-	}
-
-	tot_len = (int)(sizeof(vndr_ie_setbuf_t) + ((strlen(ie_data)-2)/2));
-	vndr_ie = (vndr_ie_setbuf_t *) kzalloc(tot_len, GFP_KERNEL);
-	if (!vndr_ie) {
-		AEXT_ERROR(dev->name, "IE memory alloc failed\n");
-		err = -ENOMEM;
-		goto exit;
-	}
-
-	/* Copy the vndr_ie SET command ("add"/"del") to the buffer */
-	strncpy(vndr_ie->cmd, add_del_cmd, VNDR_IE_CMD_LEN - 1);
-	vndr_ie->cmd[VNDR_IE_CMD_LEN - 1] = '\0';
-
-	/* Set the IE count - the buffer contains only 1 IE */
-	iecount = htod32(1);
-	memcpy((void *)&vndr_ie->vndr_ie_buffer.iecount, &iecount, sizeof(s32));
-
-	/* Set packet flag to indicate that BEACON's will contain this IE */
-	pktflag = htod32(pktflag);
-	memcpy((void *)&vndr_ie->vndr_ie_buffer.vndr_ie_list[0].pktflag, &pktflag,
-		sizeof(u32));
-
-	/* Set the IE ID */
-	vndr_ie->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.id = (uchar)DOT11_MNG_VS_ID;
-
-	/* Set the IE LEN */
-	vndr_ie->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.len = (strlen(ie_data)-2)/2;
-
-	/* Set the IE OUI and DATA */
-	ie_data_len = wl_pattern_atoh(ie_data,
-		(char *)vndr_ie->vndr_ie_buffer.vndr_ie_list[0].vndr_ie_data.oui);
-	if (ie_data_len <= 0) {
-		AEXT_ERROR(dev->name, "wrong ie_data_len %d\n", strlen(ie_data)-2);
-		goto exit;
-	}
-
-	err = wl_ext_iovar_setbuf(dev, "ie", vndr_ie, tot_len, iovar_buf,
-		sizeof(iovar_buf), NULL);
-
-exit:
-	if (vndr_ie) {
-		kfree(vndr_ie);
-	}
-	return err;
-}
-
-static int
 wl_ext_send_probreq(struct net_device *dev, char *data, char *command,
 	int total_len)
 {
@@ -4175,7 +5084,7 @@
 exit:
     return err;
 }
-#endif
+#endif /* SENDPROB */
 
 static int
 wl_ext_gtk_key_info(struct net_device *dev, char *data, char *command, int total_len)
@@ -4431,7 +5340,67 @@
 
 	return ret;
 }
-#endif
+#endif /* WL_EXT_WOWL */
+
+#ifdef WL_GPIO_NOTIFY
+typedef struct notify_payload {
+	int index;
+	int len;
+	char payload[128];
+} notify_payload_t;
+
+static int
+wl_ext_gpio_notify(struct net_device *dev, char *data, char *command,
+	int total_len)
+{
+	s8 iovar_buf[WLC_IOCTL_SMLEN];
+	notify_payload_t notify, *pnotify = NULL;
+	int i, ret = 0, bytes_written = 0;
+	char frame_str[WLC_IOCTL_SMLEN+3];
+
+	if (data) {
+		memset(&notify, 0, sizeof(notify));
+		memset(frame_str, 0, sizeof(frame_str));
+		sscanf(data, "%d %s", &notify.index, frame_str);
+
+		if (notify.index < 0)
+			notify.index = 0;
+
+		if (strlen(frame_str)) {
+			notify.len = wl_pattern_atoh(frame_str, notify.payload);
+			if (notify.len == -1) {
+				AEXT_ERROR(dev->name, "rejecting pattern=%s\n", frame_str);
+				goto exit;
+			}
+			AEXT_INFO(dev->name, "index=%d, len=%d\n", notify.index, notify.len);
+			if (android_msg_level & ANDROID_INFO_LEVEL)
+				prhex("payload", (uchar *)notify.payload, notify.len);
+			ret = wl_ext_iovar_setbuf(dev, "bcol_gpio_noti", (char *)&notify,
+				sizeof(notify), iovar_buf, WLC_IOCTL_SMLEN, NULL);
+		} else {
+			AEXT_INFO(dev->name, "index=%d\n", notify.index);
+			ret = wl_ext_iovar_getbuf(dev, "bcol_gpio_noti", &notify.index,
+				sizeof(notify.index), iovar_buf, sizeof(iovar_buf), NULL);
+			if (!ret) {
+				pnotify = (notify_payload_t *)iovar_buf;
+				bytes_written += snprintf(command+bytes_written, total_len,
+					"Id            :%d\n"
+					"Packet        :0x",
+					pnotify->index);
+				for (i=0; i<pnotify->len; i++) {
+					bytes_written += snprintf(command+bytes_written, total_len,
+						"%02x", pnotify->payload[i]);
+				}
+				AEXT_TRACE(dev->name, "command result is\n%s\n", command);
+				ret = bytes_written;
+			}
+		}
+	}
+
+exit:
+	return ret;
+}
+#endif /* WL_GPIO_NOTIFY */
 
 typedef int (wl_ext_tpl_parse_t)(struct net_device *dev, char *data, char *command,
 	int total_len);
@@ -4453,29 +5422,32 @@
 	{WLC_GET_VAR,	WLC_SET_VAR,	"pkt_filter_add",		wl_ext_pkt_filter_add},
 	{WLC_GET_VAR,	WLC_SET_VAR,	"pkt_filter_delete",	wl_ext_pkt_filter_delete},
 	{WLC_GET_VAR,	WLC_SET_VAR,	"pkt_filter_enable",	wl_ext_pkt_filter_enable},
-#endif
+#endif /* PKT_FILTER_SUPPORT */
 #if defined(WL_EXT_IAPSTA) && defined(WLMESH)
 	{WLC_GET_VAR,	WLC_SET_VAR,	"mesh_peer_status",	wl_ext_mesh_peer_status},
-#endif
+#endif /* WL_EXT_IAPSTA && WLMESH */
 #ifdef SENDPROB
 	{WLC_GET_VAR,	WLC_SET_VAR,	"send_probreq",		wl_ext_send_probreq},
 	{WLC_GET_VAR,	WLC_SET_VAR,	"send_probresp",	wl_ext_send_probresp},
 	{WLC_GET_VAR,	WLC_SET_VAR,	"recv_probreq",		wl_ext_recv_probreq},
 	{WLC_GET_VAR,	WLC_SET_VAR,	"recv_probresp",	wl_ext_recv_probresp},
-#endif
+#endif /* SENDPROB */
 #ifdef WL_EXT_TCPKA
 	{WLC_GET_VAR,	WLC_SET_VAR,	"tcpka_conn_add",		wl_ext_tcpka_conn_add},
 	{WLC_GET_VAR,	WLC_SET_VAR,	"tcpka_conn_enable",	wl_ext_tcpka_conn_enable},
 	{WLC_GET_VAR,	WLC_SET_VAR,	"tcpka_conn_sess_info",	wl_ext_tcpka_conn_info},
-#endif
+#endif /* WL_EXT_TCPKA */
 #ifdef WL_EXT_WOWL
 	{WLC_GET_VAR,	WLC_SET_VAR,	"wowl_pattern",		wl_ext_wowl_pattern},
 	{WLC_GET_VAR,	WLC_SET_VAR,	"wowl_wakeind",		wl_ext_wowl_wakeind},
-#endif
+#endif /* WL_EXT_WOWL */
 #ifdef IDHCP
 	{WLC_GET_VAR,	WLC_SET_VAR,	"dhcpc_dump",		wl_ext_dhcpc_dump},
 	{WLC_GET_VAR,	WLC_SET_VAR,	"dhcpc_param",		wl_ext_dhcpc_param},
-#endif
+#endif /* IDHCP */
+#ifdef WL_GPIO_NOTIFY
+	{WLC_GET_VAR,	WLC_SET_VAR,	"bcol_gpio_noti",	wl_ext_gpio_notify},
+#endif /* WL_GPIO_NOTIFY */
 };
 
 /*
@@ -4556,7 +5528,8 @@
 	return ret;
 }
 
-int wl_android_ext_priv_cmd(struct net_device *net, char *command,
+int
+wl_android_ext_priv_cmd(struct net_device *net, char *command,
 	int total_len, int *bytes_written)
 {
 	int ret = 0;
@@ -4601,17 +5574,20 @@
 	else if (strnicmp(command, CMD_ISAM_STATUS, strlen(CMD_ISAM_STATUS)) == 0) {
 		*bytes_written = wl_ext_isam_status(net, command, total_len);
 	}
-#endif
+	else if (strnicmp(command, CMD_ISAM_PARAM, strlen(CMD_ISAM_PARAM)) == 0) {
+		*bytes_written = wl_ext_isam_param(net, command, total_len);
+	}
+#endif /* WL_EXT_IAPSTA */
 #ifdef WL_CFG80211
 	else if (strnicmp(command, CMD_AUTOCHANNEL, strlen(CMD_AUTOCHANNEL)) == 0) {
 		*bytes_written = wl_cfg80211_autochannel(net, command, total_len);
 	}
-#endif
+#endif /* WL_CFG80211 */
 #if defined(WL_WIRELESS_EXT) && defined(WL_ESCAN)
 	else if (strnicmp(command, CMD_AUTOCHANNEL, strlen(CMD_AUTOCHANNEL)) == 0) {
 		*bytes_written = wl_iw_autochannel(net, command, total_len);
 	}
-#endif
+#endif /* WL_WIRELESS_EXT && WL_ESCAN */
 	else if (strnicmp(command, CMD_WL, strlen(CMD_WL)) == 0) {
 		*bytes_written = wl_ext_wl_iovar(net, command, total_len);
 	}
@@ -4674,7 +5650,7 @@
 	wl_bss_cache_ctrl_t *bss_cache_ctrl,
 #else
 	struct wl_scan_results *bss_list,
-#endif
+#endif /* BSSCACHE */
 	int ioctl_ver, int *best_2g_ch, int *best_5g_ch
 )
 {
@@ -4682,13 +5658,14 @@
 	s32 i, j;
 #if defined(BSSCACHE)
 	wl_bss_cache_t *node;
-#endif
+#endif /* BSSCACHE */
 	int b_band[CH_MAX_2G_CHANNEL]={0}, a_band1[4]={0}, a_band4[5]={0};
 	s32 cen_ch, distance, distance_2g, distance_5g, ch, min_ap=999;
 	u8 valid_chan_list[sizeof(u32)*(WL_NUMCHANNELS + 1)];
 	wl_uint32_list_t *list;
 	int ret;
 	chanspec_t chanspec;
+	struct dhd_pub *dhd = dhd_get_pub(net);
 
 	memset(b_band, -1, sizeof(b_band));
 	memset(a_band1, -1, sizeof(a_band1));
@@ -4705,6 +5682,8 @@
 	} else {
 		for (i = 0; i < dtoh32(list->count); i++) {
 			ch = dtoh32(list->element[i]);
+			if (!dhd_conf_match_channel(dhd, ch))
+				continue;
 			if (ch < CH_MAX_2G_CHANNEL)
 				b_band[ch-1] = 0;
 			else if (ch <= 48)
@@ -4722,13 +5701,13 @@
 	for (i=0; node && i<256; i++)
 #else
 	for (i=0; i < bss_list->count; i++)
-#endif
+#endif /* BSSCACHE */
 	{
 #if defined(BSSCACHE)
 		bi = node->results.bss_info;
 #else
 		bi = bi ? (wl_bss_info_t *)((uintptr)bi + dtoh32(bi->length)) : bss_list->bss_info;
-#endif
+#endif /* BSSCACHE */
 		chanspec = wl_ext_chspec_driver_to_host(ioctl_ver, bi->chanspec);
 		cen_ch = CHSPEC_CHANNEL(bi->chanspec);
 		distance = 0;
@@ -4745,7 +5724,7 @@
 			distance += distance_2g;
 			for (j=0; j<ARRAYSIZE(b_band); j++) {
 				if (b_band[j] >= 0 && abs(cen_ch-(1+j)) <= distance)
-				b_band[j] += 1;
+					b_band[j] += 1;
 			}
 		} else {
 			distance += distance_5g;
@@ -4763,7 +5742,7 @@
 		}
 #if defined(BSSCACHE)
 		node = node->next;
-#endif
+#endif /* BSSCACHE */
 	}
 
 	*best_2g_ch = 0;
@@ -4790,25 +5769,256 @@
 	}
 
 	if (android_msg_level & ANDROID_INFO_LEVEL) {
-		AEXT_INFO(net->name, "b_band: ");
+		struct bcmstrbuf strbuf;
+		char *tmp_buf = NULL;
+		tmp_buf = kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);
+		if (tmp_buf == NULL) {
+			AEXT_ERROR(net->name, "Failed to allocate buffer of %d bytes\n", WLC_IOCTL_SMLEN);
+			goto exit;
+		}
+		bcm_binit(&strbuf, tmp_buf, WLC_IOCTL_SMLEN);
 		for (j=0; j<ARRAYSIZE(b_band); j++)
-			printf("%d, ", b_band[j]);
-		printf("\n");
-		AEXT_INFO(net->name, "a_band1: ");
+			bcm_bprintf(&strbuf, "%d/%d, ", b_band[j], 1+j);
+		bcm_bprintf(&strbuf, "\n");
 		for (j=0; j<ARRAYSIZE(a_band1); j++)
-			printf("%d, ", a_band1[j]);
-		printf("\n");
-		AEXT_INFO(net->name, "a_band4: ");
+			bcm_bprintf(&strbuf, "%d/%d, ", a_band1[j], 36+j*4);
+		bcm_bprintf(&strbuf, "\n");
 		for (j=0; j<ARRAYSIZE(a_band4); j++)
-			printf("%d, ", a_band4[j]);
-		printf("\n");
-		AEXT_INFO(net->name, "best_2g_ch=%d, best_5g_ch=%d\n",
+			bcm_bprintf(&strbuf, "%d/%d, ", a_band4[j], 149+j*4);
+		bcm_bprintf(&strbuf, "\n");
+		bcm_bprintf(&strbuf, "best_2g_ch=%d, best_5g_ch=%d\n",
 			*best_2g_ch, *best_5g_ch);
+		AEXT_INFO(net->name, "\n%s", strbuf.origbuf);
+		if (tmp_buf) {
+			kfree(tmp_buf);
+		}
 	}
 
+exit:
 	return 0;
 }
+#endif /* WL_CFG80211 || WL_ESCAN */
+
+#define APCS_MAX_RETRY		10
+static int
+wl_ext_fw_apcs(struct net_device *dev, uint32 band)
+{
+	int channel = 0, chosen = 0, retry = 0, ret = 0, spect = 0;
+	u8 *reqbuf = NULL;
+	uint32 buf_size;
+
+	ret = wldev_ioctl_get(dev, WLC_GET_SPECT_MANAGMENT, &spect, sizeof(spect));
+	if (ret) {
+		AEXT_ERROR(dev->name, "ACS: error getting the spect, ret=%d\n", ret);
+		goto done;
+	}
+
+	if (spect > 0) {
+		ret = wl_cfg80211_set_spect(dev, 0);
+		if (ret < 0) {
+			AEXT_ERROR(dev->name, "ACS: error while setting spect, ret=%d\n", ret);
+			goto done;
+		}
+	}
+
+	reqbuf = kmalloc(CHANSPEC_BUF_SIZE, GFP_KERNEL);
+	if (reqbuf == NULL) {
+		AEXT_ERROR(dev->name, "failed to allocate chanspec buffer\n");
+		goto done;
+	}
+	memset(reqbuf, 0, CHANSPEC_BUF_SIZE);
+
+	if (band == WLC_BAND_AUTO) {
+		AEXT_INFO(dev->name, "ACS full channel scan \n");
+		reqbuf[0] = htod32(0);
+	} else if (band == WLC_BAND_5G) {
+		AEXT_INFO(dev->name, "ACS 5G band scan \n");
+		if ((ret = wl_cfg80211_get_chanspecs_5g(dev, reqbuf, CHANSPEC_BUF_SIZE)) < 0) {
+			AEXT_ERROR(dev->name, "ACS 5g chanspec retreival failed! \n");
+			goto done;
+		}
+	} else if (band == WLC_BAND_2G) {
+		/*
+		 * If channel argument is not provided/ argument 20 is provided,
+		 * Restrict channel to 2GHz, 20MHz BW, No SB
+		 */
+		AEXT_INFO(dev->name, "ACS 2G band scan \n");
+		if ((ret = wl_cfg80211_get_chanspecs_2g(dev, reqbuf, CHANSPEC_BUF_SIZE)) < 0) {
+			AEXT_ERROR(dev->name, "ACS 2g chanspec retreival failed! \n");
+			goto done;
+		}
+	} else {
+		AEXT_ERROR(dev->name, "ACS: No band chosen\n");
+		goto done;
+	}
+
+	buf_size = (band == WLC_BAND_AUTO) ? sizeof(int) : CHANSPEC_BUF_SIZE;
+	ret = wldev_ioctl_set(dev, WLC_START_CHANNEL_SEL, (void *)reqbuf,
+		buf_size);
+	if (ret < 0) {
+		AEXT_ERROR(dev->name, "can't start auto channel scan, err = %d\n", ret);
+		channel = 0;
+		goto done;
+	}
+
+	/* Wait for auto channel selection, max 3000 ms */
+	if ((band == WLC_BAND_2G) || (band == WLC_BAND_5G)) {
+		OSL_SLEEP(500);
+	} else {
+		/*
+		 * Full channel scan at the minimum takes 1.2secs
+		 * even with parallel scan. max wait time: 3500ms
+		 */
+		OSL_SLEEP(1000);
+	}
+
+	retry = APCS_MAX_RETRY;
+	while (retry--) {
+		ret = wldev_ioctl_get(dev, WLC_GET_CHANNEL_SEL, &chosen,
+			sizeof(chosen));
+		if (ret < 0) {
+			chosen = 0;
+		} else {
+			chosen = dtoh32(chosen);
+		}
+
+		if (chosen) {
+			int chosen_band;
+			int apcs_band;
+#ifdef D11AC_IOTYPES
+			if (wl_cfg80211_get_ioctl_version() == 1) {
+				channel = LCHSPEC_CHANNEL((chanspec_t)chosen);
+			} else {
+				channel = CHSPEC_CHANNEL((chanspec_t)chosen);
+			}
+#else
+			channel = CHSPEC_CHANNEL((chanspec_t)chosen);
+#endif /* D11AC_IOTYPES */
+			apcs_band = (band == WLC_BAND_AUTO) ? WLC_BAND_2G : band;
+			chosen_band = (channel <= CH_MAX_2G_CHANNEL) ? WLC_BAND_2G : WLC_BAND_5G;
+			if (apcs_band == chosen_band) {
+				WL_MSG(dev->name, "selected channel = %d\n", channel);
+				break;
+			}
+		}
+		AEXT_INFO(dev->name, "%d tried, ret = %d, chosen = 0x%x\n",
+			(APCS_MAX_RETRY - retry), ret, chosen);
+		OSL_SLEEP(250);
+	}
+
+done:
+	if (spect > 0) {
+		if ((ret = wl_cfg80211_set_spect(dev, spect) < 0)) {
+			AEXT_ERROR(dev->name, "ACS: error while setting spect\n");
+		}
+	}
+
+	if (reqbuf) {
+		kfree(reqbuf);
+	}
+
+	return channel;
+}
+
+#ifdef WL_ESCAN
+int
+wl_ext_drv_apcs(struct net_device *dev, uint32 band)
+{
+	int ret = 0, channel = 0;
+	struct dhd_pub *dhd = dhd_get_pub(dev);
+	struct wl_escan_info *escan = NULL;
+	int retry = 0, retry_max, retry_interval = 250, up = 1;
+#ifdef WL_CFG80211
+	struct bcm_cfg80211 *cfg = wl_get_cfg(dev);
+#endif /* WL_CFG80211 */
+
+	escan = dhd->escan;
+	if (dhd) {
+		retry_max = WL_ESCAN_TIMER_INTERVAL_MS/retry_interval;
+		ret = wldev_ioctl_get(dev, WLC_GET_UP, &up, sizeof(s32));
+		if (ret < 0 || up == 0) {
+			ret = wldev_ioctl_set(dev, WLC_UP, &up, sizeof(s32));
+		}
+		retry = retry_max;
+		while (retry--) {
+			if (escan->escan_state == ESCAN_STATE_SCANING
+#ifdef WL_CFG80211
+				|| wl_get_drv_status_all(cfg, SCANNING)
 #endif
+			)
+			{
+				AEXT_INFO(dev->name, "Scanning %d tried, ret = %d\n",
+					(retry_max - retry), ret);
+			} else {
+				escan->autochannel = 1;
+				ret = wl_escan_set_scan(dev, dhd, NULL, 0, TRUE);
+				if (!ret)
+					break;
+			}
+			OSL_SLEEP(retry_interval);
+		}
+		if ((retry == 0) || (ret < 0))
+			goto done;
+		retry = retry_max;
+		while (retry--) {
+			if (escan->escan_state == ESCAN_STATE_IDLE) {
+				if (band == WLC_BAND_5G)
+					channel = escan->best_5g_ch;
+				else
+					channel = escan->best_2g_ch;
+				WL_MSG(dev->name, "selected channel = %d\n", channel);
+				goto done;
+			}
+			AEXT_INFO(dev->name, "escan_state=%d, %d tried, ret = %d\n",
+				escan->escan_state, (retry_max - retry), ret);
+			OSL_SLEEP(retry_interval);
+		}
+		if ((retry == 0) || (ret < 0))
+			goto done;
+	}
+
+done:
+	if (escan)
+		escan->autochannel = 0;
+
+	return channel;
+}
+#endif /* WL_ESCAN */
+
+int
+wl_ext_autochannel(struct net_device *dev, uint acs, uint32 band)
+{
+	int ret = 0, channel = 0;
+	uint16 chan_2g, chan_5g;
+
+	AEXT_INFO(dev->name, "acs=0x%x, band=%d \n", acs, band);
+
+	if (acs & ACS_FW_BIT) {
+		ret = wldev_ioctl_get(dev, WLC_GET_CHANNEL_SEL, &channel, sizeof(channel));
+		channel = 0;
+		if (ret != BCME_UNSUPPORTED)
+			channel = wl_ext_fw_apcs(dev, band);
+		if (channel)
+			return channel;
+	}
+
+#ifdef WL_ESCAN
+	if (acs & ACS_DRV_BIT)
+		channel = wl_ext_drv_apcs(dev, band);
+#endif /* WL_ESCAN */
+
+	if (channel == 0) {
+		wl_ext_get_default_chan(dev, &chan_2g, &chan_5g, TRUE);
+		if (band == WLC_BAND_5G) {
+			channel = chan_5g;
+		} else {
+			channel = chan_2g;
+		}
+		AEXT_ERROR(dev->name, "ACS failed. Fall back to default channel (%d) \n", channel);
+	}
+
+	return channel;
+}
 
 #if defined(RSSIAVG)
 void
@@ -5103,7 +6313,7 @@
 	}
 	return (int16)rssi;
 }
-#endif
+#endif /* RSSIAVG */
 
 #if defined(RSSIOFFSET)
 int
@@ -5111,7 +6321,7 @@
 {
 #if defined(RSSIOFFSET_NEW)
 	int j;
-#endif
+#endif /* RSSIOFFSET_NEW */
 
 	if (!g_wifi_on)
 		return rssi;
@@ -5124,10 +6334,10 @@
 	rssi += j;
 #else
 	rssi += RSSI_OFFSET;
-#endif
+#endif /* RSSIOFFSET_NEW */
 	return MIN(rssi, RSSI_MAXVAL);
 }
-#endif
+#endif /* RSSIOFFSET */
 
 #if defined(BSSCACHE)
 void
@@ -5246,7 +6456,7 @@
 void dump_bss_cache(
 #if defined(RSSIAVG)
 	wl_rssi_cache_ctrl_t *rssi_cache_ctrl,
-#endif
+#endif /* RSSIAVG */
 	wl_bss_cache_t *node)
 {
 	int k = 0;
@@ -5257,7 +6467,7 @@
 		rssi = wl_get_avg_rssi(rssi_cache_ctrl, &node->results.bss_info->BSSID);
 #else
 		rssi = dtoh16(node->results.bss_info->RSSI);
-#endif
+#endif /* RSSIAVG */
 		AEXT_TRACE("wlan", "dump %d with cached BSSID %pM, RSSI=%3d, SSID \"%s\"\n",
 			k, &node->results.bss_info->BSSID, rssi, node->results.bss_info->SSID);
 		k++;
@@ -5269,7 +6479,7 @@
 wl_update_bss_cache(wl_bss_cache_ctrl_t *bss_cache_ctrl,
 #if defined(RSSIAVG)
 	wl_rssi_cache_ctrl_t *rssi_cache_ctrl,
-#endif
+#endif /* RSSIAVG */
 	wl_scan_results_t *ss_list)
 {
 	wl_bss_cache_t *node, *prev, *leaf, **bss_head;
@@ -5277,7 +6487,7 @@
 	int i, k=0;
 #if defined(SORT_BSS_BY_RSSI)
 	int16 rssi, rssi_node;
-#endif
+#endif /* SORT_BSS_BY_RSSI */
 	struct osl_timespec now, timeout;
 
 	if (!ss_list->count)
@@ -5349,14 +6559,14 @@
 			rssi = wl_get_avg_rssi(rssi_cache_ctrl, &leaf->results.bss_info->BSSID);
 #else
 			rssi = dtoh16(leaf->results.bss_info->RSSI);
-#endif
+#endif /* RSSIAVG */
 			for (;node;) {
 #if defined(RSSIAVG)
 				rssi_node = wl_get_avg_rssi(rssi_cache_ctrl,
 					&node->results.bss_info->BSSID);
 #else
 				rssi_node = dtoh16(node->results.bss_info->RSSI);
-#endif
+#endif /* RSSIAVG */
 				if (rssi > rssi_node) {
 					leaf->next = node;
 					if (node == *bss_head)
@@ -5373,13 +6583,13 @@
 #else
 			leaf->next = *bss_head;
 			*bss_head = leaf;
-#endif
+#endif /* SORT_BSS_BY_RSSI */
 		}
 	}
 	dump_bss_cache(
 #if defined(RSSIAVG)
 		rssi_cache_ctrl,
-#endif
+#endif /* RSSIAVG */
 		*bss_head);
 }
 
@@ -5389,6 +6599,6 @@
 	AEXT_TRACE("wlan", "Enter\n");
 	wl_free_bss_cache(bss_cache_ctrl);
 }
-#endif
+#endif /* BSSCACHE */
 
 
diff -urN a/drivers/net/wireless/bcmdhd/wl_android.h a/drivers/net/wireless/bcmdhd/wl_android.h
--- a/drivers/net/wireless/bcmdhd/wl_android.h	2020-01-13 17:57:02.385432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_android.h	2020-01-10 12:58:02.000000000 +0300
@@ -97,12 +97,17 @@
 int wl_ext_iapsta_attach_netdev(struct net_device *net, int ifidx, uint8 bssidx);
 int wl_ext_iapsta_attach_name(struct net_device *net, int ifidx);
 int wl_ext_iapsta_dettach_netdev(struct net_device *net, int ifidx);
-u32 wl_ext_iapsta_update_channel(dhd_pub_t *dhd, struct net_device *dev, u32 channel);
+int wl_ext_iapsta_update_net_device(struct net_device *net, int ifidx);
 int wl_ext_iapsta_alive_preinit(struct net_device *dev);
 int wl_ext_iapsta_alive_postinit(struct net_device *dev);
 int wl_ext_iapsta_attach(dhd_pub_t *pub);
 void wl_ext_iapsta_dettach(dhd_pub_t *pub);
-bool wl_ext_check_mesh_creating(struct net_device *net);
+#ifdef WL_CFG80211
+u32 wl_ext_iapsta_update_channel(dhd_pub_t *dhd, struct net_device *dev, u32 channel);
+void wl_ext_iapsta_update_iftype(struct net_device *net, int ifidx, int wl_iftype);
+void wl_ext_iapsta_ifadding(struct net_device *net, int ifidx);
+bool wl_ext_iapsta_mesh_creating(struct net_device *net);
+#endif
 extern int op_mode;
 #endif
 typedef struct bcol_gtk_para {
@@ -111,6 +116,8 @@
 	char ptk[64];
 	char replay[8];
 } bcol_gtk_para_t;
+#define ACS_FW_BIT		(1<<0)
+#define ACS_DRV_BIT		(1<<1)
 #if defined(WL_EXT_IAPSTA) || defined(USE_IW)
 typedef enum WL_EVENT_PRIO {
 	PRIO_EVENT_IAPSTA,
@@ -127,9 +134,15 @@
 	uint32 event, void *cb_func);
 void wl_ext_event_send(void *params, const wl_event_msg_t * e, void *data);
 #endif
+int wl_ext_autochannel(struct net_device *dev, uint acs, uint32 band);
 int wl_android_ext_priv_cmd(struct net_device *net, char *command, int total_len,
 	int *bytes_written);
 void wl_ext_get_sec(struct net_device *dev, int ifmode, char *sec, int total_len);
+bool wl_ext_check_scan(struct net_device *dev, dhd_pub_t *dhdp);
+#if defined(WL_CFG80211) || defined(WL_ESCAN)
+void wl_ext_user_sync(struct dhd_pub *dhd, int ifidx, bool lock);
+bool wl_ext_event_complete(struct dhd_pub *dhd, int ifidx);
+#endif
 enum wl_ext_status {
 	WL_EXT_STATUS_DISCONNECTING = 0,
 	WL_EXT_STATUS_DISCONNECTED,
@@ -172,6 +185,8 @@
  * restrict max number to 10 as maximum cmd string size is 255
  */
 #define MAX_NUM_MAC_FILT        10
+#define	WL_GET_BAND(ch)	(((uint)(ch) <= CH_MAX_2G_CHANNEL) ?	\
+	WLC_BAND_2G : WLC_BAND_5G)
 
 int wl_android_set_ap_mac_list(struct net_device *dev, int macmode, struct maclist *maclist);
 
diff -urN a/drivers/net/wireless/bcmdhd/wl_cfg80211.c a/drivers/net/wireless/bcmdhd/wl_cfg80211.c
--- a/drivers/net/wireless/bcmdhd/wl_cfg80211.c	2020-01-13 17:57:02.397432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_cfg80211.c	2020-01-10 12:55:28.000000000 +0300
@@ -94,6 +94,9 @@
 #ifdef RTT_SUPPORT
 #include <dhd_rtt.h>
 #endif /* RTT_SUPPORT */
+
+#define BRCM_SAE_VENDOR_EVENT_BUF_LEN 500
+
 #ifdef WL11U
 #endif /* WL11U */
 
@@ -1084,6 +1087,9 @@
 #ifdef BCMWAPI_WPI
 	WLAN_CIPHER_SUITE_SMS4,
 #endif
+#if defined(WLAN_CIPHER_SUITE_PMK)
+	WLAN_CIPHER_SUITE_PMK,
+#endif
 };
 
 #ifdef WL_SUPPORT_ACS
@@ -4153,7 +4159,7 @@
 	}
 
 #ifdef WL_EXT_IAPSTA
-	if (wl_ext_check_mesh_creating(ndev)) {
+	if (wl_ext_iapsta_mesh_creating(ndev)) {
 		WL_MSG(ndev->name, "change iface_type to NL80211_IFTYPE_MESH_POINT\n");
 		iface_type = NL80211_IFTYPE_MESH_POINT;
 	}
@@ -4219,6 +4225,9 @@
 		memcpy(new_ndev->dev_addr, addr, ETH_ALEN);
 		WL_ERR(("Applying updated mac address to firmware\n"));
 	}
+#ifdef WL_EXT_IAPSTA
+	wl_ext_iapsta_ifadding(new_ndev, event->ifidx);
+#endif /* WL_EXT_IAPSTA */
 
 	if (wl_cfg80211_register_if(cfg, event->ifidx, new_ndev, rtnl_lock_reqd) != BCME_OK) {
 		WL_ERR(("IFACE register failed \n"));
@@ -4242,6 +4251,9 @@
 	if (mode == WL_MODE_AP) {
 		wl_set_drv_status(cfg, AP_CREATING, new_ndev);
 	}
+#ifdef WL_EXT_IAPSTA
+	wl_ext_iapsta_update_iftype(new_ndev, event->ifidx, role);
+#endif
 
 	WL_INFORM(("Host Network Interface (%s) for Secondary I/F created."
 		" cfg_iftype:%d wl_role:%d\n", new_ndev->name, iface_type, event->role));
@@ -5001,6 +5013,12 @@
 		val = WL_AUTH_OPEN_SHARED;
 		WL_DBG(("automatic\n"));
 		break;
+#ifdef WL_SAE
+	case NL80211_AUTHTYPE_SAE:
+		val = WL_AUTH_OPEN_SHARED;
+		WL_DBG(("sae\n"));
+		break;
+#endif /* WL_SAE */
 	default:
 		val = 2;
 		WL_ERR(("invalid auth type (%d)\n", sme->auth_type));
@@ -5296,9 +5314,24 @@
 				break;
 #endif /* CUSTOMER_HW6 */
 #endif /* MFP */
+#if defined(WLFBT) && defined(WLAN_AKM_SUITE_FT_8021X)
+			case WLAN_AKM_SUITE_FT_8021X:
+				val = WPA2_AUTH_UNSPECIFIED | WPA2_AUTH_FT;
+				break;
+#endif
+#if defined(WLFBT) && defined(WLAN_AKM_SUITE_FT_PSK)
+			case WLAN_AKM_SUITE_FT_PSK:
+				val = WPA2_AUTH_PSK | WPA2_AUTH_FT;
+				break;
+#endif
 			case WLAN_AKM_SUITE_PSK:
 				val = WPA2_AUTH_PSK;
 				break;
+#ifdef WL_SAE
+			case WLAN_AKM_SUITE_SAE:
+				val = WPA3_AUTH_SAE_PSK;
+				break;
+#endif /* WL_SAE */
 			default:
 				WL_ERR(("invalid akm suite (0x%x)\n",
 					sme->crypto.akm_suites[0]));
@@ -6399,6 +6432,36 @@
 		val = AES_ENABLED;
 		WL_DBG(("WLAN_CIPHER_SUITE_CCMP\n"));
 		break;
+#if defined(WLFBT) && defined(WLAN_CIPHER_SUITE_PMK)
+	case WLAN_CIPHER_SUITE_PMK: {
+		int j;
+		wsec_pmk_t pmk;
+		char keystring[WSEC_MAX_PSK_LEN + 1];
+		char* charptr = keystring;
+		uint len;
+		struct wl_security *sec;
+		sec = wl_read_prof(cfg, dev, WL_PROF_SEC);
+		if (sec->wpa_auth == WLAN_AKM_SUITE_8021X) {
+			err = wldev_iovar_setbuf(dev, "okc_info_pmk", (void *)params->key,
+				WSEC_MAX_PSK_LEN / 2, keystring, sizeof(keystring), NULL);
+			if (err) {
+				/* could fail in case that 'okc' is not supported */
+				WL_INFORM(("Setting 'okc_info_pmk' failed, err=%d\n", err));
+			}
+		}
+		/* copy the raw hex key to the appropriate format */
+		for (j = 0; j < (WSEC_MAX_PSK_LEN / 2); j++) {
+			charptr += snprintf(charptr, sizeof(keystring), "%02x", params->key[j]);
+		}
+		len = strlen(keystring);
+		pmk.key_len = htod16(len);
+		bcopy(keystring, pmk.key, len);
+		pmk.flags = htod16(WSEC_PASSPHRASE);
+		err = wldev_ioctl(dev, WLC_SET_WSEC_PMK, &pmk, sizeof(pmk), true);
+		if (err)
+			return err;
+	} break;
+#endif /* WLFBT && WLAN_CIPHER_SUITE_PMK */
 #ifdef BCMWAPI_WPI
 	case WLAN_CIPHER_SUITE_SMS4:
 		key.algo = CRYPTO_ALGO_SMS4;
@@ -6601,9 +6664,7 @@
 	s32 rate;
 	s32 err = 0;
 	sta_info_t *sta;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
 	s8 eabuf[ETHER_ADDR_STR_LEN];
-#endif
 	dhd_pub_t *dhd =  (dhd_pub_t *)(cfg->pub);
 	bool fw_assoc_state = FALSE;
 	u32 dhd_assoc_state = 0;
@@ -6630,10 +6691,10 @@
 			sinfo->filled |= STA_INFO_BIT(INFO_CONNECTED_TIME);
 			sinfo->connected_time = sta->in;
 		}
-		WL_INFORM(("STA %s : idle time : %d sec, connected time :%d ms\n",
-			bcm_ether_ntoa((const struct ether_addr *)mac, eabuf), sinfo->inactive_time,
-			sta->idle * 1000));
 #endif
+		WL_INFORM(("STA %s, flags 0x%x, idle time %ds, connected time %ds\n",
+			bcm_ether_ntoa((const struct ether_addr *)mac, eabuf),
+			sta->flags, sta->idle, sta->in));
 	} else if (wl_get_mode_by_netdev(cfg, dev) == WL_MODE_BSS ||
 		wl_get_mode_by_netdev(cfg, dev) == WL_MODE_IBSS) {
 		get_pktcnt_t pktcnt;
@@ -7246,7 +7307,7 @@
 
 #ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
 	if (wl_get_drv_status(cfg, SCANNING, ndev)) {
-		struct timer_list *_timer;
+		timer_list_compat_t *_timer;
 		WL_DBG(("scan is running. go to fake listen state\n"));
 
 		if (duration > LONG_LISTEN_TIME) {
@@ -8251,7 +8312,10 @@
 	dev = ndev_to_wlc_ndev(dev, cfg);
 	_chan = ieee80211_frequency_to_channel(chan->center_freq);
 #ifdef WL_EXT_IAPSTA
-	_chan = wl_ext_iapsta_update_channel(dhd, dev, _chan);
+	if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP) {
+		wl_ext_iapsta_update_iftype(dev, dhd_net2idx(dhd->info, dev), WLC_E_IF_ROLE_AP);
+		_chan = wl_ext_iapsta_update_channel(dhd, dev, _chan);
+	}
 #endif
 	WL_MSG(dev->name, "netdev_ifidx(%d), chan_type(%d) target channel(%d) \n",
 		dev->ifindex, channel_type, _chan);
@@ -8549,6 +8613,12 @@
 			wpa_auth |= WPA2_AUTH_1X_SHA256;
 			break;
 #endif /* MFP */
+#ifdef WL_SAE
+		case RSN_AKM_SAE_PSK:
+		case RSN_AKM_SAE_FBT:
+			wpa_auth |= WPA3_AUTH_SAE_PSK;
+			break;
+#endif /* WL_SAE */
 		default:
 			WL_ERR(("No Key Mgmt Info\n"));
 		}
@@ -9330,9 +9400,9 @@
 	/* Do abort scan before creating GO */
 	wl_cfg80211_scan_abort(cfg);
 
-	wl_ext_get_sec(dev, 0, sec, sizeof(sec));
-	WL_MSG(dev->name, "Creating AP/GO with sec=%s\n", sec);
 	if (dev_role == NL80211_IFTYPE_P2P_GO) {
+		wl_ext_get_sec(dev, 0, sec, sizeof(sec));
+		WL_MSG(dev->name, "Creating GO with sec=%s\n", sec);
 		is_bssup = wl_cfg80211_bss_isup(dev, bssidx);
 		if (!is_bssup && (ies->wpa2_ie != NULL)) {
 
@@ -9409,8 +9479,9 @@
 			WL_ERR(("Could not get wsec %d\n", err));
 			goto exit;
 		}
-		if (dhdp->conf->chip == BCM43430_CHIP_ID && bssidx > 0 && wsec >= 2) {
-			wsec |= 0x8; // terence 20180628: fix me, this is a workaround
+		if (dhdp->conf->chip == BCM43430_CHIP_ID && bssidx > 0 &&
+				(wsec & (TKIP_ENABLED|AES_ENABLED))) {
+			wsec |= WSEC_SWFLAG; // terence 20180628: fix me, this is a workaround
 			err = wldev_iovar_setint_bsscfg(dev, "wsec", wsec, bssidx);
 			if (err < 0) {
 				WL_ERR(("wsec error %d\n", err));
@@ -9458,6 +9529,8 @@
 			join_params.ssid.SSID_len);
 		join_params.ssid.SSID_len = htod32(join_params.ssid.SSID_len);
 
+		wl_ext_get_sec(dev, 0, sec, sizeof(sec));
+		WL_MSG(dev->name, "Creating AP with sec=%s\n", sec);
 		/* create softap */
 		if ((err = wldev_ioctl_set(dev, WLC_SET_SSID, &join_params,
 			join_params_size)) != 0) {
@@ -9777,10 +9850,13 @@
 	} else {
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)) */
 #endif /* CUSTOM_BLOCK_DEAUTH_AT_EAP_FAILURE */
+	scb_val.val = DOT11_RC_DEAUTH_LEAVING;
+	WL_MSG(dev->name, "Disconnect STA %s scb_val.val %d\n",
+		bcm_ether_ntoa((const struct ether_addr *)mac_addr, eabuf),
+		scb_val.val);
 #ifndef BCMDBUS
 	dhd_wait_pend8021x(dev);
 #endif /* !BCMDBUS */
-	scb_val.val = DOT11_RC_DEAUTH_LEAVING;
 	err = wldev_ioctl_set(dev, WLC_SCB_DEAUTHENTICATE_FOR_REASON, &scb_val,
 		sizeof(scb_val_t));
 	if (err < 0)
@@ -9790,9 +9866,6 @@
 	}
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)) */
 #endif /* CUSTOM_BLOCK_DEAUTH_AT_EAP_FAILURE */
-	WL_MSG(dev->name, "Disconnect STA : %s scb_val.val %d\n",
-		bcm_ether_ntoa((const struct ether_addr *)mac_addr, eabuf),
-		scb_val.val);
 
 	if (num_associated > 0 && ETHER_ISBCAST(mac_addr))
 		wl_delay(400);
@@ -9933,6 +10006,9 @@
 		if (err) {
 			WL_ERR(("%s: Disabling NDO Failed %d\n", __FUNCTION__, err));
 		}
+#ifdef WL_EXT_IAPSTA
+		wl_ext_iapsta_update_iftype(dev, dhd_net2idx(dhd->info, dev), WLC_E_IF_ROLE_AP);
+#endif /* WL_EXT_IAPSTA */
 #ifdef PKT_FILTER_SUPPORT
 		/* Disable packet filter */
 		if (dhd->early_suspended) {
@@ -11254,7 +11330,11 @@
 
 	WL_DBG(("Registering custom regulatory)\n"));
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
-	wdev->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+	wdev->wiphy->regulatory_flags |=
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0))
+		REGULATORY_IGNORE_STALE_KICKOFF |
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0) */
+		REGULATORY_CUSTOM_REG;
 #else
 	wdev->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
 #endif
@@ -11280,6 +11360,11 @@
 	wdev->wiphy->flags &= ~WIPHY_FLAG_ENFORCE_COMBINATIONS;
 #endif
 
+#ifdef WL_SAE
+	WL_ERR(("SAE support\n"));
+	wdev->wiphy->features |= NL80211_FEATURE_SAE;
+#endif /* WL_SAE */
+
 	return err;
 }
 
@@ -11732,6 +11817,129 @@
 	return false;
 }
 
+#ifdef WL_SAE
+static s32
+wl_cfg80211_event_sae_key(struct bcm_cfg80211 *cfg, struct net_device *ndev,
+	wl_sae_key_info_t *sae_key)
+{
+	struct sk_buff *skb;
+	gfp_t kflags;
+	struct wiphy *wiphy = bcmcfg_to_wiphy(cfg);
+	int err = BCME_OK;
+
+	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+#if (defined(CONFIG_ARCH_MSM) && defined(SUPPORT_WDEV_CFG80211_VENDOR_EVENT_ALLOC)) || \
+	LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+	skb = cfg80211_vendor_event_alloc(wiphy, ndev_to_wdev(ndev), BRCM_SAE_VENDOR_EVENT_BUF_LEN,
+		BRCM_VENDOR_EVENT_SAE_KEY, kflags);
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy, BRCM_SAE_VENDOR_EVENT_BUF_LEN,
+		BRCM_VENDOR_EVENT_SAE_KEY, kflags);
+#endif /* (defined(CONFIG_ARCH_MSM) && defined(SUPPORT_WDEV_CFG80211_VENDOR_EVENT_ALLOC)) || */
+		/* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0) */
+	if (!skb) {
+		WL_ERR(("skb alloc failed"));
+		err = BCME_NOMEM;
+		goto done;
+	}
+
+	WL_INFORM(("Received Sae Key event for "MACDBG" key length %x %x",
+		MAC2STRDBG(sae_key->peer_mac), sae_key->pmk_len, sae_key->pmkid_len));
+	nla_put(skb, BRCM_SAE_KEY_ATTR_PEER_MAC, ETHER_ADDR_LEN, sae_key->peer_mac);
+	nla_put(skb, BRCM_SAE_KEY_ATTR_PMK, sae_key->pmk_len, sae_key->pmk);
+	nla_put(skb, BRCM_SAE_KEY_ATTR_PMKID, sae_key->pmkid_len, sae_key->pmkid);
+	cfg80211_vendor_event(skb, kflags);
+
+done:
+	return err;
+}
+
+static s32
+wl_bss_handle_sae_auth(struct bcm_cfg80211 *cfg, struct net_device *ndev,
+	const wl_event_msg_t *event, void *data)
+{
+	int err = BCME_OK;
+	uint status = ntoh32(event->status);
+	wl_auth_event_t *auth_data;
+	wl_sae_key_info_t sae_key;
+	uint16 tlv_buf_len;
+
+	if (status == WLC_E_STATUS_SUCCESS) {
+		auth_data = (wl_auth_event_t *)data;
+		if (auth_data->version != WL_AUTH_EVENT_DATA_V1) {
+			WL_ERR(("unknown auth event data version %x\n",
+				auth_data->version));
+			err = BCME_VERSION;
+			goto done;
+		}
+
+		tlv_buf_len = auth_data->length - WL_AUTH_EVENT_FIXED_LEN_V1;
+
+		/* check if PMK info present */
+		sae_key.pmk = bcm_get_data_from_xtlv_buf(auth_data->xtlvs, tlv_buf_len,
+			WL_AUTH_PMK_TLV_ID, &(sae_key.pmk_len), BCM_XTLV_OPTION_ALIGN32);
+		if (!sae_key.pmk || !sae_key.pmk_len) {
+			WL_ERR(("Mandatory PMK info not present"));
+			err = BCME_NOTFOUND;
+			goto done;
+		}
+		/* check if PMKID info present */
+		sae_key.pmkid = bcm_get_data_from_xtlv_buf(auth_data->xtlvs, tlv_buf_len,
+			WL_AUTH_PMKID_TLV_ID, &(sae_key.pmkid_len), BCM_XTLV_OPTION_ALIGN32);
+		if (!sae_key.pmkid || !sae_key.pmkid_len) {
+			WL_ERR(("Mandatory PMKID info not present\n"));
+			err = BCME_NOTFOUND;
+			goto done;
+		}
+		memcpy(sae_key.peer_mac, event->addr.octet, ETHER_ADDR_LEN);
+		err = wl_cfg80211_event_sae_key(cfg, ndev, &sae_key);
+		if (err) {
+			WL_ERR(("Failed to event sae key info\n"));
+		}
+	} else {
+		WL_ERR(("sae auth status failure:%d\n", status));
+	}
+done:
+	return err;
+}
+#endif /* WL_SAE */
+
+static s32
+wl_get_auth_assoc_status(struct bcm_cfg80211 *cfg, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	u32 reason = ntoh32(e->reason);
+	u32 event = ntoh32(e->event_type);
+	uint auth_type = ntoh32(e->auth_type);
+	struct wl_security *sec = wl_read_prof(cfg, ndev, WL_PROF_SEC);
+
+	WL_DBG(("event type : %d, reason : %d, auth_type : %d\n", event, reason, auth_type));
+
+#if defined(DHD_ENABLE_BIGDATA_LOGGING)
+	memcpy(&cfg->event_auth_assoc, e, sizeof(wl_event_msg_t));
+	WL_ERR(("event=%d status %d reason %d \n",
+		ntoh32(cfg->event_auth_assoc.event_type),
+		ntoh32(cfg->event_auth_assoc.status),
+		ntoh32(cfg->event_auth_assoc.reason)));
+#endif /* DHD_ENABLE_BIGDATA_LOGGING */
+	if (sec) {
+		switch (event) {
+		case WLC_E_ASSOC:
+		case WLC_E_AUTH:
+			sec->auth_assoc_res_status = reason;
+#ifdef WL_SAE
+			if (event == WLC_E_AUTH && auth_type == DOT11_SAE) {
+				wl_bss_handle_sae_auth(cfg, ndev, e, data);
+			}
+#endif /* WL_SAE */
+		default:
+			break;
+		}
+	} else
+		WL_ERR(("sec is NULL\n"));
+	return 0;
+}
+
 /* The mainline kernel >= 3.2.0 has support for indicating new/del station
  * to AP/P2P GO via events. If this change is backported to kernel for which
  * this driver is being built, then define WL_CFG80211_STA_EVENT. You
@@ -11766,6 +11974,10 @@
 #endif 
 
 	WL_DBG(("event %d status %d reason %d\n", event, ntoh32(e->status), reason));
+#ifdef WL_SAE
+	if (event == WLC_E_AUTH_IND)
+		wl_get_auth_assoc_status(cfg, ndev, e, data);
+#endif /* WL_SAE */
 	/* if link down, bsscfg is disabled. */
 	if (event == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS &&
 		wl_get_p2p_status(cfg, IF_DELETING) && (ndev != bcmcfg_to_prmry_ndev(cfg))) {
@@ -11790,7 +12002,7 @@
 
 	if (event == WLC_E_DISASSOC_IND || event == WLC_E_DEAUTH_IND || event == WLC_E_DEAUTH) {
 		WL_MSG(ndev->name, "event %s(%d) status %d reason %d\n",
-		bcmevent_get_name(event), event, ntoh32(e->status), reason);
+			bcmevent_get_name(event), event, ntoh32(e->status), reason);
 	}
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !defined(WL_CFG80211_STA_EVENT)
@@ -11992,35 +12204,6 @@
 #endif /* DHD_ENABLE_BIGDATA_LOGGING */
 
 static s32
-wl_get_auth_assoc_status(struct bcm_cfg80211 *cfg, struct net_device *ndev,
-	const wl_event_msg_t *e)
-{
-	u32 reason = ntoh32(e->reason);
-	u32 event = ntoh32(e->event_type);
-	struct wl_security *sec = wl_read_prof(cfg, ndev, WL_PROF_SEC);
-	WL_DBG(("event type : %d, reason : %d\n", event, reason));
-
-#if defined(DHD_ENABLE_BIGDATA_LOGGING)
-	memcpy(&cfg->event_auth_assoc, e, sizeof(wl_event_msg_t));
-	WL_ERR(("event=%d status %d reason %d \n",
-		ntoh32(cfg->event_auth_assoc.event_type),
-		ntoh32(cfg->event_auth_assoc.status),
-		ntoh32(cfg->event_auth_assoc.reason)));
-#endif /* DHD_ENABLE_BIGDATA_LOGGING */
-	if (sec) {
-		switch (event) {
-		case WLC_E_ASSOC:
-		case WLC_E_AUTH:
-				sec->auth_assoc_res_status = reason;
-		default:
-			break;
-		}
-	} else
-		WL_ERR(("sec is NULL\n"));
-	return 0;
-}
-
-static s32
 wl_notify_connect_status_ibss(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 	const wl_event_msg_t *e, void *data)
 {
@@ -12367,6 +12550,185 @@
 
 #endif /* DHD_ENABLE_BIGDATA_LOGGING */
 
+#ifdef WLMESH_CFG80211
+static s32
+wl_notify_connect_status_mesh(struct bcm_cfg80211 *cfg, struct net_device *ndev,
+	const wl_event_msg_t *e, void *data)
+{
+	s32 err = 0;
+	u32 event = ntoh32(e->event_type);
+	u32 reason = ntoh32(e->reason);
+	u32 len = ntoh32(e->datalen);
+	u32 status = ntoh32(e->status);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !defined(WL_CFG80211_STA_EVENT)
+	bool isfree = false;
+	u8 *mgmt_frame;
+	u8 bsscfgidx = e->bsscfgidx;
+	s32 freq;
+	s32 channel;
+	u8 *body = NULL;
+	u16 fc = 0;
+
+	struct ieee80211_supported_band *band;
+	struct ether_addr da;
+	struct ether_addr bssid;
+	struct wiphy *wiphy = bcmcfg_to_wiphy(cfg);
+	channel_info_t ci;
+#else
+	struct station_info sinfo;
+#endif 
+
+	WL_DBG(("event %d status %d reason %d\n", event, ntoh32(e->status), reason));
+	/* if link down, bsscfg is disabled. */
+	if (event == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS &&
+			(ndev != bcmcfg_to_prmry_ndev(cfg))) {
+		WL_MSG(ndev->name, "Mesh mode link down !! \n");
+		return 0;
+	}
+
+	if ((event == WLC_E_LINK) && (status == WLC_E_STATUS_SUCCESS) &&
+			(reason == WLC_E_REASON_INITIAL_ASSOC)) {
+		/* AP/GO brought up successfull in firmware */
+		WL_MSG(ndev->name, "Mesh Link up\n");
+		return 0;
+	}
+
+	if (event == WLC_E_DISASSOC_IND || event == WLC_E_DEAUTH_IND || event == WLC_E_DEAUTH) {
+		WL_MSG(ndev->name, "event %s(%d) status %d reason %d\n",
+		bcmevent_get_name(event), event, ntoh32(e->status), reason);
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !defined(WL_CFG80211_STA_EVENT)
+	WL_DBG(("Enter \n"));
+	if (!len && (event == WLC_E_DEAUTH)) {
+		len = 2; /* reason code field */
+		data = &reason;
+	}
+	if (len) {
+		body = kzalloc(len, GFP_KERNEL);
+
+		if (body == NULL) {
+			WL_ERR(("Failed to allocate body\n"));
+			return WL_INVALID;
+		}
+	}
+	memset(&bssid, 0, ETHER_ADDR_LEN);
+	WL_DBG(("Enter event %d ndev %p\n", event, ndev));
+	if (wl_get_mode_by_netdev(cfg, ndev) == WL_INVALID) {
+		kfree(body);
+		return WL_INVALID;
+	}
+	if (len)
+		memcpy(body, data, len);
+
+	wldev_iovar_getbuf_bsscfg(ndev, "cur_etheraddr",
+		NULL, 0, cfg->ioctl_buf, WLC_IOCTL_SMLEN, bsscfgidx, &cfg->ioctl_buf_sync);
+	memcpy(da.octet, cfg->ioctl_buf, ETHER_ADDR_LEN);
+	memset(&bssid, 0, sizeof(bssid));
+	err = wldev_ioctl_get(ndev, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN);
+	switch (event) {
+		case WLC_E_ASSOC_IND:
+			fc = FC_ASSOC_REQ;
+			break;
+		case WLC_E_REASSOC_IND:
+			fc = FC_REASSOC_REQ;
+			break;
+		case WLC_E_DISASSOC_IND:
+			fc = FC_DISASSOC;
+			break;
+		case WLC_E_DEAUTH_IND:
+			fc = FC_DISASSOC;
+			break;
+		case WLC_E_DEAUTH:
+			fc = FC_DISASSOC;
+			break;
+		default:
+			fc = 0;
+			goto exit;
+	}
+	memset(&ci, 0, sizeof(ci));
+	if ((err = wldev_ioctl_get(ndev, WLC_GET_CHANNEL, &ci, sizeof(ci)))) {
+		kfree(body);
+		return err;
+	}
+
+	channel = dtoh32(ci.hw_channel);
+	if (channel <= CH_MAX_2G_CHANNEL)
+		band = wiphy->bands[IEEE80211_BAND_2GHZ];
+	else
+		band = wiphy->bands[IEEE80211_BAND_5GHZ];
+	if (!band) {
+		WL_ERR(("No valid band\n"));
+		if (body)
+			kfree(body);
+		return -EINVAL;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39)
+	freq = ieee80211_channel_to_frequency(channel);
+	(void)band->band;
+#else
+	freq = ieee80211_channel_to_frequency(channel, band->band);
+#endif
+
+	err = wl_frame_get_mgmt(fc, &da, &e->addr, &bssid,
+		&mgmt_frame, &len, body);
+	if (err < 0)
+		goto exit;
+	isfree = true;
+
+	if ((event == WLC_E_ASSOC_IND && reason == DOT11_SC_SUCCESS) ||
+			(event == WLC_E_DISASSOC_IND) ||
+			((event == WLC_E_DEAUTH_IND) || (event == WLC_E_DEAUTH))) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, 0);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0))
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, 0, GFP_ATOMIC);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)) || \
+		defined(WL_COMPAT_WIRELESS)
+		cfg80211_rx_mgmt(ndev, freq, 0, mgmt_frame, len, GFP_ATOMIC);
+#else
+		cfg80211_rx_mgmt(ndev, freq, mgmt_frame, len, GFP_ATOMIC);
+#endif 
+	}
+
+exit:
+	if (isfree)
+		kfree(mgmt_frame);
+	if (body)
+		kfree(body);
+#else /* LINUX_VERSION < VERSION(3,2,0) && !WL_CFG80211_STA_EVENT && !WL_COMPAT_WIRELESS */
+	memset(&sinfo, 0, sizeof(struct station_info));
+	sinfo.filled = 0;
+	if (((event == WLC_E_ASSOC_IND) || (event == WLC_E_REASSOC_IND)) &&
+		reason == DOT11_SC_SUCCESS) {
+		/* Linux ver >= 4.0 assoc_req_ies_len is used instead of
+		 * STATION_INFO_ASSOC_REQ_IES flag
+		 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0))
+		sinfo.filled = STA_INFO_BIT(INFO_ASSOC_REQ_IES);
+#endif /*  (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)) */
+		if (!data) {
+			WL_ERR(("No IEs present in ASSOC/REASSOC_IND"));
+			return -EINVAL;
+		}
+		sinfo.assoc_req_ies = data;
+		sinfo.assoc_req_ies_len = len;
+		WL_MSG(ndev->name, "connected device "MACDBG"\n", MAC2STRDBG(e->addr.octet));
+		cfg80211_new_sta(ndev, e->addr.octet, &sinfo, GFP_ATOMIC);
+	} else if (event == WLC_E_DISASSOC_IND) {
+		WL_MSG(ndev->name, "disassociated device "MACDBG"\n", MAC2STRDBG(e->addr.octet));
+		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
+	} else if ((event == WLC_E_DEAUTH_IND) ||
+		((event == WLC_E_DEAUTH) && (reason != DOT11_RC_RESERVED))) {
+		WL_MSG(ndev->name, "deauthenticated device "MACDBG"\n", MAC2STRDBG(e->addr.octet));
+		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
+	}
+#endif 
+	return err;
+}
+#endif
+
 static s32
 wl_notify_connect_status(struct bcm_cfg80211 *cfg, bcm_struct_cfgdev *cfgdev,
 	const wl_event_msg_t *e, void *data)
@@ -12389,13 +12751,17 @@
 
 	if (wl_get_mode_by_netdev(cfg, ndev) == WL_MODE_AP) {
 		err = wl_notify_connect_status_ap(cfg, ndev, e, data);
+#ifdef WLMESH_CFG80211
+	} else if (wl_get_mode_by_netdev(cfg, ndev) == WL_MODE_MESH) {
+		err = wl_notify_connect_status_mesh(cfg, ndev, e, data);
+#endif
 	} else if (wl_get_mode_by_netdev(cfg, ndev) == WL_MODE_IBSS) {
 		err = wl_notify_connect_status_ibss(cfg, ndev, e, data);
 	} else if (wl_get_mode_by_netdev(cfg, ndev) == WL_MODE_BSS) {
 		WL_DBG(("event %d status : %d ndev %p\n",
 			ntoh32(e->event_type), ntoh32(e->status), ndev));
 		if (event == WLC_E_ASSOC || event == WLC_E_AUTH) {
-			wl_get_auth_assoc_status(cfg, ndev, e);
+			wl_get_auth_assoc_status(cfg, ndev, e, data);
 			return 0;
 		}
 		DHD_DISABLE_RUNTIME_PM((dhd_pub_t *)cfg->pub);
@@ -13298,6 +13664,11 @@
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
 	struct cfg80211_roam_info roam_info = {};
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)) */
+#ifdef WLFBT
+	uint32 data_len = 0;
+	if (data)
+		data_len = ntoh32(e->datalen);
+#endif /* WLFBT */
 
 #ifdef WLADPS_SEAK_AP_WAR
 	BCM_REFERENCE(dhdp);
@@ -13321,7 +13692,7 @@
 	if ((*channel == cur_channel) &&
 			((memcmp(curbssid, &e->addr, ETHER_ADDR_LEN) == 0) ||
 			(memcmp(&cfg->last_roamed_addr,	&e->addr, ETHER_ADDR_LEN) == 0))) {
-		WL_ERR(("BSS already present, Skipping roamed event to"
+		WL_DBG(("BSS already present, Skipping roamed event to"
 		" upper layer\n"));
 #ifdef DHD_LOSSLESS_ROAMING
 		wl_del_roam_timeout(cfg);
@@ -13345,6 +13716,15 @@
 	freq = ieee80211_channel_to_frequency(*channel, band->band);
 	notify_channel = ieee80211_get_channel(wiphy, freq);
 #endif 
+#ifdef WLFBT
+	/* back up the given FBT key for the further supplicant request,
+	 * currently not checking the FBT is enabled for current BSS in DHD,
+	 * because the supplicant decides to take it or not.
+	 */
+	if (data && (data_len == FBT_KEYLEN)) {
+		memcpy(cfg->fbt_key, data, FBT_KEYLEN);
+	}
+#endif /* WLFBT */
 #ifdef WLADPS_SEAK_AP_WAR
 	if ((dhdp->op_mode & DHD_FLAG_STA_MODE) &&
 			(!dhdp->disabled_adps)) {
@@ -13532,7 +13912,12 @@
 			sec->auth_assoc_res_status = WLAN_STATUS_UNSPECIFIED_FAILURE;
 		}
 		if (completed) {
+			WL_INFORM(("Report connect result - connection succeeded\n"));
 			wl_cfg80211_check_in4way(cfg, ndev, 0, WL_EXT_STATUS_CONNECTED, NULL);
+		} else {
+			WL_MSG(ndev->name, "Report connect result - connection failed\n");
+			wl_cfg80211_check_in4way(cfg, ndev, NO_SCAN_IN4WAY|NO_BTC_IN4WAY|WAIT_DISCONNECTED,
+				WL_EXT_STATUS_DISCONNECTED, NULL);
 		}
 		cfg80211_connect_result(ndev,
 			curbssid,
@@ -13545,13 +13930,6 @@
 			sec->auth_assoc_res_status :
 			WLAN_STATUS_UNSPECIFIED_FAILURE,
 			GFP_KERNEL);
-		if (completed) {
-			WL_INFORM(("Report connect result - connection succeeded\n"));
-		} else {
-			WL_MSG(ndev->name, "Report connect result - connection failed\n");
-			wl_cfg80211_check_in4way(cfg, ndev, NO_SCAN_IN4WAY|NO_BTC_IN4WAY|WAIT_DISCONNECTED,
-				WL_EXT_STATUS_DISCONNECTED, NULL);
-		}
 	}
 #ifdef CONFIG_TCPACK_FASTTX
 	if (wl_get_chan_isvht80(ndev, dhdp))
@@ -14522,7 +14900,9 @@
 #ifdef ENABLE_TEMP_THROTTLING
 	cfg->evt_handler[WLC_E_TEMP_THROTTLE] = wl_check_rx_throttle_status;
 #endif /* ENABLE_TEMP_THROTTLING */
-
+#ifdef WL_SAE
+	cfg->evt_handler[WLC_E_AUTH_IND] = wl_notify_connect_status;
+#endif /* WL_SAE */
 }
 
 #if defined(STATIC_WL_PRIV_STRUCT)
@@ -14698,20 +15078,10 @@
 	}
 }
 
-static void wl_scan_timeout(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	unsigned long data
-#endif
-)
+static void wl_scan_timeout(unsigned long data)
 {
 	wl_event_msg_t msg;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct bcm_cfg80211 *cfg = from_timer(cfg, t, scan_timeout);
-#else
 	struct bcm_cfg80211 *cfg = (struct bcm_cfg80211 *)data;
-#endif
 	struct wireless_dev *wdev = NULL;
 	struct net_device *ndev = NULL;
 	struct wl_scan_results *bss_list;
@@ -14792,19 +15162,9 @@
 
 }
 
-static void wl_roam_timeout(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	unsigned long data
-#endif
-)
+static void wl_roam_timeout(unsigned long data)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct bcm_cfg80211 *cfg = from_timer(cfg, t, roam_timeout);
-#else
 	struct bcm_cfg80211 *cfg = (struct bcm_cfg80211 *)data;
-#endif
 	dhd_pub_t *dhdp = (dhd_pub_t *)(cfg->pub);
 
 	WL_ERR(("roam timer expired\n"));
@@ -15037,6 +15397,7 @@
 	if (p2p_is_on(cfg))
 		wl_clr_p2p_status(cfg, SCANNING);
 	wl_clr_drv_status(cfg, SCANNING, dev);
+	wake_up_interruptible(&dhdp->conf->event_complete);
 	spin_unlock_irqrestore(&cfg->cfgdrv_lock, flags);
 
 out:
@@ -15314,8 +15675,9 @@
 
 	}
 	if (!ndev || (!wl_get_drv_status(cfg, SCANNING, ndev) && !cfg->sched_scan_running)) {
-		WL_ERR(("escan is not ready ndev %p drv_status 0x%x e_type %d e_states %d\n",
-			ndev, wl_get_drv_status(cfg, SCANNING, ndev),
+		WL_ERR_RLMT(("escan is not ready. drv_scan_status 0x%x"
+			" e_type %d e_states %d\n",
+			wl_get_drv_status(cfg, SCANNING, ndev),
 			ntoh32(e->event_type), ntoh32(e->status)));
 		goto exit;
 	}
@@ -15845,13 +16207,7 @@
 	wl_escan_init_sync_id(cfg);
 
 	/* Init scan_timeout timer */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	timer_setup(&cfg->scan_timeout, wl_scan_timeout, 0);
-#else
-	init_timer(&cfg->scan_timeout);
-	cfg->scan_timeout.data = (unsigned long) cfg;
-	cfg->scan_timeout.function = wl_scan_timeout;
-#endif
+	init_timer_compat(&cfg->scan_timeout, wl_scan_timeout, cfg);
 
 	return err;
 }
@@ -15862,13 +16218,7 @@
 	int err = 0;
 
 	/* Init roam timer */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	timer_setup(&cfg->roam_timeout, wl_roam_timeout, 0);
-#else
-	init_timer(&cfg->roam_timeout);
-	cfg->roam_timeout.data = (unsigned long) cfg;
-	cfg->roam_timeout.function = wl_roam_timeout;
-#endif
+	init_timer_compat(&cfg->roam_timeout, wl_roam_timeout, cfg);
 
 	return err;
 }
@@ -15945,11 +16295,9 @@
 	wl_destroy_event_handler(cfg);
 	wl_flush_eq(cfg);
 	wl_link_down(cfg);
-	if (cfg->scan_timeout.function)
-		del_timer_sync(&cfg->scan_timeout);
+	del_timer_sync(&cfg->scan_timeout);
 #ifdef DHD_LOSSLESS_ROAMING
-	if (cfg->roam_timeout.function)
-		del_timer_sync(&cfg->roam_timeout);
+	del_timer_sync(&cfg->roam_timeout);
 #endif
 	wl_deinit_priv_mem(cfg);
 	if (wl_cfg80211_netdev_notifier_registered) {
@@ -19554,6 +19902,29 @@
 	return BCME_OK;
 }
 
+#ifdef WLFBT
+int
+wl_cfg80211_get_fbt_key(struct net_device *dev, uint8 *key, int total_len)
+{
+	struct bcm_cfg80211 * cfg = wl_get_cfg(dev);
+	int bytes_written = -1;
+
+	if (total_len < FBT_KEYLEN) {
+		WL_ERR(("wl_cfg80211_get_fbt_key: Insufficient buffer \n"));
+		goto end;
+	}
+	if (cfg) {
+		memcpy(key, cfg->fbt_key, FBT_KEYLEN);
+		bytes_written = FBT_KEYLEN;
+	} else {
+		bzero(key, FBT_KEYLEN);
+		WL_ERR(("wl_cfg80211_get_fbt_key: Failed to copy KCK and KEK \n"));
+	}
+	prhex("KCK, KEK", (uchar *)key, FBT_KEYLEN);
+end:
+	return bytes_written;
+}
+#endif /* WLFBT */
 
 static int
 wl_cfg80211_delayed_roam(struct bcm_cfg80211 *cfg, struct net_device *ndev,
@@ -20307,7 +20678,8 @@
 	cfg80211_ch_switch_notify(dev, freq, chan_info.chan_type);
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION (3, 8, 0)) */
 
-	WL_ERR(("Channel switch notification for freq: %d chanspec: 0x%x\n", freq, chanspec));
+	WL_MSG(dev->name, "Channel switch notification for freq: %d chanspec: 0x%x\n",
+		freq, chanspec);
 	return;
 }
 #endif /* LINUX_VERSION_CODE >= (3, 5, 0) */
@@ -21971,12 +22343,12 @@
 			}
 			break;
  		case WL_EXT_STATUS_DISCONNECTING:
-			if (cur_eapol_status >= EAPOL_STATUS_WPA_START &&
-					cur_eapol_status < EAPOL_STATUS_WPA_END) {
+			if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
+					cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
 				WL_ERR(("WPA failed at %d\n", cur_eapol_status));
 				dhdp->conf->eapol_status = EAPOL_STATUS_NONE;
-			} else if (cur_eapol_status >= EAPOL_STATUS_WPS_WSC_START &&
-					cur_eapol_status < EAPOL_STATUS_WPS_DONE) {
+			} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
+					cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
 				WL_ERR(("WPS failed at %d\n", cur_eapol_status));
 				dhdp->conf->eapol_status = EAPOL_STATUS_NONE;
 			}
@@ -22004,6 +22376,7 @@
 					mutex_lock(&cfg->in4way_sync);
 					max_wait_cnt--;
 				}
+				wake_up_interruptible(&dhdp->conf->event_complete);
 			}
 			break;
 		case WL_EXT_STATUS_CONNECTING:
@@ -22012,7 +22385,7 @@
 				sec = wl_read_prof(cfg, dev, WL_PROF_SEC);
 				if ((sec->wpa_versions & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2)) &&
 						bssidx == 0) {
-					dhdp->conf->eapol_status = EAPOL_STATUS_WPA_START;
+					dhdp->conf->eapol_status = EAPOL_STATUS_4WAY_START;
 					cfg->handshaking = 1;
 					if (action & NO_BTC_IN4WAY) {
 						ret = wldev_iovar_getint(dev, "btc_mode", &cfg->btc_mode);
@@ -22037,26 +22410,26 @@
 					mutex_lock(&cfg->in4way_sync);
 					max_wait_cnt--;
 				}
+				wake_up_interruptible(&dhdp->conf->event_complete);
 			}
 			break;
 		case WL_EXT_STATUS_CONNECTED:
 			ifidx = dhd_net2idx(dhdp->info, dev);
 			if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_STATION && ifidx >= 0) {
 				dhd_conf_set_wme(cfg->pub, ifidx, 0);
-				dhd_conf_set_intiovar(cfg->pub, WLC_SET_VAR, "phy_oclscdenable",
-					cfg->pub->conf->phy_oclscdenable, 0, FALSE);
+				wake_up_interruptible(&dhdp->conf->event_complete);
 			}
 			else if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_CLIENT) {
 				dhd_conf_set_mchan_bw(cfg->pub, WL_P2P_IF_CLIENT, -1);
 			}
 			break;
 		case WL_EXT_STATUS_DISCONNECTED:
-			if (cur_eapol_status >= EAPOL_STATUS_WPA_START &&
-					cur_eapol_status < EAPOL_STATUS_WPA_END) {
+			if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
+					cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
 				WL_ERR(("WPA failed at %d\n", cur_eapol_status));
 				dhdp->conf->eapol_status = EAPOL_STATUS_NONE;
-			} else if (cur_eapol_status >= EAPOL_STATUS_WPS_WSC_START &&
-					cur_eapol_status < EAPOL_STATUS_WPS_DONE) {
+			} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
+					cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
 				WL_ERR(("WPS failed at %d\n", cur_eapol_status));
 				dhdp->conf->eapol_status = EAPOL_STATUS_NONE;
 			}
@@ -22073,9 +22446,10 @@
 			if (action & WAIT_DISCONNECTED) {
 				cfg->disconnected_jiffies = jiffies;
 			}
+			wake_up_interruptible(&dhdp->conf->event_complete);
 			break;
 		case WL_EXT_STATUS_ADD_KEY:
-			dhdp->conf->eapol_status = EAPOL_STATUS_WPA_END;
+			dhdp->conf->eapol_status = EAPOL_STATUS_4WAY_DONE;
 			if (action & (NO_SCAN_IN4WAY|NO_BTC_IN4WAY)) {
 				if (cfg->handshaking) {
 					if ((action & NO_BTC_IN4WAY) && cfg->btc_mode) {
@@ -22086,6 +22460,7 @@
 					cfg->handshaking = 0;
 				}
 			}
+			wake_up_interruptible(&dhdp->conf->event_complete);
 			break;
 		case WL_EXT_STATUS_AP_ENABLED:
 			ifidx = dhd_net2idx(dhdp->info, dev);
@@ -22101,9 +22476,9 @@
 					(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO)) {
 				u8* mac_addr = context;
 				if (mac_addr && memcmp(&ether_bcast, mac_addr, ETHER_ADDR_LEN) &&
-						cur_eapol_status == EAPOL_STATUS_WPS_DONE) {
+						cur_eapol_status == EAPOL_STATUS_WSC_DONE) {
 					u32 timeout;
-					max_wait_time = dhdp->conf->max_wait_gc_time;
+					max_wait_time = 300;
 					WL_TRACE(("status=%d, wps_done=%d, waiting %dms ...\n",
 						status, cfg->wps_done, max_wait_time));
 					mutex_unlock(&cfg->in4way_sync);
@@ -22126,7 +22501,7 @@
 		case WL_EXT_STATUS_STA_DISCONNECTED:
 			if ((action & DONT_DELETE_GC_AFTER_WPS) &&
 					(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO) &&
-					cur_eapol_status == EAPOL_STATUS_WPS_DONE) {
+					cur_eapol_status == EAPOL_STATUS_WSC_DONE) {
 				WL_TRACE(("status=%d, wps_done=%d => 0\n", status, cfg->wps_done));
 				cfg->wps_done = FALSE;
 			}
@@ -22134,7 +22509,7 @@
 		case WL_EXT_STATUS_STA_CONNECTED:
 			if ((action & DONT_DELETE_GC_AFTER_WPS) &&
 					(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO) &&
-					cur_eapol_status == EAPOL_STATUS_WPS_DONE) {
+					cur_eapol_status == EAPOL_STATUS_WSC_DONE) {
 				WL_TRACE(("status=%d, wps_done=%d => 1\n", status, cfg->wps_done));
 				cfg->wps_done = TRUE;
 				wake_up_interruptible(&cfg->wps_done_event);
diff -urN a/drivers/net/wireless/bcmdhd/wl_cfg80211.h a/drivers/net/wireless/bcmdhd/wl_cfg80211.h
--- a/drivers/net/wireless/bcmdhd/wl_cfg80211.h	2020-01-13 17:57:02.397432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_cfg80211.h	2019-11-04 04:45:14.000000000 +0300
@@ -52,6 +52,9 @@
 struct wl_security;
 struct wl_ibss;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0)
+#undef WL_SAE
+#endif // endif
 
 #define htod32(i) (i)
 #define htod16(i) (i)
@@ -139,6 +142,26 @@
 #define WL_ERR_EX(args) WL_ERR(args)
 #endif /* defined(DHD_DEBUG) */
 
+#define WL_PRINT_RATE_LIMIT_PERIOD 4000000000u /* 4s in units of ns */
+#define WL_ERR_RLMT(args) \
+do {	\
+	if (wl_dbg_level & WL_DBG_ERR) {	\
+		static uint64 __err_ts = 0; \
+		static uint32 __err_cnt = 0; \
+		uint64 __cur_ts = 0; \
+		__cur_ts = local_clock(); \
+		if (__err_ts == 0 || (__cur_ts > __err_ts && \
+		(__cur_ts - __err_ts > WL_PRINT_RATE_LIMIT_PERIOD))) { \
+			__err_ts = __cur_ts; \
+			WL_ERR(args);	\
+			WL_ERR(("[Repeats %u times]\n", __err_cnt)); \
+			__err_cnt = 0; \
+		} else { \
+			++__err_cnt; \
+		} \
+	}	\
+} while (0)
+
 #ifdef WL_INFORM
 #undef WL_INFORM
 #endif
@@ -616,6 +639,9 @@
 /* Max length of Interworking element */
 #define IW_IES_MAX_BUF_LEN 		9
 #endif
+#ifdef WLFBT
+#define FBT_KEYLEN		32
+#endif
 #define MAX_EVENT_BUF_NUM 16
 typedef struct wl_eventmsg_buf {
 	u16 num;
@@ -768,7 +794,7 @@
 	struct p2p_info *p2p;
 	bool p2p_supported;
 	void *btcoex_info;
-	struct timer_list scan_timeout;   /* Timer for catch scan event timeout */
+	timer_list_compat_t scan_timeout;   /* Timer for catch scan event timeout */
 #if defined(P2P_IE_MISSING_FIX)
 	bool p2p_prb_noti;
 #endif
@@ -782,7 +808,7 @@
 	bool sched_scan_running;	/* scheduled scan req status */
 	struct cfg80211_sched_scan_request *sched_scan_req;	/* scheduled scan req */
 	bool scan_suppressed;
-	struct timer_list scan_supp_timer;
+	timer_list_compat_t scan_supp_timer;
 	struct work_struct wlan_work;
 	struct mutex event_sync;	/* maily for up/down synchronization */
 	bool disable_roam_event;
@@ -802,6 +828,9 @@
 	bcm_struct_cfgdev *ibss_cfgdev; /* For AIBSS */
 #endif /* WLAIBSS_MCHAN */
 	bool bss_pending_op;		/* indicate where there is a pending IF operation */
+#ifdef WLFBT
+	uint8 fbt_key[FBT_KEYLEN];
+#endif
 	int roam_offload;
 #ifdef WL_CFG80211_P2P_DEV_IF
 	bool down_disc_if;
@@ -832,7 +861,7 @@
 	bool random_mac_enabled;
 #endif /* SUPPORT_RANDOM_MAC_SCAN */
 #ifdef DHD_LOSSLESS_ROAMING
-	struct timer_list roam_timeout;   /* Timer for catch roam timeout */
+	timer_list_compat_t roam_timeout;   /* Timer for catch roam timeout */
 #endif
 	uint16 escan_sync_id_cntr;
 #ifdef WLTDLS
@@ -878,6 +907,16 @@
 	ulong disconnected_jiffies;
 };
 
+#ifdef WL_SAE
+typedef struct wl_sae_key_info {
+	uint8 peer_mac[ETHER_ADDR_LEN];
+	uint16 pmk_len;
+	uint16 pmkid_len;
+	const uint8 *pmk;
+	const uint8 *pmkid;
+} wl_sae_key_info_t;
+#endif /* WL_SAE */
+
 #if defined(STRICT_GCC_WARNINGS) && defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == \
 	4 && __GNUC_MINOR__ >= 6))
 #define GCC_DIAGNOSTIC_PUSH() \
@@ -1433,7 +1472,20 @@
 	 (!_sme->crypto.n_ciphers_pairwise) && \
 	 (!_sme->crypto.cipher_group))
 
+#ifdef WLFBT
+#if defined(WLAN_AKM_SUITE_FT_8021X) && defined(WLAN_AKM_SUITE_FT_PSK)
+#define IS_AKM_SUITE_FT(sec) (sec->wpa_auth == WLAN_AKM_SUITE_FT_8021X || \
+		sec->wpa_auth == WLAN_AKM_SUITE_FT_PSK)
+#elif defined(WLAN_AKM_SUITE_FT_8021X)
+#define IS_AKM_SUITE_FT(sec) (sec->wpa_auth == WLAN_AKM_SUITE_FT_8021X)
+#elif defined(WLAN_AKM_SUITE_FT_PSK)
+#define IS_AKM_SUITE_FT(sec) (sec->wpa_auth == WLAN_AKM_SUITE_FT_PSK)
+#else
 #define IS_AKM_SUITE_FT(sec) ({BCM_REFERENCE(sec); FALSE;})
+#endif /* WLAN_AKM_SUITE_FT_8021X && WLAN_AKM_SUITE_FT_PSK */
+#else
+#define IS_AKM_SUITE_FT(sec) ({BCM_REFERENCE(sec); FALSE;})
+#endif /* WLFBT */
 
 #define IS_AKM_SUITE_CCKM(sec) ({BCM_REFERENCE(sec); FALSE;})
 
@@ -1572,6 +1624,9 @@
 	bcm_struct_cfgdev *cfgdev, s32 bssidx, s32 pktflag,
 	const u8 *vndr_ie, u32 vndr_ie_len);
 
+#ifdef WLFBT
+extern int wl_cfg80211_get_fbt_key(struct net_device *dev, uint8 *key, int total_len);
+#endif
 
 /* Action frame specific functions */
 extern u8 wl_get_action_category(void *frame, u32 frame_len);
diff -urN a/drivers/net/wireless/bcmdhd/wl_cfg_btcoex.c a/drivers/net/wireless/bcmdhd/wl_cfg_btcoex.c
--- a/drivers/net/wireless/bcmdhd/wl_cfg_btcoex.c	2020-01-13 17:57:02.397432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_cfg_btcoex.c	2019-09-19 16:27:14.000000000 +0300
@@ -45,7 +45,7 @@
 #endif
 
 struct btcoex_info {
-	struct timer_list timer;
+	timer_list_compat_t timer;
 	u32 timer_ms;
 	u32 timer_on;
 	u32 ts_dhcp_start;	/* ms ts ecord time stats */
@@ -294,19 +294,9 @@
 #endif
 }
 
-static void wl_cfg80211_bt_timerfunc(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	unsigned long data
-#endif
-)
+static void wl_cfg80211_bt_timerfunc(ulong data)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct btcoex_info *bt_local = from_timer(bt_local, t, timer);
-#else
 	struct btcoex_info *bt_local = (struct btcoex_info *)data;
-#endif
 	WL_TRACE(("Enter\n"));
 	bt_local->timer_on = 0;
 	schedule_work(&bt_local->work);
@@ -403,13 +393,7 @@
 	btco_inf->ts_dhcp_ok = 0;
 	/* Set up timer for BT  */
 	btco_inf->timer_ms = 10;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	timer_setup(&btco_inf->timer, wl_cfg80211_bt_timerfunc, 0);
-#else
-	init_timer(&btco_inf->timer);
-	btco_inf->timer.data = (ulong)btco_inf;
-	btco_inf->timer.function = wl_cfg80211_bt_timerfunc;
-#endif
+	init_timer_compat(&btco_inf->timer, wl_cfg80211_bt_timerfunc, btco_inf);
 
 	btco_inf->dev = ndev;
 
@@ -506,7 +490,8 @@
 
 					btco_inf->bt_state = BT_DHCP_START;
 					btco_inf->timer_on = 1;
-					mod_timer(&btco_inf->timer, btco_inf->timer.expires);
+					mod_timer(&btco_inf->timer,
+						timer_expires(&btco_inf->timer));
 					WL_TRACE(("enable BT DHCP Timer\n"));
 				}
 		}
diff -urN a/drivers/net/wireless/bcmdhd/wl_cfgp2p.c a/drivers/net/wireless/bcmdhd/wl_cfgp2p.c
--- a/drivers/net/wireless/bcmdhd/wl_cfgp2p.c	2020-01-13 17:57:02.398432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_cfgp2p.c	2019-09-19 16:27:13.000000000 +0300
@@ -334,9 +334,6 @@
 		return -ENOMEM;
 	}
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	cfg->p2p->cfg = cfg;
-#endif
 	wl_to_p2p_bss_ndev(cfg, P2PAPI_BSSCFG_PRIMARY) = bcmcfg_to_prmry_ndev(cfg);
 	wl_to_p2p_bss_bssidx(cfg, P2PAPI_BSSCFG_PRIMARY) = 0;
 	wl_to_p2p_bss_ndev(cfg, P2PAPI_BSSCFG_DEVICE) = NULL;
@@ -1389,21 +1386,10 @@
  *  so lets do it from thread context.
  */
 void
-wl_cfgp2p_listen_expired(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	ulong data
-#endif
-)
+wl_cfgp2p_listen_expired(unsigned long data)
 {
 	wl_event_msg_t msg;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct p2p_info *p2p = from_timer(p2p, t, listen_timer);
-	struct bcm_cfg80211 *cfg = p2p->cfg;
-#else
 	struct bcm_cfg80211 *cfg = (struct bcm_cfg80211 *) data;
-#endif
 	struct net_device *ndev;
 	CFGP2P_DBG((" Enter\n"));
 
@@ -1469,7 +1455,7 @@
 {
 #define EXTRA_DELAY_TIME	100
 	s32 ret = BCME_OK;
-	struct timer_list *_timer;
+	timer_list_compat_t *_timer;
 	s32 extra_delay;
 	struct net_device *netdev = bcmcfg_to_prmry_ndev(cfg);
 
diff -urN a/drivers/net/wireless/bcmdhd/wl_cfgp2p.h a/drivers/net/wireless/bcmdhd/wl_cfgp2p.h
--- a/drivers/net/wireless/bcmdhd/wl_cfgp2p.h	2020-01-13 17:57:02.398432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_cfgp2p.h	2019-12-10 07:49:23.000000000 +0300
@@ -71,16 +71,13 @@
 };
 
 struct p2p_info {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct bcm_cfg80211 *cfg;
-#endif
 	bool on;    /**< p2p on/off switch */
 	bool scan;
 	int16 search_state;
 	s8 vir_ifname[IFNAMSIZ];
 	unsigned long status;
 	struct p2p_bss bss[P2PAPI_BSSCFG_MAX];
-	struct timer_list listen_timer;
+	timer_list_compat_t listen_timer;
 	wl_p2p_sched_t noa;
 	wl_p2p_ops_t ops;
 	wlc_ssid_t ssid;
@@ -139,70 +136,59 @@
 #define WLC_IOCTL_MAXLEN 8192
 
 #ifdef CUSTOMER_HW4_DEBUG
-#define CFGP2P_ERROR_TEXT		"CFGP2P-INFO2) "
+#define CFGP2P_ERROR_TEXT		"[dhd] CFGP2P-INFO2) "
 #else
-#define CFGP2P_ERROR_TEXT		"CFGP2P-ERROR) "
+#define CFGP2P_ERROR_TEXT		"[dhd] CFGP2P-ERROR) "
 #endif /* CUSTOMER_HW4_DEBUG */
 
 #ifdef DHD_LOG_DUMP
-#define CFGP2P_ERR(args)									\
-	do {										\
-		if (wl_dbg_level & WL_DBG_ERR) {				\
-			printk(KERN_INFO CFGP2P_ERROR_TEXT "%s : ", __func__);	\
-			printk args;						\
-			DHD_LOG_DUMP_WRITE("[%s] %s: ",	\
-			dhd_log_dump_get_timestamp(), __func__);	\
-			DHD_LOG_DUMP_WRITE args;	\
-		}									\
+#define	CFGP2P_ERR_MSG(x, args...)	\
+	do {	\
+		if (wl_dbg_level & WL_DBG_ERR) {	\
+			printk(KERN_INFO CFGP2P_ERROR_TEXT "%s : " x, __func__, ## args);	\
+			DHD_LOG_DUMP_WRITE("[%s] %s: ", dhd_log_dump_get_timestamp(), __func__);	\
+			DHD_LOG_DUMP_WRITE(x, ## args);	\
+		}	\
 	} while (0)
+#define CFGP2P_ERR(x) CFGP2P_ERR_MSG x
 #else
-#define CFGP2P_ERR(args)									\
+#define	CFGP2P_ERR_MSG(x, args...)	\
 	do {										\
 		if (wl_dbg_level & WL_DBG_ERR) {				\
-			printk(KERN_INFO CFGP2P_ERROR_TEXT "%s : ", __func__);	\
-			printk args;						\
+			printk(KERN_INFO CFGP2P_ERROR_TEXT "%s : " x, __func__, ## args);	\
 		}									\
 	} while (0)
+#define CFGP2P_ERR(x) CFGP2P_ERR_MSG x
 #endif /* DHD_LOG_DUMP */
-#define	CFGP2P_INFO(args)									\
+#define	CFGP2P_INFO_MSG(x, args...)									\
 	do {										\
 		if (wl_dbg_level & WL_DBG_INFO) {				\
-			printk(KERN_INFO "CFGP2P-INFO) %s : ", __func__);	\
-			printk args;						\
+			printk(KERN_INFO "[dhd] CFGP2P-INFO) %s : " x, __func__, ## args);	\
 		}									\
 	} while (0)
-#define	CFGP2P_DBG(args)								\
+#define CFGP2P_INFO(x) CFGP2P_INFO_MSG x
+#define	CFGP2P_DBG_MSG(x, args...)								\
 	do {									\
 		if (wl_dbg_level & WL_DBG_DBG) {			\
-			printk(KERN_INFO "CFGP2P-DEBUG) %s :", __func__);	\
-			printk args;							\
+			printk(KERN_INFO "[dhd] CFGP2P-DEBUG) %s :" x, __func__, ## args);	\
 		}									\
 	} while (0)
+#define CFGP2P_DBG(x) CFGP2P_DBG_MSG x
 
-#define	CFGP2P_ACTION(args)								\
+#define	CFGP2P_ACTION_MSG(x, args...)								\
 	do {									\
 		if (wl_dbg_level & WL_DBG_P2P_ACTION) {			\
-			printk(KERN_INFO "CFGP2P-ACTION) %s :", __func__);	\
-			printk args;							\
+			printk(KERN_INFO "[dhd] CFGP2P-ACTION) %s :" x, __func__, ## args);	\
 		}									\
 	} while (0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-#define INIT_TIMER(timer, func, duration, extra_delay)	\
-	do {				   \
-		timer_setup(timer, func, 0); \
-		timer->expires = jiffies + msecs_to_jiffies(duration + extra_delay); \
-		add_timer(timer); \
-	} while (0);
-#else
+#define CFGP2P_ACTION(x) CFGP2P_ACTION_MSG x
+
 #define INIT_TIMER(timer, func, duration, extra_delay)	\
 	do {				   \
-		init_timer(timer); \
-		timer->function = func; \
-		timer->expires = jiffies + msecs_to_jiffies(duration + extra_delay); \
-		timer->data = (unsigned long) cfg; \
+		init_timer_compat(timer, func, cfg); \
+		timer_expires(timer) = jiffies + msecs_to_jiffies(duration + extra_delay); \
 		add_timer(timer); \
 	} while (0);
-#endif
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 0, 8))
 #ifdef WL_SUPPORT_BACKPORTED_KPATCHES
@@ -257,13 +243,7 @@
 #define P2P_ECSA_CNT 50
 
 extern void
-wl_cfgp2p_listen_expired(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	ulong data
-#endif
-);
+wl_cfgp2p_listen_expired(ulong data);
 extern bool
 wl_cfgp2p_is_pub_action(void *frame, u32 frame_len);
 extern bool
diff -urN a/drivers/net/wireless/bcmdhd/wl_cfgvendor.c a/drivers/net/wireless/bcmdhd/wl_cfgvendor.c
--- a/drivers/net/wireless/bcmdhd/wl_cfgvendor.c	2020-01-13 17:57:02.399432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_cfgvendor.c	2019-11-04 04:45:13.000000000 +0300
@@ -2080,6 +2080,53 @@
 	return ndev;
 }
 
+#ifdef WL_SAE
+static int
+wl_cfgvendor_set_sae_password(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = BCME_OK;
+	struct net_device *net = wdev->netdev;
+	struct bcm_cfg80211 *cfg = wl_get_cfg(net);
+	wsec_pmk_t pmk;
+	s32 bssidx;
+
+	/* clear the content of pmk structure before usage */
+	(void)memset(&pmk, 0x0, sizeof(wsec_pmk_t));
+
+	if ((bssidx = wl_get_bssidx_by_wdev(cfg, net->ieee80211_ptr)) < 0) {
+		WL_ERR(("Find p2p index from wdev(%p) failed\n", net->ieee80211_ptr));
+		return BCME_ERROR;
+	}
+
+	if ((len < WSEC_MIN_PSK_LEN) || (len >= WSEC_MAX_PASSPHRASE_LEN)) {
+		WL_ERR(("Invalid passphrase length %d..should be >= 8 and < 256\n",
+			len));
+		err = BCME_BADLEN;
+		goto done;
+	}
+	/* Set AUTH to SAE */
+	err = wldev_iovar_setint_bsscfg(net, "wpa_auth", WPA3_AUTH_SAE_PSK, bssidx);
+	if (unlikely(err)) {
+		WL_ERR(("could not set wpa_auth (0x%x)\n", err));
+		goto done;
+	}
+	pmk.key_len = htod16(len);
+	bcopy((const u8*)data, pmk.key, len);
+	pmk.flags = htod16(WSEC_PASSPHRASE);
+
+	err = wldev_ioctl_set(net, WLC_SET_WSEC_PMK, &pmk, sizeof(pmk));
+	if (err) {
+		WL_ERR(("\n failed to set pmk %d\n", err));
+		goto done;
+	} else {
+		WL_INFORM(("sae passphrase set successfully\n"));
+	}
+done:
+	return err;
+}
+#endif /* WL_SAE */
+
 /* Max length for the reply buffer. For BRCM_ATTR_DRIVER_CMD, the reply
  * would be a formatted string and reply buf would be the size of the
  * string.
@@ -3212,6 +3259,16 @@
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = wl_cfgvendor_priv_bcm_handler
 	},
+#ifdef WL_SAE
+	{
+		{
+			.vendor_id = OUI_BRCM,
+			.subcmd = BRCM_VENDOR_SCMD_BCM_PSK
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_set_sae_password
+	},
+#endif /* WL_SAE */
 #ifdef GSCAN_SUPPORT
 	{
 		{
@@ -3612,40 +3669,45 @@
 static const struct  nl80211_vendor_cmd_info wl_vendor_events [] = {
 		{ OUI_BRCM, BRCM_VENDOR_EVENT_UNSPEC },
 		{ OUI_BRCM, BRCM_VENDOR_EVENT_PRIV_STR },
-#ifdef GSCAN_SUPPORT
 		{ OUI_GOOGLE, GOOGLE_GSCAN_SIGNIFICANT_EVENT },
 		{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT },
 		{ OUI_GOOGLE, GOOGLE_GSCAN_BATCH_SCAN_EVENT },
 		{ OUI_GOOGLE, GOOGLE_SCAN_FULL_RESULTS_EVENT },
-#endif /* GSCAN_SUPPORT */
-#ifdef RTT_SUPPORT
 		{ OUI_GOOGLE, GOOGLE_RTT_COMPLETE_EVENT },
-#endif /* RTT_SUPPORT */
-#ifdef GSCAN_SUPPORT
 		{ OUI_GOOGLE, GOOGLE_SCAN_COMPLETE_EVENT },
 		{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_LOST_EVENT },
 		{ OUI_GOOGLE, GOOGLE_SCAN_EPNO_EVENT },
-#endif /* GSCAN_SUPPORT */
 		{ OUI_GOOGLE, GOOGLE_DEBUG_RING_EVENT },
 		{ OUI_GOOGLE, GOOGLE_FW_DUMP_EVENT },
-#ifdef GSCAN_SUPPORT
 		{ OUI_GOOGLE, GOOGLE_PNO_HOTSPOT_FOUND_EVENT },
-#endif /* GSCAN_SUPPORT */
 		{ OUI_GOOGLE, GOOGLE_RSSI_MONITOR_EVENT },
 		{ OUI_GOOGLE, GOOGLE_MKEEP_ALIVE_EVENT },
 		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_ENABLED},
 		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_DISABLED},
-		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_PUBLISH_TERMINATED},
 		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_SUBSCRIBE_MATCH},
-		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_SUBSCRIBE_UNMATCH},
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_REPLIED},
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_PUBLISH_TERMINATED},
 		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_SUBSCRIBE_TERMINATED},
 		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_DE_EVENT},
 		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_FOLLOWUP},
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_TRANSMIT_FOLLOWUP_IND},
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_DATA_REQUEST},
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_DATA_CONFIRMATION},
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_DATA_END},
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_BEACON},
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_SDF},
 		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_TCA},
-#ifdef NAN_DP
-		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_DATA_PATH_OPEN},
-#endif /* NAN_DP */
-		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_UNKNOWN}
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_SUBSCRIBE_UNMATCH},
+		{ OUI_GOOGLE, GOOGLE_NAN_EVENT_UNKNOWN},
+		{ OUI_GOOGLE, GOOGLE_ROAM_EVENT_START},
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_HANGED},
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_SAE_KEY},
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_BEACON_RECV},
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_PORT_AUTHORIZED},
+		{ OUI_GOOGLE, GOOGLE_FILE_DUMP_EVENT },
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_CU},
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_WIPS},
+		{ OUI_GOOGLE, NAN_ASYNC_RESPONSE_DISABLED}
 };
 
 int wl_cfgvendor_attach(struct wiphy *wiphy, dhd_pub_t *dhd)
diff -urN a/drivers/net/wireless/bcmdhd/wl_cfgvendor.h a/drivers/net/wireless/bcmdhd/wl_cfgvendor.h
--- a/drivers/net/wireless/bcmdhd/wl_cfgvendor.h	2020-01-13 17:57:02.399432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_cfgvendor.h	2019-11-04 04:45:13.000000000 +0300
@@ -359,6 +359,12 @@
 	RSSI_MONITOR_ATTRIBUTE_START
 };
 
+enum wifi_sae_key_attr {
+	BRCM_SAE_KEY_ATTR_PEER_MAC,
+	BRCM_SAE_KEY_ATTR_PMK,
+	BRCM_SAE_KEY_ATTR_PMKID
+};
+
 enum debug_attributes {
 	DEBUG_ATTRIBUTE_GET_DRIVER,
 	DEBUG_ATTRIBUTE_GET_FW,
@@ -395,38 +401,53 @@
 };
 
 typedef enum wl_vendor_event {
-	BRCM_VENDOR_EVENT_UNSPEC,
-	BRCM_VENDOR_EVENT_PRIV_STR,
-	GOOGLE_GSCAN_SIGNIFICANT_EVENT,
-	GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT,
-	GOOGLE_GSCAN_BATCH_SCAN_EVENT,
-	GOOGLE_SCAN_FULL_RESULTS_EVENT,
-	GOOGLE_RTT_COMPLETE_EVENT,
-	GOOGLE_SCAN_COMPLETE_EVENT,
-	GOOGLE_GSCAN_GEOFENCE_LOST_EVENT,
-	GOOGLE_SCAN_EPNO_EVENT,
-	GOOGLE_DEBUG_RING_EVENT,
-	GOOGLE_FW_DUMP_EVENT,
-	GOOGLE_PNO_HOTSPOT_FOUND_EVENT,
-	GOOGLE_RSSI_MONITOR_EVENT,
-	GOOGLE_MKEEP_ALIVE_EVENT,
+	BRCM_VENDOR_EVENT_UNSPEC		= 0,
+	BRCM_VENDOR_EVENT_PRIV_STR		= 1,
+	GOOGLE_GSCAN_SIGNIFICANT_EVENT		= 2,
+	GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT	= 3,
+	GOOGLE_GSCAN_BATCH_SCAN_EVENT		= 4,
+	GOOGLE_SCAN_FULL_RESULTS_EVENT		= 5,
+	GOOGLE_RTT_COMPLETE_EVENT		= 6,
+	GOOGLE_SCAN_COMPLETE_EVENT		= 7,
+	GOOGLE_GSCAN_GEOFENCE_LOST_EVENT	= 8,
+	GOOGLE_SCAN_EPNO_EVENT			= 9,
+	GOOGLE_DEBUG_RING_EVENT			= 10,
+	GOOGLE_FW_DUMP_EVENT			= 11,
+	GOOGLE_PNO_HOTSPOT_FOUND_EVENT		= 12,
+	GOOGLE_RSSI_MONITOR_EVENT		= 13,
+	GOOGLE_MKEEP_ALIVE_EVENT		= 14,
+
 	/*
 	 * BRCM specific events should be placed after
 	 * the Generic events so that enums don't mismatch
 	 * between the DHD and HAL
 	 */
-	GOOGLE_NAN_EVENT_ENABLED = 150,
-	GOOGLE_NAN_EVENT_DISABLED,
-	GOOGLE_NAN_EVENT_PUBLISH_TERMINATED,
-	GOOGLE_NAN_EVENT_SUBSCRIBE_MATCH,
-	GOOGLE_NAN_EVENT_SUBSCRIBE_UNMATCH,
-	GOOGLE_NAN_EVENT_SUBSCRIBE_TERMINATED,
-	GOOGLE_NAN_EVENT_DE_EVENT,
-	GOOGLE_NAN_EVENT_FOLLOWUP,
-	GOOGLE_NAN_EVENT_TCA,
-	GOOGLE_NAN_EVENT_DATA_IF_ADD,
-	GOOGLE_NAN_EVENT_DATA_PATH_OPEN,
-	GOOGLE_NAN_EVENT_UNKNOWN
+	GOOGLE_NAN_EVENT_ENABLED		= 15,
+	GOOGLE_NAN_EVENT_DISABLED		= 16,
+	GOOGLE_NAN_EVENT_SUBSCRIBE_MATCH	= 17,
+	GOOGLE_NAN_EVENT_REPLIED		= 18,
+	GOOGLE_NAN_EVENT_PUBLISH_TERMINATED	= 19,
+	GOOGLE_NAN_EVENT_SUBSCRIBE_TERMINATED	= 20,
+	GOOGLE_NAN_EVENT_DE_EVENT		= 21,
+	GOOGLE_NAN_EVENT_FOLLOWUP		= 22,
+	GOOGLE_NAN_EVENT_TRANSMIT_FOLLOWUP_IND	= 23,
+	GOOGLE_NAN_EVENT_DATA_REQUEST		= 24,
+	GOOGLE_NAN_EVENT_DATA_CONFIRMATION	= 25,
+	GOOGLE_NAN_EVENT_DATA_END		= 26,
+	GOOGLE_NAN_EVENT_BEACON			= 27,
+	GOOGLE_NAN_EVENT_SDF			= 28,
+	GOOGLE_NAN_EVENT_TCA			= 29,
+	GOOGLE_NAN_EVENT_SUBSCRIBE_UNMATCH	= 30,
+	GOOGLE_NAN_EVENT_UNKNOWN		= 31,
+	GOOGLE_ROAM_EVENT_START			= 32,
+	BRCM_VENDOR_EVENT_HANGED                = 33,
+	BRCM_VENDOR_EVENT_SAE_KEY               = 34,
+	BRCM_VENDOR_EVENT_BEACON_RECV           = 35,
+	BRCM_VENDOR_EVENT_PORT_AUTHORIZED       = 36,
+	GOOGLE_FILE_DUMP_EVENT			= 37,
+	BRCM_VENDOR_EVENT_CU			= 38,
+	BRCM_VENDOR_EVENT_WIPS			= 39,
+	NAN_ASYNC_RESPONSE_DISABLED		= 40
 } wl_vendor_event_t;
 
 enum andr_wifi_attr {
diff -urN a/drivers/net/wireless/bcmdhd/wldev_common.c a/drivers/net/wireless/bcmdhd/wldev_common.c
--- a/drivers/net/wireless/bcmdhd/wldev_common.c	2020-01-13 17:57:02.415432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wldev_common.c	2019-11-04 04:45:15.000000000 +0300
@@ -46,17 +46,17 @@
 #define htodchanspec(i) (i)
 #define dtohchanspec(i) (i)
 
-#define	WLDEV_ERROR(args)						\
-	do {										\
-		printk(KERN_ERR "WLDEV-ERROR) ");	\
-		printk args;							\
+#define	WLDEV_ERROR_MSG(x, args...)						\
+	do {												\
+		printk(KERN_INFO "WLDEV-ERROR) " x, ## args);	\
 	} while (0)
+#define WLDEV_ERROR(x) WLDEV_ERROR_MSG x
 
-#define	WLDEV_INFO(args)						\
-	do {										\
-		printk(KERN_INFO "WLDEV-INFO) ");	\
-		printk args;							\
+#define	WLDEV_INFO_MSG(x, args...)						\
+	do {												\
+		printk(KERN_INFO "WLDEV-INFO) " x, ## args);	\
 	} while (0)
+#define WLDEV_INFO(x) WLDEV_INFO_MSG x
 
 extern int dhd_ioctl_entry_local(struct net_device *net, wl_ioctl_t *ioc, int cmd);
 
diff -urN a/drivers/net/wireless/bcmdhd/wl_escan.c a/drivers/net/wireless/bcmdhd/wl_escan.c
--- a/drivers/net/wireless/bcmdhd/wl_escan.c	2020-01-13 17:57:02.414432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_escan.c	2019-12-10 07:53:53.000000000 +0300
@@ -25,6 +25,12 @@
 			printk(KERN_ERR "[dhd-%s] ESCAN-SCAN) %s : " arg1, name, __func__, ## args); \
 		} \
 	} while (0)
+#define ESCAN_DBG(name, arg1, args...) \
+	do { \
+		if (android_msg_level & ANDROID_DBG_LEVEL) { \
+			printk(KERN_ERR "[dhd-%s] ESCAN-DBG) %s : " arg1, name, __func__, ## args); \
+		} \
+	} while (0)
 
 /* IOCTL swapping mode for Big Endian host with Little Endian dongle.  Default to off */
 #define htod32(i) (i)
@@ -175,7 +181,7 @@
  * Returns INVCHANSPEC on error
  */
 static chanspec_t
-wl_ch_host_to_driver(int ioctl_ver, s32 bssidx, u16 channel)
+wl_ch_host_to_driver(int ioctl_ver, u16 channel)
 {
 	chanspec_t chanspec;
 
@@ -200,8 +206,9 @@
 		(struct wl_bss_info *)((uintptr) bss + dtoh32(bss->length)) : list->bss_info;
 }
 
+#if defined(ESCAN_RESULT_PATCH)
 static s32
-wl_escan_inform_bss(struct wl_escan_info *escan)
+wl_escan_inform_bss(struct net_device *dev, struct wl_escan_info *escan)
 {
 	struct wl_scan_results *bss_list;
 	s32 err = 0;
@@ -211,7 +218,7 @@
 
 	bss_list = escan->bss_list;
 
-	ESCAN_SCAN(escan->dev->name, "scanned AP count (%d)\n", bss_list->count);
+	ESCAN_SCAN(dev->name, "scanned AP count (%d)\n", bss_list->count);
 
 	/* Delete disconnected cache */
 #if defined(BSSCACHE)
@@ -227,7 +234,7 @@
 #if defined(RSSIAVG)
 	wl_update_rssi_cache(&escan->g_rssi_cache_ctrl, bss_list);
 	if (!in_atomic())
-		wl_update_connected_rssi_cache(escan->dev, &escan->g_rssi_cache_ctrl, &rssi);
+		wl_update_connected_rssi_cache(dev, &escan->g_rssi_cache_ctrl, &rssi);
 #endif
 #if defined(BSSCACHE)
 	wl_update_bss_cache(&escan->g_bss_cache_ctrl,
@@ -246,25 +253,25 @@
 	wl_delete_dirty_bss_cache(&escan->g_bss_cache_ctrl);
 	wl_reset_bss_cache(&escan->g_bss_cache_ctrl);
 	if (escan->autochannel)
-		wl_ext_get_best_channel(escan->dev, &escan->g_bss_cache_ctrl,
+		wl_ext_get_best_channel(dev, &escan->g_bss_cache_ctrl,
 			escan->ioctl_ver &escan->best_2g_ch, &escan->best_5g_ch);
 #else
 	if (escan->autochannel)
-		wl_ext_get_best_channel(escan->dev, bss_list, escan->ioctl_ver,
+		wl_ext_get_best_channel(dev, bss_list, escan->ioctl_ver,
 			&escan->best_2g_ch, &escan->best_5g_ch);
 #endif
 
 	return err;
 }
+#endif /* ESCAN_RESULT_PATCH */
 
 static wl_scan_params_t *
-wl_escan_alloc_params(struct wl_escan_info *escan, int channel,
-	int nprobes, int *out_params_size)
+wl_escan_alloc_params(struct net_device *dev, struct wl_escan_info *escan,
+	int channel, int nprobes, int *out_params_size)
 {
 	wl_scan_params_t *params;
 	int params_size;
 	int num_chans;
-	int bssidx = 0;
 
 	*out_params_size = 0;
 
@@ -272,7 +279,7 @@
 	params_size = WL_SCAN_PARAMS_FIXED_SIZE + 1 * sizeof(uint16);
 	params = (wl_scan_params_t*) kzalloc(params_size, GFP_KERNEL);
 	if (params == NULL) {
-		ESCAN_ERROR(escan->dev->name, "mem alloc failed (%d bytes)\n", params_size);
+		ESCAN_ERROR(dev->name, "mem alloc failed (%d bytes)\n", params_size);
 		return params;
 	}
 	memset(params, 0, params_size);
@@ -290,7 +297,7 @@
 	if (channel == -1)
 		params->channel_list[0] = htodchanspec(channel);
 	else
-		params->channel_list[0] = wl_ch_host_to_driver(escan->ioctl_ver, bssidx, channel);
+		params->channel_list[0] = wl_ch_host_to_driver(escan->ioctl_ver, channel);
 
 	/* Our scan params have 1 channel and 0 ssids */
 	params->channel_num = htod32((0 << WL_SCAN_PARAMS_NSSID_SHIFT) |
@@ -301,22 +308,22 @@
 }
 
 static void
-wl_escan_abort(struct wl_escan_info *escan)
+wl_escan_abort(struct net_device *dev, struct wl_escan_info *escan)
 {
 	wl_scan_params_t *params = NULL;
 	s32 params_size = 0;
 	s32 err = BCME_OK;
 	if (!in_atomic()) {
 		/* Our scan params only need space for 1 channel and 0 ssids */
-		params = wl_escan_alloc_params(escan, -1, 0, &params_size);
+		params = wl_escan_alloc_params(dev, escan, -1, 0, &params_size);
 		if (params == NULL) {
-			ESCAN_ERROR(escan->dev->name, "scan params allocation failed \n");
+			ESCAN_ERROR(dev->name, "scan params allocation failed \n");
 			err = -ENOMEM;
 		} else {
 			/* Do a scan abort to stop the driver's scan engine */
-			err = wldev_ioctl(escan->dev, WLC_SCAN, params, params_size, true);
+			err = wldev_ioctl(dev, WLC_SCAN, params, params_size, true);
 			if (err < 0) {
-				ESCAN_ERROR(escan->dev->name, "scan abort  failed \n");
+				ESCAN_ERROR(dev->name, "scan abort  failed \n");
 			}
 			kfree(params);
 		}
@@ -324,7 +331,8 @@
 }
 
 static s32
-wl_escan_notify_complete(struct wl_escan_info *escan, bool fw_abort)
+wl_escan_notify_complete(struct net_device *dev,
+	struct wl_escan_info *escan, bool fw_abort)
 {
 	s32 err = BCME_OK;
 #if defined(WL_WIRELESS_EXT)
@@ -334,19 +342,24 @@
 	char extra[IW_CUSTOM_MAX + 1];
 #endif
 #endif
+	struct dhd_pub *dhd = dhd_get_pub(dev);
 
-	ESCAN_TRACE(escan->dev->name, "Enter\n");
+	ESCAN_TRACE(dev->name, "Enter\n");
 
 	if (fw_abort && !in_atomic())
-		wl_escan_abort(escan);
+		wl_escan_abort(dev, escan);
 
 	if (timer_pending(&escan->scan_timeout))
 		del_timer_sync(&escan->scan_timeout);
+
 #if defined(ESCAN_RESULT_PATCH)
 	escan->bss_list = wl_escan_get_buf(escan);
-	wl_escan_inform_bss(escan);
+	wl_escan_inform_bss(dev, escan);
 #endif /* ESCAN_RESULT_PATCH */
 
+	escan->escan_state = ESCAN_STATE_IDLE;
+	wake_up_interruptible(&dhd->conf->event_complete);
+
 #if defined(WL_WIRELESS_EXT)
 #if WIRELESS_EXT > 13
 #if WIRELESS_EXT > 14
@@ -357,9 +370,9 @@
 	memset(extra, 0, sizeof(extra));
 	if (cmd) {
 		if (cmd == SIOCGIWSCAN) {
-			wireless_send_event(escan->dev, cmd, &wrqu, NULL);
+			wireless_send_event(dev, cmd, &wrqu, NULL);
 		} else
-			wireless_send_event(escan->dev, cmd, &wrqu, extra);
+			wireless_send_event(dev, cmd, &wrqu, extra);
 	}
 #endif
 #endif
@@ -388,7 +401,7 @@
 }
 
 static void
-wl_escan_remove_lowRSSI_info(struct wl_escan_info *escan,
+wl_escan_remove_lowRSSI_info(struct net_device *dev, struct wl_escan_info *escan,
 	wl_scan_results_t *list, removal_element_t *candidate, wl_bss_info_t *bi)
 {
 	int idx1, idx2;
@@ -405,7 +418,7 @@
 				candidate[idx1].RSSI == bss->RSSI &&
 				candidate[idx1].length == dtoh32(bss->length)) {
 				u32 delete_len = dtoh32(bss->length);
-				ESCAN_TRACE(escan->dev->name,
+				ESCAN_DBG(dev->name,
 					"delete scan info of %pM to add new AP\n", &bss->BSSID);
 				if (idx2 < list->count -1) {
 					memmove((u8 *)bss, (u8 *)bss + delete_len,
@@ -426,7 +439,7 @@
 }
 #endif /* ESCAN_BUF_OVERFLOW_MGMT */
 
-s32
+static s32
 wl_escan_handler(struct net_device *dev, struct wl_escan_info *escan,
 	const wl_event_msg_t *e, void *data)
 {
@@ -444,15 +457,15 @@
 	escan_result = (wl_escan_result_t *)data;
 
 	if (escan->escan_state != ESCAN_STATE_SCANING) {
-		ESCAN_TRACE(dev->name, "Not my scan\n");
+		ESCAN_DBG(dev->name, "Not my scan\n");
 		goto exit;
 	}
 
-	ESCAN_TRACE(dev->name, "enter event type : %d, status : %d \n",
+	ESCAN_DBG(dev->name, "enter event type : %d, status : %d \n",
 		ntoh32(e->event_type), ntoh32(e->status));
 
 	if (status == WLC_E_STATUS_PARTIAL) {
-		ESCAN_TRACE(dev->name, "WLC_E_STATUS_PARTIAL \n");
+		ESCAN_DBG(dev->name, "WLC_E_STATUS_PARTIAL \n");
 		if (!escan_result) {
 			ESCAN_ERROR(dev->name, "Invalid escan result (NULL pointer)\n");
 			goto exit;
@@ -497,13 +510,13 @@
 				remove_lower_rssi = TRUE;
 #endif /* ESCAN_BUF_OVERFLOW_MGMT */
 
-			ESCAN_TRACE(dev->name, "%s(%pM) RSSI %d flags 0x%x length %d\n",
+			ESCAN_DBG(dev->name, "%s(%pM) RSSI %d flags 0x%x length %d\n",
 				bi->SSID, &bi->BSSID, bi->RSSI, bi->flags, bi->length);
 			for (i = 0; i < list->count; i++) {
 				bss = bss ? (wl_bss_info_t *)((uintptr)bss + dtoh32(bss->length))
 					: list->bss_info;
 #ifdef ESCAN_BUF_OVERFLOW_MGMT
-				ESCAN_TRACE(dev->name,
+				ESCAN_DBG(dev->name,
 					"%s(%pM), i=%d bss: RSSI %d list->count %d\n",
 					bss->SSID, &bss->BSSID, i, bss->RSSI, list->count);
 
@@ -523,7 +536,7 @@
 						(bi->flags & WL_BSS_FLAGS_FROM_BEACON))
 						goto exit;
 
-					ESCAN_TRACE(dev->name,
+					ESCAN_DBG(dev->name,
 						"%s(%pM), i=%d prev: RSSI %d flags 0x%x, "
 						"new: RSSI %d flags 0x%x\n",
 						bss->SSID, &bi->BSSID, i, bss->RSSI, bss->flags,
@@ -534,7 +547,7 @@
 						/* preserve max RSSI if the measurements are
 						* both on-channel or both off-channel
 						*/
-						ESCAN_TRACE(dev->name,
+						ESCAN_DBG(dev->name,
 							"%s(%pM), same onchan, RSSI: prev %d new %d\n",
 							bss->SSID, &bi->BSSID, bss->RSSI, bi->RSSI);
 						bi->RSSI = MAX(bss->RSSI, bi->RSSI);
@@ -543,7 +556,7 @@
 						/* preserve the on-channel rssi measurement
 						* if the new measurement is off channel
 						*/
-						ESCAN_TRACE(dev->name,
+						ESCAN_DBG(dev->name,
 							"%s(%pM), prev onchan, RSSI: prev %d new %d\n",
 							bss->SSID, &bi->BSSID, bss->RSSI, bi->RSSI);
 						bi->RSSI = bss->RSSI;
@@ -552,10 +565,10 @@
 					if (dtoh32(bss->length) != bi_length) {
 						u32 prev_len = dtoh32(bss->length);
 
-						ESCAN_TRACE(dev->name,
+						ESCAN_DBG(dev->name,
 							"bss info replacement occured(bcast:%d->probresp%d)\n",
 							bss->ie_length, bi->ie_length);
-						ESCAN_TRACE(dev->name,
+						ESCAN_DBG(dev->name,
 							"%s(%pM), replacement!(%d -> %d)\n",
 							bss->SSID, &bi->BSSID, prev_len, bi_length);
 
@@ -587,9 +600,9 @@
 			}
 			if (bi_length > ESCAN_BUF_SIZE - list->buflen) {
 #ifdef ESCAN_BUF_OVERFLOW_MGMT
-				wl_escan_remove_lowRSSI_info(escan, list, candidate, bi);
+				wl_escan_remove_lowRSSI_info(dev, escan, list, candidate, bi);
 				if (bi_length > ESCAN_BUF_SIZE - list->buflen) {
-					ESCAN_TRACE(dev->name,
+					ESCAN_DBG(dev->name,
 						"RSSI(%pM) is too low(%d) to add Buffer\n",
 						&bi->BSSID, bi->RSSI);
 					goto exit;
@@ -607,39 +620,32 @@
 		}
 	}
 	else if (status == WLC_E_STATUS_SUCCESS) {
-		ESCAN_TRACE(dev->name, "ESCAN COMPLETED\n");
+		ESCAN_DBG(dev->name, "ESCAN COMPLETED\n");
 		escan->bss_list = wl_escan_get_buf(escan);
-		ESCAN_TRACE(dev->name, "SCAN COMPLETED: scanned AP count=%d\n",
+		ESCAN_DBG(dev->name, "SCAN COMPLETED: scanned AP count=%d\n",
 			escan->bss_list->count);
-		wl_escan_inform_bss(escan);
-		wl_escan_notify_complete(escan, false);
-		escan->escan_state = ESCAN_STATE_IDLE;
+		wl_escan_notify_complete(dev, escan, false);
 	} else if ((status == WLC_E_STATUS_ABORT) || (status == WLC_E_STATUS_NEWSCAN) ||
 		(status == WLC_E_STATUS_11HQUIET) || (status == WLC_E_STATUS_CS_ABORT) ||
 		(status == WLC_E_STATUS_NEWASSOC)) {
 		/* Handle all cases of scan abort */
-		ESCAN_TRACE(dev->name, "ESCAN ABORT reason: %d\n", status);
+		ESCAN_DBG(dev->name, "ESCAN ABORT reason: %d\n", status);
 		escan->bss_list = wl_escan_get_buf(escan);
-		ESCAN_TRACE(dev->name, "SCAN ABORT: scanned AP count=%d\n",
+		ESCAN_DBG(dev->name, "SCAN ABORT: scanned AP count=%d\n",
 			escan->bss_list->count);
-		wl_escan_inform_bss(escan);
-		wl_escan_notify_complete(escan, false);
-		escan->escan_state = ESCAN_STATE_IDLE;
+		wl_escan_notify_complete(dev, escan, false);
 	} else if (status == WLC_E_STATUS_TIMEOUT) {
 		ESCAN_ERROR(dev->name, "WLC_E_STATUS_TIMEOUT\n");
 		ESCAN_ERROR(dev->name, "reason[0x%x]\n", e->reason);
 		if (e->reason == 0xFFFFFFFF) {
-			wl_escan_notify_complete(escan, true);
+			wl_escan_notify_complete(dev, escan, true);
 		}
-		escan->escan_state = ESCAN_STATE_IDLE;
 	} else {
 		ESCAN_ERROR(dev->name, "unexpected Escan Event %d : abort\n", status);
 		escan->bss_list = wl_escan_get_buf(escan);
-		ESCAN_TRACE(dev->name, "SCAN ABORTED(UNEXPECTED): scanned AP count=%d\n",
+		ESCAN_DBG(dev->name, "SCAN ABORTED(UNEXPECTED): scanned AP count=%d\n",
 			escan->bss_list->count);
-		wl_escan_inform_bss(escan);
-		wl_escan_notify_complete(escan, false);
-		escan->escan_state = ESCAN_STATE_IDLE;
+		wl_escan_notify_complete(dev, escan, false);
 	}
 exit:
 	mutex_unlock(&escan->usr_sync);
@@ -763,20 +769,10 @@
 }
 
 static void
-wl_escan_timeout(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	unsigned long data
-#endif
-)
+wl_escan_timeout(unsigned long data)
 {
 	wl_event_msg_t msg;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct wl_escan_info *escan = from_timer(escan, t, scan_timeout);
-#else
 	struct wl_escan_info *escan = (struct wl_escan_info *)data;
-#endif
 	struct wl_scan_results *bss_list;
 	struct wl_bss_info *bi = NULL;
 	s32 i;
@@ -804,6 +800,7 @@
 	bzero(&msg, sizeof(wl_event_msg_t));
 	ESCAN_ERROR(escan->dev->name, "timer expired\n");
 
+	msg.ifidx = dhd_net2idx(escan->pub->info, escan->dev);
 	msg.event_type = hton32(WLC_E_ESCAN_RESULT);
 	msg.status = hton32(WLC_E_STATUS_TIMEOUT);
 	msg.reason = 0xFFFFFFFF;
@@ -811,9 +808,10 @@
 }
 
 int
-wl_escan_set_scan(struct net_device *dev, struct wl_escan_info *escan,
-	wlc_ssid_t *ssid, bool bcast)
+wl_escan_set_scan(struct net_device *dev, dhd_pub_t *dhdp,
+	wlc_ssid_t *ssid, uint16 channel, bool bcast)
 {
+	struct wl_escan_info *escan = dhdp->escan;
 	s32 err = BCME_OK;
 	s32 params_size = (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_escan_params_t, params));
 	wl_escan_params_t *params = NULL;
@@ -827,10 +825,11 @@
 	if (escan->escan_state == ESCAN_STATE_DOWN) {
 		ESCAN_ERROR(dev->name, "STATE is down\n");
 		err = -EIO;
-		goto exit2;
+		goto exit;
 	}
-	if (escan->escan_state == ESCAN_STATE_SCANING) {
-		ESCAN_ERROR(dev->name, "Scanning already\n");
+
+	if (wl_ext_check_scan(dev, dhdp)) {
+		err = -EBUSY;
 		goto exit;
 	}
 
@@ -839,13 +838,20 @@
 	/* if scan request is not empty parse scan request paramters */
 	memset(valid_chan_list, 0, sizeof(valid_chan_list));
 	list = (wl_uint32_list_t *)(void *) valid_chan_list;
-	list->count = htod32(WL_NUMCHANNELS);
-	err = wldev_ioctl(dev, WLC_GET_VALID_CHANNELS, valid_chan_list,
-		sizeof(valid_chan_list), false);
-	if (err != 0) {
-		ESCAN_ERROR(dev->name, "get channels failed with %d\n", err);
-		goto exit;
+
+	if (channel) {
+		list->count = htod32(1);
+		list->element[0] = htod32(channel);
+	} else {
+		list->count = htod32(WL_NUMCHANNELS);
+		err = wldev_ioctl(dev, WLC_GET_VALID_CHANNELS, valid_chan_list,
+			sizeof(valid_chan_list), false);
+		if (err != 0) {
+			ESCAN_ERROR(dev->name, "get channels failed with %d\n", err);
+			goto exit;
+		}
 	}
+
 	n_channels = dtoh32(list->count);
 	/* Allocate space for populating ssids in wl_escan_params_t struct */
 	if (dtoh32(list->count) % 2)
@@ -874,7 +880,7 @@
 		goto exit;
 	}
 	params->params.scan_type = DOT11_SCANTYPE_ACTIVE;
-	ESCAN_TRACE(dev->name, "Passive scan_type %d\n", params->params.scan_type);
+	ESCAN_SCAN(dev->name, "Passive scan_type %d\n", params->params.scan_type);
 
 	WL_MSG(dev->name, "LEGACY_SCAN\n");
 	err = wldev_iovar_setbuf(dev, "escan", params, params_size,
@@ -885,11 +891,9 @@
 			ESCAN_TRACE(dev->name, "Escan not permitted at this time (%d)\n", err);
 		else
 			ESCAN_ERROR(dev->name, "Escan set error (%d)\n", err);
-		wl_escan_reset(escan);
 	}
 	kfree(params);
 
-exit:
 	if (unlikely(err)) {
 		/* Don't print Error incase of Scan suppress */
 		if ((err == BCME_EPERM))
@@ -909,7 +913,10 @@
 		cnt = 0;
 		escan->dev = dev;
 	}
-exit2:
+exit:
+	if (unlikely(err)) {
+		wl_escan_reset(escan);
+	}
 	mutex_unlock(&escan->usr_sync);
 	return err;
 }
@@ -933,7 +940,7 @@
 }
 
 static int
-wl_escan_merge_scan_results(struct wl_escan_info *escan,
+wl_escan_merge_scan_results(struct net_device *dev, struct wl_escan_info *escan,
 	struct iw_request_info *info, char *extra, wl_bss_info_t *bi, int *len, int max_size)
 {
 	s32 err = BCME_OK;
@@ -942,6 +949,7 @@
 	char *event = extra, *end = extra + max_size - WE_ADD_EVENT_FIX, *value;
 	int16 rssi;
 	int channel;
+	chanspec_t chanspec;
 
 	/* overflow check cover fields before wpa IEs */
 	if (event + ETHER_ADDR_LEN + bi->SSID_len + IW_EV_UINT_LEN + IW_EV_FREQ_LEN +
@@ -958,9 +966,14 @@
 	// terence 20150419: limit the max. rssi to -2 or the bss will be filtered out in android OS
 	rssi = MIN(dtoh16(bi->RSSI), RSSI_MAXVAL);
 #endif
-	channel = wf_chspec_ctlchan(wl_chspec_driver_to_host(escan->ioctl_ver, bi->chanspec));
-	ESCAN_SCAN(escan->dev->name, "BSSID=%pM, channel=%3d, RSSI=%3d, SSID=\"%s\"\n",
-		&bi->BSSID, channel, rssi, bi->SSID);
+	chanspec = wl_chspec_driver_to_host(escan->ioctl_ver, bi->chanspec);
+	channel = wf_chspec_ctlchan(chanspec);
+	ESCAN_SCAN(dev->name, "BSSID %pM, channel %3d(%3d %sMHz), rssi %3d, SSID \"%s\"\n",
+		&bi->BSSID, channel, CHSPEC_CHANNEL(chanspec),
+		CHSPEC_IS20(chanspec)?"20":
+		CHSPEC_IS40(chanspec)?"40":
+		CHSPEC_IS80(chanspec)?"80":"160",
+		rssi, bi->SSID);
 
 	/* First entry must be the BSSID */
 	iwe.cmd = SIOCGIWAP;
@@ -1035,16 +1048,17 @@
 	}
 	*len = event - extra;
 	if (*len < 0)
-		ESCAN_ERROR(escan->dev->name, "==> Wrong size\n");
+		ESCAN_ERROR(dev->name, "==> Wrong size\n");
 
 exit:
 	return err;
 }
 
 int
-wl_escan_get_scan(struct net_device *dev, struct wl_escan_info *escan,
+wl_escan_get_scan(struct net_device *dev, dhd_pub_t *dhdp,
 	struct iw_request_info *info, struct iw_point *dwrq, char *extra)
 {
+	struct wl_escan_info *escan = dhdp->escan;
 	s32 err = BCME_OK;
 	int i = 0;
 	int len_prep = 0, len_ret = 0;
@@ -1066,7 +1080,7 @@
 
 	/* Check for scan in progress */
 	if (escan->escan_state == ESCAN_STATE_SCANING) {
-		ESCAN_TRACE(dev->name, "SIOCGIWSCAN GET still scanning\n");
+		ESCAN_DBG(dev->name, "SIOCGIWSCAN GET still scanning\n");
 		err = -EAGAIN;
 		goto exit;
 	}
@@ -1081,7 +1095,7 @@
 		goto exit;
 	}
 
-	ESCAN_TRACE(dev->name, "SIOCGIWSCAN, len=%d\n", dwrq->length);
+	ESCAN_SCAN(dev->name, "SIOCGIWSCAN, len=%d\n", dwrq->length);
 
 	err = wldev_ioctl(dev, WLC_GET_BSSID, &cur_bssid, sizeof(cur_bssid), false);
 	if (err != BCME_NOTASSOCIATED && memcmp(&ether_null, &cur_bssid, ETHER_ADDR_LEN)) {
@@ -1100,7 +1114,7 @@
 		}
 		bi = (struct wl_bss_info *)(buf + 4);
 		len_prep = 0;
-		err = wl_escan_merge_scan_results(escan, info, extra+len_ret, bi,
+		err = wl_escan_merge_scan_results(dev, escan, info, extra+len_ret, bi,
 			&len_prep, buflen_from_user-len_ret);
 		len_ret += len_prep;
 		if (err)
@@ -1129,7 +1143,7 @@
 			continue;
 		}
 		len_prep = 0;
-		err = wl_escan_merge_scan_results(escan, info, extra+len_ret, bi,
+		err = wl_escan_merge_scan_results(dev, escan, info, extra+len_ret, bi,
 			&len_prep, buflen_from_user-len_ret);
 		len_ret += len_prep;
 		if (err)
@@ -1150,7 +1164,250 @@
 	mutex_unlock(&escan->usr_sync);
 	return err;
 }
-#endif
+#endif /* WL_WIRELESS_EXT */
+
+#ifdef WLMESH
+bool
+wl_escan_meshid_ie(u8 *parse, u32 len, wlc_ssid_t *mesh_id)
+{
+	bcm_tlv_t *ie;
+
+	if((ie = bcm_parse_tlvs(parse, (int)len, DOT11_MNG_MESH_ID)) != NULL) {
+		mesh_id->SSID_len = ie->len;
+		if (ie->len) {
+			strncpy(mesh_id->SSID, ie->data, ie->len);
+		}
+		return TRUE;
+	}
+	return FALSE;
+}
+
+bool
+wl_escan_rsn_ie(u8 *parse, u32 len)
+{
+	if (bcm_parse_tlvs(parse, (u32)len, DOT11_MNG_RSN_ID)) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+void
+wl_escan_mesh_info_ie(u8 *parse, u32 len, struct wl_mesh_params *mesh_info)
+{
+	bcm_tlv_t *ie;
+	uchar mesh_oui[]={0x00, 0x22, 0xf4};
+	int totl_len;
+	uint8 *pie;
+
+	if((ie = bcm_parse_tlvs(parse, (int)len, DOT11_MNG_VS_ID)) != NULL) {
+		totl_len = ie->len;
+		if (!memcmp(ie->data, &mesh_oui, sizeof(mesh_oui))) {
+			pie = ie->data + sizeof(mesh_oui);
+			ie = (bcm_tlv_t *)pie;
+			totl_len -= sizeof(mesh_oui);
+			while (totl_len > 2 && ie->len) {
+				if (ie->id == MESH_INFO_MASTER_BSSID && ie->len == ETHER_ADDR_LEN) {
+					memcpy(&mesh_info->master_bssid, ie->data, ETHER_ADDR_LEN);
+				} else if (ie->id == MESH_INFO_MASTER_CHANNEL) {
+					mesh_info->master_channel = ie->data[0];
+				} else if (ie->id == MESH_INFO_HOP_CNT) {
+					mesh_info->hop_cnt = ie->data[0];
+				} else if (ie->id == MESH_INFO_PEER_BSSID) {
+					memcpy(&mesh_info->peer_bssid, ie->data, ETHER_ADDR_LEN);
+				}
+				totl_len -= (ie->len + 2);
+				pie = ie->data + ie->len;
+				ie = (bcm_tlv_t *)pie;
+			}
+		}
+	}
+}
+
+int
+wl_escan_mesh_info(struct net_device *dev, struct wl_escan_info *escan, 
+	struct ether_addr *peer_bssid, struct wl_mesh_params *mesh_info)
+{
+	s32 err = BCME_OK;
+	int i = 0;
+	wl_bss_info_t *bi = NULL;
+	struct wl_scan_results *bss_list;
+	int16 bi_rssi, bi_chan;
+	wlc_ssid_t bi_meshid;
+	bool is_mesh_peer = FALSE;
+	struct wl_mesh_params peer_mesh_info;
+
+	mutex_lock(&escan->usr_sync);
+
+	/* Check for scan in progress */
+	if (escan->escan_state == ESCAN_STATE_SCANING) {
+		ESCAN_ERROR(dev->name, "SIOCGIWSCAN GET still scanning\n");
+		err = -EAGAIN;
+		goto exit;
+	}
+	if (!escan->bss_list) {
+		ESCAN_ERROR(dev->name, "scan not ready\n");
+		err = -EAGAIN;
+		goto exit;
+	}
+	if (dev != escan->dev) {
+		ESCAN_ERROR(dev->name, "not my scan from %s\n", escan->dev->name);
+		err = -EINVAL;
+		goto exit;
+	}
+
+	bss_list = escan->bss_list;
+	bi = next_bss(bss_list, bi);
+	ESCAN_SCAN(dev->name, "scanned AP/Mesh count (%d)\n", bss_list->count);
+	for_each_bss(bss_list, bi, i)
+	{
+		memset(&bi_meshid, 0, sizeof(bi_meshid));
+		is_mesh_peer = FALSE;
+		bi_chan = wf_chspec_ctlchan(
+			wl_chspec_driver_to_host(escan->ioctl_ver, bi->chanspec));
+		bi_rssi = MIN(dtoh16(bi->RSSI), RSSI_MAXVAL);
+		is_mesh_peer = wl_escan_meshid_ie(((u8*)bi)+bi->ie_offset,
+			bi->ie_length, &bi_meshid);
+		if (!(bi->capability & (DOT11_CAP_ESS|DOT11_CAP_IBSS)) && is_mesh_peer) {
+			bool bi_sae = FALSE, bss_found = FALSE;
+			if (!memcmp(peer_bssid, &bi->BSSID, ETHER_ADDR_LEN)) {
+				bi_sae = wl_escan_rsn_ie(((u8*)bi)+bi->ie_offset, bi->ie_length);
+				memset(&peer_mesh_info, 0, sizeof(peer_mesh_info));
+				wl_escan_mesh_info_ie(((u8*)bi)+bi->ie_offset, bi->ie_length,
+					&peer_mesh_info);
+				if (peer_mesh_info.hop_cnt) {
+					memcpy(&mesh_info->master_bssid, &peer_mesh_info.master_bssid,
+						ETHER_ADDR_LEN);
+					mesh_info->master_channel = peer_mesh_info.master_channel;
+					mesh_info->hop_cnt = peer_mesh_info.hop_cnt;
+					memcpy(&mesh_info->peer_bssid, &peer_mesh_info.peer_bssid,
+						ETHER_ADDR_LEN);
+					mesh_info->channel = bi_chan;
+					bss_found = TRUE;
+				}
+			}
+			ESCAN_SCAN(dev->name,
+				"%s[Mesh] BSSID=%pM, channel=%d, RSSI=%d, sec=%s, "
+				"mbssid=%pM, mchannel=%d, hop=%d, pbssid=%pM, MeshID=\"%s\"\n",
+				bss_found?"*":" ", &bi->BSSID, bi_chan, bi_rssi, bi_sae?"SAE":"OPEN",
+				&peer_mesh_info.master_bssid, peer_mesh_info.master_channel,
+				peer_mesh_info.hop_cnt, &peer_mesh_info.peer_bssid, bi_meshid.SSID);
+		}
+	}
+
+exit:
+	mutex_unlock(&escan->usr_sync);
+	return err;
+}
+
+int
+wl_escan_mesh_peer(struct net_device *dev, struct wl_escan_info *escan, 
+	wlc_ssid_t *cur_ssid, uint16 cur_chan, bool sae,
+	struct wl_mesh_params *mesh_info)
+{
+	s32 err = BCME_OK;
+	int i = 0;
+	wl_bss_info_t *bi = NULL;
+	struct wl_scan_results *bss_list;
+	int16 bi_rssi, bi_chan, max_rssi = -100;
+	uint min_hop_cnt = 255;
+	wlc_ssid_t bi_meshid;
+	bool is_mesh_peer = FALSE, chan_matched = FALSE;
+	struct wl_mesh_params peer_mesh_info;
+
+	mutex_lock(&escan->usr_sync);
+
+	/* Check for scan in progress */
+	if (escan->escan_state == ESCAN_STATE_SCANING) {
+		ESCAN_ERROR(dev->name, "SIOCGIWSCAN GET still scanning\n");
+		err = -EAGAIN;
+		goto exit;
+	}
+	if (!escan->bss_list) {
+		ESCAN_ERROR(dev->name, "scan not ready\n");
+		err = -EAGAIN;
+		goto exit;
+	}
+	if (dev != escan->dev) {
+		ESCAN_ERROR(dev->name, "not my scan from %s\n", escan->dev->name);
+		err = -EINVAL;
+		goto exit;
+	}
+
+	bss_list = escan->bss_list;
+	bi = next_bss(bss_list, bi);
+	ESCAN_SCAN(dev->name, "scanned AP/Mesh count (%d)\n", bss_list->count);
+	for_each_bss(bss_list, bi, i)
+	{
+		memset(&bi_meshid, 0, sizeof(bi_meshid));
+		is_mesh_peer = FALSE;
+		bi_chan = wf_chspec_ctlchan(
+			wl_chspec_driver_to_host(escan->ioctl_ver, bi->chanspec));
+		bi_rssi = MIN(dtoh16(bi->RSSI), RSSI_MAXVAL);
+		is_mesh_peer = wl_escan_meshid_ie(((u8*)bi)+bi->ie_offset,
+			bi->ie_length, &bi_meshid);
+		if (!(bi->capability & (DOT11_CAP_ESS|DOT11_CAP_IBSS)) && is_mesh_peer) {
+			bool meshid_matched = FALSE, sec_matched = FALSE, bi_sae = FALSE,
+				bss_found = FALSE;
+
+			if (cur_ssid->SSID_len && cur_ssid->SSID_len == bi_meshid.SSID_len &&
+					!memcmp(cur_ssid->SSID, bi_meshid.SSID, bi_meshid.SSID_len))
+				meshid_matched = TRUE;
+
+			bi_sae = wl_escan_rsn_ie(((u8*)bi)+bi->ie_offset, bi->ie_length);
+			if (bi_sae == sae)
+				sec_matched = TRUE;
+
+			memset(&peer_mesh_info, 0, sizeof(peer_mesh_info));
+			wl_escan_mesh_info_ie(((u8*)bi)+bi->ie_offset, bi->ie_length,
+				&peer_mesh_info);
+
+			if (meshid_matched && sec_matched && peer_mesh_info.hop_cnt &&
+					(cur_chan == bi_chan)) {
+				if (peer_mesh_info.hop_cnt < min_hop_cnt) {
+					memcpy(&mesh_info->master_bssid, &peer_mesh_info.master_bssid,
+						ETHER_ADDR_LEN);
+					mesh_info->master_channel = peer_mesh_info.master_channel;
+					mesh_info->hop_cnt = peer_mesh_info.hop_cnt;
+					memcpy(&mesh_info->peer_bssid, &peer_mesh_info.peer_bssid,
+						ETHER_ADDR_LEN);
+					mesh_info->channel = bi_chan;
+					min_hop_cnt = peer_mesh_info.hop_cnt;
+					bss_found = TRUE;
+					chan_matched = TRUE;
+				}
+			} else if (meshid_matched && sec_matched && peer_mesh_info.hop_cnt &&
+					(cur_chan != bi_chan) && !chan_matched) {
+				if (bi_rssi > max_rssi) {
+					memcpy(&mesh_info->master_bssid, &peer_mesh_info.master_bssid,
+						ETHER_ADDR_LEN);
+					mesh_info->master_channel = peer_mesh_info.master_channel;
+					mesh_info->hop_cnt = peer_mesh_info.hop_cnt;
+					memcpy(&mesh_info->peer_bssid, &peer_mesh_info.peer_bssid,
+						ETHER_ADDR_LEN);
+					mesh_info->channel = bi_chan;
+					max_rssi = bi_rssi;
+					bss_found = TRUE;
+				}
+			}
+
+			ESCAN_SCAN(dev->name,
+				"%s[Mesh] BSSID=%pM, channel=%d, RSSI=%d, sec=%s, "
+				"mbssid=%pM, mchannel=%d, hop=%d, pbssid=%pM, MeshID=\"%s\"\n",
+				bss_found?"*":" ", &bi->BSSID, bi_chan, bi_rssi, bi_sae?"SAE":"OPEN",
+				&peer_mesh_info.master_bssid, peer_mesh_info.master_channel,
+				peer_mesh_info.hop_cnt, &peer_mesh_info.peer_bssid, bi_meshid.SSID);
+		} else {
+			ESCAN_SCAN(dev->name,
+				"[AP] BSSID=%pM, channel=%d, RSSI=%d, SSID=\"%s\"\n",
+				&bi->BSSID, bi_chan, bi_rssi, bi->SSID);
+		}
+	}
+
+exit:
+	mutex_unlock(&escan->usr_sync);
+	return err;
+}
+#endif /* WLMESH */
 
 static void
 wl_escan_deinit(struct net_device *dev, struct wl_escan_info *escan)
@@ -1174,50 +1431,57 @@
 	ESCAN_TRACE(dev->name, "Enter\n");
 
 	/* Init scan_timeout timer */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	timer_setup(&escan->scan_timeout, wl_escan_timeout, 0);
-#else
-	init_timer(&escan->scan_timeout);
-	escan->scan_timeout.data = (unsigned long) escan;
-	escan->scan_timeout.function = wl_escan_timeout;
-#endif
+	init_timer_compat(&escan->scan_timeout, wl_escan_timeout, escan);
 	escan->escan_state = ESCAN_STATE_IDLE;
 
 	return 0;
 }
 
 void
-wl_escan_down(struct net_device *dev, struct wl_escan_info *escan)
+wl_escan_down(struct net_device *dev, dhd_pub_t *dhdp)
 {
+	struct wl_escan_info *escan = dhdp->escan;
+
 	ESCAN_TRACE(dev->name, "Enter\n");
+	if (!escan) {
+		ESCAN_ERROR(dev->name, "escan is NULL\n");
+		return;
+	}
+
 	wl_escan_deinit(dev, escan);
 }
 
 int
-wl_escan_up(struct net_device *dev, struct wl_escan_info *escan)
+wl_escan_up(struct net_device *dev, dhd_pub_t *dhdp)
 {
+	struct wl_escan_info *escan = dhdp->escan;
 	s32 val = 0;
-	int err;
+	int ret = -1;
 
 	ESCAN_TRACE(dev->name, "Enter\n");
-	err = wl_escan_init(dev, escan);
-	if (err) {
-		ESCAN_ERROR(dev->name, "wl_escan_init err %d\n", err);
-		return err;
+	if (!escan) {
+		ESCAN_ERROR(dev->name, "escan is NULL\n");
+		return ret;
+	}
+
+	ret = wl_escan_init(dev, escan);
+	if (ret) {
+		ESCAN_ERROR(dev->name, "wl_escan_init ret %d\n", ret);
+		return ret;
 	}
 
 	if (!escan->ioctl_ver) {
 		val = 1;
-		if ((err = wldev_ioctl(dev, WLC_GET_VERSION, &val, sizeof(int), false) < 0)) {
-			ESCAN_ERROR(dev->name, "WLC_GET_VERSION failed, err=%d\n", err);
-			return err;
+		if ((ret = wldev_ioctl(dev, WLC_GET_VERSION, &val, sizeof(int), false) < 0)) {
+			ESCAN_ERROR(dev->name, "WLC_GET_VERSION failed, ret=%d\n", ret);
+			return ret;
 		}
 		val = dtoh32(val);
 		if (val != WLC_IOCTL_VERSION && val != 1) {
 			ESCAN_ERROR(dev->name,
 				"Version mismatch, please upgrade. Got %d, expected %d or 1\n",
 				val, WLC_IOCTL_VERSION);
-			return err;
+			return ret;
 		}
 		escan->ioctl_ver = val;
 	}
@@ -1225,28 +1489,79 @@
 	return 0;
 }
 
+int
+wl_escan_event_dettach(struct net_device *dev, dhd_pub_t *dhdp)
+{
+	struct wl_escan_info *escan = dhdp->escan;
+	int ret = -1;
+
+	if (!escan) {
+		ESCAN_ERROR(dev->name, "escan is NULL\n");
+		return ret;
+	}
+
+	wl_ext_event_deregister(dev, dhdp, WLC_E_ESCAN_RESULT, wl_escan_handler);
+
+	return 0;
+}
+
+int
+wl_escan_event_attach(struct net_device *dev, dhd_pub_t *dhdp)
+{
+	struct wl_escan_info *escan = dhdp->escan;
+	int ret = -1;
+
+	if (!escan) {
+		ESCAN_ERROR(dev->name, "escan is NULL\n");
+		return ret;
+	}
+
+	ret = wl_ext_event_register(dev, dhdp, WLC_E_ESCAN_RESULT, wl_escan_handler,
+		escan, PRIO_EVENT_ESCAN);
+	if (ret) {
+		ESCAN_ERROR(dev->name, "wl_ext_event_register err %d\n", ret);
+	}
+
+	return ret;
+}
+
 void
-wl_escan_detach(struct net_device *dev, dhd_pub_t *dhdp,
-	struct wl_escan_info *escan)
+wl_escan_detach(struct net_device *dev, dhd_pub_t *dhdp)
 {
+	struct wl_escan_info *escan = dhdp->escan;
+
 	ESCAN_TRACE(dev->name, "Enter\n");
 
+	if (!escan)
+		return;
+
 	wl_escan_deinit(dev, escan);
 	if (escan->escan_ioctl_buf) {
 		kfree(escan->escan_ioctl_buf);
 		escan->escan_ioctl_buf = NULL;
 	}
 	wl_ext_event_deregister(dev, dhdp, WLC_E_ESCAN_RESULT, wl_escan_handler);
+
+	DHD_OS_PREFREE(dhdp, escan, sizeof(struct wl_escan_info));
+	dhdp->escan = NULL;
 }
 
 int
-wl_escan_attach(struct net_device *dev, dhd_pub_t *dhdp,
-	struct wl_escan_info *escan)
+wl_escan_attach(struct net_device *dev, dhd_pub_t *dhdp)
 {
+	struct wl_escan_info *escan = NULL;
 	int ret = 0;
 
 	ESCAN_TRACE(dev->name, "Enter\n");
 
+	escan = (struct wl_escan_info *)DHD_OS_PREALLOC(dhdp,
+		DHD_PREALLOC_WL_ESCAN, sizeof(struct wl_escan_info));
+	if (!escan)
+		return -ENOMEM;
+	memset(escan, 0, sizeof(struct wl_escan_info));
+
+	dhdp->escan = escan;
+
 	/* we only care about main interface so save a global here */
 	escan->pub = dhdp;
 	escan->escan_state = ESCAN_STATE_DOWN;
@@ -1263,17 +1578,11 @@
 		goto exit;
 	}
 	mutex_init(&escan->usr_sync);
-	ret = wl_ext_event_register(dev, dhdp, WLC_E_ESCAN_RESULT, wl_escan_handler,
-		escan, PRIO_EVENT_ESCAN);
-	if (ret) {
-		ESCAN_ERROR(dev->name, "wl_ext_event_register err %d\n", ret);
-		goto exit;
-	}
 
 	return 0;
 
 exit:
-	wl_escan_detach(dev, dhdp, escan);
+	wl_escan_detach(dev, dhdp);
 	return ret;
 }
 
diff -urN a/drivers/net/wireless/bcmdhd/wl_escan.h a/drivers/net/wireless/bcmdhd/wl_escan.h
--- a/drivers/net/wireless/bcmdhd/wl_escan.h	2020-01-13 17:57:02.414432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_escan.h	2019-09-22 05:32:37.000000000 +0300
@@ -1,56 +1,78 @@
-
-#ifndef _wl_escan_
-#define _wl_escan_
-#include <wl_iw.h>
-
-#define ESCAN_BUF_SIZE (64 * 1024)
-
-#define WL_ESCAN_TIMER_INTERVAL_MS	10000 /* Scan timeout */
-
-/* donlge escan state */
-enum escan_state {
-	ESCAN_STATE_DOWN,
-	ESCAN_STATE_IDLE,
-	ESCAN_STATE_SCANING
-};
-
-typedef struct wl_escan_info {
-	struct net_device *dev;
-	dhd_pub_t *pub;
-	struct timer_list scan_timeout;   /* Timer for catch scan event timeout */
-	int escan_state;
-	int ioctl_ver;
-	char ioctlbuf[WLC_IOCTL_SMLEN];
-	u8 escan_buf[ESCAN_BUF_SIZE];
-	struct wl_scan_results *bss_list;
-	struct wl_scan_results *scan_results;
-	struct ether_addr disconnected_bssid;
-	u8 *escan_ioctl_buf;
-	struct mutex usr_sync;	/* maily for up/down synchronization */
-	int autochannel;
-	int best_2g_ch;
-	int best_5g_ch;
-#if defined(RSSIAVG)
-	wl_rssi_cache_ctrl_t g_rssi_cache_ctrl;
-	wl_rssi_cache_ctrl_t g_connected_rssi_cache_ctrl;
-#endif
-#if defined(BSSCACHE)
-	wl_bss_cache_ctrl_t g_bss_cache_ctrl;
-#endif
-} wl_escan_info_t;
-
-int wl_escan_set_scan(struct net_device *dev, struct wl_escan_info *escan,
-	wlc_ssid_t *ssid, bool bcast);
-int wl_escan_get_scan(struct net_device *dev, struct wl_escan_info *escan,
-	struct iw_request_info *info, struct iw_point *dwrq, char *extra);
-s32 wl_escan_handler(struct net_device *dev, struct wl_escan_info *escan,
-	const wl_event_msg_t *e, void *data);
-int wl_escan_attach(struct net_device *dev, dhd_pub_t *dhdp,
-	struct wl_escan_info *escan);
-void wl_escan_detach(struct net_device *dev, dhd_pub_t *dhdp,
-	struct wl_escan_info *escan);
-int wl_escan_up(struct net_device *dev, struct wl_escan_info *escan);
-void wl_escan_down(struct net_device *dev, struct wl_escan_info *escan);
-
-#endif /* _wl_escan_ */
-
+
+#ifndef _wl_escan_
+#define _wl_escan_
+#include <linuxver.h>
+#include <wl_iw.h>
+
+#define ESCAN_BUF_SIZE (64 * 1024)
+
+#define WL_ESCAN_TIMER_INTERVAL_MS	10000 /* Scan timeout */
+
+/* donlge escan state */
+enum escan_state {
+	ESCAN_STATE_DOWN,
+	ESCAN_STATE_IDLE,
+	ESCAN_STATE_SCANING
+};
+
+typedef struct wl_escan_info {
+	struct net_device *dev;
+	dhd_pub_t *pub;
+	timer_list_compat_t scan_timeout;   /* Timer for catch scan event timeout */
+	int escan_state;
+	int ioctl_ver;
+	u8 escan_buf[ESCAN_BUF_SIZE];
+	struct wl_scan_results *bss_list;
+	struct ether_addr disconnected_bssid;
+	u8 *escan_ioctl_buf;
+	struct mutex usr_sync;	/* maily for up/down synchronization */
+	int autochannel;
+	int best_2g_ch;
+	int best_5g_ch;
+#if defined(RSSIAVG)
+	wl_rssi_cache_ctrl_t g_rssi_cache_ctrl;
+	wl_rssi_cache_ctrl_t g_connected_rssi_cache_ctrl;
+#endif
+#if defined(BSSCACHE)
+	wl_bss_cache_ctrl_t g_bss_cache_ctrl;
+#endif
+} wl_escan_info_t;
+
+#if defined(WLMESH)
+/* donlge escan state */
+enum mesh_info_id {
+	MESH_INFO_MASTER_BSSID = 1,
+	MESH_INFO_MASTER_CHANNEL,
+	MESH_INFO_HOP_CNT,
+	MESH_INFO_PEER_BSSID
+};
+
+typedef struct wl_mesh_params {
+	struct ether_addr master_bssid;
+	uint16 master_channel;
+	uint hop_cnt;
+	struct ether_addr peer_bssid;
+	uint16 channel;
+	uint16 scan_channel;
+} wl_mesh_params_t;
+int wl_escan_mesh_info(struct net_device *dev,
+	struct wl_escan_info *escan, struct ether_addr *peer_bssid,
+	struct wl_mesh_params *mesh_info);
+int wl_escan_mesh_peer(struct net_device *dev,
+	struct wl_escan_info *escan, wlc_ssid_t *cur_ssid, uint16 cur_chan, bool sae,
+	struct wl_mesh_params *mesh_info);
+#endif /* WLMESH */
+
+int wl_escan_set_scan(struct net_device *dev, dhd_pub_t *dhdp,
+	wlc_ssid_t *ssid, uint16 channel, bool bcast);
+int wl_escan_get_scan(struct net_device *dev, dhd_pub_t *dhdp,
+	struct iw_request_info *info, struct iw_point *dwrq, char *extra);
+int wl_escan_attach(struct net_device *dev, dhd_pub_t *dhdp);
+void wl_escan_detach(struct net_device *dev, dhd_pub_t *dhdp);
+int wl_escan_event_attach(struct net_device *dev, dhd_pub_t *dhdp);
+int wl_escan_event_dettach(struct net_device *dev, dhd_pub_t *dhdp);
+int wl_escan_up(struct net_device *dev, dhd_pub_t *dhdp);
+void wl_escan_down(struct net_device *dev, dhd_pub_t *dhdp);
+
+#endif /* _wl_escan_ */
+
diff -urN a/drivers/net/wireless/bcmdhd/wl_event.c a/drivers/net/wireless/bcmdhd/wl_event.c
--- a/drivers/net/wireless/bcmdhd/wl_event.c	2020-01-13 17:57:02.414432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_event.c	2020-01-14 08:37:54.000000000 +0300
@@ -82,8 +82,12 @@
 	struct event_handler_head evt_head;
 	struct list_head eq_list;	/* used for event queue */
 	spinlock_t eq_lock;	/* for event queue synchronization */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0))
+	tsk_ctl_t thr_event_ctl;
+#else
 	struct workqueue_struct *event_workq;   /* workqueue for event */
 	struct work_struct event_work;		/* work item for event */
+#endif
 	struct mutex event_sync;
 } wl_event_params_t;
 
@@ -192,16 +196,36 @@
 	kfree(e);
 }
 
-static void
-wl_ext_event_handler(struct work_struct *work_data)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0))
+static int wl_ext_event_handler(void *data);
+#define WL_EXT_EVENT_HANDLER() static int wl_ext_event_handler(void *data)
+#else
+static void wl_ext_event_handler(struct work_struct *data);
+#define WL_EXT_EVENT_HANDLER() static void wl_ext_event_handler(struct work_struct *data)
+#endif
+
+WL_EXT_EVENT_HANDLER()
 {
 	struct wl_event_params *event_params = NULL;
 	struct wl_event_q *e;
 	struct net_device *dev = NULL;
 	struct event_handler_list *evt_node;
 	dhd_pub_t *dhd;
-
-	BCM_SET_CONTAINER_OF(event_params, work_data, struct wl_event_params, event_work);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0))
+	tsk_ctl_t *tsk = (tsk_ctl_t *)data;
+	event_params = (struct wl_event_params *)tsk->parent;
+#else
+	BCM_SET_CONTAINER_OF(event_params, data, struct wl_event_params, event_work);
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0))
+	while (1) {
+	if (down_interruptible(&tsk->sema) == 0) {
+		SMP_RD_BARRIER_DEPENDS();
+		if (tsk->terminated) {
+			break;
+		}
+#endif
 	DHD_EVENT_WAKE_LOCK(event_params->pub);
 	while ((e = wl_ext_event_deq_event(event_params))) {
 		if (e->emsg.ifidx >= DHD_MAX_IFS) {
@@ -210,7 +234,7 @@
 		}
 		dev = event_params->dev[e->emsg.ifidx];
 		if (!dev) {
-			EVENT_ERROR("wlan", "ifidx=%d dev not ready\n", e->emsg.ifidx);
+			EVENT_DBG("wlan", "ifidx=%d dev not ready\n", e->emsg.ifidx);
 			goto fail;
 		}
 		dhd = dhd_get_pub(dev);
@@ -236,6 +260,13 @@
 		wl_ext_event_put_event(e);
 	}
 	DHD_EVENT_WAKE_UNLOCK(event_params->pub);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0))
+	} else {
+		break;
+	}
+	}
+	complete_and_exit(&tsk->completed, 0);
+#endif
 }
 
 void
@@ -250,14 +281,22 @@
 		return;
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
 	if (event_params->event_workq == NULL) {
 		EVENT_ERROR("wlan", "Event handler is not created %d(%s)\n",
 			event_type, bcmevent_get_name(event_type));
 		return;
 	}
+#endif
 
 	if (likely(!wl_ext_event_enq_event(event_params, event_type, e, data))) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0))
+		if (event_params->thr_event_ctl.thr_pid >= 0) {
+			up(&event_params->thr_event_ctl.sema);
+		}
+#else
 		queue_work(event_params->event_workq, &event_params->event_work);
+#endif
 	}
 }
 
@@ -267,6 +306,12 @@
 	int ret = 0;
 	EVENT_TRACE("wlan", "Enter\n");
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0))
+	PROC_START(wl_ext_event_handler, event_params, &event_params->thr_event_ctl, 0, "ext_eventd");
+	if (event_params->thr_event_ctl.thr_pid < 0) {
+		ret = -ENOMEM;
+	}
+#else
 	/* Allocate workqueue for event */
 	if (!event_params->event_workq) {
 		event_params->event_workq = alloc_workqueue("ext_eventd", WQ_MEM_RECLAIM | WQ_HIGHPRI, 0);
@@ -278,6 +323,8 @@
 	} else {
 		INIT_WORK(&event_params->event_work, wl_ext_event_handler);
 	}
+#endif
+
 	return ret;
 }
 
@@ -301,11 +348,17 @@
 static void
 wl_ext_event_destroy_handler(struct wl_event_params *event_params)
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0))
+	if (event_params->thr_event_ctl.thr_pid >= 0) {
+		PROC_STOP(&event_params->thr_event_ctl);
+	}
+#else
 	if (event_params && event_params->event_workq) {
 		cancel_work_sync(&event_params->event_work);
 		destroy_workqueue(event_params->event_workq);
 		event_params->event_workq = NULL;
 	}
+#endif
 }
 
 int
@@ -441,7 +494,7 @@
 	struct wl_event_params *event_params = dhd->event_params;
 
 	EVENT_TRACE(net->name, "ifidx=%d, bssidx=%d\n", ifidx, bssidx);
-	if (event_params) {
+	if (event_params && ifidx < WL_MAX_IFS) {
 		event_params->dev[ifidx] = net;
 	}
 
@@ -455,7 +508,7 @@
 	struct wl_event_params *event_params = dhd->event_params;
 
 	EVENT_TRACE(net->name, "ifidx=%d\n", ifidx);
-	if (event_params) {
+	if (event_params && ifidx < WL_MAX_IFS) {
 		event_params->dev[ifidx] = NULL;
 	}
 
diff -urN a/drivers/net/wireless/bcmdhd/wl_iw.c a/drivers/net/wireless/bcmdhd/wl_iw.c
--- a/drivers/net/wireless/bcmdhd/wl_iw.c	2020-01-13 17:57:02.415432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_iw.c	2019-12-22 19:34:49.000000000 +0300
@@ -51,8 +51,6 @@
 #endif
 #include <dhd_config.h>
 
-typedef const struct si_pub	si_t;
-
 uint iw_msg_level = WL_ERROR_LEVEL;
 
 #define WL_ERROR_MSG(x, args...) \
@@ -196,7 +194,7 @@
 
 typedef struct iscan_info {
 	struct net_device *dev;
-	struct timer_list timer;
+	timer_list_compat_t timer;
 	uint32 timer_ms;
 	uint32 timer_on;
 	int    iscan_state;
@@ -229,9 +227,7 @@
 	struct mutex pm_sync;
 	struct wl_conn_info conn_info;
 	struct pmk_list pmk_list;
-#ifdef WL_ESCAN
-	struct wl_escan_info escan;
-#else
+#ifndef WL_ESCAN
 	struct iscan_info iscan;
 #endif
 } wl_wext_info_t;
@@ -631,29 +627,31 @@
 			return;
 		}
 		if (wpa_auth & (WPA_AUTH_PSK|WPA2_AUTH_PSK))
-			dhd->conf->eapol_status = EAPOL_STATUS_WPA_START;
+			dhd->conf->eapol_status = EAPOL_STATUS_4WAY_START;
 		else
 			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
 	} else if (status == WL_EXT_STATUS_ADD_KEY) {
-		dhd->conf->eapol_status = EAPOL_STATUS_WPA_END;
+		dhd->conf->eapol_status = EAPOL_STATUS_4WAY_DONE;
+		wake_up_interruptible(&dhd->conf->event_complete);
 	} else if (status == WL_EXT_STATUS_DISCONNECTING) {
 		wl_ext_add_remove_pm_enable_work(wext_info, FALSE);
-		if (cur_eapol_status >= EAPOL_STATUS_WPA_START &&
-				cur_eapol_status < EAPOL_STATUS_WPA_END) {
+		if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
+				cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
 			WL_ERROR(("WPA failed at %d\n", cur_eapol_status));
 			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
-		} else if (cur_eapol_status >= EAPOL_STATUS_WPS_WSC_START &&
-				cur_eapol_status < EAPOL_STATUS_WPS_DONE) {
+		} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
+				cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
 			WL_ERROR(("WPS failed at %d\n", cur_eapol_status));
 			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
 		}
 	} else if (status == WL_EXT_STATUS_DISCONNECTED) {
-		if (cur_eapol_status >= EAPOL_STATUS_WPA_START &&
-				cur_eapol_status < EAPOL_STATUS_WPA_END) {
+		if (cur_eapol_status >= EAPOL_STATUS_4WAY_START &&
+				cur_eapol_status < EAPOL_STATUS_4WAY_DONE) {
 			WL_ERROR(("WPA failed at %d\n", cur_eapol_status));
 			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
-		} else if (cur_eapol_status >= EAPOL_STATUS_WPS_WSC_START &&
-				cur_eapol_status < EAPOL_STATUS_WPS_DONE) {
+			wake_up_interruptible(&dhd->conf->event_complete);
+		} else if (cur_eapol_status >= EAPOL_STATUS_WSC_START &&
+				cur_eapol_status < EAPOL_STATUS_WSC_DONE) {
 			WL_ERROR(("WPS failed at %d\n", cur_eapol_status));
 			dhd->conf->eapol_status = EAPOL_STATUS_NONE;
 		}
@@ -1537,7 +1535,7 @@
 		}
 	}
 #endif
-	return wl_escan_set_scan(dev, &wext_info->escan, &ssid, TRUE);
+	return wl_escan_set_scan(dev, dhd, &ssid, 0, TRUE);
 #else
 	iscan = &wext_info->iscan;
 	WL_TRACE(("%s: SIOCSIWSCAN iscan=%p\n", dev->name, iscan));
@@ -1926,8 +1924,8 @@
 
 	DHD_CHECK(dhd, dev);
 	wext_info = dhd->wext_info;
- #ifdef WL_ESCAN
-	return wl_escan_get_scan(dev, &wext_info->escan, info, dwrq, extra);
+#ifdef WL_ESCAN
+	return wl_escan_get_scan(dev, dhd, info, dwrq, extra);
 #else
 	WL_TRACE(("%s SIOCGIWSCAN\n", dev->name));
 
@@ -3984,7 +3982,7 @@
 
 	memset(&scb_val, 0, sizeof(scb_val));
 	if ((res = dev_wlc_ioctl(dev, WLC_GET_RSSI, &scb_val, sizeof(scb_val_t)))) {
-		WL_ERROR(("WLC_GET_RSSI error=%d\n", res));
+		WL_TRACE(("WLC_GET_RSSI error=%d\n", res));
 		goto done;
 	}
 
@@ -4080,19 +4078,9 @@
 
 #ifndef WL_ESCAN
 static void
-wl_iw_timerfunc(
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	struct timer_list *t
-#else
-	unsigned long data
-#endif
-)
+wl_iw_timerfunc(ulong data)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	iscan_info_t *iscan = from_timer(iscan, t, timer);
-#else
 	iscan_info_t *iscan = (iscan_info_t *)data;
-#endif
 	iscan->timer_on = 0;
 	if (iscan->iscan_state != ISCAN_STATE_IDLE) {
 		WL_TRACE(("timer trigger\n"));
@@ -4304,6 +4292,38 @@
 }
 #endif /* !WL_ESCAN */
 
+void
+wl_iw_detach(struct net_device *dev, dhd_pub_t *dhdp)
+{
+	wl_wext_info_t *wext_info = dhdp->wext_info;
+#ifndef WL_ESCAN
+	iscan_buf_t  *buf;
+	iscan_info_t *iscan;
+#endif
+	if (!wext_info)
+		return;
+
+#ifndef WL_ESCAN
+	iscan = &wext_info->iscan;
+	if (iscan->sysioc_pid >= 0) {
+		KILL_PROC(iscan->sysioc_pid, SIGTERM);
+		wait_for_completion(&iscan->sysioc_exited);
+	}
+
+	while (iscan->list_hdr) {
+		buf = iscan->list_hdr->next;
+		kfree(iscan->list_hdr);
+		iscan->list_hdr = buf;
+	}
+#endif
+	wl_ext_add_remove_pm_enable_work(wext_info, FALSE);
+	wl_ext_event_deregister(dev, dhdp, WLC_E_LAST, wl_iw_event);
+	if (wext_info) {
+		kfree(wext_info);
+		dhdp->wext_info = NULL;
+	}
+}
+
 int
 wl_iw_attach(struct net_device *dev, dhd_pub_t *dhdp)
 {
@@ -4317,8 +4337,7 @@
 		return 0;
 	WL_TRACE(("Enter\n"));
 
-	wext_info = (wl_wext_info_t *)DHD_OS_PREALLOC(dhdp,
-		DHD_PREALLOC_WL_WEXT_INFO, sizeof(struct wl_wext_info));
+	wext_info = (void *)kzalloc(sizeof(struct wl_wext_info), GFP_KERNEL);
 	if (!wext_info)
 		return -ENOMEM;
 	memset(wext_info, 0, sizeof(wl_wext_info_t));
@@ -4327,11 +4346,7 @@
 	wext_info->conn_info.bssidx = 0;
 	dhdp->wext_info = (void *)wext_info;
 
-#ifdef WL_ESCAN
-	ret = wl_escan_attach(dev, dhdp, &wext_info->escan);
-	if (ret)
-		goto exit;
-#else
+#ifndef WL_ESCAN
 	iscan = &wext_info->iscan;
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0))
 	iscan->kthread = NULL;
@@ -4343,13 +4358,7 @@
 
 	/* Set up the timer */
 	iscan->timer_ms    = 2000;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
-	timer_setup(&iscan->timer, wl_iw_timerfunc, 0);
-#else
-	init_timer(&iscan->timer);
-	iscan->timer.data = (ulong)iscan;
-	iscan->timer.function = wl_iw_timerfunc;
-#endif
+	init_timer_compat(&iscan->timer, wl_iw_timerfunc, iscan);
 
 	sema_init(&iscan->sysioc_sem, 0);
 	init_completion(&iscan->sysioc_exited);
@@ -4375,48 +4384,11 @@
 
 	return ret;
 exit:
-	if (wext_info) {
-		DHD_OS_PREFREE(dhdp, wext_info, sizeof(struct wl_conn_info));
-		dhdp->wext_info = NULL;
-	}
+	wl_iw_detach(dev, dhdp);
 	return ret;
 }
 
 void
-wl_iw_detach(struct net_device *dev, dhd_pub_t *dhdp)
-{
-	wl_wext_info_t *wext_info = dhdp->wext_info;
-#ifndef WL_ESCAN
-	iscan_buf_t  *buf;
-	iscan_info_t *iscan;
-#endif
-	if (!wext_info)
-		return;
-
-#ifdef WL_ESCAN
-	wl_escan_detach(dev, dhdp, &wext_info->escan);
-#else
-	iscan = &wext_info->iscan;
-	if (iscan->sysioc_pid >= 0) {
-		KILL_PROC(iscan->sysioc_pid, SIGTERM);
-		wait_for_completion(&iscan->sysioc_exited);
-	}
-
-	while (iscan->list_hdr) {
-		buf = iscan->list_hdr->next;
-		kfree(iscan->list_hdr);
-		iscan->list_hdr = buf;
-	}
-#endif
-	wl_ext_add_remove_pm_enable_work(wext_info, FALSE);
-	wl_ext_event_deregister(dev, dhdp, WLC_E_LAST, wl_iw_event);
-	if (wext_info) {
-		DHD_OS_PREFREE(dhdp, wext_info, sizeof(struct wl_conn_info));
-		dhdp->wext_info = NULL;
-	}
-}
-
-void
 wl_iw_down(struct net_device *dev, dhd_pub_t *dhdp)
 {
 	wl_wext_info_t *wext_info = NULL;
@@ -4427,9 +4399,6 @@
 		WL_ERROR (("dhd is NULL\n"));
 		return;
 	}
-#ifdef WL_ESCAN
-	wl_escan_down(dev, &wext_info->escan);
-#endif
 	wl_ext_add_remove_pm_enable_work(wext_info, FALSE);
 }
 
@@ -4445,9 +4414,6 @@
 		WL_ERROR (("dhd is NULL\n"));
 		return -ENODEV;
 	}
-#ifdef WL_ESCAN
-	ret = wl_escan_up(dev, &wext_info->escan);
-#endif
 
 	return ret;
 }
@@ -4465,13 +4431,13 @@
 	DHD_CHECK(dhd, dev);
 	wext_info = dhd->wext_info;
 #ifdef WL_ESCAN
-	sscanf(command, "%*s %d", &wext_info->escan.autochannel);
-	if (wext_info->escan.autochannel == 0) {
-		wext_info->escan.best_2g_ch = 0;
-		wext_info->escan.best_5g_ch = 0;
-	} else if (wext_info->escan.autochannel == 2) {
+	sscanf(command, "%*s %d", &dhd->escan->autochannel);
+	if (dhd->escan->autochannel == 0) {
+		dhd->escan->best_2g_ch = 0;
+		dhd->escan->best_5g_ch = 0;
+	} else if (dhd->escan->autochannel == 2) {
 		bytes_written = snprintf(command, total_len, "2g=%d 5g=%d",
-			wext_info->escan.best_2g_ch, wext_info->escan.best_5g_ch);
+			dhd->escan->best_2g_ch, dhd->escan->best_5g_ch);
 		WL_TRACE(("command result is %s\n", command));
 		ret = bytes_written;
 	}
diff -urN a/drivers/net/wireless/bcmdhd/wl_iw.h a/drivers/net/wireless/bcmdhd/wl_iw.h
--- a/drivers/net/wireless/bcmdhd/wl_iw.h	2020-01-13 17:57:02.415432656 +0300
+++ a/drivers/net/wireless/bcmdhd/wl_iw.h	2019-09-19 16:27:13.000000000 +0300
@@ -109,7 +109,7 @@
 } wl_iw_t;
 
 struct wl_ctrl {
-	struct timer_list *timer;
+	timer_list_compat_t *timer;
 	struct net_device *dev;
 	long sysioc_pid;
 	struct semaphore sysioc_sem;
