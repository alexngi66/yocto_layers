--- a/drivers/mmc/host/Kconfig	2018-11-23 10:16:15.096870307 +0300
+++ a/drivers/mmc/host/Kconfig	2018-11-23 10:31:03.772052537 +0300
@@ -3,6 +3,22 @@
 #
 
 comment "MMC/SD/SDIO Host Controller Drivers"
+config SP_SDV2
+	tristate "Sunplus Gemini SoC SD Host Controller support"
+	default y
+	help
+	  If you say yes here, you will get support for the Secure Digital Host
+	  Interface on Sunplus SoCs. This includes support for SD cards.
+
+	  If unsure, say N.
+
+config SP_EMMC
+	bool "Sunplus Gemini eMMC Host Controller v4.51 support"
+	default y
+	help
+	  If you say yes here, you will get support for eMMC host interface 
+	  on sunplus Socs.
+	  If unsure, say N.
 
 config MMC_ARMMMCI
 	tristate "ARM AMBA Multimedia Card Interface support"
--- a/drivers/mmc/host/Makefile	2018-11-23 10:16:15.096870307 +0300
+++ a/drivers/mmc/host/Makefile	2018-11-23 10:31:03.773052477 +0300
@@ -84,6 +84,8 @@
 obj-$(CONFIG_MMC_SDHCI_ST)		+= sdhci-st.o
 obj-$(CONFIG_MMC_SDHCI_MICROCHIP_PIC32)	+= sdhci-pic32.o
 obj-$(CONFIG_MMC_SDHCI_BRCMSTB)		+= sdhci-brcmstb.o
+obj-$(CONFIG_SP_EMMC)				+= spemmc.o
+obj-$(CONFIG_SP_SDV2)				+= spsdv2.o
 
 ifeq ($(CONFIG_CB710_DEBUG),y)
 	CFLAGS-cb710-mmc	+= -DDEBUG
--- a/drivers/mmc/host/spemmc.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/mmc/host/spemmc.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,1270 @@
+/******************************************************************************
+*                          Include File
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <asm/uaccess.h>
+
+#include <linux/mmc/sd.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+
+#include <linux/miscdevice.h>
+#include <asm/cacheflush.h>
+#include <linux/of.h>
+#include <linux/interrupt.h>
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+
+#include <asm-generic/io.h>
+#include <asm/bitops.h>
+#include "spemmc.h"
+
+#ifdef SP_MMC_SUPPORT_DDR_MODE
+#define SP_MMC_DDR_READ_CRC_STATUS_DLY 0
+#define SP_MMC_DDR_WRITE_DLY 1
+#endif
+
+/******************************************************************************
+*                          MACRO Function Define
+*******************************************************************************/
+#define SPEMMC_MAX_CLOCK  CLOCK_52M     /* Max supported SD Card frequency */
+#define SPEMMC_CLK_SOURCE CLOCK_202M    /* Host controller's clk source */
+#define SPEMMCV2_SDC_NAME "sunplus,sp-emmc"
+#define MAX_SDDEVICES   2
+#define SPEMMC_DEVICE_MASK 1
+#define SPEMMC_READ_DELAY  2		/* delay for sampling data */
+#define SPEMMC_WRITE_DELAY 1		/* delay for output data   */
+#define DUMMY_COCKS_AFTER_DATA     8
+
+#define MAX_DLY_CLK     7 		/* max  delay clocks */
+#define ENABLE_TIMING_TUNING 0
+
+/* log levels */
+#define MMC_LOGLEVEL_FATAL		0x01
+#define MMC_LOGLEVEL_ERROR		0x02
+#define MMC_LOGLEVEL_DEBUG		0x04
+#define MMC_LOGLEVEL_IF 		0x10
+#define MMC_LOGLEVEL_PK 		0x20
+#define MMC_LOGLEVEL_COUNTER	0x100
+#define MMC_LOGLEVEL_WAITTIME	0x200
+#define MMC_LOGLEVEL_DUMPREG	0x1000
+#define MMC_LOGLEVEL_MINI		0x2000
+
+/* enable fatal error messages temporarily */
+static u32 loglevel = 0x003;
+
+#if 1
+#define FATAL(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_FATAL)) \
+		printk(KERN_ERR "[eMMC FATAL]: %s: " fmt, __func__ , ## args)
+
+#define EPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_ERROR)) \
+		printk(KERN_ERR "[eMMC ERROR]: %s: " fmt, __func__ , ## args)
+
+#define DPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_DEBUG)) \
+		printk(KERN_INFO "[eMMC DBG]: %s: " fmt, __func__ , ## args)
+
+#define IFPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_IF)) \
+		printk(KERN_NOTICE "[eMMC IF]: %s:" fmt, __func__, ## args)
+
+#define pk(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_PK)) \
+		printk(KERN_NOTICE "[eMMC PK]: %s: " fmt, __func__ , ## args)
+
+#define CPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_COUNTER)) \
+		printk(KERN_INFO "[eMMC COUNTER]: %s: " fmt, __func__ , ## args)
+
+#define WPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_WAITTIME)) \
+		printk(KERN_INFO "[eMMC WAITTIME]: %s: " fmt, __func__ , ## args)
+
+#define REGPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_DUMPREG)) \
+		printk(KERN_INFO "[eMMC REG]: %s: " fmt, __func__ , ## args)
+
+#define MPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_MINI)) \
+		printk(KERN_INFO "[eMMC]: %s: " fmt, __func__ , ## args)
+
+#else
+
+#define FATAL(fmt, args...)
+#define EPRINTK(fmt, args...)
+#define DPRINTK(fmt, args...)
+#define IFPRINTK(fmt, args...)
+#define pk(fmt, args...)
+#define CPRINTK(fmt, args...)
+#define WPRINTK(fmt, args...)
+#define REGPRINTK(fmt, args...)
+#define MPRINTK(fmt, args...)
+
+#endif
+
+#define IS_DMA_ADDR_2BYTE_ALIGNED(x)  (!((x) & 0x1))
+
+
+/******************************************************************************
+*                          Global Variables
+*******************************************************************************/
+
+const static spemmc_dridata_t spemmc_driv_data[] = {
+	{.id = 0,},
+};
+
+static const struct of_device_id spemmc_of_id[] = {
+	{
+		.compatible = "sunplus,sp-emmc",
+		.data = &spemmc_driv_data[0],
+	},
+	{}
+
+};
+MODULE_DEVICE_TABLE(of, spemmc_of_id);
+
+
+
+/******************************************************************************
+*                         Function Prototype
+*******************************************************************************/
+static int spemmc_get_dma_dir(SPEMMCHOST *, struct mmc_data *);
+static void sphe_mmc_finish_request(SPEMMCHOST *, struct mmc_request *);
+static void spemmc_set_cmd(SPEMMCHOST *host, struct mmc_request *mrq);
+static void spemmc_set_data_info(SPEMMCHOST *host, struct mmc_data * data);
+static void spemmc_prepare_cmd_rsp(SPEMMCHOST *host);
+
+static inline bool is_crc_token_valid(SPEMMCHOST *host)
+{
+	return (host->base->sdcrdcrc == 0x2 || host->base->sdcrdcrc == 0x5);
+}
+
+static int pinmux_enable(void *host)
+{
+#define REG_BASE					0x9c000000
+#define RF_GRP(_grp, _reg)			((((_grp) * 32 + (_reg)) * 4) + REG_BASE)
+#define RF_MASK_V(_mask, _val)      (((_mask) << 16) | (_val))
+#define RF_MASK_V_SET(_mask)        (((_mask) << 16) | (_mask))
+#define RF_MASK_V_CLR(_mask)        (((_mask) << 16) | 0)
+
+	volatile void __iomem  *reg  = ioremap_nocache(RF_GRP(1, 1), 4);
+	if (reg) {
+		writel(RF_MASK_V_CLR(1 << 4), reg);
+		writel(RF_MASK_V(1 << 5, 1 << 5), reg);
+	}
+	else {
+		printk("ioremap fail\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int emmc_set_in_clock(void *host)
+{
+	return 0;
+}
+
+static int emmc_get_in_clock(void *host)
+{
+	return SPEMMC_CLK_SOURCE;
+}
+
+
+static int Sd_Bus_Reset_Channel(SPEMMCHOST *host)
+{
+	/*reset Central FIFO*/
+	host->base->hw_dma_rst = 1;
+	/* Wait for channel reset to complete */
+	while (host->base->hwsd_sm & SP_EMMC_HW_DMA_ERROR) {
+	}
+
+	return SPEMMC_SUCCESS;
+}
+
+static int Reset_Controller(SPEMMCHOST *host)
+{
+	DPRINTK("controller reset\n");
+	EMMC_RST_seq(host->base);
+	return Sd_Bus_Reset_Channel(host);
+}
+
+static void spemmc_controller_init(SPEMMCHOST *host)
+{
+	host->base->sdddrmode = 0;
+	host->base->sdpiomode = 1;
+	host->base->rx4b_en = 1;
+	host->base->sdiomode = SP_EMMC_CARD;
+
+	host->base->sdrsptmr = 0x7ff;
+	host->base->sdrsptmren = 1;
+	host->base->sdcrctmr = 0x7ff;
+	host->base->sdcrctmren = 1;
+	host->base->sdmmcmode = SP_MMC_MODE;
+	host->base->sd_rxdattmr = SP_EMMC_RXDATTMR_MAX;
+	host->base->mediatype = 6;
+}
+/*
+ * Set SD card clock divider value based on the required clock in HZ
+ * TODO: Linux passes clock as 0, look into it
+ */
+static void spemmc_set_ac_timing(SPEMMCHOST *host, struct mmc_ios *ios)
+{
+	struct mmc_host *mmc = host->mmc;
+	uint clkrt, sys_clk, act_clock;
+	uint rd_dly = SPEMMC_READ_DELAY, wr_dly = SPEMMC_WRITE_DELAY;
+	uint clock = ios->clock;
+	/* Check if requested frequency is above/below supported range */
+	if (clock < mmc->f_min)
+		clock = mmc->f_min;
+	else if (clock > mmc->f_max)
+		clock = mmc->f_max;
+
+	sys_clk = emmc_get_in_clock(host);
+	clkrt = (sys_clk / clock) - 1;
+
+	/* Calculate the actual clock for the divider used */
+	act_clock = sys_clk / (clkrt + 1);
+	if (act_clock > clock)
+		clkrt++;
+	/* printk("sys_clk =%u, act_clock=%u, clkrt = %u\n", sys_clk, act_clock, clkrt); */
+	/* check clock divider boundary and correct it */
+	if (clkrt > 0xFFF)
+		clkrt = 0xFFF;
+
+	host->base->sdfqsel = clkrt;
+
+	/* Delay 4 msecs for now (wait till clk stabilizes?) */
+	mdelay(4);
+
+	if (ios->timing != MMC_TIMING_LEGACY) {
+		host->base->sd_high_speed_en = 1;
+		if ((ios->timing == MMC_TIMING_UHS_DDR50) || (ios->timing == MMC_TIMING_MMC_DDR52)) {
+			host->base->sdddrmode = 1;
+		}
+	} else {
+		host->base->sd_high_speed_en = 0;
+	}
+
+	/* Write delay: Controls CMD, DATA signals timing to SD Card */
+	host->base->sd_wr_dly_sel = wr_dly;
+	/* Read delay: Controls timing to sample SD card's CMD, DATA signals */
+	host->base->sd_rd_dly_sel = rd_dly;
+	#ifdef SP_MMC_SUPPORT_DDR_MODE
+	host->ddr_rd_crc_token_dly = SP_MMC_DDR_READ_CRC_STATUS_DLY;
+	host->ddr_wr_data_dly = SP_MMC_DDR_WRITE_DLY;
+	#endif
+
+	return;
+}
+
+/* Sets bus width accordingly */
+static void spemmc_set_bus_width(SPEMMCHOST *host, u32 bus_width)
+{
+	switch (bus_width) {
+	case MMC_BUS_WIDTH_8:
+		host->base->sddatawd = 0;
+		host->base->mmc8_en = 1;
+		break;
+	case MMC_BUS_WIDTH_4:
+		host->base->sddatawd = 1;
+		host->base->mmc8_en = 0;
+		break;
+	case MMC_BUS_WIDTH_1:
+		host->base->sddatawd = 0;
+		host->base->mmc8_en = 0;
+		break;
+	default:
+		EPRINTK("unknown bus wide %d\n", bus_width);
+		break;
+	}
+
+	return;
+}
+
+static void spemmc_trigger_sdstate(SPEMMCHOST *host)
+{
+	host->base->sdctrl0 = 1;   /* Start transaction */
+}
+
+
+#define SP_EMMC_WAIT_RSP_BUFF_FULL(host) \
+	do { \
+		while (1) { \
+			if ((host)->base->sdstatus & SP_SDSTATUS_RSP_BUF_FULL) \
+			break; \
+			if ((host)->base->sdstate_new & SDSTATE_NEW_ERROR_TIMEOUT) \
+			return; \
+		} \
+	} while (0)
+
+#define SP_MMC_SWAP32(x)		((((x) & 0x000000ff) << 24) | \
+				 (((x) & 0x0000ff00) <<  8) | \
+				 (((x) & 0x00ff0000) >>  8) | \
+				 (((x) & 0xff000000) >> 24)   \
+				)
+
+/*
+ * Receive 136 bits response, and pass it back to Linux
+ * Used for cmd+rsp and normal dma requests
+ * If error occurs, stop receiving response and return
+ * Note: Host doesn't support Response R2 CRC error check
+ */
+static void spemmc_get_rsp_136(SPEMMCHOST *host)
+{
+	unsigned int val[2];
+	struct mmc_command *cmd = host->mrq->cmd;
+	unsigned char rspBuf[17] = {0}; /* Used to store 17 bytes(136 bits) or 6 bytes(48 bits) response */
+
+	/*  read R2 response in 3 times, each time read 6 bytes */
+	SP_EMMC_WAIT_RSP_BUFF_FULL(host);
+		/*
+		 * Store received response buffer data.
+		 * Function runs to here only if no error occurs
+		 */
+	val[0] = host->base->sd_rspbuf[0];
+	val[1] = host->base->sd_rspbuf[1];
+	rspBuf[0] = (val[0] >> 16) & 0xff;  /* skip the first byte */
+	rspBuf[1] = (val[0] >> 8) & 0xff;
+	rspBuf[2] = (val[0] >> 0) & 0xff;
+	rspBuf[3] = (val[1] >> 8) & 0xff;
+	rspBuf[4] = (val[1] >> 0) & 0xff;
+
+	val[0] = host->base->sd_rspbuf[0];
+	val[1] = host->base->sd_rspbuf[1];
+	rspBuf[5] = (val[0] >> 24) & 0xff;
+	rspBuf[6] = (val[0] >> 16) & 0xff;
+	rspBuf[7] = (val[0] >> 8) & 0xff;
+	rspBuf[8] = (val[0] >> 0) & 0xff;
+	rspBuf[9] = (val[1] >> 8) & 0xff;
+	rspBuf[10] = (val[1] >> 0) & 0xff;
+
+	val[0] = host->base->sd_rspbuf[0];
+	val[1] = host->base->sd_rspbuf[1];
+	rspBuf[11] = (val[0] >> 24) & 0xff;
+	rspBuf[12] = (val[0] >> 16) & 0xff;
+	rspBuf[13] = (val[0] >> 8) & 0xff;
+	rspBuf[14] = (val[0] >> 0) & 0xff;
+	rspBuf[15] = (val[1] >> 8) & 0xff;
+
+
+	/*
+	 * Wait till host controller becomes idle or error occurs
+	 * The host may be busy sending 8 clk cycles for the end of a request
+	 */
+	while (1) {
+		if (host->base->sdstate_new & SDSTATE_NEW_FINISH_IDLE)
+			break;
+		if (host->base->sdstate_new & SDSTATE_NEW_ERROR_TIMEOUT)
+			return;
+	}
+
+	/*
+	 * Pass response back to Linux
+	 * Function runs to here only if no error occurs
+	 */
+	cmd->resp[0] = SP_MMC_SWAP32(*((unsigned int *)(rspBuf)));
+	cmd->resp[1] = SP_MMC_SWAP32(*((unsigned int *)(rspBuf + 4)));
+	cmd->resp[2] = SP_MMC_SWAP32(*((unsigned int *)(rspBuf + 8)));
+	cmd->resp[3] = SP_MMC_SWAP32(*((unsigned int *)(rspBuf + 12)));
+
+	return;
+}
+
+/*
+ * Receive 48 bits response, and pass it back to Linux
+ * Used for cmd+rsp and normal dma requests
+ * If error occurs, stop receiving response and return
+ */
+static void spemmc_get_rsp_48(SPEMMCHOST *host)
+{
+	struct mmc_command *cmd = host->mrq->cmd;
+	unsigned char rspBuf[6] = {0}; /* Used to store 6 bytes(48 bits) response */
+
+	/* Wait till host controller becomes idle or error occurs */
+	while (1) {
+		if (host->base->sdstate_new & SDSTATE_NEW_FINISH_IDLE)
+			break;
+		if (host->base->sdstate_new & SDSTATE_NEW_ERROR_TIMEOUT)
+			return;
+	}
+	/*
+	 * Store received response buffer data
+	 * Function runs to here only if no error occurs
+	 */
+	rspBuf[0] = host->base->sd_rspbuf0;
+	rspBuf[1] = host->base->sd_rspbuf1;
+	rspBuf[2] = host->base->sd_rspbuf2;
+	rspBuf[3] = host->base->sd_rspbuf3;
+	rspBuf[4] = host->base->sd_rspbuf4;
+	rspBuf[5] = host->base->sd_rspbuf5;
+
+	/* Pass response back to Linux */
+	cmd->resp[0] = (rspBuf[1] << 24) | (rspBuf[2] << 16) | (rspBuf[3] << 8) | rspBuf[4];
+	cmd->resp[1] = rspBuf[5] << 24;
+
+	return;
+}
+
+/*
+ * Retrieve response for cmd+rsp and normal dma request
+ * This function makes sure host returns to it's sdstate_new idle or error state
+ * Note: Error handling should be performed afterwards
+ */
+static void spemmc_get_rsp(SPEMMCHOST *host)
+{
+	struct mmc_command *cmd = host->mrq->cmd;
+
+	if (cmd->flags & MMC_RSP_136)
+		spemmc_get_rsp_136(host);
+	else
+		spemmc_get_rsp_48(host);
+
+	return;
+}
+
+#if 0
+ETIMEDOUT    Card took too long to respond
+EILSEQ       Basic format problem with the received or sent data
+(e.g. CRC check failed, incorrect opcode in response or bad end bit)
+#endif
+
+static void spemmc_check_sdstatus_errors(SPEMMCHOST *host)
+{
+	if (host->base->sdstate_new & SDSTATE_NEW_ERROR_TIMEOUT) {
+		EPRINTK("cmd %d error with sdstate = %x, sdstatus = %x\n",
+			host->mrq->cmd->opcode, host->base->sd_state, host->base->sdstatus);
+		/* Response related errors */
+		if (host->base->sdstatus & SP_SDSTATUS_WAIT_RSP_TIMEOUT)
+			host->mrq->cmd->error = -ETIMEDOUT;
+		if (host->base->sdstatus & SP_SDSTATUS_RSP_CRC7_ERROR)
+			host->mrq->cmd->error = -EILSEQ;
+
+		/* Only check the below error flags if data transaction is involved */
+		if(host->mrq->data) {
+			/* Data transaction related errors */
+			if (host->base->sdstatus & SP_SDSTATUS_WAIT_STB_TIMEOUT)
+				host->mrq->data->error = -ETIMEDOUT;
+			if (host->base->sdstatus & SP_SDSTATUS_WAIT_CARD_CRC_CHECK_TIMEOUT)
+				host->mrq->data->error = -ETIMEDOUT;
+
+			if (host->base->sdstatus & SP_SDSTATUS_CRC_TOKEN_CHECK_ERROR)
+				host->mrq->data->error = -EILSEQ;
+			if (host->base->sdstatus & SP_SDSTATUS_RDATA_CRC16_ERROR)
+				host->mrq->data->error = -EILSEQ;
+
+			/* Reset PBus channel */
+			Sd_Bus_Reset_Channel(host);
+		}
+	}
+
+	return;
+}
+
+/*
+ * Receive 48 bits response, and pass it back to kernel
+ * Used for interrupt transactions (don't need to wait sdstate_new to become idle)
+ */
+static void spemmc_get_response_48(SPEMMCHOST *host)
+{
+	unsigned char rspBuf[6] = {0}; /* Used to store 6 bytes(48 bits) response */
+
+	/* Store received response buffer data */
+	rspBuf[0] = host->base->sd_rspbuf0;
+	rspBuf[1] = host->base->sd_rspbuf1;
+	rspBuf[2] = host->base->sd_rspbuf2;
+	rspBuf[3] = host->base->sd_rspbuf3;
+	rspBuf[4] = host->base->sd_rspbuf4;
+	rspBuf[5] = host->base->sd_rspbuf5;
+
+	/* Pass response back to kernel */
+	host->mrq->cmd->resp[0] = (rspBuf[1] << 24) | (rspBuf[2] << 16) | (rspBuf[3] << 8) | rspBuf[4];
+	host->mrq->cmd->resp[1] = rspBuf[5] << 24;
+
+	return;
+}
+
+
+void dump_emmc_all_regs(SPEMMCHOST *host)
+{
+	volatile unsigned int *reg = (volatile unsigned int *)host->base;
+	int i, j;
+	for (i =  0; i < 5; i++){
+		for (j =  0; j < 32; j++){
+			printk("g%d.%d = 0x%08x\n", i, j, *reg);
+			reg++;
+		}
+	}
+}
+
+static void spemmc_irq_normDMA(SPEMMCHOST *host)
+{
+	struct mmc_data *data = host->mrq->data;
+
+	/* Get response */
+	spemmc_get_response_48(host);
+	/* Check error flags */
+	spemmc_check_sdstatus_errors(host);
+
+	if (host->base->sdstate_new & SDSTATE_NEW_FINISH_IDLE) {
+		data->bytes_xfered = data->blocks * data->blksz;
+	} else {
+		EPRINTK("normal DMA error!\n");
+		Sd_Bus_Reset_Channel(host);
+		data->bytes_xfered = 0;
+	}
+
+	host->base->sd_cmp_clr = 1;
+
+	return;
+}
+
+static void spemmc_irq_cmd_rsp(SPEMMCHOST *host)
+{
+	/* Get response */
+	spemmc_get_response_48(host);
+	/* Check error flags */
+	spemmc_check_sdstatus_errors(host);
+
+	host->base->sd_cmp_clr = 1;
+
+	return;
+}
+
+/* Interrupt Handler */
+irqreturn_t spemmc_irq(int irq, void *dev_id)
+{
+	struct mmc_host *mmc = dev_id;
+
+	SPEMMCHOST *host = (SPEMMCHOST *)mmc_priv(mmc);
+	/*ignore unexpected irq */
+	if(!host->base->sd_cmp &&
+			!host->base->hw_dma_en)
+	{
+		printk("!!!!!spemmc_irq:unknow int\n");
+		return IRQ_HANDLED;
+	}
+
+	if (host->mrq->data != NULL) {
+		spemmc_irq_normDMA(host);
+	} else { /* Cmd + Rsp(48 bits) IRQ */
+		spemmc_irq_cmd_rsp(host);
+	}
+	/* disbale interrupt to workaround unexpected irq*/
+	host->base->hwdmacmpen = 0;
+	host->base->sdcmpen = 0;
+	sphe_mmc_finish_request(host, host->mrq);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * 1. Releases semaphore for mmc_request
+ * 2. Notifies kernel that mmc_request is done
+ */
+static void sphe_mmc_finish_request(SPEMMCHOST *host, struct mmc_request *mrq)
+{
+	if (mrq->data) {
+		/*
+		 * The original sg_len may differ after dma_map_sg function callback.
+		 * When executing dma_unmap_sg, the memory segment count value returned
+		 * by dma_map_sg should be used instead (value is stored in host->dma_sgcount)
+		 */
+		dma_unmap_sg(mmc_dev(host->mmc), mrq->data->sg,
+				host->dma_sgcount,
+				spemmc_get_dma_dir(host, mrq->data));
+
+#ifdef SP_MMC_SUPPORT_DDR_MODE
+		if ((mrq->data->flags & MMC_DATA_WRITE) && host->base->sdddrmode) {
+			host->base->sd_rd_dly_sel =host->rddly;
+			host->base->sd_wr_dly_sel =host->wrdly;
+		}
+#endif
+		if(mrq->data->error && -EINVAL != mrq->data->error) {
+			#if (ENABLE_TIMING_TUNING == 1)
+			/* tune next data request timing */
+			host->need_tune_dat_timing = 1;
+			#endif
+			EPRINTK("data err(%d)\n", mrq->data->error);
+		}
+	}
+
+	if(mrq->cmd->error) {
+		#if (ENABLE_TIMING_TUNING == 1)
+		/* tune next cmd request timing */
+		host->need_tune_cmd_timing = 1;
+		#endif
+		EPRINTK("cmd err(%d)\n",mrq->cmd->error);
+	}
+
+	host->mrq = NULL;
+
+	up(&host->req_sem);
+	mmc_request_done(host->mmc, mrq);
+}
+
+static int spemmc_get_dma_dir(SPEMMCHOST *host, struct mmc_data *data)
+{
+	if (data->flags & MMC_DATA_WRITE)
+		return DMA_TO_DEVICE;
+	else
+		return DMA_FROM_DEVICE;
+}
+
+/* Get timeout_ns from kernel, and set it to HW DMA's register */
+static inline void spemmc_set_data_timeout(SPEMMCHOST *host)
+{
+	unsigned int timeout_clks, cycle_ns;
+
+	cycle_ns = (1000000000 * (1 + host->base->sdfqsel))  / emmc_get_in_clock(host);
+	timeout_clks = host->mrq->data->timeout_ns / cycle_ns;
+	timeout_clks +=  host->mrq->data->timeout_clks;
+
+	/*  kernel set max read timeout to for SDHC 100ms, */
+	/*  mult 10 to  Improve compatibility for some unstandard card */
+	if (host->mrq->data->flags & MMC_DATA_READ) {
+		timeout_clks *= READ_TIMEOUT_MULT;
+	}
+	else {
+		timeout_clks *= EMMC_WRITE_TIMEOUT_MULT;
+	}
+	host->base->sd_rxdattmr = timeout_clks;
+}
+
+/*
+ * DMA transfer mode, used for all other data transfer commands besides read/write block commands (cmd17, 18, 24, 25)
+ * Due to host limitations, this kind of DMA transfer mode only supports 1 consecutive memory area
+ */
+static void spemmc_proc_normDMA(SPEMMCHOST *host)
+{
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *data = mrq->data;
+	spemmc_prepare_cmd_rsp(host);
+	spemmc_set_data_info(host, data);
+
+	if (!data->error) {
+		/* Configure SD INT reg */
+		/* Disable HW DMA data transfer complete interrupt (when using sdcmpen) */
+		host->base->hwdmacmpen = 0;
+		host->base->sdcmpen = 0x1;
+		/* Start Transaction */
+		host->base->sdctrl0 = 1;
+	}
+	return;
+}
+
+static void spemmc_set_cmd(SPEMMCHOST *host, struct mmc_request *mrq)
+{
+	host->base->sd_cmdbuf[3] = (u8)(mrq->cmd->opcode | 0x40);	/* add start bit, according to spec, command format */
+	host->base->sd_cmdbuf[2] = (u8)((mrq->cmd->arg >> 24) & 0x000000ff);
+	host->base->sd_cmdbuf[1] = (u8)((mrq->cmd->arg >> 16) & 0x000000ff);
+	host->base->sd_cmdbuf[0] = (u8)((mrq->cmd->arg >>  8) & 0x000000ff);
+	host->base->sd_cmdbuf[4] = (u8)((mrq->cmd->arg >>  0) & 0x000000ff);
+}
+
+/* Prepare Command + Response commands (with no data), polling mode */
+static void spemmc_prepare_cmd_rsp(SPEMMCHOST *host)
+{
+	struct mmc_request *mrq = host->mrq;
+
+	/* Reset */
+	Reset_Controller(host);
+
+	/* Configure Group SD Registers */
+	spemmc_set_cmd(host, mrq);
+	host->base->sd_trans_mode = 0x0;
+	host->base->sdautorsp = 1;
+	host->base->sdcmddummy = 1;
+
+	/*
+	 * Currently, host is not capable of checking Response R2's CRC7
+	 * Because of this, enable response crc7 check only for 48 bit response commands
+	 */
+	if (mrq->cmd->flags & MMC_RSP_CRC && !(mrq->cmd->flags & MMC_RSP_136))
+		host->base->sdrspchk_en = 0x1;
+	else
+		host->base->sdrspchk_en = 0x0;
+
+	if (mrq->cmd->flags & MMC_RSP_136)
+		host->base->sdrsptype = 0x1;
+	else
+		host->base->sdrsptype = 0x0;
+
+	/* Configure SD INT reg (Disable them) */
+	host->base->hwdmacmpen = 0;
+	host->base->sdcmpen = 0x0;
+
+	return;
+}
+
+static void spemmc_set_data_info(SPEMMCHOST *host, struct mmc_data * data)
+{
+	int i, count = dma_map_sg(mmc_dev(host->mmc), data->sg,
+							  data->sg_len,
+							  spemmc_get_dma_dir(host, data));
+	struct scatterlist *sg;
+	unsigned int hw_address[SP_HW_DMA_MEMORY_SECTORS] = {0}, hw_len[SP_HW_DMA_MEMORY_SECTORS] = {0};
+
+	/* Store the dma_mapped memory segment count, it will be used when calling dma_unmap_sg */
+	host->dma_sgcount = count;
+
+	/* retreive physical memory address & size of the fragmented memory blocks */
+	for_each_sg(data->sg, sg, count, i) {
+		hw_address[i] = sg_dma_address(sg);
+		hw_len[i] = sg_dma_len(sg);
+		if(unlikely(!IS_DMA_ADDR_2BYTE_ALIGNED(hw_address[i]))) {
+			EPRINTK("dma addr is not 2 bytes aligned!\n");
+			data->error = -EINVAL;
+			return;
+		}
+	}
+
+	/* Due to host limitations, normal DMA transfer mode only supports 1 consecutive physical memory area */
+	if (count == 1) {
+		DPRINTK("page num = %d\n", data->blocks);
+		EMMC_PAGE_NUM_SET(host->base, data->blocks);
+		if (data->flags & MMC_DATA_READ) {
+			host->base->sdcmddummy = 0;
+			host->base->sdautorsp = 0;
+			host->base->sd_trans_mode = 2;
+		} else {
+			host->base->sdcmddummy = 1;
+			host->base->sdautorsp = 1;
+			host->base->sd_trans_mode = 1;
+		}
+		if (host->mrq->stop)
+			host->base->sd_len_mode = 0;
+		else
+			host->base->sd_len_mode = 1;
+
+		host->base->sdpiomode = 0;
+		host->base->hw_dma_en = 0;
+		SDDATALEN_SET(host->base, data->blksz);
+
+		/* Configure Group DMA Registers */
+		if (data->flags & MMC_DATA_WRITE) {
+			host->base->dmadst = 0x2;
+			host->base->dmasrc = 0x1;
+		} else {
+			host->base->dmadst = 0x1;
+			host->base->dmasrc = 0x2;
+		}
+		SET_DMA_BASE_ADDR(host->base, hw_address[0]);
+
+#ifdef SP_MMC_SUPPORT_DDR_MODE
+		if ((data->flags & MMC_DATA_WRITE) && host->base->sdddrmode) {
+			host->wrdly = host->base->sd_wr_dly_sel;
+			host->rddly = host->base->sd_rd_dly_sel;
+			host->base->sd_rd_dly_sel = host->ddr_rd_crc_token_dly;
+			host->base->sd_wr_dly_sel = host->ddr_wr_data_dly;
+		}
+#endif
+	} else {
+		/* Should be implemented to fallback and use PIO transfer mode in the future */
+		EPRINTK("SD Card DMA memory segment > 1, not supported!\n");
+		data->error = -EINVAL;
+	}
+	return;
+}
+
+/* Process Command + Response commands (with no data) , interrupt mode */
+static void spemmc_mmc_proc_cmd_rsp_intr(SPEMMCHOST *host)
+{
+	struct mmc_request *mrq = host->mrq;
+
+	DPRINTK("Process Command & Response (No Data)\n");
+	/* Reset */
+	Reset_Controller(host);
+
+	/* Configure Group SD Registers */
+	spemmc_set_cmd(host, mrq);
+
+	host->base->sd_trans_mode = 0x0;
+	host->base->sdautorsp = 1;
+	host->base->sdcmddummy = 1;
+
+	/* Currently, host is not capable of checking Response R2's CRC7
+	   Because of this, enable response crc7 check only for 48 bit response commands
+	 */
+	if (mrq->cmd->flags & MMC_RSP_CRC && !(mrq->cmd->flags & MMC_RSP_136))
+		host->base->sdrspchk_en = 0x1;
+	else
+		host->base->sdrspchk_en = 0x0;
+
+	if (mrq->cmd->flags & MMC_RSP_136)
+		host->base->sdrsptype = 0x1;
+	else
+		host->base->sdrsptype = 0x0;
+
+	/* Configure SD INT reg */
+	/* Disable HW DMA data transfer complete interrupt (when using sdcmpen) */
+	host->base->hwdmacmpen = 0;
+	host->base->sdcmpen = 0x1;
+
+	/* Start Transaction */
+	host->base->sdctrl0 = 1;
+
+	return;
+}
+
+/* Process Command + No Response commands (with no data) */
+static void spemmc_mmc_proc_cmd(SPEMMCHOST *host)
+{
+	struct mmc_request *mrq = host->mrq;
+
+	/* Reset */
+	Reset_Controller(host);
+
+	/* Configure Group SD Registers */
+	spemmc_set_cmd(host, mrq);
+
+	host->base->sd_trans_mode = 0x0;
+	host->base->sdautorsp = 0;
+	host->base->sdcmddummy = 1;
+
+	/* Configure SD INT reg */
+	/* Disable HW DMA data transfer complete interrupt (when using sdcmpen) */
+	host->base->hwdmacmpen = 0;
+	host->base->sdcmpen = 0x0;
+
+	/* Start Transaction */
+	host->base->sdctrl0 = 1;
+
+	while((host->base->sdstate_new & SDSTATE_NEW_FINISH_IDLE) != 0x40) {
+		/* printk("Waiting! sd_hw_state : 0x%x   LMST_SM:0x%x   Data In Counter :%u Data Out Counter: %u\n", host->base->hwsd_sm, host->base->lmst_sm, host->base->incnt, host->base->outcnt); */
+		/* printk("sd status:0x%x, state:0x%x, state new:0x%x\n", host->base->sdstatus, host->base->sdstate, host->base->sdstate_new); */
+		/* printk("Waiting\n"); */
+	}
+
+	sphe_mmc_finish_request(host, host->mrq);
+}
+
+/* For mmc_requests
+ * ================ Data transfer requests ===========================
+ * 1. Data transfer requests : use interrupt mode
+ * ================= Non data transfer requests =======================
+ * 1. Command + Response (48 bit response) requests : use interrupt mode
+ * 2. Command + Response (136 bit response) requests : use polling mode
+ * 3. Command (no response) requests : use polling mode
+ */
+void spemmc_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	SPEMMCHOST *host = mmc_priv(mmc);
+	int retry_count = (host->need_tune_cmd_timing || host->need_tune_dat_timing) ? MAX_DLY_CLK : 0;
+
+	DPRINTK("\n<-- cmd:%d, arg:0x%08x, data len:%d, stop:%s\n",
+		mrq->cmd->opcode, mrq->cmd->arg,
+		mrq->data ? (mrq->data->blocks * mrq->data->blksz) : 0,
+		mrq->stop ? "true" : "false");
+
+	/*
+	 * The below semaphore is released when "sphe_mmc_finish_request" is called
+	 * TODO: Observe if the below semaphore is necessary
+	 */
+	down(&host->req_sem);
+	host->mrq = mrq;
+
+	if (mrq->data == NULL) {
+		if (host->mrq->cmd->flags & MMC_RSP_PRESENT) {
+			if (unlikely(host->need_tune_cmd_timing || host->mrq->cmd->flags & MMC_RSP_136)) {
+				do {
+					spemmc_prepare_cmd_rsp(host);
+					spemmc_trigger_sdstate(host);
+					spemmc_get_rsp(host); /* Makes sure host returns to an idle or error state */
+					spemmc_check_sdstatus_errors(host);
+					if (-EILSEQ == mrq->cmd->error) {
+						host->base->sd_rd_dly_sel++;
+					} else if (-ETIMEDOUT == mrq->cmd->error) {
+						host->base->sd_wr_dly_sel++;
+					} else {
+						break;
+					}
+				} while(retry_count--);
+				if (!mrq->cmd->error)
+					host->need_tune_cmd_timing = 0;
+				sphe_mmc_finish_request(host, host->mrq);
+			} else {
+				spemmc_mmc_proc_cmd_rsp_intr(host);
+			}
+		} else {
+			spemmc_mmc_proc_cmd(host);
+		}
+	} else {
+		if (unlikely(host->need_tune_dat_timing)) {
+			do {
+				spemmc_prepare_cmd_rsp(host);
+				spemmc_set_data_info(host, mrq->data);
+				if(-EINVAL == mrq->data->error) {
+					break;
+				}
+				spemmc_trigger_sdstate(host);
+				spemmc_get_rsp(host); /* Makes sure host returns to an idle or error state */
+				spemmc_check_sdstatus_errors(host);
+				if (-EILSEQ == mrq->data->error) {
+					if (mrq->data->flags & MMC_DATA_WRITE) {
+						if (is_crc_token_valid(host))
+							host->base->sd_wr_dly_sel++;
+						else
+							host->base->sd_rd_dly_sel++;
+					} else {
+						host->base->sd_rd_dly_sel++;
+					}
+				} else if (-ETIMEDOUT == mrq->data->error) {
+					host->base->sd_wr_dly_sel++;
+				} else {
+					break;
+				}
+				#ifdef SP_MMC_SUPPORT_DDR_MODE
+				if ((mrq->data->flags & MMC_DATA_WRITE) && host->base->sdddrmode) {
+					host->ddr_rd_crc_token_dly = host->base->sd_rd_dly_sel;
+					host->ddr_wr_data_dly = host->base->sd_wr_dly_sel;
+				}
+				#endif
+			} while(retry_count--);
+			if (!mrq->data->error)
+				host->need_tune_dat_timing = 0;
+			sphe_mmc_finish_request(host, host->mrq);
+		} else {
+			spemmc_proc_normDMA(host);
+			if(-EINVAL == host->mrq->data->error) { /*  para is not correct return */
+				sphe_mmc_finish_request(host, host->mrq);
+			}
+		}
+	}
+}
+
+/* set_ios -
+ * 1) Set/Disable clock
+ * 2) Power on/off to offer SD card or not
+ * 3) Set SD Card Bus width to 1 or 4
+ */
+void spemmc_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	SPEMMCHOST *host = (SPEMMCHOST *)mmc_priv(mmc);
+
+	IFPRINTK("\n<----- sd%d: clk:%d, buswidth:%d(2^n), bus_mode:%d, powermode:%d(0:off, 1:up, 2:on), timing:%d\n",
+		host->id, ios->clock, ios->bus_width, ios->bus_mode, ios->power_mode, ios->timing);
+
+	down(&host->req_sem);
+
+	/* TODO: Cleanup power_mode functions */
+	switch (ios->power_mode) {
+	/* power off->up->on */
+	case MMC_POWER_ON:
+		DPRINTK("set MMC_POWER_ON\n");
+		spemmc_controller_init(host);
+		break;
+	case MMC_POWER_UP:
+		/* Set default control register */
+		DPRINTK("set MMC_POWER_UP\n");
+		Reset_Controller(host);
+		break;
+	case MMC_POWER_OFF:
+		Reset_Controller(host);
+		DPRINTK("set MMC_POWER_OFF\n");
+		break;
+	}
+
+	spemmc_set_ac_timing(host, ios);
+	spemmc_set_bus_width(host, ios->bus_width);
+	host->need_tune_cmd_timing = 0;
+	host->need_tune_dat_timing = 0;
+
+	up(&host->req_sem);
+	IFPRINTK("----- \n\n");
+
+	return;
+}
+
+int spemmc_mmc_read_only(struct mmc_host *mmc)
+{
+	/* return  > 0 :support read only */
+	/*         < 0 :not support RO */
+	/*         = 0 :no action */
+	return -ENOSYS;
+}
+
+
+/*
+ * Return values for the get_cd callback should be:
+ *   0 for a absent card
+ *   1 for a present card
+ *   -ENOSYS when not supported (equal to NULL callback)
+ *   or a negative errno value when something bad happened
+ */
+int spemmc_mmc_card_detect(struct mmc_host *mmc)
+{
+	// SPEMMCHOST *host = mmc_priv(mmc);
+
+	return 1;
+}
+
+static void spemmc_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	SPEMMCHOST *host = mmc_priv(mmc);
+	if (enable) {
+		host->base->sdio_int_en = 1;
+	} else {
+		host->base->sdio_int_en = 0;
+	}
+}
+
+const struct mmc_host_ops spemmc_sdc_ops = {
+	.request = spemmc_mmc_request,
+	.set_ios = spemmc_mmc_set_ios,
+	.get_ro = spemmc_mmc_read_only,
+	.get_cd = spemmc_mmc_card_detect,
+	.enable_sdio_irq = spemmc_enable_sdio_irq,
+};
+
+
+static uint get_max_sd_freq(SPEMMCHOST *host)
+{
+	uint max_freq = SPEMMC_MAX_CLOCK;
+
+	/* fix me read from device tree */
+	max_freq = SPEMMC_MAX_CLOCK;
+
+	printk("[eMMC] Slot %d, actually use max_freq #%d M\n", host->id, max_freq/CLOCK_1M);
+	return max_freq;
+}
+
+int spemmc_drv_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct mmc_host *mmc;
+	struct resource *resource;
+	SPEMMCHOST *host;
+	spemmc_dridata_t *priv = NULL;
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+		match = of_match_node(spemmc_of_id, pdev->dev.of_node);
+		if (match)
+			priv = (spemmc_dridata_t *)match->data;
+	}
+
+	mmc = mmc_alloc_host(sizeof(SPEMMCHOST), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto probe_free_host;
+	}
+
+	host = (SPEMMCHOST *)mmc_priv(mmc);
+	host->mmc = mmc;
+	host->pdev = pdev;
+
+	if (priv)
+		host->id  = priv->id;
+
+	printk("sd slot id:%d\n", host->id);
+
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(resource)) {
+		EPRINTK("get sd %d register resource fail\n", host->id);
+		ret = PTR_ERR(resource);
+		goto probe_free_host;
+	}
+
+	if ((resource->end - resource->start + 1) < sizeof(EMMCREG)) {
+		EPRINTK("register size not right e:%d:r:%d\n",
+			resource->end - resource->start + 1, sizeof(EMMCREG));
+		ret = -EINVAL;
+		goto probe_free_host;
+	}
+
+	host->base = devm_ioremap_resource(&pdev->dev, resource);
+	if (IS_ERR((void *)host->base)) {
+		EPRINTK("devm_ioremap_resource fail\n");
+		ret = PTR_ERR((void *)host->base);
+		goto probe_free_host;
+	}
+
+	DPRINTK("SD card driver probe, sd %d, base:0x%x, host size:%d\n", host->id, resource->start, resource->end - resource->start);
+
+	/* host->irq = of_irq_get(pdev->dev.of_node, 0); */
+	host->irq = platform_get_irq(pdev, 0);
+	if (host->irq <= 0) {
+		EPRINTK("get sd %d irq resource fail\n", host->id);
+		ret = -EINVAL;
+		goto probe_free_host;
+	}
+	DPRINTK("irq  %d\n",	host->irq);
+
+	/*
+	 * fix me read from device tree after clock pinmux device tree ok
+	 */
+	pinmux_enable(host);
+
+	emmc_set_in_clock(host);
+
+	host->wrdly = host->base->sd_wr_dly_sel;
+	host->rddly = host->base->sd_rd_dly_sel;
+
+	if (request_irq(host->irq, spemmc_irq, IRQF_SHARED, dev_name(&pdev->dev), mmc)) {
+		printk("\nFailed to request sd card interrupt.\n");
+		ret = -ENOENT;
+		goto probe_free_host;
+	}
+
+	DPRINTK("Slot %d driver probe, host:0x%x, base:0x%x\n", host->id, (unsigned int)host,(unsigned int)host->base);
+
+
+	sema_init(&host->req_sem, 1);
+
+	mmc->ops = &spemmc_sdc_ops;
+
+	/*
+	 * freq_divisor[11:10] = sdfreq[1:0]
+	 * freq_divisor[9:0] = sdfqsel[9:0]
+	 */
+	mmc->f_min = (SPEMMC_CLK_SOURCE / (0x0FFF + 1));
+	mmc->f_max = get_max_sd_freq(host);
+
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	mmc->max_seg_size = 65536 * 512;            /* Size per segment is limited via host controller's
+	                                               ((sdram_sector_#_size max value) * 512) */
+	/* Host controller supports up to "SP_HW_DMA_MEMORY_SECTORS", a.k.a. max scattered memory segments per request */
+	mmc->max_segs = 1;
+	mmc->max_req_size = 65536 * 512;			/* Decided by hw_page_num0 * SDHC's blk size */
+	mmc->max_blk_size = 512;                   /* Limited by host's dma_size & data_length max value, set it to 512 bytes for now */
+	mmc->max_blk_count = 65536;                 /* Limited by sdram_sector_#_size max value */
+	mmc->caps =  MMC_CAP_MMC_HIGHSPEED | MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE;
+	mmc->caps |= MMC_CAP_3_3V_DDR;
+	mmc->caps2 = MMC_CAP2_NO_SDIO | MMC_CAP2_NO_SD;
+
+	dev_set_drvdata(&pdev->dev, mmc);
+
+	mmc_add_host(mmc);
+
+	return 0;
+
+probe_free_host:
+	if (mmc)
+		mmc_free_host(mmc);
+
+	return ret;
+}
+
+int spemmc_drv_remove(struct platform_device *dev)
+{
+	struct mmc_host *mmc;
+	SPEMMCHOST *host;
+
+	DPRINTK("Remove sd card\n");
+	mmc = platform_get_drvdata(dev);
+	if (!mmc)
+		return -EINVAL;
+
+	host = (SPEMMCHOST *)mmc_priv(mmc);
+	platform_set_drvdata(dev, NULL);
+
+	mmc_remove_host(mmc);
+	free_irq(host->irq, mmc);
+	mmc_free_host(mmc);
+
+	return 0;
+}
+
+
+int spemmc_drv_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct mmc_host *mmc;
+	SPEMMCHOST *host;
+
+	mmc = platform_get_drvdata(dev);
+	if (!mmc)
+		return -EINVAL;
+
+	host = (SPEMMCHOST *)mmc_priv(mmc);
+
+	printk("Sunplus SD %d driver suspend.\n", host->id);
+	down(&host->req_sem);
+	up(&host->req_sem);
+
+	return 0;
+}
+
+int spemmc_drv_resume(struct platform_device *dev)
+{
+
+#ifdef CONFIG_PM
+	struct mmc_host *mmc;
+	SPEMMCHOST *host;
+
+	mmc = platform_get_drvdata(dev);
+	if (!mmc)
+		return -EINVAL;
+
+	host = (SPEMMCHOST *)mmc_priv(mmc);
+
+
+	printk("Sunplus SD%d driver resume.\n", host->id);
+#endif
+
+	return 0;
+}
+#ifdef CONFIG_PM
+
+int spemmc_pm_suspend(struct device *dev)
+{
+	struct mmc_host *mmc;
+	SPEMMCHOST *host;
+
+	mmc = platform_get_drvdata(to_platform_device(dev));
+	if (!mmc)
+		return -EINVAL;
+
+	host = (SPEMMCHOST *)mmc_priv(mmc);
+
+	printk("Sunplus SD %d driver suspend.\n", host->id);
+
+	down(&host->req_sem);
+	up(&host->req_sem);
+
+	return 0;
+}
+
+int spemmc_pm_resume(struct device *dev)
+{
+	struct mmc_host *mmc;
+	SPEMMCHOST *host;
+
+	mmc = platform_get_drvdata(to_platform_device(dev));
+	if (!mmc)
+		return -EINVAL;
+
+	host = (SPEMMCHOST *)mmc_priv(mmc);
+
+	printk("Sunplus SD%d driver resume.\n", host->id);
+	return 0;
+}
+
+const struct dev_pm_ops sphe_emmc_pm_ops = {
+	.suspend	= spemmc_pm_suspend,
+	.resume		= spemmc_pm_resume,
+};
+#endif
+
+
+
+struct platform_driver spemmc_driver_sdc = {
+	.probe = spemmc_drv_probe,
+	.remove = spemmc_drv_remove,
+	.shutdown = NULL,
+	.suspend = spemmc_drv_suspend,
+	.resume = spemmc_drv_resume,
+	.driver = {
+		.name = SPEMMCV2_SDC_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = spemmc_of_id,
+#ifdef CONFIG_PM
+		.pm= &sphe_emmc_pm_ops,
+#endif
+	}
+};
+
+module_platform_driver(spemmc_driver_sdc);
+
+MODULE_AUTHOR("SPHE B1");
+MODULE_DESCRIPTION("SPHE MMC/SD Card Interface Driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/mmc/host/spemmc.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/mmc/host/spemmc.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,576 @@
+#ifndef _SPEMMCV2_H_
+#define _SPEMMCV2_H_
+////////////////////////////////////////////////////////////////
+#include <linux/semaphore.h>
+#include <linux/kthread.h>
+#include <linux/mmc/host.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/mmc.h>
+#include <mach/irqs.h>
+
+/////////////////////////////////////////////////////////////////
+#define SP_MMC_SUPPORT_DDR_MODE
+#define SPEMMC_SUCCESS			0x00000000
+#define SPEMMC_FAIL				0x00000001
+#define SPEMMC_RSP_TIMEOUT		0x00000002
+#define SPEMMC_CRC_ERROR			0x00000004
+#define SPEMMC_COUNTER_ERROR		0x00000008
+#define SPEMMC_DMA_FAIL			0x00000010
+#define SPEMMC_TIMEOUT			0x00000020
+#define SPEMMC_CRC_TIMEOUT		0x00000040
+#define SPEMMC_CARD_NOT_EXIST		0x00000080
+#define SPEMMC_COMPLETE_INIT		0x80000000
+
+#define SDCARD_STATUS_NOTEXIST 			0
+#define SDCARD_STATUS_EXIST 			1
+#define SDCARD_STATUS_TESTNOTEXIST 		2
+#define SDCARD_STATUS_TESTEXIST 		3
+
+//1.17[14]
+#define CARD_MODE_SD	0
+#define CARD_MODE_MMC	1
+
+//to delete
+#define EMMC_1BIT_MODE 			0
+#define EMMC_4BIT_MODE 			1
+
+#define SPRSP_TYPE_NORSP		0
+#define SPRSP_TYPE_R1  			1
+#define SPRSP_TYPE_R1B 			11
+#define SPRSP_TYPE_R2  			2
+#define SPRSP_TYPE_R3  			3
+#define SPRSP_TYPE_R4  			4
+#define SPRSP_TYPE_R5  			5
+#define SPRSP_TYPE_R6  			6
+#define SPRSP_TYPE_R7 			7
+
+#define SP_DMA_DRAM      		1
+#define SP_DMA_FLASH     		2
+
+#define SP_DMA_DST_SHIFT		4
+#define SP_DMA_SRT_SHIFT		0
+
+#define SP_BUS_WIDTH_1BIT 0
+#define SP_BUS_WIDTH_4BIT 1
+#define SP_BUS_WIDTH_8BIT (1<<6)
+#define CLOCK_200K	200000
+#define CLOCK_300K	300000
+#define CLOCK_375K	375000
+#define CLOCK_400K	400000
+#define CLOCK_1M	1000000
+#define CLOCK_5M	5000000
+#define CLOCK_10M	10000000
+#define CLOCK_12M	12000000
+#define CLOCK_15M	15000000
+#define CLOCK_20M	20000000
+#define CLOCK_25M	25000000
+#define CLOCK_27M	27000000
+#define CLOCK_30M	30000000
+#define CLOCK_35M	35000000
+#define CLOCK_45M	45000000
+#define CLOCK_48M	48000000
+#define CLOCK_50M	50000000
+#define CLOCK_52M	52000000
+
+#define CLOCK_240M  240000000
+#define CLOCK_270M  270000000
+#define CLOCK_202M  202500000
+
+/* kernel set max read timeout to 100ms,
+ * mult  to  Improve compatibility for some unstandard card
+ */
+#define READ_TIMEOUT_MULT     10
+
+
+/* kernel set max read timeout to 3s,
+ * mult  to  Improve compatibility for some unstandard emmc
+ */
+#define EMMC_WRITE_TIMEOUT_MULT     5
+
+/******************************************************************************
+*                          MACRO Function Define
+*******************************************************************************/
+
+#ifndef REG
+//#define REG(x) (*(volatile unsigned long *)(x))
+#define REG(x) (*(volatile unsigned int *)(x))
+#endif
+
+#define get_val(addr)		REG(addr)
+#define set_val(addr, val)	REG(addr) = (val)
+
+#ifndef set_bit
+#define set_bit(addr, val)	set_val((addr), (get_val(addr) | (val)))
+#endif
+
+#ifndef clear_bit
+#define clear_bit(addr, val)	set_val((addr), (get_val(addr) & ~(val)))
+#endif
+
+#define SP_MEDIA_NONE			0
+#define SP_MEDIA_SMC			1
+#define SP_MEDIA_RESERVED1 		2
+#define SP_MEDIA_CF				3
+#define SP_MEDIA_SPI			4
+#define SP_MEDIA_RESERVED2		5
+#define SP_MEDIA_SD				6
+#define SP_MEDIA_MEMORY_STICK	7
+
+#define SP_HW_DMA_MEMORY_SECTORS	8 /*  supports up to 8 fragmented memory blocks */
+
+#define SP_LENMODE_SEND_STOP 				0
+#define SP_LENMODE_NOT_SEND_STOP 			1
+#define SP_TRANSACTION_MODE_CMD_RSP			0
+#define SP_TRANSACTION_MODE_WRITE_DATA		1
+#define SP_TRANSACTION_MODE_READ_DATA		2
+#define SP_AUTORSP_NO_RX_RESPONSE 			0
+#define SP_AUTORSP_ATUO_RX_RESPONSE 		1
+
+#define SP_SD_RSP_TYPE_LEN_48_BITS		0
+#define SP_SD_RSP_TYPE_LEN_136_BITS		1
+#define SP_SD_MODE   0
+#define SP_MMC_MODE  1
+#define SP_EMMC_CARD    0
+#define SP_SDIO_CARD  1
+
+#define SP_SDSTATUS_DUMMY_READY 					BIT(0)
+#define SP_SDSTATUS_RSP_BUF_FULL					BIT(1)
+#define SP_SDSTATUS_TX_DATA_BUF_EMPTY				BIT(2)
+#define SP_SDSTATUS_RX_DATA_BUF_FULL				BIT(3)
+#define SP_SDSTATUS_CMD_PIN_STATUS					BIT(4)
+#define SP_SDSTATUS_DAT0_PIN_STATUS					BIT(5)
+#define SP_SDSTATUS_WAIT_RSP_TIMEOUT				BIT(6)
+#define SP_SDSTATUS_WAIT_CARD_CRC_CHECK_TIMEOUT		BIT(7)
+#define SP_SDSTATUS_WAIT_STB_TIMEOUT				BIT(8)
+#define SP_SDSTATUS_RSP_CRC7_ERROR					BIT(9)
+#define SP_SDSTATUS_CRC_TOKEN_CHECK_ERROR			BIT(10)
+#define SP_SDSTATUS_RDATA_CRC16_ERROR				BIT(11)
+#define SP_SDSTATUS_SUSPEND_STATE_READY				BIT(12)
+#define SP_SDSTATUS_BUSY_CYCLE						BIT(13)
+#define SP_SDSTATUS_SD_DATA1						BIT(14)
+#define SP_SDSTATUS_SD_SENSE						BIT(15)
+
+#define WRITE_CRC_TOKEN_CORRECT		2
+#define WRITE_CRC_TOKEN_ERROR		5
+#define SDSTATE_NEW_FINISH_IDLE 		BIT(6)
+#define SDSTATE_NEW_ERROR_TIMEOUT 		BIT(5)
+
+#define SP_DMA_TYPE_SINGLEBLOCK_CMD	1
+#define SP_DMA_TYPE_MULTIBLOCK_CMD		2
+
+#define SP_SD_CMDBUF_SIZE 5
+
+#define SP_SD_RXDATTMR_MAX	((1 << 29) - 1)
+
+#define MS_RDDATA_SIZE 4
+
+#define SP_MS_WD_DATA_SIZE 16
+
+#define SP_DMA_NORMAL_STATE			0
+#define SP_RESET_DMA_OPERATION		1
+
+#define SP_DMA_BLOCK_MODE_PAGE_LEVEL	0
+#define SP_DMA_BLOCK_MODE_BLOCK_LEVEL	1
+
+#define SP_DMA_HW_PAGE_NUM_SIZE 4
+
+
+typedef volatile unsigned int dev_reg32;
+typedef volatile unsigned char dev_reg8;
+
+typedef struct  spemmc_general_regs{
+	/*g0.0*/
+	union {
+		struct {
+			dev_reg32 mediatype:3;
+			dev_reg32 reserved0:1;
+			dev_reg32 dmasrc:3;
+			dev_reg32 reserved1:1;
+			dev_reg32 dmadst:3;
+			dev_reg32 reserved2:21;
+		};
+		dev_reg32 medatype_dma_src_dst;
+	};
+	/*g0.1*/
+	dev_reg32 card_ctl_page_cnt:16;
+	dev_reg32 reserved3:16;
+
+	/* g0.2 */
+	dev_reg32 sdram_sector_0_size:16;
+	dev_reg32 reserved4:1;
+	/* g0.3 */
+	dev_reg32 dma_base_addr;
+	/* g0.4 */
+	union {
+		struct {
+			dev_reg32 reserved5:1;
+			dev_reg32 hw_dma_en:1;
+			dev_reg32 reserved6:1;
+			dev_reg32 hw_sd_hcsd_en:1;
+			dev_reg32 hw_sd_dma_type:2;
+			dev_reg32 hw_sd_cmd13_en:1;
+			dev_reg32 reserved7:1;
+			dev_reg32 stop_dma_flag:1;
+			dev_reg32 hw_dma_rst:1;
+			dev_reg32 dmaidle:1;
+			dev_reg32 dmastart:1;
+			dev_reg32 hw_block_num:2;
+			dev_reg32 reserved8:2;
+			dev_reg32 hw_cmd13_rca:16;
+		};
+		dev_reg32 hw_dma_ctl;
+	};
+	/* g0.5 */
+	union {
+		struct {
+			dev_reg32 reg_sd_ctl_free:1;			/*  0 */
+			dev_reg32 reg_sd_free:1;				/*  1 */
+			dev_reg32 reg_ms_ctl_free:1;			/*  2 */
+			dev_reg32 reg_ms_free:1;				/*  3 */
+			dev_reg32 reg_dma_fifo_free:1;			/*  4 */
+			dev_reg32 reg_dma_ctl_free:1;			/*  5 */
+			dev_reg32 reg_hwdma_page_free:1;		/*  6 */
+			dev_reg32 reg_hw_dma_free:1;			/*  7 */
+			dev_reg32 reg_sd_hwdma_free:1;			/*  8 */
+			dev_reg32 reg_ms_hwdma_free:1;			/*  9 */
+			dev_reg32 reg_dma_reg_free:1;			/*  10 */
+			dev_reg32 reg_card_reg_free:1;			/*  11 */
+			dev_reg32 reserved9:20;
+		};
+		dev_reg32 card_gclk_disable;
+	};
+
+	/* g0.6 ~ g0.19*/
+	struct {
+		dev_reg32 dram_sector_addr;
+		dev_reg32 sdram_sector_size:16;
+		dev_reg32 reserved10:16;
+	} dma_addr_info[7];
+
+	/* g0.20 */
+	union {
+		struct {
+			dev_reg32 dram_sector_cnt:3;			/*  2:00 ro */
+			dev_reg32 hw_block_cnt:2;				/*  04:03 ro */
+			dev_reg32 reserved11:11;				/*  15:05 ro */
+			dev_reg32 hw_page_cnt:16;				/*  31:16 ro  */
+		};
+		dev_reg32 sdram_sector_block_cnt;
+	};
+	/* g0.20 ~ g0.28 */
+	dev_reg32 dma_hw_page_addr[4];
+	dev_reg32 dma_hw_page_num[4];
+
+	/* g0.29 */
+	dev_reg32 hw_wait_num;
+
+	/* g0.30 */
+	dev_reg32 hw_delay_num:16;
+	dev_reg32 reserved12:16;
+
+	/* g0.31 */
+	union {
+		struct {
+			dev_reg32 incnt:11;
+			dev_reg32 outcnt:11;
+			dev_reg32 dma_sm:3;
+			dev_reg32 reserved13:7;
+		};
+		dev_reg32 dma_debug;
+	};
+
+	/* g1.0 */
+	union {
+		struct {
+			dev_reg32 boot_ack_en:1;
+			dev_reg32 boot_ack_tmr:1;
+			dev_reg32 boot_data_tmr:1;
+			dev_reg32 fast_boot:1;
+			dev_reg32 boot_mode:1;
+			dev_reg32 bootack:3;
+			dev_reg32 reserved14:24;
+		};
+		dev_reg32 boot_ctl;
+	};
+
+	/* g1.1 */
+	union {
+		struct {
+			dev_reg32 vol_tmr:2;
+			dev_reg32 sw_set_vol:1;
+			dev_reg32 hw_set_vol:1;
+			dev_reg32 vol_result:2;
+			dev_reg32 reserved15:26;
+		};
+		dev_reg32 sd_vol_ctrl;
+	};
+	/* g1.2 */
+	union {
+		struct {
+			dev_reg32 sdcmpen:1;
+			dev_reg32 sd_cmp:1;			/* 1 */
+			dev_reg32 sd_cmp_clr:1;		/* 2 */
+			dev_reg32 sdio_int_en:1;	/* 3 */
+			dev_reg32 sdio_int:1;		/* 4 */
+			dev_reg32 sdio_int_clr:1;	/* 5 */
+			dev_reg32 detect_int_en:1;  /* 6 */
+			dev_reg32 detect_int:1;		/* 7 */
+			dev_reg32 detect_int_clr:1; /* 8 */
+			dev_reg32 hwdmacmpen:1;		/* 9 */
+			dev_reg32 hw_dma_cmp:1;		/* 10 */
+			dev_reg32 hwdmacmpclr:1;	/* 11 */
+			dev_reg32 reserved16:20;	/* 31:12 */
+		};
+		dev_reg32 sd_int;
+	};
+
+	/* g1.3 */
+	dev_reg32 sd_page_num:16;
+	dev_reg32 reserved17:16;
+	/* g1.4 */
+	union {
+		struct {
+			dev_reg32 sdpiomode:1;
+			dev_reg32 sdddrmode:1;
+			dev_reg32 sd_len_mode:1;
+			dev_reg32 first_dat_hcyc:1;
+			dev_reg32 sd_trans_mode:2;
+			dev_reg32 sdautorsp:1;
+			dev_reg32 sdcmddummy:1;
+			dev_reg32 sdrspchk_en:1;
+			dev_reg32 sdiomode:1;
+			dev_reg32 sdmmcmode:1;
+			dev_reg32 sddatawd:1;
+			dev_reg32 sdrsptmren:1;
+			dev_reg32 sdcrctmren:1;
+			dev_reg32 rx4b_en:1;
+			dev_reg32 sdrsptype:1;
+			dev_reg32 detect_tmr:2;
+			dev_reg32 mmc8_en:1;
+			dev_reg32 selci:1;
+			dev_reg32 sdfqsel:12;
+		};
+		dev_reg32 sd_config0;
+	};
+
+	/* g1.5 */
+	union {
+		struct {
+			dev_reg32 rwc:1;
+			dev_reg32 s4mi:1;
+			dev_reg32 resu:1;
+			dev_reg32 sus_req:1;
+			dev_reg32 con_req:1;
+			dev_reg32 sus_data_flag:1;
+			dev_reg32 int_multi_trig:1;
+			dev_reg32 reserved18:25;
+		};
+		dev_reg32 sdio_ctrl;
+	};
+
+	/* g1.6 */
+	union {
+		struct {
+			dev_reg32 sdrst:1;
+			dev_reg32 sdcrcrst:1;
+			dev_reg32 sdiorst:1;
+			dev_reg32 reserved19:29;
+		};
+		dev_reg32 sd_rst;
+	};
+
+	/* g1.7 */
+	union {
+		struct {
+			dev_reg32 sdctrl0:1;
+			dev_reg32 sdctrl1:1;
+			dev_reg32 sdioctrl:1;
+			dev_reg32 emmcctrl:1;
+			dev_reg32 reserved20:28;
+		} ;
+		dev_reg32 sd_ctrl;
+	};
+	/* g1.8 */
+	union {
+		struct {
+			dev_reg32 sdstatus:19;
+			dev_reg32 reserved21:13;
+		};
+		dev_reg32 sd_status;
+	};
+	/* g1.9 */
+	union {
+		struct {
+			dev_reg32 sdstate:3;
+			dev_reg32 reserved22:1;
+			dev_reg32 sdcrdcrc:3;
+			dev_reg32 reserved23:1;
+			dev_reg32 sdstate_new:7;
+			dev_reg32 reserved24:17;
+		};
+		dev_reg32 sd_state;
+	};
+
+	/* g1.10 */
+	union {
+		struct {
+			dev_reg32 hwsd_sm:10;
+			dev_reg32 reserved25:22;
+		};
+		dev_reg32 sd_hw_state;
+#define SP_EMMC_HW_DMA_ERROR				BIT(6)
+#define SP_EMMC_HW_DMA_DONE				BIT(7)
+	};
+
+	/* g1.11 */
+	union {
+		struct {
+			dev_reg32 sddatalen:11;
+			dev_reg32 reserved26:21;
+		};
+		dev_reg32 sd_blocksize;
+	};
+
+	/* g1.12 */
+	union {
+		struct {
+			dev_reg32 tx_dummy_num:9;
+			dev_reg32 sdcrctmr:11;
+			dev_reg32 sdrsptmr:11;
+			dev_reg32 sd_high_speed_en:1;
+		};
+		dev_reg32 sd_config1;
+	};
+
+	/* g1.13 */
+	union {
+		struct {
+			dev_reg32 sd_clk_dly_sel:3;
+			dev_reg32 reserved27:1;
+			dev_reg32 sd_wr_dly_sel:3;
+			dev_reg32 reserved28:1;
+			dev_reg32 sd_rd_dly_sel:3;
+			dev_reg32 reserved29:21;
+		};
+		dev_reg32 sd_timing_config;
+	};
+
+	/* g1.14 */
+	dev_reg32 sd_rxdattmr:29;
+#define SP_EMMC_RXDATTMR_MAX	((1 << 29) - 1)
+	dev_reg32 reserved30:3;
+
+	/* g1.15 */
+	dev_reg32 sd_piodatatx;
+
+	/* g1.16 */
+	dev_reg32 sd_piodatarx;
+
+	/* g1.17 */
+	/* g1.18 */
+	dev_reg8 sd_cmdbuf[5];
+	dev_reg8 reserved32[3];
+	/* g1.19 - g1.20 */
+	union {
+		struct  {
+			dev_reg8 sd_rspbuf3;
+			dev_reg8 sd_rspbuf2;
+			dev_reg8 sd_rspbuf1;
+			dev_reg8 sd_rspbuf0;
+			dev_reg8 sd_rspbuf5;
+			dev_reg8 sd_rspbuf4;
+			dev_reg8 sd_rspbuf_reserved[2];
+		};
+		struct {
+			dev_reg32 sd_rspbuf[2];
+		};
+	};
+	/*  unused sd control regs */
+	dev_reg32 reserved34[11];
+	/* ms card related regs */
+	dev_reg32 ms_regs[32];
+} EMMCREG;
+
+#define EMMC_RST_seq(base) 				do { \
+		base->sdrst = 1; \
+		base->sdcrcrst = 1; \
+		base->stop_dma_flag = 1; \
+		base->hw_dma_rst = 1; \
+		base->dmaidle = SP_DMA_NORMAL_STATE; \
+		base->dmaidle = SP_RESET_DMA_OPERATION; \
+		base->dmaidle = SP_DMA_NORMAL_STATE; \
+	}while(0)
+
+#define BLOCK0_DMA_PARA_SET(base, pageIdx, nrPages)  do { \
+		base->block0_hw_page_addr_low = ((pageIdx) & 0x0000ffff); \
+		base->block0_hw_page_addr_high = (((pageIdx) >> 16) & 0x0000ffff); \
+		base->dma_hw_page_num[0] = ((nrPages) - 1); \
+    }while(0)
+
+#define BLOCK1_DMA_PARA_SET(base, pageIdx, nrPages)  do{ \
+		base->block1_hw_page_addr_low = ((pageIdx) & 0x0000ffff); \
+		base->block1_hw_page_addr_high = (((pageIdx) >> 16) & 0x0000ffff); \
+		base->dma_hw_page_num[1] = ((nrPages) - 1); \
+    }while(0)
+
+#define BLOCK2_DMA_PARA_SET(base, pageIdx, nrPages)  do{ \
+		base->block2_hw_page_addr_low = ((pageIdx) & 0x0000ffff); \
+		base->block2_hw_page_addr_high = (((pageIdx) >> 16) & 0x0000ffff); \
+		base->dma_hw_page_num[2] = ((nrPages) - 1); \
+    }while(0)
+
+#define BLOCK3_DMA_PARA_SET(base, pageIdx, nrPages)  do{ \
+		base->block3_hw_page_addr_low = ((pageIdx) & 0x0000ffff); \
+		base->block3_hw_page_addr_high = (((pageIdx) >> 16) & 0x0000ffff); \
+		base->dma_hw_page_num[3] = ((nrPages) - 1); \
+    }while(0)
+
+#define SET_DMA_BASE_ADDR(base, addr)  base->dma_base_addr = (u32)(addr)
+
+#define DMA_RESET(base)		do{ \
+			base->dmaidle = SP_RESET_DMA_OPERATION; \
+			base->dmaidle = SP_DMA_NORMAL_STATE; \
+			base->hw_dma_rst = 1; \
+			base->dma_hw_page_num[0] = 0; \
+			base->dma_hw_page_num[1] = 0; \
+			base->dma_hw_page_num[2] = 0; \
+			base->dma_hw_page_num[3] = 0; \
+			base->hw_block_num = 0; \
+		}while(0)
+
+#define SDDATALEN_SET(base, x)			(base->sddatalen = ((x)-1))
+#define SDDATALEN_GET(base)				(base->sddatalen + 1)
+#define HWEMMC_TIMEOUT(base)				((base->sdstatus >> 7) & 0x01)
+
+#define EMMC_PAGE_NUM_SET(base, x)		(base->sd_page_num = ((x)-1))
+#define EMMC_PAGE_NUM_GET(base)			(base->sd_page_num +1)
+
+typedef struct spsdhost {
+	volatile struct spemmc_general_regs *base;
+	uint id;
+	char *name;
+	struct mmc_host *mmc;
+	struct mmc_request *mrq;
+	struct platform_device *pdev;
+	struct semaphore req_sem;
+
+	int dma_sgcount;   /* Used to store dma_mapped sg count */
+	int irq;
+	uint InsertGPIO;
+	int cd_sta;
+
+	uint wrdly;
+	uint rddly;
+#ifdef SP_MMC_SUPPORT_DDR_MODE
+	uint ddr_rd_crc_token_dly;
+	uint ddr_wr_data_dly;
+#endif
+	int need_tune_cmd_timing;
+	int need_tune_dat_timing;
+}SPEMMCHOST;
+
+typedef struct spemmc_dridata {
+	uint id;
+} spemmc_dridata_t;
+
+#endif //#ifndef _SPEMMCV2_H_
--- a/drivers/mmc/host/spsdv2.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/mmc/host/spsdv2.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,1437 @@
+/******************************************************************************
+*                          Include File
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <linux/pm_runtime.h>
+#include <asm/uaccess.h>
+
+#include <linux/mmc/sd.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+
+#include <linux/miscdevice.h>
+#include <asm/cacheflush.h>
+#include <linux/of.h>
+#include <linux/interrupt.h>
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+
+#include <asm-generic/io.h>
+#include <asm/bitops.h>
+#include "mach/gpio_drv.h" /* for card sense */
+#include "spsdv2.h"
+
+/******************************************************************************
+*                          MACRO Function Define
+*******************************************************************************/
+#define SPSD_MAX_CLOCK  CLOCK_52M     /* Max supported SD Card frequency */
+#define SPSD_CLK_SOURCE CLOCK_202M    /* Host controller's clk source */
+#define SPSDV2_SDC_NAME "sunplus,sp-cardx"
+#define MAX_SDDEVICES   2
+#define SPSD_DEVICE_MASK 1
+#define SPSD_READ_DELAY  0		/* delay for sampling data */
+#define SPSD_WRITE_DELAY 0		/* delay for output data   */
+#define SPEMMC_READ_DELAY  0		/* delay for sampling data */
+#define SPEMMC_WRITE_DELAY 2		/* delay for output data   */
+#define DUMMY_COCKS_AFTER_DATA     8
+
+#define MAX_DLY_CLK     7 		/* max  delay clocks */
+#ifdef CONFIG_SP_SDEMMCV2
+#define SP_EMMCSLOT_ID  0
+#else
+#define SP_EMMCSLOT_ID  (~0)
+#endif
+#define SP_SDIO_SLOT_ID  4
+#define SP_SDCARD_SENSE_WITH_GPIO
+
+/* Disabled fatal error messages temporarily */
+static u32 loglevel = 0x002;
+/* static u32 loglevel = 0x001; */
+/* static u32 loglevel = 0x033; */
+/* static u32 loglevel = 0xefff; */
+/* static u32 loglevel = 0xffff; */
+
+
+#define MMC_LOGLEVEL_FATAL		0x01
+#define MMC_LOGLEVEL_ERROR		0x02
+#define MMC_LOGLEVEL_DEBUG		0x04
+
+
+#define MMC_LOGLEVEL_IF 		0x10
+#define MMC_LOGLEVEL_PK 		0x20
+
+#define MMC_LOGLEVEL_COUNTER	0x100
+#define MMC_LOGLEVEL_WAITTIME	0x200
+
+#define MMC_LOGLEVEL_DUMPREG	0x1000
+#define MMC_LOGLEVEL_MINI		0x2000
+
+#if 1
+
+#define FATAL(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_FATAL)) \
+		printk(KERN_ERR "[SD FATAL]: %s: " fmt, __func__ , ## args)
+
+#define EPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_ERROR)) \
+		printk(KERN_ERR "[SD ERROR]: %s: " fmt, __func__ , ## args)
+
+#define DPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_DEBUG)) \
+		printk(KERN_INFO "[SD DBG]: %s: " fmt, __func__ , ## args)
+
+#define IFPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_IF)) \
+		printk(KERN_NOTICE "[SD IF]: %s:" fmt, __func__, ## args)
+
+#define pk(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_PK)) \
+		printk(KERN_NOTICE "[SD PK]: %s: " fmt, __func__ , ## args)
+
+#define CPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_COUNTER)) \
+		printk(KERN_INFO "[SD COUNTER]: %s: " fmt, __func__ , ## args)
+
+#define WPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_WAITTIME)) \
+		printk(KERN_INFO "[SD WAITTIME]: %s: " fmt, __func__ , ## args)
+
+#define REGPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_DUMPREG)) \
+		printk(KERN_INFO "[SD REG]: %s: " fmt, __func__ , ## args)
+
+#define MPRINTK(fmt, args...) if(unlikely(loglevel & MMC_LOGLEVEL_MINI)) \
+		printk(KERN_INFO "[SD]: %s: " fmt, __func__ , ## args)
+
+#else
+
+#define FATAL(fmt, args...)
+#define EPRINTK(fmt, args...)
+#define DPRINTK(fmt, args...)
+
+#define IFPRINTK(fmt, args...)
+#define pk(fmt, args...)
+
+#define CPRINTK(fmt, args...)
+#define WPRINTK(fmt, args...)
+
+
+#define REGPRINTK(fmt, args...)
+#define MPRINTK(fmt, args...)
+
+#endif
+
+#define IS_DMA_ADDR_2BYTE_ALIGNED(x)  (!((x) & 0x1))
+
+
+
+/******************************************************************************
+*                          Global Variables
+*******************************************************************************/
+
+const static spsdv2_dridata_t spsdv2_driv_data[] = {
+	{.id = 0,},
+	{.id = 1,},
+	{.id = 4,},
+};
+
+static const struct of_device_id spsdv2_of_id[] = {
+	{
+		.compatible = "sunplus,sp-card0",
+	  	.data = &spsdv2_driv_data[0],
+	},
+	{
+		.compatible = "sunplus,sp-card1",
+		.data = &spsdv2_driv_data[1],
+	},
+	{
+		.compatible = "sunplus,sp-sdio",
+		.data = &spsdv2_driv_data[2],
+	},
+	{}
+
+};
+MODULE_DEVICE_TABLE(of, spsdv2_of_id);
+
+
+
+/******************************************************************************
+*                         Function Prototype
+*******************************************************************************/
+#define REG_BASE					0x9c000000
+#define RF_GRP(_grp, _reg)			((((_grp) * 32 + (_reg)) * 4) + REG_BASE)
+#define RF_MASK_V(_mask, _val)      (((_mask) << 16) | (_val))
+#define RF_MASK_V_SET(_mask)        (((_mask) << 16) | (_mask))
+#define RF_MASK_V_CLR(_mask)        (((_mask) << 16) | 0)
+#define REGn(base, n)	((base) + 4 * (n))
+
+static int spsdv2_get_dma_dir(SPSDHOST *, struct mmc_data *);
+static void sphe_mmc_finish_request(SPSDHOST *, struct mmc_request *);
+static void spsdv2_set_data_info(SPSDHOST *, struct mmc_data *);
+static void spsdv2_prepare_cmd_rsp(SPSDHOST *, struct mmc_command *);
+
+static inline bool is_crc_token_valid(SPSDHOST *host)
+{
+	return (host->base->sdcrdcrc == 0x2 || host->base->sdcrdcrc == 0x5);
+}
+
+static int pinmux_enable(void *host)
+{
+	volatile void __iomem  *reg  = ioremap_nocache(RF_GRP(1, 1), 4);
+	if (reg) {
+		writel(RF_MASK_V(1 << 6, 1 << 6), reg);
+	}
+	else {
+		printk("ioremap fail\n");
+		return -ENOMEM;
+	}
+	iounmap(reg);
+	/* fully pin-mux configuration */
+	if (SP_SDIO_SLOT_ID == ((SPSDHOST *)host)->id) {
+		reg = ioremap_nocache(RF_GRP(2, 0), 128);
+		if (!reg) {
+			printk("trying to set sdio pinmux failed at ioremap!\n");
+			return -1;
+		}
+		writel(0x7f << 16 | 14, REGn(reg, 11)); /* CLK */
+		writel(0x7f << 24 | 16 << 8, REGn(reg, 11)); /* CMD */
+		writel(0x7f << 16 | 12, REGn(reg, 12)); /* DAT0 */
+		writel(0x7f << 24 | 10 << 8, REGn(reg, 12)); /* DAT1 */
+		writel(0x7f << 16 | 20, REGn(reg, 13)); /* DAT2 */
+		writel(0x7f << 24 | 18 << 8, REGn(reg, 13)); /* DAT3 */
+		iounmap(reg);
+	}
+	return 0;
+}
+
+static int ctlr_clk_enable(void)
+{
+	volatile void __iomem  *reg  = ioremap_nocache(RF_GRP(0, 4), 4);
+	if (reg) {
+		writel(RF_MASK_V_SET(1 << 15), reg);
+	}	else {
+		printk("ioremap fail\n");
+		return -ENOMEM;
+	}
+	iounmap(reg);
+	return 0;
+}
+
+static int ctlr_clk_disable(void)
+{
+	volatile void __iomem  *reg  = ioremap_nocache(RF_GRP(0, 4), 4);
+	if (reg) {
+		writel(RF_MASK_V_CLR(1 << 15), reg);
+	}	else {
+		printk("ioremap fail\n");
+		return -ENOMEM;
+	}
+	iounmap(reg);
+	return 0;
+}
+
+static int sd_set_in_clock(void *host)
+{
+	return 0;
+}
+
+static int sd_get_in_clock(void *host)
+{
+	return SPSD_CLK_SOURCE;
+}
+
+void tx_dummy(SPSDHOST *host, u32 rounds)
+{
+	host->base->tx_dummy_num = rounds;
+	host->base->sdctrl_trigger_dummy = 1;
+	/* wait  dummy done  */
+	while (host->base->sdstate);
+}
+
+
+static int Sd_Bus_Reset_Channel(SPSDHOST *host)
+{
+	int counter = 0;
+
+	host->base->rst_cnad = 1;	/*reset Central FIFO*/
+	/* Wait for channel reset to complete */
+	while (host->base->rst_cnad == 1) {
+	}
+
+	CPRINTK("%s, counter:%d\n", __func__, counter);
+	return SPSD_SUCCESS;
+}
+
+static int Reset_Controller(SPSDHOST *host)
+{
+	DPRINTK("controller reset\n");
+	SD_RST_seq(host->base);
+	return Sd_Bus_Reset_Channel(host);
+}
+
+static void spsdv2_controller_init(SPSDHOST *host)
+{
+	host->base->sdddrmode = 0;
+	host->base->sdpiomode = 1;
+	host->base->rx4b_en = 1;
+	if (SP_SDIO_SLOT_ID == host->id)
+		host->base->sdiomode = SP_SDIO_CARD;
+	else
+		host->base->sdiomode = SP_SD_CARD;
+
+	host->base->sdrsptmr = 0x7ff;
+	host->base->sdrsptmren = 1;
+	host->base->sdcrctmr = 0x7ff;
+	host->base->sdcrctmren = 1;
+	if (SP_EMMCSLOT_ID == host->id)
+		host->base->sdmmcmode = SP_MMC_MODE;
+	else
+		host->base->sdmmcmode = SP_SD_MODE;
+	host->base->sdrxdattmr_sel = SP_SD_RXDATTMR_MAX;
+	host->base->mediatype = 6;
+}
+
+static void spsdv2_set_power_mode(SPSDHOST *host, struct mmc_ios *ios)
+{
+	if (host->power_state == ios->power_mode)
+		return;
+
+	switch (ios->power_mode) {
+		/* power off->up->on */
+	case MMC_POWER_ON:
+		DPRINTK("set MMC_POWER_ON\n");
+		spsdv2_controller_init(host);
+		//pm_runtime_get_sync(&pdev->dev);
+		break;
+	case MMC_POWER_UP:
+		/* Set default control register */
+		DPRINTK("set MMC_POWER_UP\n");
+		Reset_Controller(host);
+		break;
+	case MMC_POWER_OFF:
+		Reset_Controller(host);
+		DPRINTK("set MMC_POWER_OFF\n");
+		//pm_runtime_put(&pdev->dev);
+		break;
+	}
+	host->power_state = ios->power_mode;
+}
+
+/*
+ * Set SD card clock divider value based on the required clock in HZ
+ * TODO: Linux passes clock as 0, look into it
+ */
+static void spsdv2_set_clock(SPSDHOST *host, struct mmc_ios *ios)
+{
+	struct mmc_host *mmc = host->mmc;
+	uint clkrt, sys_clk, act_clock;
+	uint rd_dly = SPSD_READ_DELAY, wr_dly = SPSD_WRITE_DELAY;
+	uint clock = ios->clock;
+	/* Check if requested frequency is above/below supported range */
+	if (clock < mmc->f_min)
+		clock = mmc->f_min;
+	else if (clock > mmc->f_max)
+		clock = mmc->f_max;
+
+	sys_clk = sd_get_in_clock(host);
+	clkrt = (sys_clk / clock) - 1;
+
+	/* Calculate the actual clock for the divider used */
+	act_clock = sys_clk / (clkrt + 1);
+	/*
+	if (act_clock > clock)
+		clkrt++;
+	*/
+	/* printk("sys_clk =%u, act_clock=%u, clkrt = %u\n", sys_clk, act_clock, clkrt); */
+	/* check clock divider boundary and correct it */
+	if (clkrt > 0xFFF)
+		clkrt = 0xFFF;
+
+	host->base->sdfqsel = clkrt;
+	/* Delay 4 msecs for now (wait till clk stabilizes?) */
+	mdelay(4);
+
+	/*
+	*Host adjusts the data sampling edge and send edge depending on the speed mode used.
+	*sd:
+	* read delay:
+	* default speed controller sample data at fall edge, card send data at fall edge
+	* high speed controller sample data at rise edge, card send data at rise edge
+	* tunel (clkrt + 1)/2 clks to ensure controller sample In the middle of the data.
+	* write delay:
+	*  default speed controller send data at fall edge, card sample data at rise edge
+	* high speed controller send data at rise edge, card sample data at rise edge
+	* so we need to tunel write delay (clkrt + 1)/2  clks at high speed to ensure card sample right data
+	*mmc:
+	* mmc card host and device sample data at rising edge in sdr mode,
+	*  so we need to  tunel write and read delay (clkrt + 1)/2
+	*/
+	rd_dly = (clkrt + 1)/2 > MAX_DLY_CLK ? MAX_DLY_CLK:(clkrt + 1)/2;
+	if (ios->timing != MMC_TIMING_LEGACY) {
+		host->base->sd_high_speed_en = 1;
+		wr_dly = rd_dly;
+	} else {
+		host->base->sd_high_speed_en = 0;
+	}
+
+	if (SP_EMMCSLOT_ID == host->id)
+	{
+		wr_dly = host->wrdly;
+		rd_dly = host->rddly;
+	}
+	/* Write delay: Controls CMD, DATA signals timing to SD Card */
+	host->base->sd_wr_dly_sel = wr_dly;
+	/* Read delay: Controls timing to sample SD card's CMD, DATA signals */
+	host->base->sd_rd_dly_sel = rd_dly;
+
+	return;
+}
+
+/* Sets bus width accordingly */
+static void spsdv2_set_bus_width(SPSDHOST *host, u32 bus_width)
+{
+	switch (bus_width) {
+	case MMC_BUS_WIDTH_8:
+		host->base->sddatawd = 0;
+		host->base->mmc8_en = 1;
+		break;
+	case MMC_BUS_WIDTH_4:
+		host->base->sddatawd = 1;
+		host->base->mmc8_en = 0;
+		if (SP_SDIO_SLOT_ID == host->id) {
+			host->base->s4mi = 1;
+			host->base->int_multi_trig = 1;
+		}
+		break;
+	case MMC_BUS_WIDTH_1:
+		host->base->sddatawd = 0;
+		host->base->mmc8_en = 0;
+		if (SP_SDIO_SLOT_ID == host->id) {
+			host->base->s4mi = 0;
+			host->base->int_multi_trig = 1;
+		}
+		break;
+	default:
+		EPRINTK("unknown bus wide %d\n", bus_width);
+		break;
+	}
+
+	return;
+}
+
+static void spsdv2_trigger_sdstate(SPSDHOST *host)
+{
+	host->base->sdctrl_trigger_cmd = 1;   /* Start transaction */
+}
+
+
+#define SP_SD_WAIT_RSP_BUFF_FULL(host) \
+	do { \
+		while (1) { \
+			if ((host)->base->sdstatus & SP_SDSTATUS_RSP_BUF_FULL) \
+			break; \
+			if ((host)->base->sdstate_new & SDSTATE_NEW_ERROR_TIMEOUT) \
+			return; \
+		} \
+	} while (0)
+
+
+/*
+ * Receive 136 bits response, and pass it back to Linux
+ * Used for cmd+rsp and normal dma requests
+ * If error occurs, stop receiving response and return
+ * Note: Host doesn't support Response R2 CRC error check
+ */
+static void spsdv2_get_rsp_136(SPSDHOST *host, struct mmc_command *cmd)
+{
+	unsigned int rspNum;
+	unsigned char rspBuf[18] = {0}; /* Used to store 17 bytes(136 bits) or 6 bytes(48 bits) response */
+
+	/*  read R2 response in 3 times, each time read 6 bytes */
+	for (rspNum = 0; rspNum + 6 < 18; ) {
+		SP_SD_WAIT_RSP_BUFF_FULL(host);
+		/*
+		 * Store received response buffer data.
+		 * Function runs to here only if no error occurs
+		 */
+		rspBuf[rspNum++] = host->base->sdrspbuf0;
+		rspBuf[rspNum++] = host->base->sdrspbuf1;
+		rspBuf[rspNum++] = host->base->sdrspbuf2;
+		rspBuf[rspNum++] = host->base->sdrspbuf3;
+		rspBuf[rspNum++] = host->base->sdrspbuf4;
+		rspBuf[rspNum++] = host->base->sdrspbuf5;
+	}
+
+	/*
+	 * Wait till host controller becomes idle or error occurs
+	 * The host may be busy sending 8 clk cycles for the end of a request
+	 */
+	while (1) {
+		if (host->base->sdstate_new & SDSTATE_NEW_FINISH_IDLE)
+			break;
+		if (host->base->sdstate_new & SDSTATE_NEW_ERROR_TIMEOUT)
+			return;
+	}
+
+	/*
+	 * Pass response back to Linux
+	 * Function runs to here only if no error occurs
+	 */
+	cmd->resp[0] = (rspBuf[1] << 24) | (rspBuf[2] << 16) | (rspBuf[3] << 8) | rspBuf[4];
+	cmd->resp[1] = (rspBuf[5] << 24) | (rspBuf[6] << 16) | (rspBuf[7] << 8) | rspBuf[8];
+	cmd->resp[2] = (rspBuf[9] << 24) | (rspBuf[10] << 16) | (rspBuf[11] << 8) | rspBuf[12];
+	cmd->resp[3] = (rspBuf[13] << 24) | (rspBuf[14] << 16) | (rspBuf[15] << 8) | rspBuf[16];
+
+	return;
+}
+
+/*
+ * Receive 48 bits response, and pass it back to Linux
+ * Used for cmd+rsp and normal dma requests
+ * If error occurs, stop receiving response and return
+ */
+static void spsdv2_get_rsp_48(SPSDHOST *host, struct mmc_command *cmd)
+{
+	unsigned char rspBuf[6] = {0}; /* Used to store 6 bytes(48 bits) response */
+
+	/* Wait till host controller becomes idle or error occurs */
+	while (1) {
+		if (host->base->sdstate_new & SDSTATE_NEW_FINISH_IDLE)
+			break;
+		if (host->base->sdstate_new & SDSTATE_NEW_ERROR_TIMEOUT)
+			return;
+	}
+	/*
+	 * Store received response buffer data
+	 * Function runs to here only if no error occurs
+	 */
+	rspBuf[0] = host->base->sdrspbuf0;
+	rspBuf[1] = host->base->sdrspbuf1;
+	rspBuf[2] = host->base->sdrspbuf2;
+	rspBuf[3] = host->base->sdrspbuf3;
+	rspBuf[4] = host->base->sdrspbuf4;
+	rspBuf[5] = host->base->sdrspbuf5;
+
+	/* Pass response back to Linux */
+	cmd->resp[0] = (rspBuf[1] << 24) | (rspBuf[2] << 16) | (rspBuf[3] << 8) | rspBuf[4];
+	cmd->resp[1] = rspBuf[5] << 24;
+
+	return;
+}
+
+/*
+ * Retrieve response for cmd+rsp and normal dma request
+ * This function makes sure host returns to it's sdstate_new idle or error state
+ * Note: Error handling should be performed afterwards
+ */
+static void spsdv2_get_rsp(SPSDHOST *host, struct mmc_command *cmd)
+{
+	if (cmd->flags & MMC_RSP_136)
+		spsdv2_get_rsp_136(host, cmd);
+	else
+		spsdv2_get_rsp_48(host, cmd);
+	return;
+}
+
+#if 0
+ETIMEDOUT    Card took too long to respond
+EILSEQ       Basic format problem with the received or sent data
+(e.g. CRC check failed, incorrect opcode in response or bad end bit)
+#endif
+
+static void spsdv2_check_sdstatus_errors(SPSDHOST *host, struct mmc_command *cmd, struct mmc_data *data)
+{
+	if (host->base->sdstate_new & SDSTATE_NEW_ERROR_TIMEOUT) {
+		DPRINTK("cmd %d error with sdstate = %x, sdstatus = %x\n",
+			cmd->opcode, host->base->sd_state, host->base->sdstatus);
+		/* Response related errors */
+		if (host->base->sdstatus & SP_SDSTATUS_WAIT_RSP_TIMEOUT)
+			cmd->error = -ETIMEDOUT;
+		if (host->base->sdstatus & SP_SDSTATUS_RSP_CRC7_ERROR)
+			cmd->error = -EILSEQ;
+
+		/* Only check the below error flags if data transaction is involved */
+		if(data) {
+			/* Data transaction related errors */
+			if (host->base->sdstatus & SP_SDSTATUS_WAIT_STB_TIMEOUT)
+				data->error = -ETIMEDOUT;
+			if (host->base->sdstatus & SP_SDSTATUS_WAIT_CARD_CRC_CHECK_TIMEOUT)
+				data->error = -ETIMEDOUT;
+
+			if (host->base->sdstatus & SP_SDSTATUS_CRC_TOKEN_CHECK_ERROR)
+				data->error = -EILSEQ;
+			if (host->base->sdstatus & SP_SDSTATUS_RDATA_CRC16_ERROR)
+				data->error = -EILSEQ;
+
+			/* Reset PBus channel */
+			Sd_Bus_Reset_Channel(host);
+		}
+	}
+
+	return;
+}
+
+/*
+ * Receive 48 bits response, and pass it back to kernel
+ * Used for interrupt transactions (don't need to wait sdstate_new to become idle)
+ */
+static void spsdv2_get_response_48(SPSDHOST *host)
+{
+	unsigned char rspBuf[6] = {0}; /* Used to store 6 bytes(48 bits) response */
+
+	/* Store received response buffer data */
+	rspBuf[0] = host->base->sdrspbuf0;
+	rspBuf[1] = host->base->sdrspbuf1;
+	rspBuf[2] = host->base->sdrspbuf2;
+	rspBuf[3] = host->base->sdrspbuf3;
+	rspBuf[4] = host->base->sdrspbuf4;
+	rspBuf[5] = host->base->sdrspbuf5;
+
+	/* Pass response back to kernel */
+	host->mrq->cmd->resp[0] = (rspBuf[1] << 24) | (rspBuf[2] << 16) | (rspBuf[3] << 8) | rspBuf[4];
+	host->mrq->cmd->resp[1] = rspBuf[5] << 24;
+
+	return;
+}
+
+void dump_all_regs(SPSDHOST *host)
+{
+	volatile unsigned int *reg = (volatile unsigned int *)host->base;
+	int i, j;
+	for (i =  0; i < 5; i++){
+		for (j =  0; j < 32; j++){
+			printk("g%d.%d = 0x%08x\n", i, j, *reg);
+			reg++;
+		}
+	}
+}
+
+static void spsdv2_irq_normDMA(SPSDHOST *host)
+{
+	struct mmc_data *data = host->mrq->data;
+	struct mmc_command *cmd = host->mrq->cmd;
+
+	/* Get response */
+	spsdv2_get_response_48(host);
+	/* Check error flags */
+	spsdv2_check_sdstatus_errors(host, cmd, data);
+
+	if (host->base->sdstate_new & SDSTATE_NEW_FINISH_IDLE) {
+		data->bytes_xfered = data->blocks * data->blksz;
+	} else {
+		EPRINTK("normal DMA error!\n");
+		Sd_Bus_Reset_Channel(host);
+		data->bytes_xfered = 0;
+	}
+
+	host->base->sd_cmp_clr = 1;
+
+	return;
+}
+
+static void spsdv2_irq_cmd_rsp(SPSDHOST *host)
+{
+	struct mmc_data *data = host->mrq->data;
+	struct mmc_command *cmd = host->mrq->cmd;
+
+	/* Get response */
+	spsdv2_get_response_48(host);
+	/* Check error flags */
+	spsdv2_check_sdstatus_errors(host, cmd, data);
+
+	host->base->sd_cmp_clr = 1;
+
+	return;
+}
+
+/* Interrupt Handler */
+irqreturn_t spsdv2_irq(int irq, void *dev_id)
+{
+	struct mmc_host *mmc = dev_id;
+
+	SPSDHOST *host = (SPSDHOST *)mmc_priv(mmc);
+
+	/*ignore unexpected irq */
+	if (SP_SDIO_SLOT_ID == host->id) {
+		if (host->base->sd_cmp) {
+			if (host->mrq->data != NULL)
+				spsdv2_irq_normDMA(host);
+			else
+				spsdv2_irq_cmd_rsp(host);
+			sphe_mmc_finish_request(host, host->mrq);
+		}
+
+		if (host->base->sdio_int) {
+			host->base->sdio_int_clr = 1;
+			mmc_signal_sdio_irq(mmc);
+		}
+	} else {
+		if(!host->base->sd_cmp &&
+				!host->base->hw_dma_en)
+		{
+			printk("!!!!!spsdv2_irq:unknow int\n");
+			return IRQ_HANDLED;
+		}
+
+		if (host->mrq->data != NULL) {
+			spsdv2_irq_normDMA(host);
+		} else { /* Cmd + Rsp(48 bits) IRQ */
+			spsdv2_irq_cmd_rsp(host);
+		}
+		/* disbale interrupt to workaround unexpected irq*/
+		host->base->dmacmpen_interrupt = 0;
+		host->base->sdcmpen = 0;
+		sphe_mmc_finish_request(host, host->mrq);
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+ * 1. Releases semaphore for mmc_request
+ * 2. Notifies kernel that mmc_request is done
+ */
+static void sphe_mmc_finish_request(SPSDHOST *host, struct mmc_request *mrq)
+{
+	if (mrq->data) {
+		/*
+		 * The original sg_len may differ after dma_map_sg function callback.
+		 * When executing dma_unmap_sg, the memory segment count value returned
+		 * by dma_map_sg should be used instead (value is stored in host->dma_sgcount)
+		 */
+		dma_unmap_sg(mmc_dev(host->mmc), mrq->data->sg,
+					host->dma_sgcount,
+					spsdv2_get_dma_dir(host, mrq->data));
+		if(mrq->data->error && -EINVAL != mrq->data->error) {
+			/* tune next data request timing */
+			host->need_tune_dat_timing = 1;
+			EPRINTK("data err(%d)\n", mrq->data->error);
+		}
+	}
+	if(mrq->cmd->error) {
+		/* tune next cmd request timing */
+		host->need_tune_cmd_timing = 1;
+		EPRINTK("cmd err(%d)\n",mrq->cmd->error);
+	}
+
+	host->mrq = NULL;
+
+	up(&host->req_sem);
+	mmc_request_done(host->mmc, mrq);
+}
+
+static int spsdv2_get_dma_dir(SPSDHOST *host, struct mmc_data *data)
+{
+	if (data->flags & MMC_DATA_WRITE)
+		return DMA_TO_DEVICE;
+	else
+		return DMA_FROM_DEVICE;
+}
+
+/* Get timeout_ns from kernel, and set it to HW DMA's register */
+static inline void spsdv2_set_data_timeout(SPSDHOST *host)
+{
+	unsigned int timeout_clks, cycle_ns;
+
+	cycle_ns = 1000000000 / sd_get_in_clock(host);
+	timeout_clks = host->mrq->data->timeout_ns / cycle_ns;
+	timeout_clks +=  host->mrq->data->timeout_clks;
+
+	/*  kernel set max read timeout to for SDHC 100ms, */
+	/*  mult 10 to  Improve compatibility for some unstandard card */
+	if (host->mrq->data->flags & MMC_DATA_READ)
+		timeout_clks *= READ_TIMEOUT_MULT;
+	else {
+		if (SP_EMMCSLOT_ID == host->id) {
+			timeout_clks *= EMMC_WRITE_TIMEOUT_MULT;
+		}
+	}
+
+	host->base->hw_wait_num_low = (u16)(timeout_clks & 0x0000ffff);
+	host->base->hw_wait_num_high = (u16)((timeout_clks >> 16) & 0x0000ffff);
+}
+
+static void spsdv2_set_data_info(SPSDHOST *host, struct mmc_data *data)
+{
+	int i, count = dma_map_sg(mmc_dev(host->mmc), data->sg,
+							  data->sg_len,
+							  spsdv2_get_dma_dir(host, data));
+	struct scatterlist *sg;
+	struct mmc_request *mrq = host->mrq;
+	unsigned int hw_address[SP_HW_DMA_MEMORY_SECTORS] = {0}, hw_len[SP_HW_DMA_MEMORY_SECTORS] = {0};
+
+	/* Store the dma_mapped memory segment count, it will be used when calling dma_unmap_sg */
+	host->dma_sgcount = count;
+
+	/* retreive physical memory address & size of the fragmented memory blocks */
+	for_each_sg(data->sg, sg, count, i) {
+		hw_address[i] = sg_dma_address(sg);
+		hw_len[i] = sg_dma_len(sg);
+		if(unlikely(!IS_DMA_ADDR_2BYTE_ALIGNED(hw_address[i]))) {
+			printk("[sd err]dma addr is not 2 bytes aligned\n");
+			data->error = -EINVAL;
+			return;
+		}
+	}
+
+	/* Due to host limitations, normal DMA transfer mode only supports 1 consecutive physical memory area */
+	if (count == 1) {
+		/* Reset */
+		Reset_Controller(host);
+
+		/* Configure Group SD Registers */
+		host->base->sd_cmdbuf[0] = (u8)(mrq->cmd->opcode | 0x40);	/* add start bit, according to spec, command format */
+		host->base->sd_cmdbuf[1] = (u8)((mrq->cmd->arg >> 24) & 0x000000ff);
+		host->base->sd_cmdbuf[2] = (u8)((mrq->cmd->arg >> 16) & 0x000000ff);
+		host->base->sd_cmdbuf[3] = (u8)((mrq->cmd->arg >>  8) & 0x000000ff);
+		host->base->sd_cmdbuf[4] = (u8)((mrq->cmd->arg >>  0) & 0x000000ff);
+
+		SD_PAGE_NUM_SET(host->base, data->blocks);
+		if (mrq->cmd->flags & MMC_RSP_CRC && !(mrq->cmd->flags & MMC_RSP_136))
+			host->base->sdrspchk_en = 0x1;
+		else
+			host->base->sdrspchk_en = 0x0;
+
+		if (data->flags & MMC_DATA_READ) {
+			host->base->sdcmddummy = 0;
+			host->base->sdautorsp = 0;
+			host->base->sd_trans_mode = 2;
+		} else {
+			host->base->sdcmddummy = 1;
+			host->base->sdautorsp = 1;
+			host->base->sd_trans_mode = 1;
+		}
+		if (mrq->stop)
+			host->base->sd_len_mode = 0;
+		else
+			host->base->sd_len_mode = 1;
+
+		host->base->sdpiomode = 0;
+		host->base->sdcrctmren = 1;
+		host->base->sdrsptmren = 1;
+		host->base->hw_dma_en = 0;
+		/* Set response type */
+		if(mrq->cmd->flags & MMC_RSP_136)
+			host->base->sdrsptype = 0x1;
+		else
+			host->base->sdrsptype = 0x0;
+
+		SDDATALEN_SET(host->base, data->blksz);
+
+		/* Configure Group DMA Registers */
+		if (data->flags & MMC_DATA_WRITE) {
+			host->base->dmadst = 0x2;
+			host->base->dmasrc = 0x1;
+		} else {
+			host->base->dmadst = 0x1;
+			host->base->dmasrc = 0x2;
+		}
+		DMASIZE_SET(host->base, data->blksz);
+		SET_HW_DMA_BASE_ADDR(host->base, hw_address[0]);
+	} else {
+		EPRINTK("SD Card DMA memory segment > 1, not supported!\n");
+		data->error = -EINVAL;
+	}
+	return;
+}
+
+/*
+ * DMA transfer mode, used for all other data transfer commands besides read/write block commands (cmd17, 18, 24, 25)
+ * Due to host limitations, this kind of DMA transfer mode only supports 1 consecutive memory area
+ */
+static void spsdv2_proc_normDMA(SPSDHOST *host)
+{
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *data = mrq->data;
+	spsdv2_prepare_cmd_rsp(host, mrq->cmd);
+	spsdv2_set_data_info(host, data);
+	if (!data->error) {
+		/* Configure SD INT reg */
+		/* Disable HW DMA data transfer complete interrupt (when using sdcmpen) */
+		host->base->dmacmpen_interrupt = 0;
+		host->base->sdcmpen = 0x1;
+		/* Start Transaction */
+		host->base->sdctrl_trigger_cmd = 1;
+	}
+	return;
+}
+
+static void spsdv2_prepare_cmd_rsp(SPSDHOST *host, struct mmc_command *cmd)
+{
+	struct mmc_request *mrq = host->mrq;
+
+	/* Reset */
+	Reset_Controller(host);
+
+	/* Configure Group SD Registers */
+	host->base->sd_cmdbuf[0] = (u8)(cmd->opcode | 0x40);	/* add start bit, according to spec, command format */
+	host->base->sd_cmdbuf[1] = (u8)((cmd->arg >> 24) & 0x000000ff);
+	host->base->sd_cmdbuf[2] = (u8)((cmd->arg >> 16) & 0x000000ff);
+	host->base->sd_cmdbuf[3] = (u8)((cmd->arg >>  8) & 0x000000ff);
+	host->base->sd_cmdbuf[4] = (u8)((cmd->arg >>  0) & 0x000000ff);
+
+	host->base->sd_trans_mode = 0x0;
+	if (cmd->flags & MMC_RSP_PRESENT)
+		host->base->sdautorsp = 1;
+	else
+		host->base->sdautorsp = 0;
+	host->base->sdcmddummy = 1;
+
+	/*
+	 * Currently, host is not capable of checking Response R2's CRC7
+	 * Because of this, enable response crc7 check only for 48 bit response commands
+	 */
+	if (cmd->flags & MMC_RSP_CRC && !(mrq->cmd->flags & MMC_RSP_136))
+		host->base->sdrspchk_en = 0x1;
+	else
+		host->base->sdrspchk_en = 0x0;
+
+	if (cmd->flags & MMC_RSP_136)
+		host->base->sdrsptype = 0x1;
+	else
+		host->base->sdrsptype = 0x0;
+
+	/* Configure SD INT reg (Disable them) */
+	host->base->dmacmpen_interrupt = 0;
+	host->base->sdcmpen = 0x0;
+
+	return;
+}
+
+/* Process Command + Response commands (with no data) , interrupt mode */
+static void spsdv2_mmc_proc_cmd_rsp_intr(SPSDHOST *host)
+{
+	struct mmc_request *mrq = host->mrq;
+	spsdv2_prepare_cmd_rsp(host, mrq->cmd);
+
+	/* Configure SD INT reg */
+	/* Disable HW DMA data transfer complete interrupt (when using sdcmpen) */
+	host->base->dmacmpen_interrupt = 0;
+	host->base->sdcmpen = 0x1;
+
+	/* Start Transaction */
+	host->base->sdctrl_trigger_cmd = 1;
+
+	return;
+}
+
+/* Process Command + No Response commands (with no data) */
+static void spsdv2_mmc_proc_cmd(SPSDHOST *host)
+{
+	struct mmc_request *mrq = host->mrq;
+	spsdv2_prepare_cmd_rsp(host, mrq->cmd);
+
+	/* Configure SD INT reg */
+	/* Disable HW DMA data transfer complete interrupt (when using sdcmpen) */
+	host->base->dmacmpen_interrupt = 0;
+	host->base->sdcmpen = 0x0;
+
+	/* Start Transaction */
+	host->base->sdctrl_trigger_cmd = 1;
+
+	while((host->base->sdstate_new & SDSTATE_NEW_FINISH_IDLE) != 0x40) {
+		/* printk("Waiting! sd_hw_state : 0x%x   LMST_SM:0x%x   Data In Counter :%u Data Out Counter: %u\n", host->base->hwsd_sm, host->base->lmst_sm, host->base->incnt, host->base->outcnt); */
+		/* printk("sd status:0x%x, state:0x%x, state new:0x%x\n", host->base->sdstatus, host->base->sdstate, host->base->sdstate_new); */
+		/* printk("Waiting\n"); */
+	}
+
+	sphe_mmc_finish_request(host, host->mrq);
+}
+
+/* For mmc_requests
+ * ================ Data transfer requests ===========================
+ * 1. Data transfer requests : use interrupt mode
+ * ================= Non data transfer requests =======================
+ * 1. Command + Response (48 bit response) requests : use interrupt mode
+ * 2. Command + Response (136 bit response) requests : use polling mode
+ * 3. Command (no response) requests : use polling mode
+ */
+void spsdv2_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	SPSDHOST *host = mmc_priv(mmc);
+	int retry_count = (host->need_tune_cmd_timing || host->need_tune_dat_timing)
+		? MAX_DLY_CLK : 0;
+
+	DPRINTK("\n<----- mrq:0x%x, cmd:%d, arg:0x%08x, data len:%d, stop:0x%x\n",
+		(unsigned int)mrq, mrq->cmd->opcode&0xfff, mrq->cmd->arg,
+		(mrq->data)?(mrq->data->blocks*mrq->data->blksz):0, (unsigned int)mrq->stop);
+
+	/*
+	 * The below semaphore is released when "sphe_mmc_finish_request" is called
+	 * TODO: Observe if the below semaphore is necessary
+	 */
+	down(&host->req_sem);
+
+	host->mrq = mrq;
+	if (mrq->data == NULL) {
+		if (mrq->cmd->flags & MMC_RSP_PRESENT) {
+			if (unlikely(host->need_tune_cmd_timing || mrq->cmd->flags & MMC_RSP_136)) {
+				do {
+					mrq->cmd->error = 0;
+					spsdv2_prepare_cmd_rsp(host, mrq->cmd);
+					spsdv2_trigger_sdstate(host);
+					spsdv2_get_rsp(host, mrq->cmd); /* Makes sure host returns to an idle or error state */
+					spsdv2_check_sdstatus_errors(host, mrq->cmd, mrq->data);
+					if (-EILSEQ == mrq->cmd->error) {
+						host->base->sd_rd_dly_sel++;
+					} else if (-ETIMEDOUT == mrq->cmd->error) {
+						host->base->sd_wr_dly_sel++;
+					} else {
+						break;
+					}
+				} while(retry_count--);
+				if (!mrq->cmd->error)
+					host->need_tune_cmd_timing = 0;
+				sphe_mmc_finish_request(host, host->mrq);
+			} else {
+				spsdv2_mmc_proc_cmd_rsp_intr(host);
+			}
+		} else {
+			spsdv2_mmc_proc_cmd(host);
+		}
+	} else {
+		if (unlikely(host->need_tune_dat_timing)) {
+			do {
+				mrq->data->error = 0;
+				spsdv2_prepare_cmd_rsp(host, mrq->cmd);
+				spsdv2_set_data_info(host, mrq->data);
+				if(-EINVAL == mrq->data->error) {
+					break;
+				}
+				spsdv2_trigger_sdstate(host);
+				spsdv2_get_rsp(host, mrq->cmd); /* Makes sure host returns to an idle or error state */
+				spsdv2_check_sdstatus_errors(host, mrq->cmd, mrq->data);
+				if (-EILSEQ == mrq->data->error) {
+					if (mrq->data->flags & MMC_DATA_WRITE) {
+						if (is_crc_token_valid(host))
+							host->base->sd_wr_dly_sel++;
+						else
+							host->base->sd_rd_dly_sel++;
+					} else {
+						host->base->sd_rd_dly_sel++;
+					}
+				} else if (-ETIMEDOUT == mrq->data->error) {
+					host->base->sd_wr_dly_sel++;
+				} else {
+					break;
+				}
+				if (mrq->stop) {
+					spsdv2_prepare_cmd_rsp(host, mrq->stop);
+					spsdv2_trigger_sdstate(host);
+					spsdv2_get_rsp(host, mrq->stop); /* Makes sure host returns to an idle or error state */
+					spsdv2_check_sdstatus_errors(host, mrq->stop, NULL);
+				}
+			} while(retry_count--);
+			if (!mrq->data->error)
+				host->need_tune_dat_timing = 0;
+			sphe_mmc_finish_request(host, host->mrq);
+		} else {
+			spsdv2_proc_normDMA(host);
+			if(-EINVAL == host->mrq->data->error) { /*  para is not correct return */
+				sphe_mmc_finish_request(host, host->mrq);
+			}
+		}
+	}
+}
+
+/* set_ios -
+ * 1) Set/Disable clock
+ * 2) Power on/off to offer SD card or not
+ * 3) Set SD Card Bus width to 1 or 4
+ */
+void spsdv2_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	SPSDHOST *host = (SPSDHOST *)mmc_priv(mmc);
+
+	IFPRINTK("\n<----- sd%d: clk:%d, buswidth:%d(2^n), bus_mode:%d, powermode:%d(0:off, 1:up, 2:on), timing:%d\n",
+		host->id, ios->clock, ios->bus_width, ios->bus_mode, ios->power_mode, ios->timing);
+
+	down(&host->req_sem);
+
+	spsdv2_set_power_mode(host, ios);
+	spsdv2_set_clock(host, ios);
+	spsdv2_set_bus_width(host, ios->bus_width);
+	host->need_tune_cmd_timing = 0;
+	host->need_tune_dat_timing = 0;
+
+	up(&host->req_sem);
+	IFPRINTK("----- \n\n");
+
+	return;
+}
+
+int spsdv2_mmc_read_only(struct mmc_host *mmc)
+{
+	/* return  > 0 :support read only */
+	/*         < 0 :not support RO */
+	/*         = 0 :no action */
+	return -ENOSYS;
+}
+
+
+/*
+ * Return values for the get_cd callback should be:
+ *   0 for a absent card
+ *   1 for a present card
+ *   -ENOSYS when not supported (equal to NULL callback)
+ *   or a negative errno value when something bad happened
+ */
+int spsdv2_mmc_card_detect(struct mmc_host *mmc)
+{
+	SPSDHOST *host = mmc_priv(mmc);
+
+	int ret = 0;
+	#ifdef SP_SDCARD_SENSE_WITH_GPIO
+	ret = !GPIO_I_GET(host->cd_gpio);
+	#endif
+	host->cd_state = ret;
+	return ret;
+}
+
+static void spsdv2_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	SPSDHOST *host = mmc_priv(mmc);
+	if (enable) {
+		host->base->sdio_int_en = 1;
+	} else {
+		host->base->sdio_int_en = 0;
+	}
+}
+
+const struct mmc_host_ops spsdv2_sdc_ops = {
+	.request = spsdv2_mmc_request,
+	.set_ios = spsdv2_mmc_set_ios,
+	.get_ro = spsdv2_mmc_read_only,
+	.get_cd = spsdv2_mmc_card_detect,
+	.enable_sdio_irq = spsdv2_enable_sdio_irq,
+};
+
+
+static uint get_max_sd_freq(SPSDHOST *host)
+{
+	uint max_freq = SPSD_MAX_CLOCK;
+
+	/* fix me read from device tree */
+	max_freq = SPSD_MAX_CLOCK;
+
+	printk("[SDCard] Slot %d, actually use max_freq #%d M\n", host->id, max_freq/CLOCK_1M);
+	return max_freq;
+}
+
+int spsdv2_drv_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct mmc_host *mmc;
+	struct resource *resource;
+	SPSDHOST *host;
+	spsdv2_dridata_t *priv = NULL;
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+		match = of_match_node(spsdv2_of_id, pdev->dev.of_node);
+		if (match)
+			priv = (spsdv2_dridata_t *)match->data;
+	}
+
+	mmc = mmc_alloc_host(sizeof(SPSDHOST), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto probe_free_host;
+	}
+
+	host = (SPSDHOST *)mmc_priv(mmc);
+	host->mmc = mmc;
+	host->pdev = pdev;
+	host->power_state = MMC_POWER_UNDEFINED;
+
+	if (priv)
+		host->id  = priv->id;
+
+	printk("sd slot id:%d\n", host->id);
+
+	/*sd controller register*/
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(resource)) {
+		EPRINTK("get sd %d register resource fail\n", host->id);
+		ret = PTR_ERR(resource);
+		goto probe_free_host;
+	}
+
+	if ((resource->end - resource->start + 1) < sizeof(SDREG)) {
+		EPRINTK("register size not right e:%d:r:%d\n",
+			resource->end - resource->start + 1, sizeof(SDREG));
+		ret = -EINVAL;
+		goto probe_free_host;
+	}
+
+	host->base = devm_ioremap_resource(&pdev->dev, resource);
+	if (IS_ERR((void *)host->base)) {
+		EPRINTK("devm_ioremap_resource fail\n");
+		ret = PTR_ERR((void *)host->base);
+		goto probe_free_host;
+	}
+	DPRINTK("SD card driver probe, sd %d, base:0x%x, host size:%d\n", host->id, resource->start, resource->end - resource->start);
+
+	/* host->irq = of_irq_get(pdev->dev.of_node, 0); */
+	host->irq = platform_get_irq(pdev, 0);
+	if (host->irq <= 0) {
+		EPRINTK("get sd %d irq resource fail\n", host->id);
+		ret = -EINVAL;
+		goto probe_free_host;
+	}
+	DPRINTK("irq  %d\n",	host->irq);
+
+	/*
+	 * fix me read from device tree after clock pinmux device tree ok
+	 */
+	pinmux_enable(host);
+
+	sd_set_in_clock(host);
+
+	if(SP_EMMCSLOT_ID == host->id) {
+		host->wrdly = host->base->sd_wr_dly_sel;
+		host->rddly = host->base->sd_rd_dly_sel;
+	} else if(SP_SDIO_SLOT_ID == host->id) {
+		host->wrdly = 1;
+		host->rddly = 0;
+	}
+
+	if (request_irq(host->irq, spsdv2_irq, IRQF_SHARED, dev_name(&pdev->dev), mmc)) {
+		printk("\nFailed to request sd card interrupt.\n");
+		ret = -ENOENT;
+		goto probe_free_host;
+	}
+
+	DPRINTK("[SDCard] Slot %d driver probe, host:0x%x, base:0x%x\n", host->id, (unsigned int)host,(unsigned int)host->base);
+
+
+	sema_init(&host->req_sem, 1);
+
+	mmc->ops = &spsdv2_sdc_ops;
+
+	/*
+	 * freq_divisor[11:10] = sdfreq[1:0]
+	 * freq_divisor[9:0] = sdfqsel[9:0]
+	 */
+	mmc->f_min = (SPSD_CLK_SOURCE / (0x0FFF + 1));
+	mmc->f_max = get_max_sd_freq(host);
+
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	mmc->max_seg_size = 65536 * 512;            /* Size per segment is limited via host controller's
+	                                               ((sdram_sector_#_size max value) * 512) */
+	/* mmc->max_segs = SP_HW_DMA_MEMORY_SECTORS; */
+	/* Host controller supports up to "SP_HW_DMA_MEMORY_SECTORS", a.k.a. max scattered memory segments per request */
+	mmc->max_segs = 1;
+	mmc->max_req_size = 65536 * 512;			/* Decided by hw_page_num0 * SDHC's blk size */
+	mmc->max_blk_size = 512;                   /* Limited by host's dma_size & data_length max value, set it to 512 bytes for now */
+	mmc->max_blk_count = 65536;                 /* Limited by sdram_sector_#_size max value */
+	if(SP_EMMCSLOT_ID == host->id) {
+		mmc->caps =  MMC_CAP_MMC_HIGHSPEED | MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE;
+		mmc->caps2 = MMC_CAP2_NO_SDIO | MMC_CAP2_NO_SD;
+	} else if (SP_SDIO_SLOT_ID == host->id) {
+		mmc->caps =  MMC_CAP_SD_HIGHSPEED | MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ | MMC_CAP_NONREMOVABLE;
+		mmc->caps2 = MMC_CAP2_NO_SD | MMC_CAP2_NO_MMC;
+	} else {
+		mmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED | MMC_CAP_NEEDS_POLL;
+		mmc->caps2 = MMC_CAP2_NO_SDIO | MMC_CAP2_NO_MMC;
+		#ifdef SP_SDCARD_SENSE_WITH_GPIO
+		if (of_property_read_u32(pdev->dev.of_node, "sense-gpio", &host->cd_gpio)) {
+			printk(KERN_ERR "Failed to get card detect gpio pin configuration!\n");
+			ret = -ENOENT;
+			goto probe_free_host;
+		}
+		GPIO_F_SET(host->cd_gpio, 1);
+		GPIO_M_SET(host->cd_gpio, 1);
+		GPIO_E_SET(host->cd_gpio, 0);
+		#endif
+	}
+	dev_set_drvdata(&pdev->dev, mmc);
+
+	mmc_add_host(mmc);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	return 0;
+
+probe_free_host:
+	if (mmc)
+		mmc_free_host(mmc);
+
+	return ret;
+}
+
+int spsdv2_drv_remove(struct platform_device *dev)
+{
+	struct mmc_host *mmc;
+	SPSDHOST *host;
+
+	DPRINTK("Remove sd card\n");
+	mmc = platform_get_drvdata(dev);
+	if (!mmc)
+		return -EINVAL;
+
+	host = (SPSDHOST *)mmc_priv(mmc);
+	devm_iounmap(&dev->dev, (void *)host->base);
+	platform_set_drvdata(dev, NULL);
+
+	mmc_remove_host(mmc);
+	free_irq(host->irq, mmc);
+	mmc_free_host(mmc);
+
+	return 0;
+}
+
+
+int spsdv2_drv_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct mmc_host *mmc;
+	SPSDHOST *host;
+
+	mmc = platform_get_drvdata(dev);
+	if (!mmc)
+		return -EINVAL;
+
+	host = (SPSDHOST *)mmc_priv(mmc);
+
+	printk("Sunplus SD %d driver suspend.\n", host->id);
+	down(&host->req_sem);
+	up(&host->req_sem);
+
+	return 0;
+}
+
+int spsdv2_drv_resume(struct platform_device *dev)
+{
+
+#ifdef CONFIG_PM
+	struct mmc_host *mmc;
+	SPSDHOST *host;
+
+	mmc = platform_get_drvdata(dev);
+	if (!mmc)
+		return -EINVAL;
+
+	host = (SPSDHOST *)mmc_priv(mmc);
+
+
+	printk("Sunplus SD%d driver resume.\n", host->id);
+#endif
+
+	return 0;
+}
+#ifdef CONFIG_PM
+
+static int spsdv2_pm_suspend(struct device *dev)
+{
+	pm_runtime_force_suspend(dev);
+	return 0;
+}
+
+static int spsdv2_pm_resume(struct device *dev)
+{
+	pm_runtime_force_resume(dev);
+	return 0;
+}
+
+static int spsdv2_pm_runtime_suspend(struct device *dev)
+{
+	#if 0
+	int qctl_val, ret = 0, retry = 1000;
+	struct mmc_host *mmc;
+	SPSDHOST *host;
+	volatile void __iomem *reg;
+	mmc = platform_get_drvdata(to_platform_device(dev));
+	if (!mmc)
+		return -EINVAL;
+	host = (SPSDHOST *)mmc_priv(mmc);
+	down(&host->req_sem);
+	if (ctlr_clk_disable()) {
+		EPRINTK("fail to disable card controller clock!\n");
+		ret = -EIO;
+		goto out;
+	}
+	reg = ioremap_nocache(RF_GRP(30, 1), 4);
+	if (!reg) {
+		EPRINTK("map Q-channel register failed!\n");
+		ret = -EIO;
+		goto out;
+	}
+	writel(RF_MASK_V_CLR(1 << 11), reg);
+	qctl_val = readl(reg);
+	while((qctl_val & (1 << 8)) && retry--)
+		qctl_val = readl(reg);
+	if ((qctl_val & (1 << 10)) || !retry) {
+		EPRINTK("[SD]q-channel unable to enter quiescence state\n");
+		writel(RF_MASK_V_SET(1 << 11), reg);
+		ret = -EIO;
+	}
+	iounmap(reg);
+out:
+	up(&host->req_sem);
+	return ret;
+	#endif
+	return 0;
+}
+
+static int spsdv2_pm_runtime_resume(struct device *dev)
+{
+	#if 0
+	int qctl_val, ret = 0, retry = 1000;
+	struct mmc_host *mmc;
+	SPSDHOST *host;
+	volatile void __iomem *reg;
+	mmc = platform_get_drvdata(to_platform_device(dev));
+	if (!mmc)
+		return -EINVAL;
+	host = (SPSDHOST *)mmc_priv(mmc);
+	reg = ioremap_nocache(RF_GRP(30, 1), 4);
+	if (!reg) {
+		EPRINTK("map Q-channel register failed!\n");
+		ret = -EIO;
+		goto out;
+	}
+	writel(RF_MASK_V_SET(1 << 11), reg);
+	qctl_val = readl(reg);
+	while(!(qctl_val & (1 << 8)) && retry--)
+		qctl_val = readl(reg);
+	iounmap(reg);
+	if (!retry) {
+		EPRINTK("[SD]q-channel unable to exit quiescence state\n");
+		ret = -EIO;
+		goto out;
+	}
+	if (ctlr_clk_enable()) {
+		EPRINTK("fail to enable card controller clock!\n");
+		ret = -EIO;
+	}
+out:
+	return ret;
+	#endif
+	return 0;
+}
+
+const struct dev_pm_ops sphe_mmc2_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(spsdv2_pm_suspend, spsdv2_pm_resume)
+	SET_RUNTIME_PM_OPS(spsdv2_pm_runtime_suspend, spsdv2_pm_runtime_resume, NULL)
+};
+#endif
+
+
+
+struct platform_driver spsdv2_driver_sdc = {
+	.probe = spsdv2_drv_probe,
+	.remove = spsdv2_drv_remove,
+	.shutdown = NULL,
+	.suspend = spsdv2_drv_suspend,
+	.resume = spsdv2_drv_resume,
+	.driver = {
+		.name = SPSDV2_SDC_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = spsdv2_of_id,
+#ifdef CONFIG_PM
+		.pm= &sphe_mmc2_pm_ops,
+#endif
+	}
+};
+
+module_platform_driver(spsdv2_driver_sdc);
+
+MODULE_AUTHOR("SPHE B1");
+MODULE_DESCRIPTION("SPHE MMC/SD Card Interface Driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/mmc/host/spsdv2.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/mmc/host/spsdv2.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,581 @@
+#ifndef _SPSDV2_H_
+#define _SPSDV2_H_
+////////////////////////////////////////////////////////////////
+#include <linux/semaphore.h>
+#include <linux/kthread.h>
+#include <linux/mmc/host.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/mmc.h>
+#include <mach/irqs.h>
+
+/////////////////////////////////////////////////////////////////
+#define SPSD_SUCCESS			0x00000000
+#define SPSD_FAIL				0x00000001
+#define SPSD_RSP_TIMEOUT		0x00000002
+#define SPSD_CRC_ERROR			0x00000004
+#define SPSD_COUNTER_ERROR		0x00000008
+#define SPSD_DMA_FAIL			0x00000010
+#define SPSD_TIMEOUT			0x00000020
+#define SPSD_CRC_TIMEOUT		0x00000040
+#define SPSD_CARD_NOT_EXIST		0x00000080
+#define SPSD_COMPLETE_INIT		0x80000000
+
+#define SDCARD_STATUS_NOTEXIST 			0
+#define SDCARD_STATUS_EXIST 			1
+#define SDCARD_STATUS_TESTNOTEXIST 		2
+#define SDCARD_STATUS_TESTEXIST 		3
+
+//1.17[14]
+#define CARD_MODE_SD	0
+#define CARD_MODE_MMC	1
+
+//to delete
+#define SD_1BIT_MODE 			0
+#define SD_4BIT_MODE 			1
+
+#define SPRSP_TYPE_NORSP		0
+#define SPRSP_TYPE_R1  			1
+#define SPRSP_TYPE_R1B 			11
+#define SPRSP_TYPE_R2  			2
+#define SPRSP_TYPE_R3  			3
+#define SPRSP_TYPE_R4  			4
+#define SPRSP_TYPE_R5  			5
+#define SPRSP_TYPE_R6  			6
+#define SPRSP_TYPE_R7 			7
+
+#define SP_DMA_DRAM      		1
+#define SP_DMA_FLASH     		2
+
+#define SP_DMA_DST_SHIFT		4
+#define SP_DMA_SRT_SHIFT		0
+
+#define SP_BUS_WIDTH_1BIT 0
+#define SP_BUS_WIDTH_4BIT 1
+#define SP_BUS_WIDTH_8BIT (1<<6)
+#define CLOCK_200K	200000
+#define CLOCK_300K	300000
+#define CLOCK_375K	375000
+#define CLOCK_400K	400000
+#define CLOCK_1M	1000000
+#define CLOCK_5M	5000000
+#define CLOCK_10M	10000000
+#define CLOCK_12M	12000000
+#define CLOCK_15M	15000000
+#define CLOCK_20M	20000000
+#define CLOCK_25M	25000000
+#define CLOCK_27M	27000000
+#define CLOCK_30M	30000000
+#define CLOCK_35M	35000000
+#define CLOCK_45M	45000000
+#define CLOCK_48M	48000000
+#define CLOCK_50M	50000000
+#define CLOCK_52M	52000000
+
+#define CLOCK_240M  240000000
+#define CLOCK_270M  270000000
+#define CLOCK_202M  202500000
+
+/* kernel set max read timeout to 100ms,
+ * mult  to  Improve compatibility for some unstandard card
+ */
+#define READ_TIMEOUT_MULT     10
+
+
+/* kernel set max read timeout to 3s,
+ * mult  to  Improve compatibility for some unstandard emmc
+ */
+#define EMMC_WRITE_TIMEOUT_MULT     5
+
+/******************************************************************************
+*                          MACRO Function Define
+*******************************************************************************/
+
+#ifndef REG
+//#define REG(x) (*(volatile unsigned long *)(x))
+#define REG(x) (*(volatile unsigned int *)(x))
+#endif
+
+#define get_val(addr)		REG(addr)
+#define set_val(addr, val)	REG(addr) = (val)
+
+#ifndef set_bit
+#define set_bit(addr, val)	set_val((addr), (get_val(addr) | (val)))
+#endif
+
+#ifndef clear_bit
+#define clear_bit(addr, val)	set_val((addr), (get_val(addr) & ~(val)))
+#endif
+
+typedef volatile unsigned int dv_reg;
+
+typedef struct spsd_general_regs {
+	/*  group 0 */
+	dv_reg mediatype:3;				/* 0. lower bits first, mmc set 6?? */
+	dv_reg reserved_card_mediatype:29;
+#define SP_MEDIA_NONE			0
+#define SP_MEDIA_SMC			1
+#define SP_MEDIA_RESERVED1 		2
+#define SP_MEDIA_CF				3
+#define SP_MEDIA_SPI			4
+#define SP_MEDIA_RESERVED2		5
+#define SP_MEDIA_SD				6
+#define SP_MEDIA_MEMORY_STICK	7
+
+	/* for the register that take whole bits(0-15, ignore 16-31), just define the field name */
+	dv_reg reserved0;				/* 1. 32 bits */
+	dv_reg cpu_page_cnt;			/* 2. 16 bits */
+	dv_reg card_ctl_page_cnt;		/* 3. 16 bits */
+	dv_reg sdram_sector_0_size;		/* 4. 16 bits */
+	dv_reg ring_buffer_on;			/* 5. 1 bit valid */
+	dv_reg CARD_GCLK_DISABLE;		/* 6. 12 bits */
+	dv_reg SDRAM_SECTOR_1_ADDR;		/* 7. 32 bits */
+	dv_reg SDRAM_SECTOR_1_SIZE;		/* 8. 16 bits */
+	dv_reg SDRAM_SECTOR_2_ADDR;		/* 9. 32 bits */
+	dv_reg SDRAM_SECTOR_2_SIZE;		/* 10.16 bits */
+	dv_reg SDRAM_SECTOR_3_ADDR;		/* 11.32 bits */
+	dv_reg SDRAM_SECTOR_3_SIZE;		/* 12.16 bits */
+	dv_reg SDRAM_SECTOR_4_ADDR;		/* 13.32 bits */
+	dv_reg SDRAM_SECTOR_4_SIZE;		/* 14.16 bits */
+	dv_reg SDRAM_SECTOR_5_ADDR;		/* 15.32 bits */
+	dv_reg SDRAM_SECTOR_5_SIZE;		/* 16.16 bits */
+	dv_reg SDRAM_SECTOR_6_ADDR;		/* 17.32 bits */
+	dv_reg SDRAM_SECTOR_6_SIZE;		/* 18.16 bits */
+	dv_reg SDRAM_SECTOR_7_ADDR;		/* 19.32 bits */
+	dv_reg SDRAM_SECTOR_7_SIZE;		/* 20.16 bits */
+	dv_reg sdram_sector_cnt;		/* 21.3 bits */
+#define SP_HW_DMA_MEMORY_SECTORS	8 /*  supports up to 8 fragmented memory blocks */
+	dv_reg reserved[10];			/* 22-31. */
+
+	/*  group 1 */
+	dv_reg reserved_group1[11];			/* 0-10. */
+
+	dv_reg vol_tmr:2;				/* 11. */
+	dv_reg sw_set_vol:1;
+	dv_reg hw_set_vol:1;
+	dv_reg vol_result:2;
+	dv_reg Reserved_sd_vol_ctrl:26;
+
+	dv_reg sdcmpen:1;				/* 12. */
+	dv_reg sd_cmp:1;
+	dv_reg sd_cmp_clr:1;
+	dv_reg reserved0_sd_int:1;
+	dv_reg sdio_int_en:1;
+	dv_reg sdio_int:1;
+	dv_reg sdio_int_clr:1;
+	dv_reg detect_int_en:1;
+	dv_reg detect_int:1;
+	dv_reg detect_int_clr:1;
+	dv_reg reserved1_sd_int:22;
+
+	dv_reg sd_page_num;				/* 13. 16 bits */
+
+	dv_reg sdpiomode:1;				/* 14. */
+	dv_reg sdddrmode:1;
+	dv_reg sd_len_mode:1;
+#define SP_LENMODE_SEND_STOP 				0
+#define SP_LENMODE_NOT_SEND_STOP 			1
+	dv_reg reserved0_sd_config0:1;
+	dv_reg sd_trans_mode:2;
+#define SP_TRANSACTION_MODE_CMD_RSP			0
+#define SP_TRANSACTION_MODE_WRITE_DATA		1
+#define SP_TRANSACTION_MODE_READ_DATA		2
+	dv_reg sdautorsp:1; 				/* sdautorsp should be enabled except CMD0(idle, norsp) and read command(rx data, including acmd51, acmd13, ...) */
+#define SP_AUTORSP_NO_RX_RESPONSE 			0
+#define SP_AUTORSP_ATUO_RX_RESPONSE 		1
+	dv_reg sdcmddummy:1; 				/* sdcmddummy should be enabled except read command(rx data, including acmd51, acmd13, ...) */
+	dv_reg sdrspchk_en:1;
+	dv_reg reserved1_sd_config0:23;
+
+	dv_reg rwc:1;					/* 15. */
+	dv_reg s4mi:1;
+	dv_reg resu:1;
+	dv_reg sus_req:1;
+	dv_reg con_req:1;
+	dv_reg sus_data_flag:1;
+	dv_reg int_multi_trig:1;
+	dv_reg reserved_sdio_ctrl:25;
+
+	dv_reg sdrst:1;					/* 16. */
+	dv_reg sdcrcrst:1;
+	dv_reg sdiorst:1;
+	dv_reg reserved_sd_rst:29;
+
+	dv_reg sdfqsel:12;				/* 17. */
+	dv_reg sddatawd:1;				/* bus width:0:1bit   1:4bit */
+	dv_reg sdrsptype:1;
+#define SP_SD_RSP_TYPE_LEN_48_BITS		0
+#define SP_SD_RSP_TYPE_LEN_136_BITS		1
+	dv_reg sdrsptmren:1;
+	dv_reg sdcrctmren:1;
+	dv_reg sdmmcmode:1;
+#define SP_SD_MODE   0
+#define SP_MMC_MODE  1
+	dv_reg selci:1;
+	dv_reg mmc8_en:1;
+	dv_reg rx4b_en:1;
+	dv_reg sdiomode:1;
+#define SP_SD_CARD    0
+#define SP_SDIO_CARD  1
+	dv_reg reserved_sd_config:11;
+
+	dv_reg sdctrl_trigger_cmd:1;	/* 18. */
+	dv_reg sdctrl_trigger_dummy:1;
+	dv_reg reserved_sd_ctrl:30;
+
+	dv_reg sdstatus:16;				/* 19. */
+#define SP_SDSTATUS_DUMMY_READY 					BIT(0)
+#define SP_SDSTATUS_RSP_BUF_FULL					BIT(1)
+#define SP_SDSTATUS_TX_DATA_BUF_EMPTY				BIT(2)
+#define SP_SDSTATUS_RX_DATA_BUF_FULL				BIT(3)
+#define SP_SDSTATUS_CMD_PIN_STATUS					BIT(4)
+#define SP_SDSTATUS_DAT0_PIN_STATUS					BIT(5)
+#define SP_SDSTATUS_WAIT_RSP_TIMEOUT				BIT(6)
+#define SP_SDSTATUS_WAIT_CARD_CRC_CHECK_TIMEOUT		BIT(7)
+#define SP_SDSTATUS_WAIT_STB_TIMEOUT				BIT(8)
+#define SP_SDSTATUS_RSP_CRC7_ERROR					BIT(9)
+#define SP_SDSTATUS_CRC_TOKEN_CHECK_ERROR			BIT(10)
+#define SP_SDSTATUS_RDATA_CRC16_ERROR				BIT(11)
+#define SP_SDSTATUS_SUSPEND_STATE_READY				BIT(12)
+#define SP_SDSTATUS_BUSY_CYCLE						BIT(13)
+#define SP_SDSTATUS_SD_DATA1						BIT(14)
+#define SP_SDSTATUS_SD_SENSE						BIT(15)
+
+	dv_reg reserved_sd_status:16;
+
+	union {
+		struct {
+			dv_reg sdstate:3;				/* 20. */
+			dv_reg reserved0_sd_state:1;
+			dv_reg sdcrdcrc:3;
+#define WRITE_CRC_TOKEN_CORRECT		2
+#define WRITE_CRC_TOKEN_ERROR		5
+			dv_reg reserved1_sd_state:1;
+			dv_reg sdstate_new:7;
+#define SDSTATE_NEW_FINISH_IDLE 		BIT(6)
+#define SDSTATE_NEW_ERROR_TIMEOUT 		BIT(5)
+			dv_reg reserved2_sd_state:17;
+		};
+		dv_reg sd_state;
+	};
+
+	dv_reg sddatalen:11;			/* 21. */
+	dv_reg reserved_sd_blocksize:21;
+
+	dv_reg hw_sd_hcsd_en:1;			/* 22. */
+	dv_reg hw_sd_dma_type:2;
+#define SP_DMA_TYPE_SINGLEBLOCK_CMD	1
+#define SP_DMA_TYPE_MULTIBLOCK_CMD		2
+	dv_reg hw_sd_cmd13_en:1;
+	dv_reg hwsd_stb_en:1;			/* ?? */
+	dv_reg cmd13_rsp_cnt:11;
+	dv_reg reserved_sd_hwdma_config:16;
+
+	dv_reg sdrsptmr:11;				/* 23. */
+	dv_reg sd_high_speed_en:1;
+	dv_reg sd_wr_dly_sel:3;
+	dv_reg reserved_sd_timing_config0:17;
+
+	dv_reg sdcrctmr:11;				/* 24. */
+	dv_reg reserved_sdcrctmr:2;
+	dv_reg sd_rd_dly_sel:3;
+	dv_reg reserved_sd_timing_config1:16;
+
+	dv_reg sdpiodatatx;				/* 25. 16 bits, the write buffer always 2 bytes. */
+	dv_reg sdpiodatarx;				/* 26. when rx4b_en=1, read 4 bytes from this register. When rx4b_en=0, read 2 bytes. Little endian. */
+#define SP_SD_CMDBUF_SIZE 5
+	dv_reg sd_cmdbuf[SP_SD_CMDBUF_SIZE];	/* 27-31. 8 bits. the first bit is the start bit. So the command should be cmd|0x40 */
+	/* total 5 bytes, and the controller will append the crc7. Overall 6 bytes (48 bits) for the command */
+
+	/*  group 2 */
+	union {
+		struct {
+			dv_reg sdrspbuf3:8;				/* 0. */
+			dv_reg sdrspbuf2:8;
+			dv_reg sdrspbuf1:8;
+			dv_reg sdrspbuf0:8;
+
+			dv_reg sdrspbuf5:8;				/* 1. */
+			dv_reg sdrspbuf4:8;
+			dv_reg reserved_sd_rspbuf:16;
+		};
+		dv_reg sd_rspbuf[2];
+	};
+
+	dv_reg sdcrc16evenbuf0:16;		/* 2. */
+	dv_reg sdcrc16evenbuf4:16;
+
+	dv_reg sdcrc16evenbuf1:16;		/* 3. */
+	dv_reg sdcrc16evenbuf5:16;
+
+	dv_reg sdcrc16evenbuf2:16;		/* 4. */
+	dv_reg sdcrc16evenbuf6:16;
+
+	dv_reg sdcrc16evenbuf3:16;		/* 5. */
+	dv_reg sdcrc16evenbuf7:16;
+
+	dv_reg reserved0_sd_crc7buf:1;	/* 6. */
+	dv_reg sdcrc7buf:7;
+	dv_reg reserved1_sd_crc7buf:24;
+
+	dv_reg sdcrc16buf0:16;			/* 7. */
+	dv_reg sdcrc16buf4:16;
+
+	dv_reg hwsd_sm:10;				/* 8. */
+	dv_reg reserved_sd_hw_state:22;
+
+	dv_reg sdcrc16buf1:16;			/* 9. */
+	dv_reg sdcrc16buf5:16;
+
+	dv_reg hwsd_cmd13_rca:16;		/* 10. */
+	dv_reg reserved_sd_hw_cmd13_rca:16;
+
+	dv_reg sdcrc16buf2:16;			/* 11. */
+	dv_reg sdcrc16buf6:16;
+
+	dv_reg tx_dummy_num:9;			/* 12. */
+	dv_reg reserved_sd_tx_dummy_num:23;
+
+	dv_reg sdcrc16buf3:16;			/* 13. */
+	dv_reg sdcrc16buf7:16;
+
+	dv_reg sd_clk_dly_sel:3;			/* 14. */
+#define SP_SD_RXDATTMR_MAX	((1 << 29) - 1)
+	dv_reg sdrxdattmr_sel:29;
+
+	dv_reg reserved_reserved_2_15;		/* 15. */
+
+	dv_reg mspiomode:1;				/* 16. */
+	dv_reg reserved0_ms_piodmarst:3;
+	dv_reg msreset:1;
+	dv_reg mscrcrst:1;
+	dv_reg msclrerr:1;
+	dv_reg reserved1_ms_piodmarst:25;
+
+	/* the following ms register not yet use in sd. */
+	dv_reg mscommand:4;					/* 17. */
+	dv_reg datasize:4;
+	dv_reg reserved_ms_cmd:24;
+
+	dv_reg reserved_reserved_2_18;		/* 18. */
+
+	dv_reg hwms_sm:10;
+	dv_reg reserved_hw_hw_state:22;		/* 19. */
+
+	dv_reg msspeed:8;					/* 20. */
+	dv_reg msdatwd:1;
+	dv_reg msspeed8:1;
+	dv_reg mstype:1;
+	dv_reg ms_rdy_chk3_en:1;
+	dv_reg ms_wdat_sel:3;
+	dv_reg reserved_ms_modespeed:17;
+
+	dv_reg ms_busy_rdy_timer:5;			/* 21. */
+	dv_reg reserved0_ms_timeout:3;
+	dv_reg ms_clk_dly_sel:3;
+	dv_reg ms_rdat_dly_sel:3;
+	dv_reg reserved_ms_timeout:18;
+
+	dv_reg msstate:8;					/* 22. */
+	dv_reg reserved_ms_state:24;
+
+	dv_reg reserved0_ms_status:1;		/* 23. */
+	dv_reg mserror_busy_rdy_timeout:1;
+	dv_reg msbs:1;
+	dv_reg reserved1_ms_status:1;
+	dv_reg ms_data_in:4;
+	dv_reg reserved2_ms_status:24;
+
+#define MS_RDDATA_SIZE 4
+	dv_reg ms_rddata[MS_RDDATA_SIZE];	/* 24-27. 8 bits */
+
+	dv_reg mscrc16buf_low:8;				/* 28. */
+	dv_reg reserved_ms_crcbuf0:24;
+
+	dv_reg mscrc16buf_high:8;			/* 29. */
+	dv_reg reserved_ms_crcbuf1:24;
+
+	dv_reg mserror:1;					/* 30. */
+	dv_reg mscrc16cor:1;
+	dv_reg reserved_mccrcerror:30;
+
+	dv_reg mspiordy:1;					/* 31. */
+	dv_reg reserved_ms_piordy:31;
+
+	/*  group 3 */
+#define SP_MS_WD_DATA_SIZE 16
+	dv_reg ms_wd_data[SP_MS_WD_DATA_SIZE];
+	dv_reg reserved_ms[16];
+
+	/*  group 4 */
+	dv_reg dmadata:16;					/* 0. */
+	dv_reg reserved_dma_data:16;
+
+	dv_reg dmasrc:3;					/* 1. */
+	dv_reg reserved0_dma_data:1;
+	dv_reg dmadst:3;
+	dv_reg reserved1_dma_data:25;
+
+	dv_reg dmasize:11;					/* 2. */
+	dv_reg reserved_dma_size:21;
+
+	dv_reg stop_dma_flag:1;				/* 3. */
+	dv_reg hw_dma_rst:1;
+	dv_reg rst_cnad:1;					/* When set this bit to 1, wait it change back to 0 */
+	dv_reg reserved_dma_hw_stop_rst:29;
+	dv_reg dmaidle:1;					/* 4. */
+#define SP_DMA_NORMAL_STATE			0
+#define SP_RESET_DMA_OPERATION		1
+	dv_reg reserved_dma_ctrl:31;
+
+	dv_reg dma_base_addr_low:16;		/* 5. */
+	dv_reg reserved_dma_base_addr_low:16;
+
+	dv_reg dma_base_addr_high:16;		/* 6. */
+	dv_reg reserved_dma_base_addr_high:16;
+
+	dv_reg hw_dma_en:1;					/* 7. */
+	dv_reg hw_block_mode_en:1;
+#define SP_DMA_BLOCK_MODE_PAGE_LEVEL	0
+#define SP_DMA_BLOCK_MODE_BLOCK_LEVEL	1
+
+	dv_reg reserved_dma_hw_en:30;
+
+
+	dv_reg block0_hw_page_addr_low:16;	/* 8. */
+	dv_reg reserved_block0_hw_page_addr_low:16;
+
+	dv_reg block0_hw_page_addr_high:16;	/* 9. */
+	dv_reg reserved_block0_hw_page_addr_high:16;
+
+	dv_reg block1_hw_page_addr_low:16;	/* 10. */
+	dv_reg reserved_block1_hw_page_addr_low:16;
+
+	dv_reg block1_hw_page_addr_high:16;	/* 11. */
+	dv_reg reserved_block1_hw_page_addr_high:16;
+
+	dv_reg block2_hw_page_addr_low:16;	/* 12. */
+	dv_reg reserved_block2_hw_page_addr_low:16;
+
+	dv_reg block2_hw_page_addr_high:16;	/* 13. */
+	dv_reg reserved_block2_hw_page_addr_high:16;
+
+	dv_reg block3_hw_page_addr_low:16;	/* 14. */
+	dv_reg reserved_block3_hw_page_addr_low:16;
+
+	dv_reg block3_hw_page_addr_high:16;	/* 15. */
+	dv_reg reserved_block3_hw_page_addr_high:16;
+
+#define SP_DMA_HW_PAGE_NUM_SIZE 4
+	dv_reg dma_hw_page_num[SP_DMA_HW_PAGE_NUM_SIZE];	/* 16-19. 16 bits the actual page number is x+1 */
+
+	dv_reg hw_block_num:2;				/* 20. */
+	dv_reg hw_blcok_cnt:2;
+	dv_reg reserved_dma_hw_block_num:28;
+
+	dv_reg dmastart:1;					/* 21. */
+	dv_reg reserved_dma_start:31;
+
+	dv_reg hw_page_cnt;					/* 22. 16 bits */
+
+	dv_reg dma_cmp:1;					/* 23. */
+	dv_reg reserved_dma_cmp:31;
+
+	dv_reg dmacmpen_interrupt:1;		/* 24. */
+	dv_reg reserved_dma_int_en:31;
+
+	dv_reg reserved_reserved_4_25;		/* 25. */
+	dv_reg hw_wait_num_low;				/* 26. 16 bits */
+	dv_reg hw_wait_num_high;			/* 27. 16 bits */
+	dv_reg hw_delay_num;				/* 28. 16 bits */
+
+	dv_reg incnt:11;					/* 29. */
+	dv_reg outcnt:11;
+	dv_reg lmst_sm:2;
+	dv_reg reserved_dma_debug:8;
+
+} SDREG;
+
+#define SD_RST_seq(base) 				do { \
+		base->sdrst = 1; \
+		base->sdcrcrst = 1; \
+		base->stop_dma_flag = 1; \
+		base->hw_dma_rst = 1; \
+		base->dmaidle = SP_DMA_NORMAL_STATE; \
+		base->dmaidle = SP_RESET_DMA_OPERATION; \
+		base->dmaidle = SP_DMA_NORMAL_STATE; \
+	}while(0)
+
+#define BLOCK0_DMA_PARA_SET(base, pageIdx, nrPages)  do { \
+		base->block0_hw_page_addr_low = ((pageIdx) & 0x0000ffff); \
+		base->block0_hw_page_addr_high = (((pageIdx) >> 16) & 0x0000ffff); \
+		base->dma_hw_page_num[0] = ((nrPages) - 1); \
+    }while(0)
+
+#define BLOCK1_DMA_PARA_SET(base, pageIdx, nrPages)  do{ \
+		base->block1_hw_page_addr_low = ((pageIdx) & 0x0000ffff); \
+		base->block1_hw_page_addr_high = (((pageIdx) >> 16) & 0x0000ffff); \
+		base->dma_hw_page_num[1] = ((nrPages) - 1); \
+    }while(0)
+
+#define BLOCK2_DMA_PARA_SET(base, pageIdx, nrPages)  do{ \
+		base->block2_hw_page_addr_low = ((pageIdx) & 0x0000ffff); \
+		base->block2_hw_page_addr_high = (((pageIdx) >> 16) & 0x0000ffff); \
+		base->dma_hw_page_num[2] = ((nrPages) - 1); \
+    }while(0)
+
+#define BLOCK3_DMA_PARA_SET(base, pageIdx, nrPages)  do{ \
+		base->block3_hw_page_addr_low = ((pageIdx) & 0x0000ffff); \
+		base->block3_hw_page_addr_high = (((pageIdx) >> 16) & 0x0000ffff); \
+		base->dma_hw_page_num[3] = ((nrPages) - 1); \
+    }while(0)
+
+#define SET_HW_DMA_BASE_ADDR(base, addr)  do{ \
+		base->dma_base_addr_low = ((u32)(addr) & 0xffff); \
+		base->dma_base_addr_high =  (((u32)(addr) >> 16) & 0xffff); \
+	}while(0)
+
+#define DMA_RESET(base)		do{ \
+			base->dmaidle = SP_RESET_DMA_OPERATION; \
+			base->dmaidle = SP_DMA_NORMAL_STATE; \
+			base->hw_dma_rst = 1; \
+			base->dma_hw_page_num[0] = 0; \
+			base->dma_hw_page_num[1] = 0; \
+			base->dma_hw_page_num[2] = 0; \
+			base->dma_hw_page_num[3] = 0; \
+			base->hw_block_num = 0; \
+		}while(0)
+
+#define DMASIZE_SET(base, x)			(base->dmasize = ((x)-1))
+#define SDDATALEN_SET(base, x)			(base->sddatalen = ((x)-1))
+#define SDDATALEN_GET(base)				(base->sddatalen + 1)
+#define HWSD_TIMEOUT(base)				((base->sdstatus >> 7) & 0x01)
+
+#define SD_PAGE_NUM_SET(base, x)		(base->sd_page_num = ((x)-1))
+#define SD_PAGE_NUM_GET(base)			(base->sd_page_num +1)
+
+typedef struct spsdhost {
+	volatile struct spsd_general_regs *base;
+	uint id;
+	char *name;
+	struct mmc_host *mmc;
+	struct mmc_request *mrq;
+	struct platform_device *pdev;
+	struct semaphore req_sem;
+
+	int dma_sgcount;   /* Used to store dma_mapped sg count */
+	int irq;
+	uint cd_gpio; /* gpio used for card sense */
+	int cd_state;
+
+	uint wrdly;
+	uint rddly;
+	int need_tune_cmd_timing;
+	int need_tune_dat_timing;
+	int power_state;
+}SPSDHOST;
+
+typedef struct spsdv2_dridata {
+	uint id;
+} spsdv2_dridata_t;
+
+#endif //#ifndef _SPSDV2_H_
--- a/drivers/mtd/nand/Kconfig	2018-11-23 10:16:15.112869356 +0300
+++ a/drivers/mtd/nand/Kconfig	2018-11-23 10:31:03.777052240 +0300
@@ -560,4 +560,17 @@
 	  Enables support for NAND controller on MTK SoCs.
 	  This controller is found on mt27xx, mt81xx, mt65xx SoCs.
 
+config MTD_NAND_SP
+	tristate "Support for NAND controller on MTK SoCs"
+	select MTD
+	select MTD_CHAR
+	select MTD_BLOCK
+	select MTD_BLKDEVS
+	select MTD_NAND
+	select MTD_NAND_IDS
+	select MTD_NAND_ECC
+	help
+	  Enables support for NAND controller on SUNPLUS SoCs.
+	  This controller is found on Sunplus SoCs.	  
+	  
 endif # MTD_NAND
--- a/drivers/mtd/nand/Makefile	2018-11-23 10:16:15.112869356 +0300
+++ a/drivers/mtd/nand/Makefile	2018-11-23 10:31:03.776052299 +0300
@@ -59,6 +59,8 @@
 obj-$(CONFIG_MTD_NAND_BRCMNAND)		+= brcmnand/
 obj-$(CONFIG_MTD_NAND_QCOM)		+= qcom_nandc.o
 obj-$(CONFIG_MTD_NAND_MTK)		+= mtk_nand.o mtk_ecc.o
+obj-$(CONFIG_MTD_NAND_SP)		+= sp_spinand.o sp_bch.o
+
 
 nand-objs := nand_base.o nand_bbt.o nand_timings.o nand_ids.o
 nand-objs += nand_amd.o
--- a/drivers/mtd/nand/sp_bch.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/mtd/nand/sp_bch.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,654 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include "sp_bch.h"
+#include <mach/hardware.h>
+
+#define ISP_MODE	 (*(volatile unsigned char *)(SRAM0_BASE + 0x9e36))
+
+static struct sp_bch_chip __this;
+unsigned int* sp_bch_ftl_info;
+unsigned int* Get_SP_BCH_Info(void)
+{
+	return sp_bch_ftl_info;
+}
+EXPORT_SYMBOL(Get_SP_BCH_Info);
+
+static int get_setbits(uint32_t n)
+{
+	n = n - ((n >> 1) & 0x55555555);
+	n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
+	return (((n + (n >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
+}
+
+static int sp_bch_blank(dma_addr_t ecc, int len)
+{
+	uint8_t *oob = ioremap(ecc, len);
+	int mbe = 4; /* Max. BIT errors */
+	int ret = 0;
+	int i, n;
+
+	if (oob) {
+		ret = 1;
+		for (i = 2, n = 0; i < len; ++i) {
+			if (oob[i] != 0xff)
+				n += get_setbits(oob[i] ^ 0xff);
+			if (n > mbe) {
+				ret = 0;
+				break;
+			}
+		}
+	}
+
+	if (oob)
+		iounmap(oob);
+
+	return ret;
+}
+
+static int sp_bch_reset(struct sp_bch_chip *chip)
+{
+	struct sp_bch_regs *regs = chip->regs;
+	unsigned long timeout = jiffies + msecs_to_jiffies(50);
+
+	writel(32 << 4, &regs->cr1);
+	/* reset controller */
+	writel(SRR_RESET, &regs->srr);
+	while (jiffies < timeout) {
+		if (!(readl(&regs->srr) & SRR_RESET))
+			break;
+		cpu_relax();
+	}
+	if (jiffies >= timeout) {
+		printk("sp_bch: reset timeout\n");
+		return -1;
+	}
+
+	/* reset interrupts */
+	writel(IER_DONE | IER_FAIL, &regs->ier);
+	writel(ISR_BCH, &regs->isr);
+
+	return 0;
+}
+
+static int sp_bch_wait(struct sp_bch_chip *chip)
+{
+	int ret = 0;
+
+	if (ISP_MODE != 0xA5) {
+		if (!wait_event_timeout(chip->wq, !chip->busy, HZ/10)) {
+			if (chip->busy == 0) {
+				printk(KERN_WARNING "sp_bch 1..system irq busy\n");
+				return 0;
+			}
+			ret = -EBUSY;
+		}
+	} else {
+		if (!wait_event_timeout(chip->wq, !chip->busy, HZ)) {
+			if (chip->busy == 0) {
+				printk(KERN_WARNING "sp_bch 2..system irq busy\n");
+				return 0;
+			}
+			ret = -EBUSY;
+		}
+	}
+
+	return ret;
+}
+
+static irqreturn_t sp_bch_irq(int irq, void *dev)
+{
+	struct sp_bch_chip *chip = dev;
+	struct sp_bch_regs *regs = chip->regs;
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(1);
+	writel(ISR_BCH, &regs->isr);
+	chip->busy = 0;
+	wake_up(&chip->wq);
+
+	if (time_after(jiffies, timeout)) {
+		printk(KERN_ERR "more 1ms");
+	}
+
+	return IRQ_HANDLED;
+}
+
+int sp_bch_init(struct mtd_info *mtd)
+{
+	struct sp_bch_chip *chip = &__this;
+	struct nand_chip *nand;
+	struct nand_oobfree *oobfree;
+	int i;
+	int oobsz;
+	int pgsz;
+	int rsvd;  /* Reserved bytes for YAFFS2 */
+	int size;  /* BCH data length per sector */
+	int bits;  /* BCH strength per sector */
+	int nrps;  /* BCH parity sector number */
+	int pssz;  /* BCH parity sector size */
+	int free;  /* BCH free bytes per sector */
+
+	if (!mtd || !chip)
+		BUG();
+
+	if (!mtd->priv)
+		BUG();
+
+	rsvd = 32;
+	oobsz = mtd->oobsize;
+	pgsz = mtd->writesize;
+	nand = mtd->priv;
+	chip->mtd = mtd;
+
+	/* 1024x60 */
+	size = 1024;
+	bits = 60;
+	nrps = pgsz >> 10;
+	chip->cr0 = CR0_CMODE_1024x60 | CR0_NBLKS(nrps);
+	if (oobsz >= nrps * 128) {
+		chip->cr0 |= CR0_DMODE(0) | CR0_BMODE(5);
+		pssz = 128;
+		free = 23;
+	} else if (oobsz >= nrps * 112) {
+		chip->cr0 |= CR0_DMODE(1) | CR0_BMODE(1);
+		pssz = 112;
+		free = 7;
+	} else {
+		pssz = 0;
+		free = 0;
+	}
+	if (free * nrps >= rsvd)
+		goto ecc_detected;
+
+	/* 1024x40 */
+	size = 1024;
+	bits = 40;
+	nrps = pgsz >> 10;
+	chip->cr0 = CR0_CMODE_1024x40 | CR0_NBLKS(nrps);
+	if (oobsz >= nrps * 96) {
+		chip->cr0 |= CR0_DMODE(0) | CR0_BMODE(6);
+		pssz = 96;
+		free = 26;
+	} else if (oobsz >= nrps * 80) {
+		chip->cr0 |= CR0_DMODE(1) | CR0_BMODE(2);
+		pssz = 80;
+		free = 10;
+	} else {
+		pssz = 0;
+		free = 0;
+	}
+	if (free * nrps >= rsvd)
+		goto ecc_detected;
+
+	/* 1024x24 */
+	size = 1024;
+	bits = 24;
+	nrps = pgsz >> 10;
+	chip->cr0 = CR0_CMODE_1024x24 | CR0_NBLKS(nrps);
+	if (oobsz >= nrps * 64) {
+		chip->cr0 |= CR0_DMODE(0) | CR0_BMODE(5);
+		pssz = 64;
+		free = 22;
+	} else if (oobsz >= nrps * 48) {
+		chip->cr0 |= CR0_DMODE(1) | CR0_BMODE(1);
+		pssz = 48;
+		free = 6;
+	} else {
+		pssz = 0;
+		free = 0;
+	}
+	if (free * nrps >= rsvd)
+		goto ecc_detected;
+
+	/* 1024x16 */
+	size = 1024;
+	bits = 16;
+	nrps = pgsz >> 10;
+	chip->cr0 = CR0_CMODE_1024x16 | CR0_NBLKS(nrps);
+	if (oobsz >= nrps * 64) {
+		chip->cr0 |= CR0_DMODE(0) | CR0_BMODE(6);
+		pssz = 64;
+		free = 28;
+	} else if (oobsz >= nrps * 48) {
+		chip->cr0 |= CR0_DMODE(1) | CR0_BMODE(4);
+		pssz = 48;
+		free = 20;
+	} else {
+		pssz = 0;
+		free = 0;
+	}
+	if (free * nrps >= rsvd)
+		goto ecc_detected;
+
+	/* 512x8 */
+	size = 512;
+	bits = 8;
+	nrps = pgsz >> 9;
+	chip->cr0 = CR0_CMODE_512x8 | CR0_NBLKS(nrps);
+	if (oobsz >= nrps * 32) {
+		chip->cr0 |= CR0_DMODE(0) | CR0_BMODE(4);
+		pssz = 32;
+		free = 18;
+	} else if (oobsz >= nrps * 16) {
+		chip->cr0 |= CR0_DMODE(1) | CR0_BMODE(0);
+		pssz = 16;
+		free = 2;
+	} else {
+		pssz = 0;
+		free = 0;
+	}
+	if (free * nrps >= rsvd)
+		goto ecc_detected;
+
+	/* 512x4 */
+	size = 512;
+	bits = 4;
+	nrps = pgsz >> 9;
+	chip->cr0 = CR0_CMODE_512x4 | CR0_NBLKS(nrps);
+	if (oobsz >= nrps * 32) {
+		chip->cr0 |= CR0_DMODE(0) | CR0_BMODE(6);
+		pssz = 32;
+		free = 25;
+	} else {
+		chip->cr0 |= CR0_DMODE(1) | CR0_BMODE(2);
+		pssz = 16;
+		free = 9;
+	}
+
+ecc_detected:
+	printk("sp_bch: ecc mode=%ux%u, cr0=0x%x\n", size, bits, chip->cr0);
+	nand->ecc.size = size;
+	nand->ecc.steps = nrps;
+	nand->ecc.bytes = ((12 + (size >> 9)) * bits + 7) >> 3;
+
+	/* sanity check */
+	if (nand->ecc.steps > MTD_MAX_OOBFREE_ENTRIES_LARGE)
+		BUG();
+
+	if (free * nrps < rsvd)
+		BUG();
+
+	nand->ecc.layout->oobavail = 0;
+	oobfree = nand->ecc.layout->oobfree;
+	for (i = 0; i < nand->ecc.steps; ++i) {
+		oobfree->offset = i * pssz;
+		oobfree->length = free;
+
+		/* reserved bad block + scrambler marker */
+		if (i == 0) {
+			oobfree->offset += 2;
+			oobfree->length -= 2;
+		}
+
+		if (oobfree->length) {
+			nand->ecc.layout->oobavail += oobfree->length;
+			++oobfree;
+		}
+	}
+
+	printk("sp_bch: oob avail=%u\n", nand->ecc.layout->oobavail);
+	sp_bch_ftl_info = (unsigned int *)chip;
+	/* printk("sp_bch chip addr:0x%p,0x%p\n", chip,sp_bch_ftl_info); */
+
+#if 0
+	for (i = 0; i < nand->ecc.steps; ++i) {
+		printk("off=%u, len=%u\n",
+			nand->ecc.layout->oobfree[i].offset,
+			nand->ecc.layout->oobfree[i].length);
+	}
+	printk("\n");
+#endif
+
+	mutex_lock(&chip->lock);
+	sp_bch_reset(chip);
+	mutex_unlock(&chip->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(sp_bch_init);
+
+/*
+ * Calculate BCH ecc code
+ */
+int sp_bch_encode(struct mtd_info *mtd, dma_addr_t buf, dma_addr_t ecc)
+{
+	struct sp_bch_chip *chip = &__this;
+	struct sp_bch_regs *regs = chip->regs;
+	int ret;
+
+	if (!mtd)
+		BUG();
+
+	if (chip->mtd != mtd)
+		sp_bch_init(mtd);
+
+	mutex_lock(&chip->lock);
+
+	writel(buf, &regs->buf);
+	writel(ecc, &regs->ecc);
+
+	chip->busy = 1;
+	writel(CR0_START | CR0_ENCODE | chip->cr0, &regs->cr0);
+	ret = sp_bch_wait(chip);
+	if (ret)
+		printk("sp_bch: encode timeout\n");
+
+	mutex_unlock(&chip->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(sp_bch_encode);
+
+/*
+ * Detect and correct bit errors
+ */
+int sp_bch_decode(struct mtd_info *mtd, dma_addr_t buf, dma_addr_t ecc)
+{
+	struct sp_bch_chip *chip = &__this;
+	struct sp_bch_regs *regs = chip->regs;
+	uint32_t status;
+	int ret;
+
+	if (!mtd)
+		BUG();
+
+	if (chip->mtd != mtd)
+		sp_bch_init(mtd);
+
+	mutex_lock(&chip->lock);
+
+	writel(buf, &regs->buf);
+	writel(ecc, &regs->ecc);
+
+	chip->busy = 1;
+	writel(CR0_START | CR0_DECODE | chip->cr0, &regs->cr0);
+	ret = sp_bch_wait(chip);
+	status = readl(&regs->sr);
+	if (ret) {
+		printk("sp_bch: decode timeout\n");
+	} else if (status & SR_FAIL) {
+#if 0
+		if ((status & SR_BLANK_FF) || (status & SR_BLANK_00)) {
+#else
+		if (sp_bch_blank(ecc, mtd->oobsize)) {
+#endif
+			/* printk("sp_bch: decode All FF or 00!\n"); */
+			ret = 0;
+		} else {
+			printk("sp_bch: decode failed.\n");
+			mtd->ecc_stats.failed += SR_ERR_BITS(status);
+			sp_bch_reset(chip);
+			ret = 2;
+		}
+	} else {
+		mtd->ecc_stats.corrected += SR_ERR_BITS(status);
+	}
+
+	mutex_unlock(&chip->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(sp_bch_decode);
+
+static long sp_bch_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct sp_bch_chip *chip = &__this;
+	struct sp_bch_regs *regs = chip->regs;
+	void __user *argp = (void __user *)arg;
+	unsigned long size;
+	long ret = 0;
+	void *buf;
+	struct sp_bch_req *req;
+	dma_addr_t buf_phys, ecc_phys;
+
+	size = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;
+	if (cmd & IOC_IN) {
+		if (!access_ok(VERIFY_READ, argp, size))
+			return -EFAULT;
+	}
+	if (cmd & IOC_OUT) {
+		if (!access_ok(VERIFY_WRITE, argp, size))
+			return -EFAULT;
+	}
+
+	buf = kmalloc(sizeof(*req) + 32, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	/* make sure it's 32 bytes aligned */
+	req = (void *)(((unsigned)buf + 31) & 0xffffffe0);
+
+	switch (cmd) {
+	case SP_BCH_IOC1K60ENC:
+		if (copy_from_user(req, argp, sizeof(*req))) {
+			ret = -EFAULT;
+			break;
+		}
+
+		mutex_lock(&chip->lock);
+
+		buf_phys = dma_map_single(chip->dev, req->buf, 1024, DMA_TO_DEVICE);
+		ecc_phys = dma_map_single(chip->dev, req->ecc, 128, DMA_BIDIRECTIONAL);
+
+		writel(buf_phys, &regs->buf);
+		writel(ecc_phys, &regs->ecc);
+
+		chip->busy = 1;
+		writel(CR0_START | CR0_ENCODE | CR0_CMODE_1024x60, &regs->cr0);
+		if (sp_bch_wait(chip)) {
+			printk("sp_bch: 1k60 encode timeout\n");
+			ret = -EFAULT;
+		}
+
+		dma_unmap_single(chip->dev, buf_phys, 1024, DMA_TO_DEVICE);
+		dma_unmap_single(chip->dev, ecc_phys, 128, DMA_BIDIRECTIONAL);
+
+		mutex_unlock(&chip->lock);
+
+		if (copy_to_user(argp, req, sizeof(*req)))
+			ret = -EFAULT;
+		break;
+
+	case SP_BCH_IOC1K60DEC:
+		if (copy_from_user(req, argp, sizeof(*req))) {
+			ret = -EFAULT;
+			break;
+		}
+
+		mutex_lock(&chip->lock);
+
+		buf_phys = dma_map_single(chip->dev, req->buf, 1024, DMA_BIDIRECTIONAL);
+		ecc_phys = dma_map_single(chip->dev, req->ecc, 128, DMA_TO_DEVICE);
+
+		writel(buf_phys, &regs->buf);
+		writel(ecc_phys, &regs->ecc);
+
+		chip->busy = 1;
+		writel(CR0_START | CR0_DECODE | CR0_CMODE_1024x60, &regs->cr0);
+		if (sp_bch_wait(chip)) {
+			printk("sp_bch: 1k60 decode timeout\n");
+			ret = -EFAULT;
+		}
+
+		dma_unmap_single(chip->dev, buf_phys, 1024, DMA_BIDIRECTIONAL);
+		dma_unmap_single(chip->dev, ecc_phys, 128, DMA_TO_DEVICE);
+
+		mutex_unlock(&chip->lock);
+
+		if (copy_to_user(argp, req, sizeof(*req)))
+			ret = -EFAULT;
+		break;
+
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+	kfree(buf);
+
+	return ret;
+}
+
+static struct file_operations sp_bch_fops = {
+	.owner          = THIS_MODULE,
+	.llseek         = no_llseek,
+	.compat_ioctl   = sp_bch_ioctl,
+	.unlocked_ioctl = sp_bch_ioctl,
+};
+
+static struct miscdevice sp_bch_dev = {
+	.name = "sp_bch",
+	.fops = &sp_bch_fops,
+};
+
+static int sp_bch_probe(struct platform_device *pdev)
+{
+	struct sp_bch_chip *chip = &__this;
+	struct resource *res;
+	int ret = 0;
+
+	/*
+	 * use reasonable defaults so platforms don't have to provide these.
+	 * with DT probing on ARM, none of these are set.
+	 */
+	if (!pdev->dev.dma_mask)
+		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
+	if (!pdev->dev.coherent_dma_mask)
+		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+
+	memset(chip, 0, sizeof(*chip));
+
+	mutex_init(&chip->lock);
+	init_waitqueue_head(&chip->wq);
+
+	chip->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENXIO;
+		return ret;
+	}
+	if (!request_mem_region(res->start, resource_size(res), "sp_bch")) {
+		ret = -EBUSY;
+		goto err;
+	}
+	chip->regs = ioremap(res->start, resource_size(res));
+	if (!chip->regs) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	chip->irq = platform_get_irq(pdev, 0);
+	if (chip->irq <= 0) {
+		ret = -ENXIO;
+		goto err;
+	}
+
+	printk("sp_bch: mmio=0x%p, irq=%d\n", chip->regs, chip->irq);
+
+	if (sp_bch_reset(chip)) {
+		ret = -ENXIO;
+		goto err;
+	}
+
+	if (request_irq(chip->irq, sp_bch_irq, 0, "sp_bch", chip)) {
+		printk("sp_bch: unable to register IRQ(%d)\n", chip->irq);
+		ret = -EBUSY;
+		goto err;
+	}
+
+	platform_set_drvdata(pdev, chip);
+
+	ret = misc_register(&sp_bch_dev);
+
+	return ret;
+
+err:
+	release_mem_region(res->start, resource_size(res));
+	return ret;
+}
+
+static int sp_bch_remove(struct platform_device *pdev)
+{
+	struct sp_bch_chip *chip = platform_get_drvdata(pdev);
+	struct resource *res;
+
+	misc_deregister(&sp_bch_dev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+
+	if (!chip)
+		BUG();
+
+	if (chip->regs)
+		iounmap(chip->regs);
+
+	if (chip->irq)
+		free_irq(chip->irq, "sp_bch");
+
+	wake_up(&chip->wq);
+	mutex_destroy(&chip->lock);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int sp_bch_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int sp_bch_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define sp_bch_suspend	NULL
+#define sp_bch_resume	NULL
+#endif
+
+static const struct of_device_id of_fun_match[] = {
+	{ .compatible = "sunplus,sp_bch" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_fun_match);
+
+static struct platform_driver sp_bch_driver = {
+	.probe = sp_bch_probe,
+	.remove = sp_bch_remove,
+	.shutdown = NULL,
+	.suspend = sp_bch_suspend,
+	.resume = sp_bch_resume,
+	.driver = {
+			.name = "sunplus,sp_bch",
+			.owner = THIS_MODULE,
+			.of_match_table = of_fun_match,
+		   },
+};
+
+module_platform_driver(sp_bch_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Sunplus BCH controller");
--- a/drivers/mtd/nand/sp_bch.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/mtd/nand/sp_bch.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,85 @@
+#ifndef __SP_BCH_H
+#define __SP_BCH_H
+
+struct sp_bch_regs {
+	uint32_t cr0;     /* control register */
+	uint32_t buf;     /* data base address register */
+	uint32_t ecc;     /* parity base address register */
+	uint32_t isr;     /* interrupt status register */
+
+	uint32_t srr;     /* software reset register */
+	uint32_t ier;     /* interrupt enable register */
+	uint32_t sr;      /* status register */
+	uint32_t esr;     /* error status register */
+
+	uint32_t fsr;     /* failure status register */
+	uint32_t lwa;     /* address of last write operation */
+	uint32_t lwd;     /* data of last write operation */
+	uint32_t cr1;     /* control register */
+
+	uint32_t revr;    /* revision register */
+};
+
+#define CR0_START		BIT(0)
+#define CR0_ENCODE		0
+#define CR0_DECODE		BIT(4)
+#define CR0_CMODE_1024x60	(0 << 8)
+#define CR0_CMODE_1024x40	(1 << 8)
+#define CR0_CMODE_1024x24	(2 << 8)
+#define CR0_CMODE_1024x16	(3 << 8)
+#define CR0_CMODE_512x8		(4 << 8)
+#define CR0_CMODE_512x4		(5 << 8)
+#define CR0_CMODE(n)		(((n) & 7) << 8)
+#define CR0_DMODE(n)		((n) ?  BIT(11) : 0)
+#define CR0_NBLKS(n)		((((n) - 1) & 0x1f) << 16)
+#define CR0_BMODE(n)		(((n) & 7) << 28)
+
+/* 32-bits word aligned */
+#define CR1_WORD_ALIGN		BIT(0)
+/* Non-buffered write */
+#define CR1_NBWR		BIT(1)
+/* Non-buffered write for last correction write only */
+#define CR1_NBWR_LAST		BIT(2)
+/* Threshold for blank check (0x00 or 0xff) */
+#define CR1_BLANK_THRES(n)	(((n) & 0x3ff) << 4)
+
+#define ISR_BCH			BIT(0)
+#define ISR_BUSY		BIT(4)
+#define ISR_CURR_DBLK(x)	(((x) >> 8) & 0x1f)
+#define ISR_CURR_CBLK(x)	(((x) >> 16) & 0x1f)
+
+#define IER_DONE		BIT(0)
+#define IER_FAIL		BIT(1)
+
+#define SRR_RESET		BIT(0)
+
+#define SR_DONE			BIT(0)
+#define SR_FAIL			BIT(4)
+#define SR_ERR_BITS(x)		(((x) >> 8) & 0x7ff)
+#define SR_ERR_MAX(x)		(((x) >> 20) & 0x7f)
+#define SR_BLANK_00		BIT(28)	/* data are all 0x00 */
+#define SR_BLANK_FF		BIT(29)	/* data are all 0xff */
+#define SP_BCH_IOC1K60ENC	_IOWR('S', 0, struct sp_bch_req)
+#define SP_BCH_IOC1K60DEC	_IOWR('S', 1, struct sp_bch_req)
+
+struct sp_bch_chip {
+	struct device *dev;
+	struct mtd_info *mtd;
+	void __iomem *regs;
+	int irq;
+	int busy;
+	uint32_t cr0;
+	struct mutex lock;
+	wait_queue_head_t wq;
+};
+
+struct sp_bch_req {
+	uint8_t buf[1024];
+	uint8_t ecc[128];
+};
+
+int sp_bch_init(struct mtd_info *mtd);
+int sp_bch_encode(struct mtd_info *mtd, dma_addr_t buf, dma_addr_t ecc);
+int sp_bch_decode(struct mtd_info *mtd, dma_addr_t buf, dma_addr_t ecc);
+
+#endif /* __SP_BCH_H */
--- a/drivers/mtd/nand/sp_spinand.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/mtd/nand/sp_spinand.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,1107 @@
+#include <common.h>
+#include <malloc.h>
+//#include <asm/io.h>
+#include <nand.h>
+
+#include <linux/mtd/nand.h>
+#include <dm.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+
+#include "sp_bch.h"
+#include "sp_spinand.h"
+
+
+/**************************************************************************
+ *                             M A C R O S                                *
+ **************************************************************************/
+/* SRAM */
+/* #define CFG_BBT_USE_FLASH */
+#define CFG_BUFF_MAX		(18 << 10)
+#define CONFIG_MTD_SP_NAND_SRAM_BASE	(0x9e800000)
+#define QUADIO_DIS_ECC 	(0x01)
+#define WB_BUF1_DIS_ECC (0x08)
+
+/* device id */
+#define ESMT1G_ID 0x21C8
+#define GD_ID 0xC8
+#define GD_ID_HIGH 0x2100
+#define WB_ID 0xEF
+#define MXIC_ID 0xC2
+
+
+static void wait_spi_idle(struct sp_spinand_info *info)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int retry = 0;
+	
+	do {
+		retry++;
+	} while((readl(&regs->spi_ctrl) & SPI_DEVICE_IDLE) && (retry < 100));
+}
+
+static int sp_spinand_reset(struct sp_spinand_info *info)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;
+	int ret = -1;
+	int retry = 0;
+	//initial
+	do {
+		retry++;
+	} while((readl(&regs->spi_ctrl) & SPI_DEVICE_IDLE) && (retry < 100));
+	
+	/* ==== Flash reset ==== */
+	value = (SPI_NAND_CHIP_A)|(SPI_NAND_CLK_32DIV)|(SPINAND_CMD_RESET<<8)|(SPI_NAND_CTRL_EN)|(SPI_NAND_WRITE_MDOE);
+	writel(value, &regs->spi_ctrl);
+
+	value = SPINAND_CFG01_DEFAULT3;
+	writel(value, &regs->spi_cfg[1]);	
+
+	value = SPINAND_AUTOCFG_CMDEN;
+	writel(value, &regs->spi_auto_cfg);
+
+	wait_spi_idle(info);
+
+	retry = 0;	
+	do {
+		ret = spi_nand_getfeatures(info, DEVICE_STATUS_ADDR);
+		retry++;
+	} while ((ret & 0x01) && (retry < 100));
+
+	return ret;
+}
+
+static void spi_nand_readid(struct sp_spinand_info *info, uint32_t addr, uint32_t *data)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;
+
+	writel(addr, &regs->spi_page_addr);
+	/*read 3 byte cycle same to 8388 */
+	value = SPI_NAND_CHIP_A|SPI_NAND_AUTO_WEL|(SPI_NAND_CLK_32DIV)|(SPINAND_CMD_READID<<8)|SPI_NAND_CTRL_EN|(SPINAND_CUSTCMD_3_DATA)|(SPINAND_CUSTCMD_1_ADDR);
+	writel(value, &regs->spi_ctrl);
+
+	value = SPINAND_CFG01_DEFAULT;
+	writel(value ,&regs->spi_cfg[1]);
+
+	value = SPINAND_AUTOCFG_CMDEN;
+	writel(value ,&regs->spi_auto_cfg);
+
+	wait_spi_idle(info);
+
+	value = readl(&regs->spi_data);
+
+	printk("\nReadID:0x%02x,0x%02x,0x%02x,0x%02x\n",
+	       (value & 0xFF),
+	       ((value >> 8) & 0xFF),
+	       ((value >> 16) & 0xFF),
+	       ((value >> 24) & 0xFF));
+
+	*data = value;
+	
+	return ;
+}
+
+static int spi_nand_getfeatures(struct sp_spinand_info *info, uint32_t addr)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;
+	
+	value = (SPI_NAND_CHIP_A)|(SPI_NAND_AUTO_WEL)|(SPI_NAND_CLK_32DIV)|(SPINAND_CMD_GETFEATURES<<8)|(SPI_NAND_CTRL_EN)|(SPINAND_CUSTCMD_1_DATA)|(SPINAND_CUSTCMD_1_ADDR);
+	writel(value ,&regs->spi_ctrl);
+
+	writel(addr ,&regs->spi_page_addr);
+
+	value = SPINAND_CFG01_DEFAULT;
+	writel(value ,&regs->spi_cfg[1]);
+
+	value = SPINAND_AUTOCFG_CMDEN;
+	writel(value ,&regs->spi_auto_cfg);
+
+	wait_spi_idle(info);
+
+	return (readl(&regs->spi_data) & 0xFF);
+}
+
+static void spi_nand_setfeatures(struct sp_spinand_info *info,uint32_t addr, uint32_t data)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;
+
+	value = (SPI_NAND_CHIP_A)|(SPI_NAND_AUTO_WEL)|(SPI_NAND_CLK_32DIV)|(SPINAND_CMD_SETFEATURES<<8)|(SPI_NAND_CTRL_EN)|(SPINAND_CUSTCMD_1_DATA)|(SPI_NAND_WRITE_MDOE)|(SPINAND_CUSTCMD_1_ADDR);
+	writel(value ,&regs->spi_ctrl);
+
+	writel(addr ,&regs->spi_page_addr);
+
+	writel(data ,&regs->spi_data);
+
+	value = SPINAND_CFG01_DEFAULT1;
+	writel(value ,&regs->spi_cfg[1]);
+
+	value = SPINAND_AUTOCFG_CMDEN;
+	writel(value ,&regs->spi_auto_cfg);
+
+	wait_spi_idle(info);
+	
+	return ;
+}
+
+static int spi_nand_blkerase(struct sp_spinand_info *info, uint32_t addr)
+{	
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;
+	
+	value = (1<<24)|(1<<20)|(1<<19)|(7<<16)|(0xd8<<8)|(1<<7)|(0<<4)|(1<<2)|(3);
+	writel(value ,&regs->spi_ctrl);
+
+	writel(addr ,&regs->spi_page_addr);
+
+	value = 0x150095;
+	writel(value ,&regs->spi_cfg[1]);
+
+	value = (1<<21);
+	writel(value ,&regs->spi_auto_cfg);
+
+	wait_spi_idle(info);
+
+	value = (1<<21)|(1<<19);
+	writel(value ,&regs->spi_auto_cfg);
+
+	wait_spi_idle(info);
+	
+	value = readl(&regs->spi_status);
+
+	if (value & ERASE_STATUS) {
+		printk("\nErase Fail!\n");
+		value = 0x1;
+	} else {
+		value = 0x0;
+	}
+	
+	return value;
+}
+
+static void spi_nanddma_pageread_prep(struct sp_spinand_info *info, uint32_t addr, unsigned int size, uint32_t *pbuf)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;
+	int retry;
+	
+	while ((readl(&regs->spi_auto_cfg) & SPI_NAND_DMA_OWNER) && (retry < 100)) {
+		retry++;
+	}
+
+	if (retry >= 100) {
+		printk("sp_spinand: dma busy timeout \n");
+		info->err |= SPI_NAND_READ_FAIL;
+		return ;
+	}
+	
+	value = SPI_NAND_CHIP_A|SPI_NAND_CLK_32DIV|SPI_NAND_CTRL_EN|(2);
+	writel(value, &regs->spi_ctrl);
+
+	writel(addr, &regs->spi_page_addr);
+
+	value = 0x08350095; // 4 bit data 8 dummy clock 1bit cmd  1bit addr
+	writel(value, &regs->spi_cfg[1]);
+
+	value = readl(&regs->spi_cfg[0]);
+	value = value|size; // 1k data len
+	writel(value, &regs->spi_cfg[0]);
+
+	if ((addr & 0x40) && (((info->id & 0xFF) == 0xC2)||((info->id & 0xFF) == 0x2C)))		
+		value = 0x1000;
+	else
+		value = 0x0;
+	
+	writel(value, &regs->spi_col_addr);
+
+	value = (0x40<<4)|(0x1);
+	writel(value, &regs->spi_page_size);
+
+	writel((uint32_t)pbuf, &regs->mem_data_addr);
+
+	//config ctrl info	
+	//set auto cfg
+	value = 0x5;
+	writel(value, &regs->spi_intr_msk);
+	value = 0x7;
+	writel(value, &regs->spi_intr_sts);
+	
+	value = (0x6b<<24)|(1<<20)|(1<18);
+	writel(value, &regs->spi_auto_cfg);
+	
+	return ;
+}
+
+static void spi_nanddma_run(struct sp_spinand_info *info)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;
+
+	value = (1<<17);
+	writel(value, &regs->spi_auto_cfg);
+
+	return ;
+}
+
+static void spi_nanddma_down(struct sp_spinand_info *info)
+{
+	int ret;
+	
+	info->busy = 1;
+	
+	spi_nanddma_run(info);
+
+	ret = sp_spinand_wait(info);
+	if (ret) {
+		printk("sp_spinand: descriptor timeout, cmd=0x%x\n", info->cmd);
+		sp_spinand_reset(info);
+	}
+	
+	return ;
+}
+
+#if 0
+static void spi_nanddma_pageread(struct sp_spinand_info *info, uint32_t addr, unsigned int size, uint32_t *pbuf)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;
+	int retry;
+	
+	while ((readl(&regs->spi_auto_cfg) & SPI_NAND_DMA_OWNER) && (retry < 100)) {
+		retry++;
+	}
+
+	if (retry >= 100) {
+		printk("sp_spinand: dma busy timeout \n");
+		info->err |= SPI_NAND_READ_FAIL;
+		return ;
+	}
+	
+	value = SPI_NAND_CHIP_A|SPI_NAND_CLK_32DIV|SPI_NAND_CTRL_EN|(2);
+	writel(value, &regs->spi_ctrl);
+
+	writel(addr, &regs->spi_page_addr);
+
+	value = 0x08350095; // 4 bit data 8 dummy clock 1bit cmd  1bit addr
+	writel(value, &regs->spi_cfg[1]);
+
+	value = readl(&regs->spi_cfg[0]);
+	value = value|size; // 1k data len
+	writel(value, &regs->spi_cfg[0]);
+
+	if ((addr & 0x40) && (((info->id & 0xFF) == 0xC2)||((info->id & 0xFF) == 0x2C)))		
+		value = 0x1000;
+	else
+		value = 0x0;
+	
+	writel(value, &regs->spi_col_addr);
+
+	value = (0x40<<4)|(0x1);
+	writel(value, &regs->spi_page_size);
+
+	writel((uint32_t)pbuf, &regs->mem_data_addr);
+
+	//config ctrl info	
+	//set auto cfg
+	value = 0x5;
+	writel(value, &regs->spi_intr_msk);
+	value = 0x7;
+	writel(value, &regs->spi_intr_sts);
+	
+	value = (0x6b<<24)|(1<<20)|(1<18)|(1<<17);
+	writel(value, &regs->spi_auto_cfg);
+
+	/* porting  dma ready */
+	//while((readl(&regs->spi_intr_sts) & 0x2) == 0x0);
+
+	return ;
+}
+#endif 
+
+static void spi_nanddma_pageprogram_prep(struct sp_spinand_info *info, uint32_t addr, unsigned int size, uint32_t *pbuf)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;	
+	int retry;
+	
+	/* polling DMA_OWNER == 0 */
+	while ((readl(&regs->spi_auto_cfg) & SPI_NAND_DMA_OWNER) && (retry < 100)) {
+		retry++;
+	}
+	
+	if (retry >= 100) {
+		printk("sp_spinand: dma busy timeout \n");
+		info->err |= SPI_NAND_WRITE_FAIL;
+		return ;
+	}
+
+	value = (1<<24)|(7<<16)|(1<<7)|(1<<2)|(2);
+	writel(value, &regs->spi_ctrl);
+
+	writel(addr, &regs->spi_page_addr);
+
+	// config device info
+	//set cfg[1]= cmd 1 bit addr 1 bit data 1 bit	
+	value = 0x150095;
+	writel(value, &regs->spi_cfg[1]);
+
+	//read 2k data
+	value = readl(&regs->spi_cfg[0]);
+	value |= size; 
+	writel(value, &regs->spi_cfg[0]);
+	
+	// col addr set
+	if ((addr & 0x40) && (((info->id & 0xFF) == 0xC2)||((info->id & 0xFF) == 0x2C)))		
+		value = 0x1000;
+	else
+		value = 0x0;
+	writel(value, &regs->spi_col_addr);
+
+	//set nand page size
+	value = (0x0<<15)|(0x40<<4)|(0x1); 
+	writel(value, &regs->spi_page_size);
+
+	//page size 2K
+	writel((uint32_t)pbuf, &regs->mem_data_addr);
+
+	//config ctrl info	
+	//set auto cfg 	
+	value = 0x5;	
+	writel((uint32_t)value, &regs->spi_intr_msk);
+	value = 0x7;	
+	writel((uint32_t)value, &regs->spi_intr_sts);
+
+	value = (1<18)|(0x02<<8)|(1);
+	writel(value, &regs->spi_auto_cfg);
+
+	//polling dma operation done bit	
+	//while((readl(&regs->spi_intr_sts) & 0x2) == 0x0);
+
+	return;
+}
+
+#if 0
+static void spi_nanddma_pageprogram(struct sp_spinand_info *info, uint32_t addr, unsigned int size, uint32_t *pbuf)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int value = 0;	
+	int retry;
+	
+	/* polling DMA_OWNER == 0 */
+	while ((readl(&regs->spi_auto_cfg) & SPI_NAND_DMA_OWNER) && (retry < 100)) {
+		retry++;
+	}
+	
+	if (retry >= 100) {
+		printk("sp_spinand: dma busy timeout \n");
+		info->err |= SPI_NAND_WRITE_FAIL;
+		return ;
+	}
+
+	value = (1<<24)|(7<<16)|(1<<7)|(1<<2)|(2);
+	writel(value, &regs->spi_ctrl);
+
+	writel(addr, &regs->spi_page_addr);
+
+	// config device info
+	//set cfg[1]= cmd 1 bit addr 1 bit data 1 bit	
+	value = 0x150095;
+	writel(value, &regs->spi_cfg[1]);
+
+	//read 2k data
+	value = readl(&regs->spi_cfg[0]);
+	value |= size; 
+	writel(value, &regs->spi_cfg[0]);
+	
+	// col addr set
+	if ((addr & 0x40) && (((info->id & 0xFF) == 0xC2)||((info->id & 0xFF) == 0x2C)))		
+		value = 0x1000;
+	else
+		value = 0x0;
+	writel(value, &regs->spi_col_addr);
+
+	//set nand page size
+	value = (0x0<<15)|(0x40<<4)|(0x1); 
+	writel(value, &regs->spi_page_size);
+
+	//page size 2K
+	writel((uint32_t)pbuf, &regs->mem_data_addr);
+
+	//config ctrl info	
+	//set auto cfg 	
+	value = 0x5;	
+	writel((uint32_t)value, &regs->spi_intr_msk);
+	value = 0x7;	
+	writel((uint32_t)value, &regs->spi_intr_sts);
+
+	value = (1<18)|(1<<17)|(0x02<<8)|(1);
+	writel(value, &regs->spi_auto_cfg);
+
+	//polling dma operation done bit	
+	//while((readl(&regs->spi_intr_sts) & 0x2) == 0x0);
+
+	return;
+}
+#endif
+
+static irqreturn_t sp_nand_irq(int irq, void *dev)
+{
+	struct sp_nand_info *info = dev;
+	struct sp_nand_regs *regs = info->regs;
+	uint32_t st;
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(1);
+
+	/* clear intrrupt flag */	
+	st = readl(&regs->spi_intr_sts);
+	writel(st, &regs->spi_intr_sts);
+
+	info->busy = 0;
+	wake_up(&info->wq);
+
+	if (time_after(jiffies, timeout))
+	{
+		printk(KERN_ERR "more 1ms");
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sp_spinand_wait(struct sp_spinand_info *info)
+{
+	int ret = 0;
+
+	if (!wait_event_timeout(info->wq, !info->busy, HZ/10)) {
+		/*HZ=100, means timeout=100*jiffies, jiffies=every 10ms plus one */
+		if (info->busy == 0) {
+			printk(KERN_WARNING "sp_nand ..system irq busy?\n");
+			return ret;
+		}
+		ret = -1;
+		printk("\n\nERROR!!!! sp_nand_wait timeout\n\n");		
+	}	
+
+	return ret;
+}
+
+static void sp_spinand_write_page(struct mtd_info *mtd, struct nand_chip *chip, const uint8_t * buf)
+{
+	struct sp_spinand_info *info = container_of(mtd, struct sp_spinand_info, mtd);
+
+	down(&info->spnand_sem);
+	chip->write_buf(mtd, buf, mtd->writesize);
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	sp_bch_encode(mtd, info->buff.phys, info->buff.phys + mtd->writesize);
+
+	up(&info->spnand_sem);
+}
+
+static int sp_spinand_read_page(struct mtd_info *mtd, struct nand_chip *chip, uint8_t * buf, int page)
+{
+	struct sp_spinand_info *info = container_of(mtd, struct sp_spinand_info, mtd);
+	int ret = 0;
+
+	down(&info->spnand_sem);
+
+	ret = sp_spinand_wait(info);
+	if (ret) {
+		printk("sp_spinand: descriptor timeout, cmd=0x%x\n", info->cmd);
+		sp_spinand_reset(info);
+		goto exit_pp;
+	}
+	
+	if ((info->cmd == NAND_CMD_READ0)||(info->cmd == NAND_CMD_READOOB)) {
+		/*check spi nand control busy/ready status */
+		if (info->err&SPI_NAND_READ_FAIL) {
+			info->err&=~SPI_NAND_READ_FAIL;
+			goto exit_pp;
+		}
+	}
+
+	ret = sp_bch_decode(mtd, info->buff.phys, info->buff.phys + mtd->writesize);
+	if (ret) {
+		printk("sp_spinand: bch decode failed at page=%d\n", page);
+		goto exit_pp;
+	}
+
+	chip->read_buf(mtd, buf, mtd->writesize);
+
+	if (page < 0)
+		up(&info->spnand_sem);
+	else {
+		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+		up(&info->spnand_sem);
+	}
+	return ret;
+
+exit_pp:
+	ret = -1;
+	up(&info->spnand_sem);
+	return ret;
+}
+
+static void sp_spinand_write_buf(struct mtd_info *mtd, const u_char * buf, int len)
+{
+	dma_addr_t src, dst;
+	struct sp_spinand_info *info = container_of(mtd, struct sp_spinand_info, mtd);
+
+	if (virt_addr_valid(buf) || virt_addr_valid(buf + len - 1)) {
+		printk("buf addr valid \n");
+		return;
+	}
+
+	memcpy(info->buff.virt + info->buff.idx, buf, len);
+
+	info->buff.idx += len;
+}
+
+static void sp_spinand_read_buf(struct mtd_info *mtd, u_char * buf, int len)
+{
+	dma_addr_t src, dst;
+
+	struct sp_spinand_info *info = container_of(mtd, struct sp_spinand_info, mtd);
+
+	if (virt_addr_valid(buf) || virt_addr_valid(buf + len - 1)) {
+		printk("buf addr valid \n");
+		return;
+	}
+
+	memcpy(buf, info->buff.virt + info->buff.idx, len);
+
+	info->buff.idx += len;
+}
+
+static uint8_t sp_spinand_read_byte(struct mtd_info *mtd)
+{
+	struct sp_spinand_info *info = container_of(mtd, struct sp_spinand_info, mtd);
+	uint8_t ret = 0;
+
+	switch (info->cmd) {
+		case NAND_CMD_STATUS:
+			ret = readb(info->buff.virt);
+			break;
+
+		default:
+			if (info->buff.idx < info->buff.size) {
+				ret = readb(info->buff.virt + info->buff.idx);
+				info->buff.idx += 1;
+			}
+			break;
+	}
+
+	return ret;
+}
+
+/*
+ * Check hardware register for wait status. Returns 1 if device is ready,
+ * 0 if it is still busy.
+ */
+static int sp_spinand_dev_ready(struct mtd_info *mtd)
+{
+	return 1;
+}
+
+static void sp_spinand_desc_prep(struct sp_spinand_info *info, uint8_t cmd, int col, int row)
+{
+	mutex_lock(&info->lock);
+	switch (cmd) {
+		case NAND_CMD_READOOB:	/* 0x50 */
+			col += info->mtd.writesize;
+		/* fall through */
+
+		case NAND_CMD_READ0:	/* 0x00 */
+			info->cmd = SPINAND_CMD_PAGE2CACHE;
+			info->buff.idx = col;
+			info->row = row;
+			//spi_nanddma_pageread(info, row, ((info->mtd.writesize) + (info->mtd.oobsize)), (unsigned int *)info->buff.phys);	
+			spi_nanddma_pageread_prep(info, row, ((info->mtd.writesize) + (info->mtd.oobsize)), (unsigned int *)info->buff.phys);
+			break;
+
+		case NAND_CMD_SEQIN:	/* 0x80 */
+			info->cmd = SPINAND_CMD_PROLOADx4;
+			info->buff.idx = col;
+			spi_nand_setfeatures(info, DEVICE_PROTECTION_ADDR, 0x0);
+			spi_nand_wren(info);
+			info->row = row;
+			break;
+
+		case NAND_CMD_ERASE1:	/* 0x60 */
+			info->cmd = SPINAND_CMD_BLKERASE;
+			spi_nand_wren(info);	/* for MXIC,ESMT */
+			spi_nand_setfeatures(info, DEVICE_PROTECTION_ADDR, 0x0);
+			spi_nand_wren(info);
+			if (spi_nand_blkerase(info, row)) {
+				pr_err("block erase fail! \n");
+				info->err |= SPI_NAND_ERASE_FAIL;
+			}
+			break;
+
+		case NAND_CMD_STATUS:	/* 0x70 */
+			info->cmd = SPINAND_CMD_GETFEATURES;
+			info->buff.idx = 0;
+
+			/*get protection info*/
+			if (spi_nand_getfeatures(info, DEVICE_PROTECTION_ADDR) & PROTECT_STATUS) {
+				*(unsigned int *)info->buff.virt = 0x0;	/* protected */
+			} else {
+				/* not protectd. comply w/ raw NAND */
+				*(unsigned int *)info->buff.virt = 0x80;
+			}
+
+			/*get erase & program status*/
+			if (spi_nand_getfeatures(info, DEVICE_STATUS_ADDR) & (PROGRAM_STATUS|ERASE_STATUS)) {
+				*(unsigned int *)info->buff.virt |= 0x01;	/*return status is fail */
+			}
+			break;
+
+		case NAND_CMD_READID:	/* 0x90 */
+		case NAND_CMD_PARAM:	/* 0xEC */
+		case NAND_CMD_GET_FEATURES:	/* 0xEE */
+		case NAND_CMD_SET_FEATURES:	/* 0xEF */
+		case NAND_CMD_RESET:	/* 0xFF */
+			break;
+		default:
+			BUG();
+			break;
+	}
+
+}
+EXPORT_SYMBOL(sp_spinand_desc_prep);
+
+static int sp_spinand_desc_send(struct sp_spinand_info *info)
+{
+	struct sp_spinand_regs *regs = info->regs;
+	int ret = 0;
+	int retry = 0;	
+	
+	/*clear status.  start dma. check flag */ 
+	if ( (info->cmd == NAND_CMD_READ0) || (info->cmd == NAND_CMD_READOOB) || (info->cmd == NAND_CMD_PAGEPROG)) {
+		info->busy = 1;
+		spi_nanddma_run(info);
+		ret = sp_spinand_wait(info);
+		if (ret) {
+			printk("sp_spinand: descriptor timeout, cmd=0x%x\n", info->cmd);
+			sp_spinand_reset(info);
+			/* set err flag */
+			ret = 0x01;
+			return ret;
+		}	
+	}
+
+	do {
+		retry++;
+	} while((readl(&regs->spi_ctrl) & SPI_DEVICE_IDLE) && (retry < 100));
+
+	if (retry >= 100) {
+		ret = 0x01;
+	}
+
+	mutex_unlock(&info->lock);
+	if (ret) {
+		pr_info("sp_spinand: timeout, cmd=0x%x\n", info->cmd);
+		sp_spinand_reset(info);
+	}
+
+	return ret;
+}
+
+static void sp_spinand_cmdfunc(struct mtd_info *mtd, unsigned cmd, int col, int row)
+{
+	struct sp_spinand_info *info = container_of(mtd, struct sp_spinand_info, mtd);
+	int ret = 0;
+
+	if (cmd == NAND_CMD_STATUS) {
+		if (info->cmd == SPINAND_CMD_PROEXECUTE) {
+			/*check spi nand control busy/ready  status */
+			if (info->err&SPI_NAND_WRITE_FAIL) {
+				info->err &= ~SPI_NAND_WRITE_FAIL;
+				*(unsigned int *)info->buff.virt = 0x1;
+				return;
+			}
+		}
+
+		if ((info->cmd == SPINAND_CMD_BLKERASE)||(info->cmd == NAND_CMD_ERASE2)) {
+			/*check spi nand control busy/ready  status */
+			if (info->err&SPI_NAND_ERASE_FAIL) {
+				info->err &= ~SPI_NAND_ERASE_FAIL;
+				*(unsigned int *)info->buff.virt = 0x1;
+				return;
+			}
+		}
+	}
+
+	info->cmd = cmd;
+
+	switch (cmd) {
+		case NAND_CMD_READ0:	/* 0x00 */
+			sp_spinand_desc_prep(info, cmd, col, row);
+			ret=sp_spinand_desc_send(info);
+			if (ret&0x1) {
+				info->err |= SPI_NAND_READ_FAIL;
+				break;
+			}
+
+			if (readb(info->buff.virt + mtd->writesize + 1) == 0xFF)
+				break;
+
+		case NAND_CMD_READOOB:	/* 0x50 */
+			sp_spinand_desc_prep(info, cmd, col, row);
+			ret=sp_spinand_desc_send(info);
+			if(ret&0x1)
+				info->err |= SPI_NAND_READ_FAIL;
+			break;
+
+		case NAND_CMD_SEQIN:	/* 0x80 */
+			sp_spinand_desc_prep(info, cmd, col, row);
+			break;
+
+		case NAND_CMD_PAGEPROG:	/* 0x10 */
+			ret=sp_spinand_desc_send(info);
+			if(ret&0x1)
+				info->err |= SPI_NAND_WRITE_FAIL;
+			break;
+
+		case NAND_CMD_ERASE1:	/* 0x60 */
+			sp_spinand_desc_prep(info, cmd, col, row);
+			break;
+
+		case NAND_CMD_ERASE2:	/* 0xD0 */
+			ret=sp_spinand_desc_send(info);
+			if(ret&0x1)
+				info->err |= SPI_NAND_ERASE_FAIL;
+			break;
+
+		case NAND_CMD_STATUS:	/* 0x70 */
+			sp_spinand_desc_prep(info, cmd, -1, -1);
+			ret=sp_spinand_desc_send(info);
+			if(ret&0x1)
+				pr_err("get status fail\n");
+			break;
+
+		case NAND_CMD_RESET:	/* 0xFF */
+			ret=sp_spinand_reset(info);
+			if (ret & 0x1)
+				pr_err("reset nand fail\n");
+			mdelay(5);
+			break;
+
+		case NAND_CMD_READID:	/* 0x90 */
+			info->buff.idx = 0;
+			spi_nand_readid(info, 0, info->buff.virt);
+			break;
+
+		case NAND_CMD_PARAM:	/* 0xEC */
+		case NAND_CMD_GET_FEATURES:	/* 0xEE */
+			sp_spinand_desc_prep(info, cmd, col, -1);
+			ret=sp_spinand_desc_send(info);
+			if(ret&0x1)
+				pr_err("get feature fail!\n");
+			/* mdelay(5); */
+			break;
+
+		case NAND_CMD_SET_FEATURES:	/* 0xEF */
+			sp_spinand_desc_prep(info, cmd, col, -1);
+			ret=sp_spinand_desc_send(info);
+			if(ret&0x1)
+				pr_err("set feature fail!\n");
+			/* mdelay(5); */
+			break;
+
+		default:
+			break;
+	}
+}
+
+/*
+ * nand_select_chip - control CE line
+ * @mtd:	MTD device structure
+ * @chipnr:	chipnumber to select, -1 for deselect
+ */
+static void sp_spinand_select_chip(struct mtd_info *mtd, int chipnr)
+{
+	struct sp_spinand_info *info = container_of(mtd, struct sp_spinand_info, mtd);
+
+	switch (chipnr) {
+		case -1:
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+			info->cs = chipnr;
+			break;
+
+		default:
+			BUG();
+	}
+}
+
+#define LP_OPTIONS  (0x00000004|0x00000008|0x00000010)
+#define NAND_LP(name, id, ext_id, pgsz, bksz, size) \
+		{ name, id, pgsz, size, bksz, LP_OPTIONS, ext_id }
+
+struct nand_flash_dev spinand_flash_ids2[] = {
+/* GigaDevice SPI NAND  */
+	NAND_LP("GD5F1GQ4UAYIG", 0xC8D1, 0x0, (2048 + 128), SZ_128K, 128),
+	NAND_LP("GD5F2GQ4UAYIG", 0xC8D2, 0x0, (2048 + 128), SZ_128K, 256),
+
+/* MXIC  */
+	NAND_LP("MX30LF1G18AC", 0xC2F1, 0x80950200, (2048 + 64), SZ_128K, 128),
+
+/* Winbond SPI NAND  */
+	NAND_LP("W25N01GVxx1G", 0xEFAA, 0, (2048 + 64), SZ_128K, 128),
+	NAND_LP("W25N02GVxx2G", 0xEFAB, 0, (2048 + 64), SZ_128K, 256),
+
+/* MXIC SPI NAND  */
+	NAND_LP("MX35LF1GE4AB", 0xC212, 0, (2048 + 64), SZ_128K, 128),
+	NAND_LP("MX35LF2GE4AB", 0xC222, 0, (2048 + 64), SZ_128K, 256),
+
+/* ESMT SPI NAND  */
+	NAND_LP("ESMTF50L1G41A", 0xC821, 0, (2048 + 64), SZ_128K, 128)
+};
+static int sp_spinand_loadids(struct sp_spinand_info *info, const char *fn)
+{
+	int num, num_spinand_flash_ids;
+	struct nand_flash_dev *ptr;
+
+	num_spinand_flash_ids = 0;
+	for (ptr = nand_flash_ids; ptr->name; ptr++) {
+		num_spinand_flash_ids++;
+	}
+
+	num = ARRAY_SIZE(spinand_flash_ids2) + num_spinand_flash_ids;
+
+	info->ids = kzalloc(num * sizeof(struct nand_flash_dev), GFP_KERNEL);
+	if (!info->ids) {
+		printk("sp_spinand: out of memory\n");
+		info->ids = nand_flash_ids;
+		printk("sp_spinand: %s\n", __func__);
+		printk("\nsp_spinand: %s:%d\t%s return -ENOMEM", __FILE__, __LINE__, __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	memcpy(info->ids, spinand_flash_ids2, sizeof(spinand_flash_ids2));
+
+	memcpy(&(info->ids[ARRAY_SIZE(spinand_flash_ids2)]), nand_flash_ids,
+	       num_spinand_flash_ids * sizeof(struct nand_flash_dev));
+
+	return 0;
+}
+
+static int sp_spinand_fixup(struct sp_spinand_info *info)
+{
+	struct mtd_info *mtd = &info->mtd;
+	struct nand_chip *chip = mtd->priv;
+	uint64_t nrpg;
+
+	info->cac = 2;
+
+	/* row address */
+	nrpg = lldiv(chip->chipsize, mtd->writesize);
+	if (nrpg & 0xFF000000)
+		info->rac = 4;
+	else if (nrpg & 0xFFFF0000)
+		info->rac = 3;
+	else
+		info->rac = 2;
+
+	return 0;
+}
+
+static int sp_spinand_probe(struct platform_device *pdev)
+{
+	int i, ret = 0;
+	unsigned int id;
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct sp_spinand_info *info;
+	struct mtd_part_parser_data data;
+
+	const char *part_types[] = {
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+		"cmdlinepart",
+#endif
+		NULL
+	};
+
+	info = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->dev = dev;	
+	
+	/* init sema */
+	sema_init(&info->spnand_sem, 1);
+	
+	/* init mutex */
+	mutex_init(&info->lock);
+	
+	/* get module reg addr */	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);	
+	if (!res) {
+		devm_kfree(info);
+		printk("sp_spinand: %s:[%d]\n", __FILE__, __LINE__);
+		return -ENXIO;
+	}	
+	
+	info->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(info->regs))
+	{
+		devm_kfree(info);
+		return PTR_ERR(info->regs);	
+	}
+	
+	/* get irp */
+	info->irq = platform_get_irq(pdev, 0);
+	if (info->irq <= 0) {
+		devm_kfree(info);
+		printk("get spi nand irq resource fail\n");
+		return -EINVAL;
+	}else {
+		ret = request_irq(info->irq, sp_nand_irq, 0, "sp_spinand", info);
+		if (ret) {
+			printk("sp_spinand: unable to register IRQ(%d) \n", info->irq);
+		}
+	}
+	
+	platform_set_drvdata(pdev, info);
+	
+	info->hdr = dev->platform_data;
+	info->mtd.priv = &info->nand;
+	info->mtd.name = dev_name(info->dev);
+	info->mtd.owner = THIS_MODULE;
+	init_waitqueue_head(&info->wq);
+	
+	if (sp_spinand_reset(info) < 0) {
+		ret = -ENXIO;
+		printk("sp_spinand: %s:[%d]\n", __FILE__, __LINE__);
+		goto err1;
+	}	
+	
+	info->buff.size = CFG_BUFF_MAX;
+	info->buff.phys = CONFIG_MTD_SP_NAND_SRAM_BASE;
+	info->buff.virt = ioremap(info->buff.phys, info->buff.size);
+	if (!info->buff.virt) {
+		ret = -ENOMEM;
+		printk("sp_spinand: %s:[%d]\n", __FILE__, __LINE__);
+		goto err1;
+	}	
+	
+	printk("sp_spinand: buff=0x%p@0x%08x size=%u\n",
+	       info->buff.virt, info->buff.phys, info->buff.size);	
+	
+	info->nand.select_chip = sp_spinand_select_chip;
+	//info->nand.cmd_ctrl = sp_spinand_cmd_ctrl;
+	info->nand.cmdfunc = sp_spinand_cmdfunc;
+	info->nand.dev_ready = sp_spinand_dev_ready;
+	info->nand.chip_delay = 0;
+
+	info->nand.read_byte = sp_spinand_read_byte;
+	info->nand.read_buf = sp_spinand_read_buf;
+	info->nand.write_buf = sp_spinand_write_buf;
+	//info->nand.verify_buf = sp_spinand_verify_buf;
+
+	info->nand.ecc.read_page = sp_spinand_read_page;
+	info->nand.ecc.write_page = sp_spinand_write_page;
+	info->nand.ecc.layout = &info->ecc_layout;
+	info->nand.ecc.mode = NAND_ECC_HW;
+
+	/* Read ID */
+	spi_nand_readid(info, 0, &id);	
+	
+	if ((id & 0xFF) == WB_ID) {
+		info->id = (id & 0xff);
+		/* disable ecc , enable BUF mode */
+		spi_nand_setfeatures(info, DEVICE_FEATURE_ADDR, WB_BUF1_DIS_ECC);
+	} else if(((id & 0xFF) == GD_ID)||((id & 0xFF) == MXIC_ID)||((id & 0xFFFF) == ESMT1G_ID)) {
+		info->id = (id & 0xff);
+		/* disable ecc , enable QE mode */
+		spi_nand_setfeatures(info, DEVICE_FEATURE_ADDR, QUADIO_DIS_ECC);		
+	} else {
+		info->id = (id & 0xff);
+		/* disable ecc */
+		spi_nand_setfeatures(info, DEVICE_FEATURE_ADDR, 0);			
+	}
+	
+	spi_nand_setfeatures(info, DEVICE_PROTECTION_ADDR, 0x0);
+	
+	ret = sp_spinand_loadids(info, "name");	
+	if (ret < 0) {
+		goto err1;
+	}
+	
+	if (nand_scan_ident(&info->mtd, CONFIG_MTD_SP_NAND_CSNR, info->ids)) {
+		ret = -ENXIO;
+		printk("sp_spinand: %s:[%d]\n", __FILE__, __LINE__);
+		goto err1;
+	}
+
+	if (sp_spinand_fixup(info) < 0) {
+		ret = -ENXIO;
+		printk("sp_spinand: %s:[%d]\n", __FILE__, __LINE__);
+		goto err1;
+	}
+
+	if (sp_bch_init(&info->mtd) < 0) {
+		ret = -ENXIO;
+		printk("sp_spinand: %s:[%d]\n", __FILE__, __LINE__);
+		goto err1;
+	}
+
+	if (nand_scan_tail(&info->mtd)) {
+		ret = -ENXIO;
+		printk("sp_spinand: %s:[%d]\n", __FILE__, __LINE__);
+		goto err1;
+	}	
+	
+	data.origin = (unsigned long)info->hdr;
+	ret = mtd_device_parse_register(&info->mtd, part_types, &data, NULL, 0);	
+	
+	return ret;
+err1:
+	if (info->regs)
+		iounmap(info->regs);
+
+	if (info->buff.virt)
+		iounmap(info->buff.virt);
+	
+	devm_kfree(info);
+	
+	return ret;
+}
+
+
+#define sp_spinand_suspend	NULL
+#define sp_spinand_resume	NULL
+
+static const struct of_device_id of_fun_match[] = {
+	{ .compatible = "sunplus,sp_spinand" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_fun_match);
+
+static struct platform_driver sp_spinand_driver = {
+	.probe = sp_spinand_probe,
+	.remove = sp_spinand_remove,
+	.shutdown = NULL,
+	.suspend = sp_spinand_suspend,
+	.resume = sp_spinand_resume,
+	.driver = {
+			.name = "sunplus,sp_spinand",
+			.owner = THIS_MODULE,
+			.of_match_table = of_fun_match,
+		   },
+};
+
+module_platform_driver(sp_spinand_driver);
+
+MODULE_ALIAS("platform:sp_spinand");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Sunplus SPINAND flash controller");
+
+
--- a/drivers/mtd/nand/sp_spinand.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/mtd/nand/sp_spinand.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,149 @@
+/*
+ * Sunplus Technology
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __SP_SPINAND_H
+#define __SP_SPINAND_H
+
+/* Q628 spi nand driver */
+struct sp_spinand_regs {
+unsigned int spi_ctrl;       // 87.0	
+unsigned int spi_timing;     // 87.1	
+unsigned int spi_page_addr;  // 87.2	
+unsigned int spi_data;       // 87.3	
+unsigned int spi_status;     // 87.4	
+unsigned int spi_auto_cfg;   // 87.5	
+unsigned int spi_cfg[3];     // 87.6	
+unsigned int spi_data_64;    // 87.9	
+unsigned int spi_buf_addr;   // 87.10	
+unsigned int spi_statu_2;    // 87.11	
+unsigned int spi_err_status; // 87.12
+unsigned int mem_data_addr;  // 87.13	
+unsigned int mem_parity_addr;// 87.14	
+unsigned int spi_col_addr;   // 87.15	
+unsigned int spi_bch;        // 87.16	
+unsigned int spi_intr_msk;   // 87.17	
+unsigned int spi_intr_sts;   // 87.18	
+unsigned int spi_page_size;  // 87.19
+};
+
+#define SPI_DEVICE_IDLE  	(1<<31)
+#define SPI_NAND_ENABLE  	(1<<11)
+#define SPI_NAND_CHIP_A	 	(1<<24)	
+#define SPI_NAND_AUTO_WEL	(1<<19)
+#define SPI_NAND_CLK_32DIV	(0x7<<16)
+#define SPI_NAND_DMA_OWNER	(0x1<<17)
+
+#define SPI_CUSTCMD_SHIFT          8
+#define SPI_CUSTCMD_FN_SHIFT       7 
+#define SPI_CUSTCMD_RW_SHIFT       2 
+#define CUSTCMD_BYTECNT_DATA_SHIFT 4
+#define CUSTCMD_BYTECNT_ADDR_SHIFT 0
+#define SPI_NAND_CTRL_EN       	(1<<SPI_CUSTCMD_FN_SHIFT)
+#define SPI_NAND_READ_MDOE      (0<<SPI_CUSTCMD_RW_SHIFT)
+#define SPI_NAND_WRITE_MDOE     (1<<SPI_CUSTCMD_RW_SHIFT)
+#define SPINAND_CUSTCMD_NO_DATA	(0<<CUSTCMD_BYTECNT_DATA_SHIFT)
+#define SPINAND_CUSTCMD_1_DATA	(1<<CUSTCMD_BYTECNT_DATA_SHIFT)
+#define SPINAND_CUSTCMD_2_DATA	(2<<CUSTCMD_BYTECNT_DATA_SHIFT)
+#define SPINAND_CUSTCMD_3_DATA	(3<<CUSTCMD_BYTECNT_DATA_SHIFT)
+#define SPINAND_CUSTCMD_4_DATA	(4<<CUSTCMD_BYTECNT_DATA_SHIFT)
+#define SPINAND_CUSTCMD_NO_ADDR	(0<<CUSTCMD_BYTECNT_ADDR_SHIFT)
+#define SPINAND_CUSTCMD_1_ADDR	(1<<CUSTCMD_BYTECNT_ADDR_SHIFT)
+#define SPINAND_CUSTCMD_2_ADDR	(2<<CUSTCMD_BYTECNT_ADDR_SHIFT)
+#define SPINAND_CUSTCMD_3_ADDR	(3<<CUSTCMD_BYTECNT_ADDR_SHIFT)
+
+#define SPINAND_CMD_RESET		  0xff	
+#define SPINAND_CMD_READID		  0x9f	
+#define SPINAND_CMD_GETFEATURES   0x0F
+#define SPINAND_CMD_SETFEATURES   0x1F
+#define SPINAND_CMD_BLKERASE      0xD8
+#define SPINAND_CMD_PAGE2CACHE    0x13
+#define SPINAND_CMD_PAGEREAD	  0x3
+#define SPINAND_CMD_RDCACHEQUADIO 0xEB
+#define SPINAND_CMD_PROLOADx4     0x32
+#define SPINAND_CMD_PROEXECUTE    0x10
+
+#define SPINAND_AUTOCFG_CMDEN		(1<<21)
+#define SPINAND_AUTOCFG_RDCACHE		(1<<20)
+#define SPINAND_AUTOCFG_RDSTATUS	(1<<18)
+
+#define SPINAND_CFG01_DEFAULT	  0x150085	//CMD 1bit DQ0 output, ADDR 1bit DQ0 output, DATA 1bit DQ1 INTPUT
+											//cmd 1bit mode, addr 1bit mode, data 1 bit.
+#define SPINAND_CFG01_DEFAULT1	  0x150015	//CMD 1bit DQ0 output, ADDR 1bit DQ0 output, DATA 1bit DQ0 OUTPUT
+											//cmd 1bit mode, addr 1bit mode, data 1 bit.
+#define SPINAND_CFG01_DEFAULT2	  0x50005   //CMD 1bit DQ0 output, ADDR 1bit DQ0 output,
+											//cmd 1bit mode, addr 1bit mode, 											
+#define SPINAND_CFG01_DEFAULT3	  0x10001   //CMD 1bit DQ0 output,
+											//cmd 1bit mode, 
+#define SPINAND_CFG02_DEFAULT	  0x8150085 //CMD 1bit DQ0 output, ADDR 1bit DQ0 output, DATA 1bit DQ1 INTPUT,
+											//cmd 1bit mode, addr 1bit mode, data 1 bit. 8 dummy cycle
+
+// =============================
+/*block erase status */
+#define ERASE_STATUS		0x04
+
+/*protect status */
+#define PROTECT_STATUS		0x38
+
+/*data mode & ecc mode */
+#define QUADIO_EN_ECC 		0x11
+#define QUADIO_DIS_ECC 		0x01
+#define WB_BUF1_DIS_ECC		0x08
+#define WB_BUF1_EN_ECC		0x18
+#define WB_BUF0_EN_ECC		0x10
+
+/*data mode & ecc mode */
+#define DEVICE_PROTECTION_ADDR	0xA0
+#define DEVICE_FEATURE_ADDR	0xB0
+#define DEVICE_STATUS_ADDR	0xC0
+
+/* device id */
+#define ESMT1G_ID 0x21C8
+#define GD_ID 0xC8
+#define GD_ID_HIGH 0x2100
+#define WB_ID 0xEF
+#define MXIC_ID 0xC2
+
+/* read map addr */
+#define SPI_NAND_READ_ADDR 0x94000000
+#define SPI_NAND_READ_MXIC_ADDR 0x94001000
+
+extern const struct nand_flash_dev sp_nand_ids[];
+
+struct sp_spinand_info {
+	struct device *dev;
+	struct device *dma;
+	struct mtd_info mtd;
+	struct nand_chip nand;
+	wait_queue_head_t wq;
+	void __iomem *regs;
+	int irq;
+	int cs;
+	struct {
+		uint32_t idx;
+		uint32_t size;
+		void *virt;
+		dma_addr_t phys;
+	} buff;
+
+	struct nand_ecclayout ecc_layout;
+	int busy;
+	int cmd;		/* current command code */
+	int cac;		/* col address cycles */
+	int rac;		/* row address cycles */
+	int id;
+	int row;
+	int err;		/* keep err flag */
+	struct nand_flash_dev *ids;	/* NAND flash IDs */
+	void *hdr;		/* Sunplus Boot Header */
+
+#ifdef CONFIG_MTD_SP_NAND_BKER_COUNTER
+	uint16_t *blk_erased;
+#endif
+
+	struct mutex lock;
+	struct semaphore spnand_sem;
+};
+
+#endif /* __SP_SPINAND_H */
--- a/drivers/mtd/spi-nor/Kconfig	2018-11-23 10:16:15.121868822 +0300
+++ a/drivers/mtd/spi-nor/Kconfig	2018-11-23 10:31:03.775052359 +0300
@@ -129,4 +129,11 @@
 	  This enables support for the STM32 Quad SPI controller.
 	  We only connect the NOR to this controller.
 
+config SPI_SUNPLUS_SPI
+	tristate "Sunplus SPI nor controller"
+	depends on ARCH_PENTAGRAM
+	help
+	  Enable the Sunplus spi nor controller driver. This driver
+	  can be used to access the SPI NOR flash on platforms.
+
 endif # MTD_SPI_NOR
--- a/drivers/mtd/spi-nor/Makefile	2018-11-23 10:16:15.121868822 +0300
+++ a/drivers/mtd/spi-nor/Makefile	2018-11-23 10:31:03.776052299 +0300
@@ -1,3 +1,4 @@
+obj-$(CONFIG_SPI_SUNPLUS_SPI)	+= sp-spi-nor.o
 obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor.o
 obj-$(CONFIG_SPI_ASPEED_SMC)	+= aspeed-smc.o
 obj-$(CONFIG_SPI_ATMEL_QUADSPI)	+= atmel-quadspi.o
--- a/drivers/mtd/spi-nor/sp-spi-nor.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/mtd/spi-nor/sp-spi-nor.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,1154 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/completion.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/spi-nor.h>
+#include <linux/mutex.h>
+#include <linux/sizes.h>
+#include <linux/time.h>
+
+//#define SPHE8388
+#ifdef SPHE8388
+#define SPI_DATA64_EN (1 << 10)
+#define SPI_WRITE_TO (1 << 5)
+#define SPI_READ_FROM (~(1 << 5))
+#define SPI_CUST_CMD_ENA (1 << 7)
+#define SPI_DATA64_MAX_LEN 256
+#define SPI_SRAM_FULL (0x4000)
+#define SPI_SRAM_EMPTY (0x2000)
+#define SPI_TIMEOUT (500*1000)
+#define XFER_RW
+typedef struct {
+	// Group 022 : SPI_FLASH
+	unsigned int spi_ctrl;
+	unsigned int spi_wait;
+	unsigned int spi_cust_cmd;
+	unsigned int spi_addr_low;
+	unsigned int spi_addr_high;
+	unsigned int spi_data_low;
+	unsigned int spi_data_high;
+	unsigned int spi_status;
+	unsigned int spi_cfg0;
+	unsigned int spi_cfg1;
+	unsigned int spi_cfg2;
+	unsigned int spi_cfg3;
+	unsigned int spi_cfg4;
+	unsigned int spi_cfg5;
+	unsigned int spi_cfg6;
+	unsigned int spi_cfg7;
+	unsigned int spi_cfg8;
+	unsigned int spi_cust_cmd_2;
+	unsigned int spi_data_64;
+	unsigned int spi_buf_addr;
+	unsigned int spi_status_2;
+	unsigned int spi_status_3;
+	unsigned int spi_mode_status;
+	unsigned int spi_err_status;
+	unsigned int grp22_reserved[8];
+}SPI_NOR_REG;
+#else
+#define PIO_TRIGGER (1<<21)
+#define SPI_CTRL_BUSY (1<<31)
+#define SPI_DUMMY_CYC(x) (x<<24)
+#define CUST_CMD(x) (x<<8)
+#define CLEAR_CUST_CMD (~0xffff)
+#define AXI_DEFINED_READ(x) (x<<24)
+#define CLEAR_AXI_DEFINED_READ (0xffffff)
+#define ENABLE_AXI_DEFINED_READ (1<<20)
+#define CLEAR_DATA_LEN (~0xff)
+#define DMA_TRIGGER (1<<17)
+#define ENHANCE_DATA(x) (x<<24)
+#define CLEAR_ENHANCE_DATA (~(0xff<<24))
+#define DATA64_EN (1<<20)
+#define DATA64_DIS ~(1<<20)
+#define DATA64_READ_ADDR(x) (x<<16)
+#define DATA64_WRITE_ADDR(x) (x)
+#define SPI_SRAM_ST (0x7<<13)
+#define DUMMY_CYCLE(x) (x)
+#define USER_DEFINED_READ(x) (x<<24)
+#define USER_DEFINED_READ_EN (1<<20)
+#define PREFETCH_ENABLE (1<<22)
+#define PREFETCH_DISABLE (~(1<<22))
+#define PAGE_ACCESS_ENABLE (1<<29)
+#define PAGE_ACCESS_DISABLE (~(1<<29))
+#define AUTO_RDSR_EN (1<<18)
+#define CLEAR_DATA64_LEN (~0xffff)
+
+#define SPI_DATA64_MAX_LEN ((1<<16)-1)
+#define CMD_FAST_READ (0xb)
+#define CMD_READ_STATUS (0x5)
+#define SPI_TIMEOUT 450
+
+typedef struct{
+	unsigned char enhance_en;
+	unsigned char enhance_bit;
+	unsigned char enhance_bit_mode;
+	unsigned char enhance_data;
+}SPI_ENHANCE;
+enum ERASE_TYPE
+{
+	SECTOR = 0,
+	BLOCK = 1,
+	CHIP = 2
+};
+enum SPI_CLOCK_SEL
+{
+	SPI_CLK_D_2 = (1)<<16,
+	SPI_CLK_D_4 = (2)<<16,
+	SPI_CLK_D_6 = (3)<<16,
+	SPI_CLK_D_8 = (4)<<16,
+	SPI_CLK_D_16 = (5)<<16,
+	SPI_CLK_D_24 = (6)<<16,
+	SPI_CLK_D_32 = (7)<<16
+};
+enum SPI_USEABLE_DQ
+{
+	DQ0 = 1<<20,
+	DQ1 = 1<<21,
+	DQ2 = 1<<22,
+	DQ3 = 1<<23
+};
+enum SPI_CHIP_SEL
+{
+	A_CHIP = 1<<24,
+	B_CHIP = 1<<25
+};
+enum SPI_PIO_ADDRESS_BYTE
+{
+	ADDR_0B = 0,
+	ADDR_1B = 1,
+	ADDR_2B = 2,
+	ADDR_3B = 3
+};
+enum SPI_PIO_CMD
+{
+	READ_CMD = 0<<2,
+	WRITE_CMD = 1<<2
+};
+enum SPI_PIO_DATA_BYTE
+{
+	BYTE_0 = 0<<4,
+	BYTE_1 = 1<<4,
+	BYTE_2 = 2<<4,
+	BYTE_3 = 3<<4,
+	BYTE_4 = 4<<4
+};
+enum SPI_CMD_BIT
+{
+	SPI_CMD_NO = (0)<<16,
+	SPI_CMD_1b = (1)<<16,
+	SPI_CMD_2b = (2)<<16,
+	SPI_CMD_4b = (3)<<16
+};
+enum SPI_ADDR_BIT
+{
+	SPI_ADDR_NO = (0)<<18,
+	SPI_ADDR_1b = (1)<<18,
+	SPI_ADDR_2b = (2)<<18,
+	SPI_ADDR_4b = (3)<<18
+};
+enum SPI_DATA_BIT
+{
+	SPI_DATA_NO = (0)<<20,
+	SPI_DATA_1b = (1)<<20,
+	SPI_DATA_2b = (2)<<20,
+	SPI_DATA_4b = (3)<<20
+};
+enum SPI_ENHANCE_BIT
+{
+	SPI_ENHANCE_NO = (0)<<22,
+	SPI_ENHANCE_1b = (1)<<22,
+	SPI_ENHANCE_2b = (2)<<22,
+	SPI_ENHANCE_4b = (3)<<22
+};
+enum SPI_CMD_OEN_BIT
+{
+	SPI_CMD_OEN_NO = 0,
+	SPI_CMD_OEN_1b = 1,
+	SPI_CMD_OEN_2b = 2,
+	SPI_CMD_OEN_4b = 3
+};
+enum SPI_ADDR_OEN_BIT
+{
+	SPI_ADDR_OEN_NO = (0)<<2,
+	SPI_ADDR_OEN_1b = (1)<<2,
+	SPI_ADDR_OEN_2b = (2)<<2,
+	SPI_ADDR_OEN_4b = (3)<<2
+};
+enum SPI_DATA_OEN_BIT
+{
+	SPI_DATA_OEN_NO = (0)<<4,
+	SPI_DATA_OEN_1b = (1)<<4,
+	SPI_DATA_OEN_2b = (2)<<4,
+	SPI_DATA_OEN_4b = (3)<<4
+};
+enum SPI_DATA_IEN_BIT
+{
+	SPI_DATA_IEN_NO = (0)<<6,
+	SPI_DATA_IEN_DQ0 = (1)<<6,
+	SPI_DATA_IEN_DQ1 = (2)<<6
+};
+enum SPI_CMD_IO_BIT
+{
+	CMD_0 = 0,
+	CMD_1 = 1,
+	CMD_2 = 2,
+	CMD_4 = 4
+};
+enum SPI_ADDR_IO_BIT
+{
+	ADDR_0 = 0,
+	ADDR_1 = 1,
+	ADDR_2 = 2,
+	ADDR_4 = 4
+};
+enum SPI_DATA_IO_BIT
+{
+	DATA_0 = 0,
+	DATA_1 = 1,
+	DATA_2 = 2,
+	DATA_4 = 4
+};
+enum SPI_DMA_MODE
+{
+	DMA_OFF = 0,
+	DMA_ON = 1
+};
+enum SPI_SRAM_STATUS
+{
+	SRAM_CONFLICT = 0,
+	SRAM_EMPTY = 1,
+	SRAM_FULL = 2
+};
+enum SPI_INTR_STATUS
+{
+	BUFFER_ENOUGH = 1,
+	DMA_DONE = 2,
+	PIO_DONE = 4
+};
+typedef struct{
+	// Group 022 : SPI_FLASH
+	unsigned int  spi_ctrl							; 
+	unsigned int  spi_timing						; 
+	unsigned int  spi_page_addr						; 
+	unsigned int  spi_data							; 
+	unsigned int  spi_status						; 
+	unsigned int  spi_auto_cfg						; 
+	unsigned int  spi_cfg0							; 
+	unsigned int  spi_cfg1							; 
+	unsigned int  spi_cfg2							; 
+	unsigned int  spi_data64						; 
+	unsigned int  spi_buf_addr						; 
+	unsigned int  spi_status_2						; 
+	unsigned int  spi_err_status					; 
+	unsigned int  spi_mem_data_addr					; 
+	unsigned int  spi_mem_parity_addr				; 
+	unsigned int  spi_col_addr						; 
+	unsigned int  spi_bch							; 
+	unsigned int  spi_intr_msk						; 
+	unsigned int  spi_intr_sts						; 
+	unsigned int  spi_page_size						; 
+	unsigned int  G22_RESERVED[12]					; 
+}SPI_NOR_REG;
+#endif
+
+struct pentagram_spi_nor 
+{
+	struct spi_nor nor;
+	struct device *dev;
+	void __iomem *io_base;
+	struct clk *ctrl_clk;
+	struct clk *nor_clk;
+	u32 clk_rate;
+	u32 clk_src;
+	u32 read_mode;
+	u32 nor_size;
+	struct mutex lock;
+};
+
+#ifdef SPHE8388
+static int pentagram_spi_nor_init(SPI_NOR_REG* spi_reg)
+{
+	printk("%s\n",__FUNCTION__);
+	return 0;
+}
+static unsigned char pentagram_spi_nor_rdsr(SPI_NOR_REG* reg_base)
+{
+	unsigned char data;
+	SPI_NOR_REG* spi_reg = (SPI_NOR_REG*)reg_base;
+
+	writel(0,&spi_reg->spi_data_low);
+	writel(0,&spi_reg->spi_data_high);
+	writel(0x0584,&spi_reg->spi_cust_cmd);
+
+	while (readl(&spi_reg->spi_cust_cmd) & 0x80);
+
+	data = readl(&spi_reg->spi_status) & 0xff;
+	return data;
+}
+
+static int pentagram_spi_nor_erase(struct spi_nor *nor, loff_t offs)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s \n",__FUNCTION__);
+	SPI_NOR_REG* spi_reg = (SPI_NOR_REG *)pspi->io_base;
+	unsigned char opcode = nor->erase_opcode;
+	unsigned char addr_len = 3;
+	unsigned int temp_reg = 0;
+	unsigned int offset = (unsigned int)offs;
+	unsigned int data_count = 0;
+
+	while (readl(&spi_reg->spi_ctrl) & 0x8000);
+	writel(0, &spi_reg->spi_cust_cmd);
+	writel(0, &spi_reg->spi_cust_cmd_2);
+	writel(0, &spi_reg->spi_buf_addr);
+	writel(0, &spi_reg->spi_addr_low);
+	writel(0, &spi_reg->spi_addr_high);
+	temp_reg = readl(&spi_reg->spi_cust_cmd_2);
+	temp_reg |= SPI_DATA64_EN | data_count;
+	dev_dbg(pspi->dev,"cust cmd 2 0x%x\n",temp_reg);
+	writel(temp_reg, &spi_reg->spi_cust_cmd_2);
+	temp_reg = readl(&spi_reg->spi_cust_cmd);
+	temp_reg |= addr_len;
+	writel(offset & 0xffff, &spi_reg->spi_addr_low);
+	writel((offset & 0xff0000)>>16, &spi_reg->spi_addr_high);
+	dev_dbg(pspi->dev,"addr 0x%x\n",offset);
+	temp_reg |= (opcode << 8);
+	temp_reg |= SPI_WRITE_TO;
+	temp_reg |= SPI_CUST_CMD_ENA;
+	dev_dbg(pspi->dev,"cust cmd 0x%x\n",temp_reg);
+	writel(temp_reg, &spi_reg->spi_cust_cmd);
+	while (readl(&spi_reg->spi_ctrl) & 0x8000)
+	{
+		dev_dbg(pspi->dev,"wait spi ctrl busy\n");
+	};
+	while ((pentagram_spi_nor_rdsr(spi_reg) & 0x01) != 0)
+	{
+		dev_dbg(pspi->dev,"wait spi device busy\n");
+	};
+	return 0;
+}
+static int pentagram_spi_nor_xfer_write(struct spi_nor *nor, u8 opcode, u32 addr, u8 addr_len,
+				u8 *buf, size_t len)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	SPI_NOR_REG* spi_reg = (SPI_NOR_REG *)pspi->io_base;
+	int ret;
+	int total_count = len;
+	int data_count = 0;
+	unsigned int temp_reg = 0;
+	unsigned int offset = (unsigned int)addr;
+	unsigned int addr_offset = 0;
+	unsigned int addr_temp = 0;
+	unsigned short data_temp = 0;
+	unsigned char * data_in = buf;
+	unsigned char cmd = opcode;
+	struct timeval time;
+	struct timeval time_out;
+
+	dev_dbg(pspi->dev,"to 0x%x, len 0x%x\n",offset,len);
+	dev_dbg(pspi->dev,"opcode 0x%x\n",opcode);
+	mutex_lock(&pspi->lock);
+	if(total_count == 0)
+	{
+		dev_dbg(pspi->dev,"total_count = 0\n");
+		while (readl(&spi_reg->spi_ctrl) & 0x8000);
+		writel(0, &spi_reg->spi_cust_cmd);
+		writel(0, &spi_reg->spi_cust_cmd_2);
+		writel(0, &spi_reg->spi_buf_addr);
+		writel(0, &spi_reg->spi_addr_low);
+		writel(0, &spi_reg->spi_addr_high);
+		temp_reg = readl(&spi_reg->spi_cust_cmd_2);
+		temp_reg |= SPI_DATA64_EN | data_count;
+		dev_dbg(pspi->dev,"cust cmd 2 0x%x\n",temp_reg);
+		writel(temp_reg, &spi_reg->spi_cust_cmd_2);
+		temp_reg = readl(&spi_reg->spi_cust_cmd);
+		temp_reg |= addr_len;
+		writel(offset & 0xffff, &spi_reg->spi_addr_low);
+		writel((offset & 0xff0000)>>16, &spi_reg->spi_addr_high);
+		dev_dbg(pspi->dev,"addr 0x%x\n",offset);
+		temp_reg |= (cmd << 8);
+		temp_reg |= SPI_WRITE_TO;
+		temp_reg |= SPI_CUST_CMD_ENA;
+		dev_dbg(pspi->dev,"cust cmd 0x%x\n",temp_reg);
+		writel(temp_reg, &spi_reg->spi_cust_cmd);
+		while (readl(&spi_reg->spi_ctrl) & 0x8000)
+		{
+			dev_dbg(pspi->dev,"wait spi ctrl busy\n");
+		};
+		while ((pentagram_spi_nor_rdsr(spi_reg) & 0x01) != 0)
+		{
+			dev_dbg(pspi->dev,"wait spi device busy\n");
+		};
+	}
+	while (total_count > 0)
+	{
+		dev_dbg(pspi->dev,"total_count > 0\n");
+		if (total_count > SPI_DATA64_MAX_LEN)
+		{
+			total_count = total_count - SPI_DATA64_MAX_LEN;
+			data_count = SPI_DATA64_MAX_LEN;
+		}else
+		{
+			data_count = total_count;
+			total_count = 0;
+		}
+		while (readl(&spi_reg->spi_ctrl) & 0x8000);
+		writel(0, &spi_reg->spi_cust_cmd);
+		writel(0, &spi_reg->spi_cust_cmd_2);
+		writel(0, &spi_reg->spi_buf_addr);
+		if(addr_len > 0)
+		{
+			addr_temp = offset +  addr_offset* SPI_DATA64_MAX_LEN;
+			dev_dbg(pspi->dev,"addr 0x%x\n",addr_temp);
+			writel(addr_temp&0xffff, &spi_reg->spi_addr_low);
+			writel((addr_temp&0xff0000)>>16, &spi_reg->spi_addr_high);
+		}
+		temp_reg = readl(&spi_reg->spi_cust_cmd_2);
+		temp_reg |= SPI_DATA64_EN | data_count;
+		dev_dbg(pspi->dev,"cust cmd 2 0x%x\n",temp_reg);
+		writel(temp_reg, &spi_reg->spi_cust_cmd_2);
+		temp_reg = readl(&spi_reg->spi_cust_cmd);
+		temp_reg |= (cmd << 8) | 0x3;
+		temp_reg |= SPI_WRITE_TO;
+		temp_reg |= SPI_CUST_CMD_ENA;
+		dev_dbg(pspi->dev,"cust cmd 0x%x\n",temp_reg);
+		writel(temp_reg, &spi_reg->spi_cust_cmd);
+
+		while (data_count > 0)
+		{
+			if ((data_count / 2) > 0)
+			{
+				if ((readl(&spi_reg->spi_status_2) & SPI_SRAM_FULL) == SPI_SRAM_FULL)
+				{
+					do_gettimeofday(&time);
+					while ((readl(&spi_reg->spi_status_2) & SPI_SRAM_EMPTY) != SPI_SRAM_EMPTY)
+					{
+						do_gettimeofday(&time_out);
+						if ((time_out.tv_usec - time.tv_usec) > SPI_TIMEOUT)
+						{
+							dev_dbg(pspi->dev,"timeout \n");
+							break;
+						}
+					};
+				}
+				data_temp = (data_in[1] << 8) | data_in[0];
+				dev_dbg(pspi->dev,"data 0x%x\n",data_temp);
+				writel(data_temp, &spi_reg->spi_data_64);
+				data_in = data_in + 2;
+				data_count = data_count - 2;
+			}else 
+			{
+				if ((readl(&spi_reg->spi_status_2) & SPI_SRAM_FULL) == SPI_SRAM_FULL)
+				{
+					do_gettimeofday(&time);
+					while ((readl(&spi_reg->spi_status_2) & SPI_SRAM_EMPTY) != SPI_SRAM_EMPTY)
+					{
+						do_gettimeofday(&time_out);
+						if ((time_out.tv_usec - time.tv_usec) > SPI_TIMEOUT)
+						{
+							dev_dbg(pspi->dev,"timeout \n");
+							break;
+						}
+					};
+				}
+				data_temp = data_in[0] & 0xff;
+				dev_dbg(pspi->dev,"data 0x%x\n",data_temp);
+				writel(data_temp, &spi_reg->spi_data_64);
+				data_count = data_count - 1;
+			}
+		}
+		while (readl(&spi_reg->spi_ctrl) & 0x8000)
+		{
+			dev_dbg(pspi->dev,"wait spi ctrl busy\n");
+		};
+		while ((pentagram_spi_nor_rdsr(spi_reg) & 0x01) != 0)
+		{
+			dev_dbg(pspi->dev,"wait spi device busy\n");
+		};
+		addr_offset = addr_offset + 1;
+	}
+	mutex_unlock(&pspi->lock);
+	return 0;
+}
+static int pentagram_spi_nor_xfer_read(struct spi_nor *nor, u8 opcode, u32 addr, u8 addr_len,
+				u8 *buf, size_t len)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	SPI_NOR_REG* spi_reg = (SPI_NOR_REG *)pspi->io_base;
+	int ret;
+	int total_count = len;
+	int data_count = 0;
+	unsigned int temp_reg = 0;
+	unsigned int offset = (unsigned int)addr;
+	unsigned int addr_offset = 0;
+	unsigned int addr_temp = 0;
+	unsigned short data_temp = 0;
+	unsigned char * data_in = buf;
+	unsigned char cmd = opcode;
+	struct timeval time;
+	struct timeval time_out;
+
+	dev_dbg(pspi->dev,"from 0x%x, len 0x%x\n",offset,len);
+	dev_dbg(pspi->dev,"opcode 0x%x, len 0x%x\n",opcode);
+	mutex_lock(&pspi->lock);
+	while (total_count > 0)
+	{
+		if (total_count > SPI_DATA64_MAX_LEN)
+		{
+			total_count = total_count - SPI_DATA64_MAX_LEN;
+			data_count = SPI_DATA64_MAX_LEN;
+		}else
+		{
+			data_count = total_count;
+			total_count = 0;
+		}
+		while (readl(&spi_reg->spi_ctrl) & 0x8000);
+		writel(0, &spi_reg->spi_cust_cmd);
+		writel(0, &spi_reg->spi_cust_cmd_2);
+		writel(0, &spi_reg->spi_buf_addr);
+		if(addr_len > 0)
+		{
+			addr_temp = offset +  addr_offset* SPI_DATA64_MAX_LEN;
+			dev_dbg(pspi->dev,"addr_offset 0x%x\n",addr_offset);
+			dev_dbg(pspi->dev,"offset 0x%x\n",offset);
+			dev_dbg(pspi->dev,"addr 0x%x\n",addr_temp);
+			writel(addr_temp&0xffff, &spi_reg->spi_addr_low);
+			writel((addr_temp&0xff0000)>>16, &spi_reg->spi_addr_high);
+		}
+		temp_reg = readl(&spi_reg->spi_cust_cmd_2);
+		temp_reg |= SPI_DATA64_EN | data_count;
+		dev_dbg(pspi->dev,"cust cmd 2 0x%x\n",temp_reg);
+		writel(temp_reg, &spi_reg->spi_cust_cmd_2);
+		temp_reg = readl(&spi_reg->spi_cust_cmd);
+		temp_reg |= (opcode << 8) | 0x3;
+		temp_reg &= SPI_READ_FROM;
+		temp_reg |= SPI_CUST_CMD_ENA;
+		dev_dbg(pspi->dev,"cust cmd 0x%x\n",temp_reg);
+		writel(temp_reg, &spi_reg->spi_cust_cmd);
+		if (opcode == SPINOR_OP_RDSR)
+		{
+			data_in[0] = readl(&spi_reg->spi_status)&0xff;
+			data_count = 0;
+		}
+		while (data_count > 0)
+		{
+			if ((data_count / 2) > 0)
+			{
+				do_gettimeofday(&time);
+				while ((readl(&spi_reg->spi_status_2) & SPI_SRAM_EMPTY) == SPI_SRAM_EMPTY)
+				{
+					do_gettimeofday(&time_out);
+					if ((time_out.tv_usec - time.tv_usec) > SPI_TIMEOUT)
+					{
+						dev_dbg(pspi->dev,"timeout \n");
+						break;
+					}
+				};
+				data_temp = readl(&spi_reg->spi_data_64);
+				dev_dbg(pspi->dev,"data 0x%x\n",data_temp);
+				data_in[0] = data_temp & 0xff;
+				data_in[1] = ((data_temp & 0xff00) >> 8);
+				data_in = data_in + 2;
+				data_count = data_count - 2;
+			}else 
+			{
+				do_gettimeofday(&time);
+				while ((readl(&spi_reg->spi_status_2) & SPI_SRAM_EMPTY) == SPI_SRAM_EMPTY)
+				{
+					do_gettimeofday(&time_out);
+					if ((time_out.tv_usec - time.tv_usec) > SPI_TIMEOUT)
+					{
+						dev_dbg(pspi->dev,"timeout \n");
+						break;
+					}
+				};
+				data_temp = readl(&spi_reg->spi_data_64);
+				dev_dbg(pspi->dev,"data 0x%x\n",data_temp);
+				data_in[0] = data_temp & 0xff;
+				data_count = data_count - 1;
+			}
+		}
+		while (readl(&spi_reg->spi_ctrl) & 0x8000)
+		{
+			dev_dbg(pspi->dev,"wait spi ctrl busy\n");
+		};
+		while ((pentagram_spi_nor_rdsr(spi_reg) & 0x01) != 0)
+		{
+			dev_dbg(pspi->dev,"wait spi device busy\n");
+		};
+		addr_offset = addr_offset + 1;
+	}
+	mutex_unlock(&pspi->lock);
+	return 0;
+}
+#else
+static int pentagram_spi_nor_init(SPI_NOR_REG* spi_reg)
+{
+	unsigned int reg_temp;
+	writel(A_CHIP | SPI_CLK_D_32,&spi_reg->spi_ctrl);
+	reg_temp = readl(&spi_reg->spi_ctrl);
+	writel(SPI_CMD_OEN_1b | SPI_ADDR_OEN_1b | SPI_DATA_OEN_1b | SPI_CMD_1b | SPI_ADDR_1b
+		| SPI_DATA_1b | SPI_ENHANCE_NO | SPI_DUMMY_CYC(0) | SPI_DATA_IEN_DQ1,&spi_reg->spi_cfg1);
+	reg_temp = readl(&spi_reg->spi_auto_cfg);
+	reg_temp &= ~(AUTO_RDSR_EN);
+	writel(reg_temp,&spi_reg->spi_auto_cfg);
+	return 0;
+}
+static unsigned char pentagram_spi_nor_rdsr(SPI_NOR_REG* reg_base)
+{
+	unsigned char data;
+	SPI_NOR_REG* spi_reg = (SPI_NOR_REG*)reg_base;
+	unsigned int reg_temp;
+	reg_temp = readl(&spi_reg->spi_ctrl) & CLEAR_CUST_CMD;
+	reg_temp = reg_temp | READ_CMD | BYTE_0 | ADDR_0B | CUST_CMD(0x05);
+	while((readl(&spi_reg->spi_ctrl) & SPI_CTRL_BUSY)!=0);
+
+	writel(0,&spi_reg->spi_data);
+	writel(reg_temp,&spi_reg->spi_ctrl);
+	reg_temp = readl(&spi_reg->spi_auto_cfg);
+	reg_temp |= PIO_TRIGGER;
+	writel(reg_temp,&spi_reg->spi_auto_cfg);
+	while((readl(&spi_reg->spi_auto_cfg) & PIO_TRIGGER)!=0);
+	data = readl(&spi_reg->spi_status) & 0xff;
+	return data;
+}
+static int pentagram_spi_nor_xfer_write(struct spi_nor *nor, u8 opcode, u32 addr, u8 addr_len,
+				u8 *buf, size_t len)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	SPI_NOR_REG* spi_reg = (SPI_NOR_REG *)pspi->io_base;
+	int ret;
+	int total_count = len;
+	int data_count = 0;
+	unsigned int temp_reg = 0;
+	unsigned int offset = (unsigned int)addr;
+	unsigned int addr_offset = 0;
+	unsigned int addr_temp = 0;
+	unsigned int reg_temp = 0;
+	unsigned int cfg0 = 0;
+	unsigned int data_temp = 0;
+	unsigned char * data_in = buf;
+	unsigned char cmd = opcode;
+	struct timeval time;
+	struct timeval time_out;
+
+	dev_dbg(pspi->dev,"to 0x%x, len 0x%x\n",offset,len);
+	dev_dbg(pspi->dev,"opcode 0x%x\n",opcode);
+	mutex_lock(&pspi->lock);
+	if (total_count == 0) 
+	{
+		while((readl(&spi_reg->spi_ctrl) & SPI_CTRL_BUSY)!=0)
+		{
+			dev_dbg(pspi->dev,"wait ctrl busy\n");
+		};
+		reg_temp = readl(&spi_reg->spi_ctrl) & CLEAR_CUST_CMD;
+		reg_temp = reg_temp | WRITE_CMD | BYTE_0 | ADDR_0B | CUST_CMD(cmd);
+		cfg0 = readl(&spi_reg->spi_cfg0);
+		cfg0 = (cfg0 & CLEAR_DATA64_LEN) | data_count | DATA64_EN;
+		writel(cfg0,&spi_reg->spi_cfg0);
+		writel(DATA64_READ_ADDR(0) | DATA64_WRITE_ADDR(0),&spi_reg->spi_buf_addr);
+		if (addr_len > 0)
+		{
+			writel(addr,&spi_reg->spi_page_addr);
+			reg_temp = reg_temp | ADDR_3B ;
+			dev_dbg(pspi->dev,"addr 0x%x\n", spi_reg->spi_page_addr);
+		}
+		writel(0,&spi_reg->spi_data);
+		writel(reg_temp,&spi_reg->spi_ctrl);
+		reg_temp = readl(&spi_reg->spi_auto_cfg);
+		reg_temp |= PIO_TRIGGER;
+		writel(reg_temp,&spi_reg->spi_auto_cfg);
+	}
+	while (total_count > 0) 
+	{
+		if (total_count > SPI_DATA64_MAX_LEN) {
+			total_count = total_count - SPI_DATA64_MAX_LEN;
+			data_count = SPI_DATA64_MAX_LEN;
+		} else {
+			data_count = total_count;
+			total_count = 0;
+		}
+		while((readl(&spi_reg->spi_ctrl) & SPI_CTRL_BUSY)!=0)
+		{
+			dev_dbg(pspi->dev,"wait ctrl busy\n");
+		};
+		reg_temp = readl(&spi_reg->spi_ctrl) & CLEAR_CUST_CMD;
+		reg_temp = reg_temp | WRITE_CMD | BYTE_0 | ADDR_0B | CUST_CMD(cmd);
+		cfg0 = readl(&spi_reg->spi_cfg0);
+		cfg0 = (cfg0 & CLEAR_DATA64_LEN) | data_count | DATA64_EN;
+		writel(cfg0,&spi_reg->spi_cfg0);
+		writel(DATA64_READ_ADDR(0) | DATA64_WRITE_ADDR(0),&spi_reg->spi_buf_addr);
+		if (addr_len > 0) 
+		{
+			addr_temp = offset +  addr_offset* SPI_DATA64_MAX_LEN;
+			dev_dbg(pspi->dev,"addr_offset 0x%x\n",addr_offset);
+			dev_dbg(pspi->dev,"offset 0x%x\n",offset);
+			dev_dbg(pspi->dev,"addr 0x%x\n",addr_temp);
+			writel(addr_temp,&spi_reg->spi_page_addr);
+			reg_temp = reg_temp | ADDR_3B ;
+		}
+		writel(0,&spi_reg->spi_data);
+		writel(reg_temp,&spi_reg->spi_ctrl);
+		reg_temp = readl(&spi_reg->spi_auto_cfg);
+		reg_temp |= PIO_TRIGGER;
+		writel(reg_temp,&spi_reg->spi_auto_cfg);
+
+		while (data_count > 0) 
+		{
+			if ((data_count / 2) > 0) {
+				if ((readl(&spi_reg->spi_status_2) & SPI_SRAM_ST) == SRAM_FULL) {
+					do_gettimeofday(&time);
+					while ((readl(&spi_reg->spi_status_2) & SPI_SRAM_ST) != SRAM_EMPTY)
+					{
+						do_gettimeofday(&time_out);
+						if ((time_out.tv_usec - time.tv_usec) > SPI_TIMEOUT)
+						{
+							dev_dbg(pspi->dev,"timeout \n");
+							break;
+						}
+					};
+				}
+				data_temp = (data_in[3] << 24) | (data_in[2] << 16) | (data_in[1] << 8) | data_in[0];
+				writel(data_temp,&spi_reg->spi_data64);
+				data_in = data_in + 4;
+				data_count = data_count - 4;
+			} else {
+				if ((readl(&spi_reg->spi_status_2) & SPI_SRAM_ST) == SRAM_FULL) {
+					do_gettimeofday(&time);
+					while ((readl(&spi_reg->spi_status_2) & SPI_SRAM_ST) != SRAM_EMPTY)
+					{
+						do_gettimeofday(&time_out);
+						if ((time_out.tv_usec - time.tv_usec) > SPI_TIMEOUT)
+						{
+							dev_dbg(pspi->dev,"timeout \n");
+							break;
+						}
+					};
+				}
+				if(data_count%4 == 3)
+				{
+					data_temp = (data_in[2] << 16) | (data_in[1] << 8) | data_in[0];
+					data_count = data_count-3; 
+				}else if(data_count%4 == 2)
+				{
+					data_temp =  (data_in[1] << 8) | data_in[0];
+					data_count = data_count-2; 
+				}else if (data_count%4 == 1)
+				{
+					data_temp = data_in[0];
+					data_count = data_count-1; 
+				}
+				writel(data_temp,&spi_reg->spi_data64);
+			}
+		}
+		addr_offset = addr_offset + 1;
+		while ((pentagram_spi_nor_rdsr(spi_reg) & 0x01) != 0)
+		{
+			dev_dbg(pspi->dev,"wait DEVICE busy \n");
+		};
+	}
+	while((readl(&spi_reg->spi_auto_cfg) & PIO_TRIGGER)!=0)
+	{
+		dev_dbg(pspi->dev,"wait PIO_TRIGGER\n");
+	};
+	while((readl(&spi_reg->spi_ctrl) & SPI_CTRL_BUSY)!=0)
+	{
+		dev_dbg(pspi->dev,"wait ctrl busy\n");
+	};
+	cfg0 = readl(&spi_reg->spi_cfg0);
+	cfg0 &= DATA64_DIS;
+	writel(cfg0,&spi_reg->spi_cfg0);
+	mutex_unlock(&pspi->lock);
+	return 0;
+}
+static int pentagram_spi_nor_xfer_read(struct spi_nor *nor, u8 opcode, u32 addr, u8 addr_len,
+				u8 *buf, size_t len)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	SPI_NOR_REG* spi_reg = (SPI_NOR_REG *)pspi->io_base;
+	int ret;
+	int total_count = len;
+	int data_count = 0;
+	unsigned int temp_reg = 0;
+	unsigned int offset = (unsigned int)addr;
+	unsigned int addr_offset = 0;
+	unsigned int addr_temp = 0;
+	unsigned int reg_temp = 0;
+	unsigned int cfg0 = 0; 
+	unsigned int data_temp = 0;
+	unsigned char * data_in = buf;
+	unsigned char cmd = opcode;
+	struct timeval time;
+	struct timeval time_out;
+
+	dev_dbg(pspi->dev,"from 0x%x, len 0x%x\n",offset,len);
+	dev_dbg(pspi->dev,"opcode 0x%x, len 0x%x\n",opcode);
+	mutex_lock(&pspi->lock);
+
+	while (total_count > 0)
+	{
+		if (total_count > SPI_DATA64_MAX_LEN)
+		{
+			total_count = total_count - SPI_DATA64_MAX_LEN;
+			data_count = SPI_DATA64_MAX_LEN;
+		} else
+		{
+			data_count = total_count;
+			total_count = 0;
+		}
+		while((readl(&spi_reg->spi_ctrl) & SPI_CTRL_BUSY)!=0)
+		{
+			dev_dbg(pspi->dev,"wait ctrl busy\n");
+		};
+		reg_temp = readl(&spi_reg->spi_ctrl) & CLEAR_CUST_CMD;
+		reg_temp = reg_temp | READ_CMD | BYTE_0 | ADDR_0B | CUST_CMD(cmd);
+		cfg0 = readl(&spi_reg->spi_cfg0);
+		cfg0 = (cfg0 & CLEAR_DATA64_LEN) | data_count | DATA64_EN;
+		dev_dbg(pspi->dev,"spi_cfg0 0x%x\n",cfg0);
+		writel(cfg0,&spi_reg->spi_cfg0);
+		writel(0,&spi_reg->spi_page_addr);
+		writel(DATA64_READ_ADDR(0) | DATA64_WRITE_ADDR(0),&spi_reg->spi_buf_addr);
+		if(addr_len > 0)
+		{
+			addr_temp = offset +  addr_offset* SPI_DATA64_MAX_LEN;
+			dev_dbg(pspi->dev,"addr_offset 0x%x\n",addr_offset);
+			dev_dbg(pspi->dev,"offset 0x%x\n",offset);
+			dev_dbg(pspi->dev,"addr 0x%x\n",addr_temp);
+			writel(addr_temp,&spi_reg->spi_page_addr);
+			reg_temp = reg_temp | ADDR_3B ;
+		}
+		writel(0,&spi_reg->spi_data);
+		dev_dbg(pspi->dev,"spi_ctrl 0x%x\n",reg_temp);
+		writel(reg_temp,&spi_reg->spi_ctrl);
+		reg_temp = readl(&spi_reg->spi_auto_cfg);
+		reg_temp |= PIO_TRIGGER;
+		writel(reg_temp,&spi_reg->spi_auto_cfg);
+		if (opcode == SPINOR_OP_RDSR)
+		{
+			data_in[0] = readl(&spi_reg->spi_status)&0xff;
+			data_count = 0;
+		}
+		dev_dbg(pspi->dev,"cfg1 0x%x, len 0x%x\n",readl(&spi_reg->spi_cfg1));
+		while (data_count > 0)
+		{
+			if ((data_count / 4) > 0)
+			{
+				do_gettimeofday(&time);
+				while ((readl(&spi_reg->spi_status_2) & SPI_SRAM_ST) == SRAM_EMPTY)
+				{
+					do_gettimeofday(&time_out);
+					if ((time_out.tv_usec - time.tv_usec) > SPI_TIMEOUT)
+					{
+						dev_dbg(pspi->dev,"timeout \n");
+						break;
+					}
+				};
+				data_temp = readl(&spi_reg->spi_data64);
+				dev_dbg(pspi->dev,"data_temp 0x%x\n",data_temp);
+				data_in[0] = data_temp & 0xff;
+				data_in[1] = ((data_temp & 0xff00) >> 8);
+				data_in[2] = ((data_temp & 0xff0000) >> 16);
+				data_in[3] = ((data_temp & 0xff000000) >> 24);
+				data_in = data_in + 4;
+				data_count = data_count - 4;
+			} else {
+				do_gettimeofday(&time);
+				while ((readl(&spi_reg->spi_status_2) & SPI_SRAM_ST) == SRAM_EMPTY)
+				{
+					do_gettimeofday(&time_out);
+					if ((time_out.tv_usec - time.tv_usec) > SPI_TIMEOUT)
+					{
+						dev_dbg(pspi->dev,"timeout \n");
+						break;
+					}
+				};
+				data_temp = readl(&spi_reg->spi_data64);
+				dev_dbg(pspi->dev,"data_temp 0x%x\n",data_temp);
+				if(data_count%4 == 3)
+				{
+					data_in[0] = data_temp & 0xff;
+					data_in[1] = ((data_temp & 0xff00) >> 8);
+					data_in[2] = ((data_temp & 0xff0000) >> 16);
+					data_count = data_count-3; 
+				}else if(data_count%4 == 2)
+				{
+					data_in[0] = data_temp & 0xff;
+					data_in[1] = ((data_temp & 0xff00) >> 8);
+					data_count = data_count-2; 
+				}else if (data_count%4 == 1)
+				{
+					data_in[0] = data_temp & 0xff;
+					data_count = data_count-1; 
+				}
+			}
+		}
+		addr_offset = addr_offset + 1;
+		while ((pentagram_spi_nor_rdsr(spi_reg) & 0x01) != 0)
+		{
+			dev_dbg(pspi->dev,"wait DEVICE busy \n");
+		};
+	}
+	while((readl(&spi_reg->spi_auto_cfg) & PIO_TRIGGER)!=0)
+	{
+		dev_dbg(pspi->dev,"wait PIO_TRIGGER\n");
+	};
+	while((readl(&spi_reg->spi_ctrl) & SPI_CTRL_BUSY)!=0)
+	{
+		dev_dbg(pspi->dev,"wait ctrl busy\n");
+	};
+	cfg0 = readl(&spi_reg->spi_cfg0);
+	cfg0 &= DATA64_DIS;
+	writel(cfg0,&spi_reg->spi_cfg0);
+	mutex_unlock(&pspi->lock);
+	return 0;
+}
+#endif
+static ssize_t pentagram_spi_nor_read(struct spi_nor *nor, loff_t from, size_t len, u_char *buf)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	unsigned char opcode = nor->read_opcode;
+	unsigned int offset = (unsigned int)from;
+	pentagram_spi_nor_xfer_read(nor, opcode, offset, 0x3, buf, len);
+	return len;
+}
+static ssize_t pentagram_spi_nor_write(struct spi_nor *nor, loff_t to,
+				size_t len, const u_char *buf)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	unsigned char opcode = nor->program_opcode;
+	unsigned int offset = (unsigned int)to;
+	pentagram_spi_nor_xfer_write(nor, opcode, offset, 0x3, buf, len);
+	return len;
+}
+static int pentagram_spi_nor_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	pentagram_spi_nor_xfer_read(nor, opcode, 0, 0, buf, len);
+	return 0;
+}
+
+static int pentagram_spi_nor_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	unsigned char * data_in = buf;
+	unsigned int addr = 0;
+	int addr_len = 0;
+	int data_len = 0;
+	switch(opcode)
+	{
+		case SPINOR_OP_BE_4K:
+			addr_len = len;
+			data_len = 0;
+			addr= data_in[2]<<16 | data_in[1]<<8 | data_in[0];
+			break;
+		default:
+			addr_len = 0;
+			data_len = len;
+			break;
+	};
+	pentagram_spi_nor_xfer_write(nor, opcode, addr, addr_len, buf, data_len);
+	return 0;
+}
+
+static int pentagram_spi_nor_prep(struct spi_nor *nor, enum spi_nor_ops ops)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	switch(ops)
+	{
+		case 0:
+			dev_dbg(pspi->dev,"SPI_NOR_OPS_READ \n");
+			break;
+		case 1:
+			dev_dbg(pspi->dev,"SPI_NOR_OPS_WRITE \n");
+			break;
+		case 2:
+			dev_dbg(pspi->dev,"SPI_NOR_OPS_ERASE \n");
+			break;
+		case 3:
+			dev_dbg(pspi->dev,"SPI_NOR_OPS_LOCK \n");
+			break;
+		case 4:
+			dev_dbg(pspi->dev,"SPI_NOR_OPS_UNLOCK \n");
+			break;
+		default:
+			dev_dbg(pspi->dev,"Unknow ops \n");
+			break;
+	};
+	return 0;
+}
+static void pentagram_spi_nor_unprep(struct spi_nor *nor, enum spi_nor_ops ops)
+{
+	struct pentagram_spi_nor *pspi = nor->priv;
+	dev_dbg(pspi->dev,"%s\n",__FUNCTION__);
+	return ;
+}
+static int pentagram_spi_nor_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct pentagram_spi_nor *pspi ;
+	struct resource *res;
+	struct spi_nor *nor;
+	struct mtd_info *mtd;
+	SPI_NOR_REG* spi_reg;
+	int ret;
+
+	pspi = devm_kzalloc(dev, sizeof(*pspi), GFP_KERNEL);
+	if (!pspi)
+		return -ENOMEM;
+
+	pspi->dev = dev;
+
+	platform_set_drvdata(pdev, pspi);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pspi->io_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(pspi->io_base))
+		return PTR_ERR(pspi->io_base);
+
+	#if 0
+	/* find the clocks */
+	pspi->ctrl_clk = devm_clk_get(dev, "sysslow");
+	if (IS_ERR(pspi->ctrl_clk))
+		return PTR_ERR(pspi->ctrl_clk);
+
+	pspi->nor_clk = devm_clk_get(dev, "sysslow");
+	if (IS_ERR(pspi->nor_clk))
+		return PTR_ERR(pspi->nor_clk);
+
+	ret = clk_prepare_enable(pspi->ctrl_clk);
+	if (ret)
+	{
+		dev_err(dev, "can not enable the clock\n");
+		goto clk_failed;
+	}
+
+	ret = clk_prepare_enable(pspi->nor_clk);
+	if (ret)
+	{
+		goto clk_failed_nor;
+	}
+	#endif
+	
+	/* find the irq */
+	#if 0
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0) 
+	{
+		dev_err(dev, "failed to get the irq: %d\n", ret);
+		goto irq_failed;
+	}
+
+	ret = devm_request_irq(dev, ret,fsl_qspi_irq_handler, 0, pdev->name, pspi);
+	if (ret) 
+	{
+		dev_err(dev, "failed to request irq: %d\n", ret);
+		goto irq_failed;
+	}
+	#endif
+
+	nor = &pspi->nor;
+	mtd = &nor->mtd;
+
+	nor->dev = dev;
+	spi_nor_set_flash_node(nor, np);
+	nor->priv = pspi;
+
+	mutex_init(&pspi->lock);
+	/* fill the hooks */
+	nor->read_reg = pentagram_spi_nor_read_reg;
+	nor->write_reg = pentagram_spi_nor_write_reg;
+	nor->read = pentagram_spi_nor_read;
+	nor->write = pentagram_spi_nor_write;
+	//nor->erase = pentagram_spi_nor_erase;
+
+	nor->prepare = pentagram_spi_nor_prep;
+	nor->unprepare = pentagram_spi_nor_unprep;
+
+	ret = of_property_read_u32(np, "spi-max-frequency",&pspi->clk_rate);
+	if (ret < 0)
+		goto mutex_failed;
+
+	spi_reg = (SPI_NOR_REG *)pspi->io_base;
+	pentagram_spi_nor_init(spi_reg);
+	
+	ret = spi_nor_scan(nor, NULL, SPI_NOR_NORMAL);
+	if (ret)
+		goto mutex_failed;
+
+	ret = mtd_device_register(mtd, NULL, 0);
+	if (ret)
+		goto mutex_failed;
+
+	if (pspi->nor_size == 0)
+	{
+		pspi->nor_size = mtd->size;
+	}
+
+mutex_failed:
+	mutex_destroy(&pspi->lock);
+clk_failed:
+
+clk_failed_nor:
+	clk_disable_unprepare(pspi->nor_clk);
+	clk_disable_unprepare(pspi->ctrl_clk);
+
+irq_failed:
+
+	return 0;
+}
+static int pentagram_spi_nor_remove(struct platform_device *pdev)
+{
+	struct pentagram_spi_nor *pspi = platform_get_drvdata(pdev);
+
+	mtd_device_unregister(&pspi->nor.mtd);
+
+	mutex_destroy(&pspi->lock);
+
+	clk_disable_unprepare(pspi->ctrl_clk);
+	clk_disable_unprepare(pspi->nor_clk);
+	
+	return 0;
+}
+
+static const struct of_device_id pentagram_spi_nor_ids[] = {
+	{.compatible = "sunplus,pentagram-spi-nor"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, pentagram_spi_nor_ids);
+
+static struct platform_driver pentagram_spi_nor_driver = {
+	.probe	= pentagram_spi_nor_probe,
+	.remove	= pentagram_spi_nor_remove,
+	.driver	= {
+		.name = "pentagram-spi-nor",
+		.of_match_table = pentagram_spi_nor_ids,
+	},
+};
+module_platform_driver(pentagram_spi_nor_driver);
+
+MODULE_AUTHOR("Sunplus");
+MODULE_DESCRIPTION("Sunplus spi nor driver");
+MODULE_LICENSE("GPL");
--- a/drivers/scsi/sd.c	2018-11-23 10:16:15.712833715 +0300
+++ a/drivers/scsi/sd.c	2018-11-23 10:31:03.774052418 +0300
@@ -1664,6 +1664,7 @@
 {
 	struct scsi_disk *sdkp = dev_get_drvdata(dev);
 
+	sdkp->media_present = 1;
 	revalidate_disk(sdkp->disk);
 }
 
--- a/drivers/scsi/sd.h	2018-11-23 10:16:15.712833715 +0300
+++ a/drivers/scsi/sd.h	2018-11-23 10:31:03.775052359 +0300
@@ -11,7 +11,7 @@
 /*
  * Time out in seconds for disks and Magneto-opticals (which are slower).
  */
-#define SD_TIMEOUT		(30 * HZ)
+#define SD_TIMEOUT		(10 * HZ)
 #define SD_MOD_TIMEOUT		(75 * HZ)
 /*
  * Flush timeout is a multiplier over the standard device timeout which is
--- a/fs/block_dev.c	2018-11-23 10:16:16.112809954 +0300
+++ a/fs/block_dev.c	2018-11-23 10:31:03.825049386 +0300
@@ -1325,6 +1325,10 @@
 		       disk->disk_name, bdev_size, disk_size);
 		i_size_write(bdev->bd_inode, disk_size);
 		flush_disk(bdev, false);
+		if(disk_size == 0)
+			kobject_uevent(&disk_to_dev(disk)->kobj, KOBJ_OFFLINE);
+		else
+			kobject_uevent(&disk_to_dev(disk)->kobj, KOBJ_ONLINE);
 	}
 }
 EXPORT_SYMBOL(check_disk_size_change);
--- a/fs/fat/inode.c	2018-11-23 10:16:16.156807340 +0300
+++ a/fs/fat/inode.c	2018-11-23 10:31:03.826049327 +0300
@@ -1762,11 +1762,15 @@
 	/* check that FAT table does not overflow */
 	fat_clusters = calc_fat_clusters(sb);
 	total_clusters = min(total_clusters, fat_clusters - FAT_START_ENT);
+	/* to support that disks of fat16 , but total size is bigger than 2GB. */
 	if (total_clusters > MAX_FAT(sb)) {
 		if (!silent)
 			fat_msg(sb, KERN_ERR, "count of clusters too big (%u)",
 			       total_clusters);
-		goto out_invalid;
+		if(sbi->fat_bits != 16) {
+			brelse(bh);
+			goto out_invalid;
+		}
 	}
 
 	sbi->max_cluster = total_clusters + FAT_START_ENT;
