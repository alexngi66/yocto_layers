--- a/arch/arm/boot/dts/pentagram-3502-achip.dts	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-3502-achip.dts	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,127 @@
+/dts-v1/;
+
+#include "skeleton.dtsi"
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	model = "Sunplus 3502 (CA9)";
+	compatible = "sunplus,3502-achip";
+
+	interrupt-parent = <&gic>;
+
+	aliases {
+		serial0 = &uart0;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200 root=/dev/ram rw loglevel=8 earlyprintk";
+	};
+
+	memory {
+		reg = <0x00000000 0x04000000>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a9";
+			device_type = "cpu";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			compatible = "arm,cortex-a9";
+			device_type = "cpu";
+			reg = <1>;
+			enable-method = "sunplus,sc-smp";
+			cpu-boot-reg = <0x9e809ff0>;
+		};
+	};
+
+	clocks {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                ranges;
+
+		extclk: clk@osc0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+			clock-output-names = "extclk";
+		};
+
+		divextclk: clk@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-factor-clock";
+			clocks  = <&extclk>;
+			clock-mult = <1>;
+			clock-div = <2>;
+			clock-output-names = "extdivclk";
+		};
+
+		sysclk: clk@sys0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <250000000>;
+			clock-output-names = "sysclk";
+		};
+	};
+
+	soc@A {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		scu@9f100000 {
+			compatible = "arm,cortex-a9-scu";
+			reg = <0x9f100000 0x100>;
+		};
+
+		gic: interrupt-controller@CPU {
+			compatible = "arm,cortex-a9-gic";
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			reg = <0x9f101000 0x1000>,
+				<0x9f100100 0x2000>;
+		};
+
+		arm_periph_clk: clk@ca9 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";	/* for testing */
+			clock-frequency = <250000000>;	/* core clk / 2 */
+			clock-output-names = "arm_periph_clk";
+		};
+
+		global_timer: timer@9f100200 {
+			compatible = "arm,cortex-a9-global-timer";
+			reg = <0x9f100200 0x100>;
+			interrupts = <GIC_PPI 11 IRQ_TYPE_EDGE_RISING>;
+			interrupt-parent = <&gic>;
+			clocks = <&arm_periph_clk>;
+		};
+
+		/* STC_AV2 */
+		timer: timer@G99 {
+			compatible = "sunplus,sp-stc";
+			reg = <0x9c003180 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts =
+				<GIC_SPI 164 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<GIC_SPI 165 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<GIC_SPI 166 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<GIC_SPI 167 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+
+		uart0: serial@G18 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000900 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysclk>;
+		};
+	};
+};
--- a/arch/arm/boot/dts/pentagram-8388-achip.dtsi	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-8388-achip.dtsi	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,276 @@
+/dts-v1/;
+
+#include "skeleton.dtsi"
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+#define ENABLE_DMARX0
+/* #define ENABLE_DMARX1 */
+/* #define ENABLE_DMATX0 */
+/* #define ENABLE_DMATX1 */
+
+/ {
+	model = "Sunplus 8388 (CA9)";
+	compatible = "sunplus,8388-achip";
+
+	interrupt-parent = <&gic>;
+
+	aliases {
+
+#ifdef ENABLE_DMARX0
+		serial10 = &uartdmarx0;
+#endif
+#ifdef ENABLE_DMARX1
+		serial11 = &uartdmarx1;
+#endif
+#ifdef ENABLE_DMATX0
+		serial20 = &uartdmatx0;
+#endif
+#ifdef ENABLE_DMATX1
+		serial21 = &uartdmatx1;
+#endif
+
+		serial0 = &uart0;
+		serial3 = &uart3;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a9";
+			device_type = "cpu";
+			reg = <0>;
+		};
+	};
+
+	clocks {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                ranges;
+
+		extclk: clk@osc0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+			clock-output-names = "extclk";
+		};
+
+		divextclk: clk@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-factor-clock";
+			clocks  = <&extclk>;
+			clock-mult = <1>;
+			clock-div = <2>;
+			clock-output-names = "extdivclk";
+		};
+
+		sysslow: clk@sys0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <270000000>;
+			clock-output-names = "sysslow";
+		};
+	};
+
+	soc@A {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		gic: interrupt-controller@CPU {
+			compatible = "arm,cortex-a9-gic";
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			reg = <0x9f101000 0x1000>,
+				<0x9f100100 0x2000>;
+		};
+
+#if 0
+		/* STC */
+		timer: timer@G12 {
+			compatible = "sunplus,sp-stc";
+			reg = <0x9c000600 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts =
+				<GIC_SPI 151 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<GIC_SPI 152 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<GIC_SPI 153 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<GIC_SPI 154 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+#else
+		/* STC_AV2 */
+		timer: timer@G99 {
+			compatible = "sunplus,sp-stc";
+			reg = <0x9c003180 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts =
+				<GIC_SPI 164 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<GIC_SPI 165 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<GIC_SPI 166 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<GIC_SPI 167 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+#endif
+
+/* Timer tests: */
+/* 1. Enable device tree for timers. */
+/* 2. Enable sp_timer_test in drivers/misc/Makefile */
+#if 0
+#if 0
+		sp_tmr_tst0: sp_tmr_tst@9c000600 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c000600 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts =
+				<GIC_SPI 151 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<GIC_SPI 152 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<GIC_SPI 153 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<GIC_SPI 154 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+#endif
+		sp_tmr_tst1: sp_tmr_tst@9c003000 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003000 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts =
+				<GIC_SPI 155 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<GIC_SPI 156 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<GIC_SPI 157 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<GIC_SPI 158 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+
+		sp_tmr_tst2: sp_tmr_tst@9c003080 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003080 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts =
+				<GIC_SPI 159 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<GIC_SPI 160 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<GIC_SPI 161 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<GIC_SPI 162 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+#endif
+
+/* CBDMA tests: */
+/* 1. Enable device tree for CBDMA. */
+/* 2. Enable sp_cbdma_test in drivers/misc/Makefile */
+#if 0
+#if 1
+		sp_cbdma_tst0: sp_cbdma_tst@9c000d00 {
+			compatible = "sunplus,sp-cbdma-tst";
+			reg = <0x9c000d00 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>;
+		};
+#endif
+#if 1
+		sp_cbdma_tst1: sp_cbdma_tst@9c000d80 {
+			compatible = "sunplus,sp-cbdma-tst";
+			reg = <0x9c000d80 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
+		};
+#endif
+#endif
+
+#ifdef ENABLE_DMARX0
+		/* DMA Rx for UARTx */
+		uartdmarx0: serial@sp_uartdmarx0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008980 0x40>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+			which-uart = <3>;
+		};
+#endif
+#ifdef ENABLE_DMARX1
+		uartdmarx1: serial@sp_uartdmarx1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c0089c0 0x40>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+			which-uart = <4>;
+		};
+#endif
+#ifdef ENABLE_DMATX0
+		/* DMA Tx for UARTx */
+		uartdmatx0: serial@sp_uartdmatx0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008a00 0x40>;
+			clocks = <&sysslow>;
+			which-uart = <3>;
+		};
+#endif
+#ifdef ENABLE_DMATX1
+		uartdmatx1: serial@sp_uartdmatx1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008a40 0x40>;
+			clocks = <&sysslow>;
+			which-uart = <4>;
+		};
+#endif
+
+		uart0: serial@sp_uart0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000900 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+		};
+
+		uart3: serial@sp_uart3 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000880 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+		};
+
+		usb_phy: phy{
+			compatible = "sunplus,sunplus-usb-phy";
+		};
+
+		sp_ehci0: usb@9C102100 {
+			compatible = "sunplus,sunplus-q628-usb-ehci0";
+			reg = <0x9C102100 0x68>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+		};
+
+		sp_ehci1: usb@9C103100 {
+			compatible = "sunplus,sunplus-q628-usb-ehci1";
+			reg = <0x9C103100 0x68>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+		};
+
+		sp_ohci0: usb@0x9C102080 {
+			compatible = "sunplus,sunplus-q628-usb-ohci0";
+			reg = <0x9C102080 0x68>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+		};
+
+		sp_ohci1: usb@0x9C103080 {
+			compatible = "sunplus,sunplus-q628-usb-ohci1";
+			reg = <0x9C103080 0x68>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+		};
+
+		sp_udc0: usb@0x9c102800 {
+			compatible = "sunplus,sunplus-q628-usb-udc0";
+			reg = <0x9c102800 0x400>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+		};
+	};
+};
--- a/arch/arm/boot/dts/pentagram-8388-achip-emu.dts	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-8388-achip-emu.dts	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,16 @@
+/dts-v1/;
+
+#include "pentagram-8388-achip.dtsi"
+
+/ {
+	model = "Sunplus 8388 EVM (CA9)";
+	compatible = "sunplus,8388-achip";
+
+	chosen {
+		bootargs = "console=ttyS0,115200 root=/dev/ram rw loglevel=8 earlyprintk";
+	};
+
+	memory {
+		reg = <0x00000000 0x04000000>;
+	};
+};
--- a/arch/arm/boot/dts/pentagram-8388-bchip.dts	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-8388-bchip.dts	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,127 @@
+/dts-v1/;
+
+#include "skeleton.dtsi"
+
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "Sunplus 8388 (ARM926)";
+	compatible = "sunplus,8388-bchip";
+
+	interrupt-parent = <&intc>;
+
+	aliases {
+		serial0 = &uart0;
+
+		i2c0 = &i2cm0;
+		i2c1 = &i2cm1;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200 root=/dev/ram rw loglevel=8 earlyprintk";
+	};
+
+	memory {
+		reg = <0x00000000 0x04000000>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,arm926ej-s";
+			device_type = "cpu";
+			reg = <0>;
+		};
+	};
+
+	clocks {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                ranges;
+
+		extclk: clk@osc0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+			clock-output-names = "extclk";
+		};
+
+		divextclk: clk@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-factor-clock";
+			clocks  = <&extclk>;
+			clock-mult = <1>;
+			clock-div = <2>;
+			clock-output-names = "extdivclk";
+		};
+
+		sysslow: clk@sys0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <270000000>;
+			clock-output-names = "sysslow";
+		};
+	};
+
+	soc@B {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		intc: interrupt-controller@G9 {
+			compatible = "sunplus,sp-intc";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x9c000480 0x80>, /* G9  */
+			      <0x9c000500 0x80>; /* G10 */
+		};
+
+		/* STC_AV2 */
+		timer: timer@G99 {
+			compatible = "sunplus,sp-stc";
+			reg = <0x9c003180 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<164 IRQ_TYPE_EDGE_RISING>, /* AV2 timer0 */
+				<165 IRQ_TYPE_EDGE_RISING>, /* AV2 timer1 */
+				<166 IRQ_TYPE_EDGE_RISING>, /* AV2 timer2 */
+				<167 IRQ_TYPE_EDGE_RISING>; /* AV2 timer3 */
+		};
+
+		uart0: serial@G18 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000900 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&sysslow>;
+		};
+
+		pwm: pwm@0x9c007480 {
+			#pwm-cells = <2>;
+			compatible = "sunplus,sc7021-pwm";
+			reg = <0x9c007480 0x80>;
+			clocks = <&sysslow>;
+		};
+
+		i2cm0: i2c@sp_i2cm0 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9C001C80 0x80>, <0x9C000000 0x80>, <0x9C000080 0x80>;
+			reg-names = "i2cm", "moon0", "moon1";
+			interrupt-parent = <&intc>;
+			interrupts = <146 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		i2cm1: i2c@sp_i2cm1 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9C001D00 0x80>;
+			reg-names = "i2cm";
+			interrupt-parent = <&intc>;
+			interrupts = <147 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+	};
+};
--- a/arch/arm/boot/dts/pentagram-i136-achip.dts	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-i136-achip.dts	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,141 @@
+/dts-v1/;
+
+#include "skeleton.dtsi"
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	model = "Sunplus I136 (CA7)";
+	compatible = "sunplus,i136-achip";
+
+	interrupt-parent = <&gic>;
+
+	aliases {
+		serial0 = &uart0;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200 root=/dev/ram rw loglevel=8 earlyprintk";
+	};
+
+	memory {
+		reg = <0x00000000 0x04000000>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <1>;
+			enable-method = "sunplus,sc-smp";
+			cpu-boot-reg = <0x9e007ff4>;
+		};
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		extclk: clk@osc0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+			clock-output-names = "extclk";
+		};
+
+		divextclk: clk@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-factor-clock";
+			clocks  = <&extclk>;
+			clock-mult = <1>;
+			clock-div = <2>;
+			clock-output-names = "extdivclk";
+		};
+
+		A_pll0: clk@A_pll0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <2000000000>;
+			clock-output-names = "A_pll0";
+		};
+
+		B_pllsys: clk@B_pllsys {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <202500000>;
+			clock-output-names = "B_pllsys";
+		};
+	};
+
+	soc@A {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		gic: interrupt-controller@CPU {
+			compatible = "arm,cortex-a7-gic";
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			reg = <0x9f101000 0x1000>,
+			      <0x9f102000 0x2000>;
+		};
+
+		timer: timer@CPU {
+			compatible = "arm,armv7-timer";
+			interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+				     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+				     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+				     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+			clock-frequency = <27000000>;
+		};
+
+		timer@A_G19 {
+			compatible = "sunplus,sp-stc";
+			reg = <0x9ec00980 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 1 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				     <GIC_SPI 2 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				     <GIC_SPI 3 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				     <GIC_SPI 4 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+	};
+
+	soc@B {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		interrupt-parent = <&intc>;
+
+		/* B modules */
+		intc: interrupt-controller@G15 {
+			compatible = "sunplus,sp-intc";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x9c000780 0x80>, /* G15 */
+			      <0x9c000a80 0x80>; /* G21 */
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>; /* EXT_INT0 */
+		};
+
+		uart0: serial@G18 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000900 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+	};
+};
--- a/arch/arm/boot/dts/pentagram-i137-bchip.dts	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-i137-bchip.dts	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,106 @@
+/dts-v1/;
+
+#include "skeleton.dtsi"
+
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "Sunplus I137 (ARM926)";
+	compatible = "sunplus,i137-bchip";
+
+	interrupt-parent = <&intc>;
+
+	aliases {
+		serial0 = &uart0;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0 root=/dev/ram rw loglevel=8 earlyprintk";
+	};
+
+	memory {
+		reg = <0x00000000 0x04000000>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,arm926ej-s";
+			device_type = "cpu";
+			reg = <0>;
+		};
+	};
+
+	clocks {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                ranges;
+
+		extclk: clk@osc0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+			clock-output-names = "extclk";
+		};
+
+		divextclk: clk@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-factor-clock";
+			clocks  = <&extclk>;
+			clock-mult = <1>;
+			clock-div = <2>;
+			clock-output-names = "extdivclk";
+		};
+
+		A_pll0: clk@A_pll0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <2000000000>;
+			clock-output-names = "A_pll0";
+		};
+
+		B_pllsys: clk@B_pllsys {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <202500000>;
+			clock-output-names = "B_pllsys";
+		};
+	};
+
+	soc@B {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		intc: interrupt-controller@G9 {
+			compatible = "sunplus,sp-intc";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x9c000480 0x80>, /* G9  */
+			      <0x9c000500 0x80>; /* G10 */
+		};
+
+		/* STC_AV2 */
+		timer: timer@G99 {
+			compatible = "sunplus,sp-stc";
+			reg = <0x9c003180 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<164 IRQ_TYPE_EDGE_RISING>, /* AV2 timer0 */
+				<165 IRQ_TYPE_EDGE_RISING>, /* AV2 timer1 */
+				<166 IRQ_TYPE_EDGE_RISING>, /* AV2 timer2 */
+				<167 IRQ_TYPE_EDGE_RISING>; /* AV2 timer3 */
+		};
+
+		uart0: serial@G18 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000900 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+	};
+};
--- a/arch/arm/boot/dts/pentagram-sc7021-achip.dtsi	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-sc7021-achip.dtsi	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,505 @@
+/dts-v1/;
+
+#include "skeleton.dtsi"
+
+#include <dt-bindings/clock/sp-q628.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+#define ENABLE_DMARX0
+#define ENABLE_DMARX1
+#define ENABLE_DMATX0
+#define ENABLE_DMATX1
+
+/ {
+	model = "Sunplus SC7021 (CA7)";
+	compatible = "sunplus,sc7021-achip";
+
+	interrupt-parent = <&gic>;
+
+	aliases {
+#ifdef ENABLE_DMARX0
+		serial10 = &uartdmarx0;
+#endif
+#ifdef ENABLE_DMARX1
+		serial11 = &uartdmarx1;
+#endif
+#ifdef ENABLE_DMATX0
+		serial20 = &uartdmatx0;
+#endif
+#ifdef ENABLE_DMATX1
+		serial21 = &uartdmatx1;
+#endif
+
+
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		iop_reserve: iop_device {
+			no-map;
+			reg = <SP_IOP_RESERVE_BASE SP_IOP_RESERVE_SIZE>;
+		};
+	};
+
+	iop_device {
+		compatible = "sunplus,iop_device";
+		memory-region = <&iop_reserve>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <0>;
+			clock-frequency = <931000000>;
+		};
+#if 1
+		cpu@1 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <1>;
+			enable-method = "sunplus,sc-smp";
+			cpu-boot-reg = <0x9ea7fff0>;
+			clock-frequency = <931000000>;
+		};
+		cpu@2 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <2>;
+			enable-method = "sunplus,sc-smp";
+			cpu-boot-reg = <0x9ea7ffec>;
+			clock-frequency = <931000000>;
+		};
+		cpu@3 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <3>;
+			enable-method = "sunplus,sc-smp";
+			cpu-boot-reg = <0x9ea7ffe8>;
+			clock-frequency = <931000000>;
+		};
+#endif
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		extclk: clk@osc0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+			clock-output-names = "extclk";
+		};
+
+		divextclk: clk@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-factor-clock";
+			clocks  = <&extclk>;
+			clock-mult = <1>;
+			clock-div = <2>;
+			clock-output-names = "extdivclk";
+		};
+
+		A_pll0: clk@A_pll0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <2000000000>;
+			clock-output-names = "A_pll0";
+		};
+
+		clkc: clkc@0 {
+			#clock-cells = <1>;
+			compatible = "sunplus,sp-clkc";
+		};
+	};
+
+	soc@A {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		gic: interrupt-controller@CPU {
+			compatible = "arm,cortex-a7-gic";
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			reg = <0x9f101000 0x1000>,
+			      <0x9f102000 0x2000>;
+		};
+
+		timer: timer@CPU {
+			compatible = "arm,armv7-timer";
+			interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+				     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+				     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+				     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+			clock-frequency = <27000000>;
+			arm,cpu-registers-not-fw-configured;
+		};
+
+#if 0		/* Each Cortex A-7 has its own system timer, it's not required if armv7-timer is enabled. */
+		/* This timer will be used in sp_timer_test.c */
+		timer@A_G19 {
+			compatible = "sunplus,sp-stc";
+			reg = <0x9ec00980 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 1 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				     <GIC_SPI 2 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				     <GIC_SPI 3 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				     <GIC_SPI 4 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+#endif
+#if 0
+		sp_tmr_tst@9ec00980 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9ec00980 0x80>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 1 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				     <GIC_SPI 2 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				     <GIC_SPI 3 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				     <GIC_SPI 4 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+#endif
+
+		dma0@A_G11 {
+			compatible = "sunplus,sp-dma0";
+			reg = <0x9ec00580 0x180>; /* G11 ~ G13 */
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 8  IRQ_TYPE_EDGE_RISING>, /* ch0_job_done */
+                                     <GIC_SPI 9  IRQ_TYPE_EDGE_RISING>, /* ch1_job_done */
+                                     <GIC_SPI 10 IRQ_TYPE_EDGE_RISING>, /* ch2_job_done */
+                                     <GIC_SPI 11 IRQ_TYPE_EDGE_RISING>, /* ch3_job_done */
+                                     <GIC_SPI 12 IRQ_TYPE_EDGE_RISING>, /* ch4_job_done */
+                                     <GIC_SPI 13 IRQ_TYPE_EDGE_RISING>, /* ch5_job_done */
+                                     <GIC_SPI 14 IRQ_TYPE_EDGE_RISING>, /* ch6_job_done */
+                                     <GIC_SPI 15 IRQ_TYPE_EDGE_RISING>, /* ch7_job_done */
+                                     <GIC_SPI 16 IRQ_TYPE_EDGE_RISING>; /* addr_exp_err */
+		};
+	};
+
+	soc@B {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		interrupt-parent = <&intc>;
+
+		/* B modules */
+		intc: interrupt-controller@G15 {
+			compatible = "sunplus,sp-intc";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x9c000780 0x80>, /* G15 */
+			      <0x9c000a80 0x80>; /* G21 */
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>; /* EXT_INT0 */
+		};
+
+#ifdef ENABLE_DMARX0
+		/* DMA Rx for UARTx */
+		uartdmarx0: serial@sp_uartdmarx0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008980 0x40>;
+			interrupt-parent = <&intc>;
+			interrupts = <138 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+			which-uart = <1>;
+		};
+#endif
+#ifdef ENABLE_DMARX1
+		uartdmarx1: serial@sp_uartdmarx1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c0089c0 0x40>;
+			interrupt-parent = <&intc>;
+			interrupts = <139 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+			which-uart = <2>;
+		};
+#endif
+#ifdef ENABLE_DMATX0
+		/* DMA Tx for UARTx */
+		uartdmatx0: serial@sp_uartdmatx0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008a00 0x40>;
+			clocks = <&extclk>;
+			which-uart = <1>;
+		};
+#endif
+#ifdef ENABLE_DMATX1
+		uartdmatx1: serial@sp_uartdmatx1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008a40 0x40>;
+			clocks = <&extclk>;
+			which-uart = <2>;
+		};
+#endif
+
+		uart0: serial@sp_uart0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000900 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart1: serial@sp_uart1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000980 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <54 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart2: serial@sp_uart2 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000800 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <55 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart3: serial@sp_uart3 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000880 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <56 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart4: serial@sp_uart4 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008780 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <134 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		icm: icm@G81 {
+			compatible = "sunplus,sp-icm";
+			clocks = <&clkc ICM>;
+			/* clken format: (group << 16) | (index << 8) | shift */
+			clken = <0x00000a08>; /* 0.10.8 */
+			reg = <0x9c002880 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<92 IRQ_TYPE_EDGE_RISING>, /* icm0 */
+				<93 IRQ_TYPE_EDGE_RISING>, /* icm1 */
+				<94 IRQ_TYPE_EDGE_RISING>, /* icm2 */
+				<95 IRQ_TYPE_EDGE_RISING>; /* icm3 */
+		};
+
+		crypto: crypto@G84 {
+			compatible = "sunplus,sp-crypto";
+			reg = <0x9c002a00 0x100>; /* G84 ~ G85 */
+			interrupt-parent = <&intc>;
+			interrupts = <148 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		ipc: ipc@G258 {
+			compatible = "sunplus,sp-ipc";
+			reg = <0x9c008100 0x100>; /* G258 ~ G259 */
+			interrupt-parent = <&intc>;
+			interrupts =
+				<182 IRQ_TYPE_EDGE_RISING>, /* ACHIPCPU0_DIRECT_INT0 */
+				<183 IRQ_TYPE_EDGE_RISING>, /* ACHIPCPU0_DIRECT_INT1 */
+				<184 IRQ_TYPE_EDGE_RISING>, /* ACHIPCPU0_DIRECT_INT2 */
+				<185 IRQ_TYPE_EDGE_RISING>, /* ACHIPCPU0_DIRECT_INT3 */
+				<186 IRQ_TYPE_EDGE_RISING>, /* ACHIPCPU0_DIRECT_INT4 */
+				<187 IRQ_TYPE_EDGE_RISING>, /* ACHIPCPU0_DIRECT_INT5 */
+				<188 IRQ_TYPE_EDGE_RISING>, /* ACHIPCPU0_DIRECT_INT6 */
+				<189 IRQ_TYPE_EDGE_RISING>, /* ACHIPCPU0_DIRECT_INT7 */
+				<190 IRQ_TYPE_EDGE_RISING>, /* A926_DIRECT_INT0 */
+				<191 IRQ_TYPE_EDGE_RISING>, /* A926_DIRECT_INT1 */
+				<192 IRQ_TYPE_EDGE_RISING>, /* A926_DIRECT_INT2 */
+				<193 IRQ_TYPE_EDGE_RISING>, /* A926_DIRECT_INT3 */
+				<194 IRQ_TYPE_EDGE_RISING>, /* A926_DIRECT_INT4 */
+				<195 IRQ_TYPE_EDGE_RISING>, /* A926_DIRECT_INT5 */
+				<196 IRQ_TYPE_EDGE_RISING>, /* A926_DIRECT_INT6 */
+				<197 IRQ_TYPE_EDGE_RISING>, /* A926_DIRECT_INT7 */
+				<198 IRQ_TYPE_EDGE_RISING>, /* ACHIPCPU0_INT */
+				<199 IRQ_TYPE_EDGE_RISING>; /* A926_INT */
+		};
+
+/* Timer tests: */
+/* 1. Enable device tree for timers. */
+/* 2. Enable sp_timer_test in drivers/misc/Makefile */
+#if 0
+		sp_tmr_tst0: sp_tmr_tst@9c000600 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c000600 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<151 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<152 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<153 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<154 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+
+		sp_tmr_tst1: sp_tmr_tst@9c003000 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003000 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<155 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<156 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<157 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<158 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+
+		sp_tmr_tst2: sp_tmr_tst@9c003080 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003080 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<159 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<160 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<161 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<162 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+
+		sp_tmr_tst3: sp_tmr_tst@9c003180 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003180 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<164 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<165 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<166 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<167 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+#endif
+
+		pwm: pwm@0x9c007a00 {
+			#pwm-cells = <2>;
+			compatible = "sunplus,sc7021-pwm";
+			reg = <0x9c007a00 0x80>;
+			clocks = <&clkc DISP_PWM>;
+		 };
+
+		sp_uphy0: uphy@0x9C004A80 {
+			compatible = "sunplus,sunplus-usb-phy0";
+			reg = <0x9C004A80 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <36 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_uphy1: uphy@0x9C004B00 {
+			compatible = "sunplus,sunplus-usb-phy1";
+			reg = <0x9C004B00 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <37 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ehci0: usb@9C102100 {
+			compatible = "sunplus,sunplus-q628-usb-ehci0";
+			reg = <0x9C102100 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <14 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ehci1: usb@9C103100 {
+			compatible = "sunplus,sunplus-q628-usb-ehci1";
+			reg = <0x9C103100 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <17 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ohci0: usb@0x9C102080 {
+			compatible = "sunplus,sunplus-q628-usb-ohci0";
+			reg = <0x9C102080 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <15 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ohci1: usb@0x9C103080 {
+			compatible = "sunplus,sunplus-q628-usb-ohci1";
+			reg = <0x9C103080 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <18 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_udc0: usb@0x9c102800 {
+			compatible = "sunplus,sunplus-q628-usb-udc0";
+			reg = <0x9c102800 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <13 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_udc1: usb@0x9c103800 {
+			compatible = "sunplus,sunplus-q628-usb-udc1";
+			reg = <0x9c103800 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <16 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		display0: display@0x9c005c80 {
+			compatible = "sunplus,sp-display";
+			reg = <0x9c005c80 0x1980>,
+				<0x9c105000 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>,
+					   <1 IRQ_TYPE_EDGE_RISING>,
+					   <4 IRQ_TYPE_EDGE_RISING>,
+					   <5 IRQ_TYPE_EDGE_RISING>;
+		};
+
+		l2sw: l2sw@0x9c108000 {
+			compatible = "sunplus,sp-l2sw";
+			reg = <0x9c108000 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <66 IRQ_TYPE_LEVEL_HIGH>;
+		};
+		
+		mmc0: mmc@emmc {
+			compatible = "sunplus,sp-emmc";
+			reg = <0x9c003b00 0x180>;
+			interrupts = <20 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkc PLL_SYS>;
+		};
+
+		mmc1: mmc@sdcard {
+			compatible = "sunplus,sp-card1";
+			reg = <0x9c003e80 0x280>;
+			interrupts = <21 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkc PLL_SYS>;
+			sense-gpio = <71>;
+
+		};
+
+		sdio: sdio@sdcard {
+			compatible = "sunplus,sp-sdio";
+			reg = <0x9c008400 0x280>;
+			interrupts = <22 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkc PLL_SYS>;
+		};
+
+		gpio: gpio@0x9C000300 {
+			compatible = "sunplus,sp_gpio";
+			reg = <0x9C000300 0x80>, <0x9C000380 0x80>, <0x9C0032e4 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<120 IRQ_TYPE_LEVEL_HIGH>,
+				<121 IRQ_TYPE_LEVEL_HIGH>,
+				<122 IRQ_TYPE_LEVEL_HIGH>,
+				<123 IRQ_TYPE_LEVEL_HIGH>,
+				<124 IRQ_TYPE_LEVEL_HIGH>,
+				<125 IRQ_TYPE_LEVEL_HIGH>,
+				<126 IRQ_TYPE_LEVEL_HIGH>,
+				<127 IRQ_TYPE_LEVEL_HIGH>;
+		};
+	};
+};
--- a/arch/arm/boot/dts/pentagram-sc7021-achip-emu.dts	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-sc7021-achip-emu.dts	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,18 @@
+/dts-v1/;
+
+#include "pentagram-sc7021-achip.dtsi"
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	model = "Sunplus SC7021 EMU (CA7)";
+	compatible = "sunplus,sc7021-achip";
+
+	chosen {
+		bootargs = "console=ttyS0,115200 root=/dev/ram rw loglevel=8 earlyprintk";
+	};
+
+	memory {
+		reg = <0x00000000 0x20000000>; /* 512MB */
+	};
+};
--- a/arch/arm/boot/dts/pentagram-sc7021-bchip.dtsi	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-sc7021-bchip.dtsi	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,493 @@
+/dts-v1/;
+
+#include "skeleton.dtsi"
+
+#include <dt-bindings/clock/sp-q628.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+#define ENABLE_DMARX0
+#define ENABLE_DMARX1
+#define ENABLE_DMATX0
+#define ENABLE_DMATX1
+
+/ {
+	model = "Sunplus SC7021 (ARM926)";
+	compatible = "sunplus,sc7021-bchip";
+
+	interrupt-parent = <&intc>;
+
+	aliases {
+#ifdef ENABLE_DMARX0
+		serial10 = &uartdmarx0;
+#endif
+#ifdef ENABLE_DMARX1
+		serial11 = &uartdmarx1;
+#endif
+#ifdef ENABLE_DMATX0
+		serial20 = &uartdmatx0;
+#endif
+#ifdef ENABLE_DMATX1
+		serial21 = &uartdmatx1;
+#endif
+
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+
+		i2c0 = &i2cm0;
+		i2c1 = &i2cm1;
+		i2c2 = &i2cm2;
+		i2c3 = &i2cm3;
+
+		#if 0
+		i2c10 = &i2cdma0;
+		i2c11 = &i2cdma1;
+		i2c12 = &i2cdma2;
+		i2c13 = &i2cdma3;
+		#endif
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,arm926ej-s";
+			device_type = "cpu";
+			reg = <0>;
+		};
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		extclk: clk@osc0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+			clock-output-names = "extclk";
+		};
+
+		divextclk: clk@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-factor-clock";
+			clocks  = <&extclk>;
+			clock-mult = <1>;
+			clock-div = <2>;
+			clock-output-names = "extdivclk";
+		};
+
+		A_pll0: clk@A_pll0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <2000000000>;
+			clock-output-names = "A_pll0";
+		};
+
+		clkc: clkc@0 {
+			#clock-cells = <1>;
+			compatible = "sunplus,sp-clkc";
+		};
+	};
+
+	soc@B {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		intc: interrupt-controller@G9 {
+			compatible = "sunplus,sp-intc";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x9c000480 0x80>, /* G9  */
+			      <0x9c000500 0x80>; /* G10 */
+		};
+
+/* Timer tests: */
+/* 1. Enable device tree for timers. */
+/* 2. Enable sp_timer_test in drivers/misc/Makefile */
+#if 0
+		sp_tmr_tst0: sp_tmr_tst@9c000600 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c000600 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<151 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<152 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<153 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<154 IRQ_TYPE_EDGE_RISING>, /* timer3 */
+				<150 IRQ_TYPE_LEVEL_HIGH>; /* watchdog */
+		};
+
+		sp_tmr_tst1: sp_tmr_tst@9c003000 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003000 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<155 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<156 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<157 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<158 IRQ_TYPE_EDGE_RISING>, /* timer3 */
+				<168 IRQ_TYPE_LEVEL_HIGH>; /* watchdog */
+		};
+
+		sp_tmr_tst2: sp_tmr_tst@9c003080 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003080 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<159 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<160 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<161 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<162 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+
+#if 0	/* this timer is used as system tick in B-Chip's kernel */
+		sp_tmr_tst3: sp_tmr_tst@9c003180 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003180 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<164 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<165 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<166 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<167 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+#endif
+#endif
+		/* STC_AV2 */
+		timer: timer@G99 {
+			compatible = "sunplus,sp-stc";
+			reg = <0x9c003180 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<164 IRQ_TYPE_EDGE_RISING>, /* AV2 timer0 */
+				<165 IRQ_TYPE_EDGE_RISING>, /* AV2 timer1 */
+				<166 IRQ_TYPE_EDGE_RISING>, /* AV2 timer2 */
+				<167 IRQ_TYPE_EDGE_RISING>; /* AV2 timer3 */
+		};
+
+/* CBDMA tests: */
+/* 1. Enable device tree for CBDMA. */
+/* 2. Enable sp_cbdma_test in drivers/misc/Makefile */
+#if 0
+#if 1
+		sp_cbdma_tst0: sp_cbdma_tst@9c000d00 {
+			compatible = "sunplus,sp-cbdma-tst";
+			reg = <0x9c000d00 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <128 IRQ_TYPE_LEVEL_HIGH>;
+		};
+#endif
+#if 1
+		sp_cbdma_tst1: sp_cbdma_tst@9c000d80 {
+			compatible = "sunplus,sp-cbdma-tst";
+			reg = <0x9c000d80 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <129 IRQ_TYPE_LEVEL_HIGH>;
+		};
+#endif
+#endif
+
+/* RTC ISR tests: */
+/* 1. Enable device tree for RTC ISR test. */
+/* 2. Enable sp_rct_isr_test in drivers/misc/Makefile */
+#if 0
+		sp_rtc_isr_tst0: sp_rtc_isr_tst@9c003a00 {
+			compatible = "sunplus,sp-rtc-isr-tst";
+			reg = <0x9c003a00 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <163 IRQ_TYPE_EDGE_RISING>;
+		};
+#endif
+
+#ifdef ENABLE_DMARX0
+		/* DMA Rx for UARTx */
+		uartdmarx0: serial@sp_uartdmarx0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008980 0x40>;
+			interrupt-parent = <&intc>;
+			interrupts = <138 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+			which-uart = <1>;
+		};
+#endif
+#ifdef ENABLE_DMARX1
+		uartdmarx1: serial@sp_uartdmarx1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c0089c0 0x40>;
+			interrupt-parent = <&intc>;
+			interrupts = <139 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+			which-uart = <2>;
+		};
+#endif
+#ifdef ENABLE_DMATX0
+		/* DMA Tx for UARTx */
+		uartdmatx0: serial@sp_uartdmatx0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008a00 0x40>;
+			clocks = <&extclk>;
+			which-uart = <3>;
+		};
+#endif
+#ifdef ENABLE_DMATX1
+		uartdmatx1: serial@sp_uartdmatx1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008a40 0x40>;
+			clocks = <&extclk>;
+			which-uart = <4>;
+		};
+#endif
+
+
+		uart0: serial@sp_uart0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000900 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart1: serial@sp_uart1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000980 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <54 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart2: serial@sp_uart2 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000800 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <55 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart3: serial@sp_uart3 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000880 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <56 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart4: serial@sp_uart4 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008780 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <134 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		icm: icm@G81 {
+			compatible = "sunplus,sp-icm";
+			clocks = <&clkc ICM>;
+			/* clken format: (group << 16) | (index << 8) | shift */
+			clken = <0x00000a08>; /* 0.10.8 */
+			reg = <0x9c002880 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<92 IRQ_TYPE_EDGE_RISING>, /* icm0 */
+				<93 IRQ_TYPE_EDGE_RISING>, /* icm1 */
+				<94 IRQ_TYPE_EDGE_RISING>, /* icm2 */
+				<95 IRQ_TYPE_EDGE_RISING>; /* icm3 */
+		};
+
+		crypto: crypto@G84 {
+			compatible = "sunplus,sp-crypto";
+			reg = <0x9c002a00 0x100>; /* G84 ~ G85 */
+			interrupt-parent = <&intc>;
+			interrupts = <148 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		mmc0: mmc@emmc {
+			compatible = "sunplus,sp-emmc";
+			reg = <0x9c003b00 0x180>;
+			interrupts = <20 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkc PLL_SYS>;
+		};
+
+		mmc1: mmc@sdcard {
+			compatible = "sunplus,sp-card1";
+			reg = <0x9c003e80 0x280>;
+			interrupts = <21 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkc PLL_SYS>;
+			sense-gpio = <71>;
+		};
+
+		sdio: sdio@sdcard {
+			compatible = "sunplus,sp-sdio";
+			reg = <0x9c008400 0x280>;
+			interrupts = <22 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkc PLL_SYS>;
+		};
+
+		spinor0: spinor@sp_spinor {
+			compatible = "sunplus,pentagram-spi-nor";
+			reg = <0x9C000B00 0x80>;
+			spi-max-frequency = <50000000>;
+		};
+
+		spinand0: spinand@sp_spinand {
+			compatible = "sunplus,sp_spinand";
+			reg = <0x9c000AE0 0x50>;
+			interrupt-parent = <&intc>;
+			interrupts = <149 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		bch0: bch@sp_bch {
+			compatible = "sunplus,sp_bch";
+			reg = <0x9c101000 0x20>;
+			interrupt-parent = <&intc>;
+			interrupts = <58 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		i2cm0: i2c@sp_i2cm0 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004600 0x80>, <0x9c000000 0x80>, <0x9c000180 0x80>;
+			reg-names = "i2cm", "moon0", "moon3";
+			interrupt-parent = <&intc>;
+			interrupts = <174 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		i2cm1: i2c@sp_i2cm1 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004700 0x80>;
+			reg-names = "i2cm";
+			interrupt-parent = <&intc>;
+			interrupts = <175 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		i2cm2: i2c@sp_i2cm2 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004800 0x80>;
+			reg-names = "i2cm";
+			interrupt-parent = <&intc>;
+			interrupts = <176 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		i2cm3: i2c@sp_i2cm3 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004900 0x80>;
+			reg-names = "i2cm";
+			interrupt-parent = <&intc>;
+			interrupts = <177 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		#if 0
+		i2cdma0: i2c@sp_i2cdma0 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004680 0x80>;
+			clocks = <&extclk>;
+		};
+
+		i2cdma1: i2c@sp_i2cdma1 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004780 0x80>;
+			clocks = <&extclk>;
+		};
+
+		i2cdma2: i2c@sp_i2cdma2 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004880 0x80>;
+			clocks = <&extclk>;
+		};
+
+		i2cdma3: i2c@sp_i2cdma3 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004980 0x80>;
+			clocks = <&extclk>;
+		};
+		#endif
+
+		sp_uphy0: uphy@0x9C004A80 {
+			compatible = "sunplus,sunplus-usb-phy0";
+			reg = <0x9C004A80 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <36 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_uphy1: uphy@0x9C004B00 {
+			compatible = "sunplus,sunplus-usb-phy1";
+			reg = <0x9C004B00 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <37 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ehci0: usb@9C102100 {
+			compatible = "sunplus,sunplus-q628-usb-ehci0";
+			reg = <0x9C102100 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <14 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ehci1: usb@9C103100 {
+			compatible = "sunplus,sunplus-q628-usb-ehci1";
+			reg = <0x9C103100 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <17 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ohci0: usb@0x9C102080 {
+			compatible = "sunplus,sunplus-q628-usb-ohci0";
+			reg = <0x9C102080 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <15 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ohci1: usb@0x9C103080 {
+			compatible = "sunplus,sunplus-q628-usb-ohci1";
+			reg = <0x9C103080 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <18 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_udc0: usb@0x9c102800 {
+			compatible = "sunplus,sunplus-q628-usb-udc0";
+			reg = <0x9c102800 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <13 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+
+		l2sw: l2sw@0x9c108000 {
+			compatible = "sunplus,sp-l2sw";
+			reg = <0x9c108000 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <66 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_udc1: usb@0x9c103800 {
+			compatible = "sunplus,sunplus-q628-usb-udc1";
+			reg = <0x9c103800 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <16 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		gpio: gpio@0x9C000300 {
+			compatible = "sunplus,sp_gpio";
+			reg = <0x9C000300 0x80>, <0x9C000380 0x80>, <0x9C0032e4 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<120 IRQ_TYPE_LEVEL_HIGH>,
+				<121 IRQ_TYPE_LEVEL_HIGH>,
+				<122 IRQ_TYPE_LEVEL_HIGH>,
+				<123 IRQ_TYPE_LEVEL_HIGH>,
+				<124 IRQ_TYPE_LEVEL_HIGH>,
+				<125 IRQ_TYPE_LEVEL_HIGH>,
+				<126 IRQ_TYPE_LEVEL_HIGH>,
+				<127 IRQ_TYPE_LEVEL_HIGH>;
+		};
+	};
+};
--- a/arch/arm/boot/dts/pentagram-sc7021-bchip-emu.dts	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-sc7021-bchip-emu.dts	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,16 @@
+/dts-v1/;
+
+#include "pentagram-sc7021-bchip.dtsi"
+
+/ {
+	model = "Sunplus SC7021 EMU (ARM926)";
+	compatible = "sunplus,sc7021-bchip";
+
+	chosen {
+		bootargs = "console=ttyS0,115200 root=/dev/ram rw loglevel=8 earlyprintk";
+	};
+
+	memory {
+		reg = <0x00000000 0x20000000>; /* 512MB */
+	};
+};
--- a/arch/arm/boot/dts/pentagram-sc7021-bchip-hwbuf-tst.dtsi	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/boot/dts/pentagram-sc7021-bchip-hwbuf-tst.dtsi	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,484 @@
+/dts-v1/;
+
+#include "skeleton.dtsi"
+
+#include <dt-bindings/clock/sp-q628.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+#define ENABLE_DMARX0
+#define ENABLE_DMARX1
+#define ENABLE_HW_BUF_UA0
+#define ENABLE_HW_BUF_UA1
+
+/ {
+	model = "Sunplus SC7021 (ARM926)";
+	compatible = "sunplus,sc7021-bchip";
+
+	interrupt-parent = <&intc>;
+
+	aliases {
+#ifdef ENABLE_DMARX0
+		serial10 = &uartdmarx0;
+#endif
+#ifdef ENABLE_DMARX1
+		serial11 = &uartdmarx1;
+#endif
+#ifdef ENABLE_HW_BUF_UA0
+		serial20 = &uarthwbuf0;
+#endif
+#ifdef ENABLE_HW_BUF_UA1
+		serial21 = &uarthwbuf1;
+#endif
+
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+
+		i2c0 = &i2cm0;
+		i2c1 = &i2cm1;
+		i2c2 = &i2cm2;
+		i2c3 = &i2cm3;
+
+		i2c10 = &i2cdma0;
+		i2c11 = &i2cdma1;
+		i2c12 = &i2cdma2;
+		i2c13 = &i2cdma3;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,arm926ej-s";
+			device_type = "cpu";
+			reg = <0>;
+		};
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		extclk: clk@osc0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+			clock-output-names = "extclk";
+		};
+
+		divextclk: clk@0 {
+			#clock-cells = <0>;
+			compatible = "fixed-factor-clock";
+			clocks  = <&extclk>;
+			clock-mult = <1>;
+			clock-div = <2>;
+			clock-output-names = "extdivclk";
+		};
+
+		A_pll0: clk@A_pll0 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <2000000000>;
+			clock-output-names = "A_pll0";
+		};
+
+		clkc: clkc@0 {
+			#clock-cells = <1>;
+			compatible = "sunplus,sp-clkc";
+		};
+	};
+
+	soc@B {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		intc: interrupt-controller@G9 {
+			compatible = "sunplus,sp-intc";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x9c000480 0x80>, /* G9  */
+			      <0x9c000500 0x80>; /* G10 */
+		};
+
+/* Timer tests: */
+/* 1. Enable device tree for timers. */
+/* 2. Enable sp_timer_test in drivers/misc/Makefile */
+#if 0
+		sp_tmr_tst0: sp_tmr_tst@9c000600 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c000600 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<151 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<152 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<153 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<154 IRQ_TYPE_EDGE_RISING>, /* timer3 */
+				<150 IRQ_TYPE_LEVEL_HIGH>; /* watchdog */
+		};
+
+		sp_tmr_tst1: sp_tmr_tst@9c003000 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003000 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<155 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<156 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<157 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<158 IRQ_TYPE_EDGE_RISING>, /* timer3 */
+				<168 IRQ_TYPE_LEVEL_HIGH>; /* watchdog */
+		};
+
+		sp_tmr_tst2: sp_tmr_tst@9c003080 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003080 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<159 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<160 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<161 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<162 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+
+#if 0	/* this timer is used as system tick in B-Chip's kernel */
+		sp_tmr_tst3: sp_tmr_tst@9c003180 {
+			compatible = "sunplus,sp-tmr-tst";
+			reg = <0x9c003180 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<164 IRQ_TYPE_EDGE_RISING>, /* timer0 */
+				<165 IRQ_TYPE_EDGE_RISING>, /* timer1 */
+				<166 IRQ_TYPE_EDGE_RISING>, /* timer2 */
+				<167 IRQ_TYPE_EDGE_RISING>; /* timer3 */
+		};
+#endif
+#endif
+		/* STC_AV2 */
+		timer: timer@G99 {
+			compatible = "sunplus,sp-stc";
+			reg = <0x9c003180 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<164 IRQ_TYPE_EDGE_RISING>, /* AV2 timer0 */
+				<165 IRQ_TYPE_EDGE_RISING>, /* AV2 timer1 */
+				<166 IRQ_TYPE_EDGE_RISING>, /* AV2 timer2 */
+				<167 IRQ_TYPE_EDGE_RISING>; /* AV2 timer3 */
+		};
+
+/* CBDMA tests: */
+/* 1. Enable device tree for CBDMA. */
+/* 2. Enable sp_cbdma_test in drivers/misc/Makefile */
+#if 0
+#if 1
+		sp_cbdma_tst0: sp_cbdma_tst@9c000d00 {
+			compatible = "sunplus,sp-cbdma-tst";
+			reg = <0x9c000d00 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <128 IRQ_TYPE_LEVEL_HIGH>;
+		};
+#endif
+#if 1
+		sp_cbdma_tst1: sp_cbdma_tst@9c000d80 {
+			compatible = "sunplus,sp-cbdma-tst";
+			reg = <0x9c000d80 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <129 IRQ_TYPE_LEVEL_HIGH>;
+		};
+#endif
+#endif
+
+/* RTC ISR tests: */
+/* 1. Enable device tree for RTC ISR test. */
+/* 2. Enable sp_rct_isr_test in drivers/misc/Makefile */
+#if 0
+		sp_rtc_isr_tst0: sp_rtc_isr_tst@9c003a00 {
+			compatible = "sunplus,sp-rtc-isr-tst";
+			reg = <0x9c003a00 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <163 IRQ_TYPE_EDGE_RISING>;
+		};
+#endif
+
+#ifdef ENABLE_DMARX0
+		/* DMA Rx for UARTx */
+		uartdmarx0: serial@sp_uartdmarx0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008980 0x40>;
+			interrupt-parent = <&intc>;
+			interrupts = <138 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+			which-uart = <3>;
+		};
+#endif
+#ifdef ENABLE_DMARX1
+		uartdmarx1: serial@sp_uartdmarx1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c0089c0 0x40>;
+			interrupt-parent = <&intc>;
+			interrupts = <139 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+			which-uart = <4>;
+		};
+#endif
+#ifdef ENABLE_HW_BUF_UA0
+		uarthwbuf0: serial@sp_uarthwbuf0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008a00 0x40>,
+			      <0x9c008880 0x80>;
+			clocks = <&extclk>;
+			which-uart = <2>;
+			tx-1-rx-0 = <0>;
+		};
+#endif
+#ifdef ENABLE_HW_BUF_UA1
+		uarthwbuf1: serial@sp_uarthwbuf1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008a40 0x40>,
+			      <0x9c008900 0x80>;
+			clocks = <&extclk>;
+			which-uart = <1>;
+			tx-1-rx-0 = <1>;
+		};
+#endif
+
+
+		uart0: serial@sp_uart0 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000900 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart1: serial@sp_uart1 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000980 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <54 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart2: serial@sp_uart2 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000800 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <55 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart3: serial@sp_uart3 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c000880 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <56 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		uart4: serial@sp_uart4 {
+			compatible = "sunplus,sp-uart";
+			reg = <0x9c008780 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <134 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		icm: icm@G81 {
+			compatible = "sunplus,sp-icm";
+			clocks = <&clkc ICM>;
+			/* clken format: (group << 16) | (index << 8) | shift */
+			clken = <0x00000a08>; /* 0.10.8 */
+			reg = <0x9c002880 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<92 IRQ_TYPE_EDGE_RISING>, /* icm0 */
+				<93 IRQ_TYPE_EDGE_RISING>, /* icm1 */
+				<94 IRQ_TYPE_EDGE_RISING>, /* icm2 */
+				<95 IRQ_TYPE_EDGE_RISING>; /* icm3 */
+		};
+
+		crypto: crypto@G84 {
+			compatible = "sunplus,sp-crypto";
+			reg = <0x9c002a00 0x100>; /* G84 ~ G85 */
+			interrupt-parent = <&intc>;
+			interrupts = <148 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		mmc0: mmc@emmc {
+			compatible = "sunplus,sp_emmc";
+			reg = <0x9c003b00 0x180>;
+			interrupts = <20 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkc PLL_SYS>;
+		};
+
+		mmc1: mmc@sdcard {
+			compatible = "sunplus,sp_card1";
+			reg = <0x9c003e80 0x280>;
+			interrupts = <21 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clkc PLL_SYS>;
+		};
+
+		spinor0: spinor@sp_spinor {
+			compatible = "sunplus,pentagram-spi-nor";
+			reg = <0x9C000B00 0x80>;
+			spi-max-frequency = <50000000>;
+		};
+
+		spinand0: spinand@sp_spinand {
+			compatible = "sunplus,sp_spinand";
+			reg = <0x9c000AE0 0x50>;
+			interrupt-parent = <&intc>;
+			interrupts = <149 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		bch0: bch@sp_bch {
+			compatible = "sunplus,sp_bch";
+			reg = <0x9c101000 0x20>;
+			interrupt-parent = <&intc>;
+			interrupts = <58 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		i2cm0: i2c@sp_i2cm0 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004600 0x80>, <0x9c000000 0x80>, <0x9c000180 0x80>;
+			reg-names = "i2cm", "moon0", "moon3";
+			interrupt-parent = <&intc>;
+			interrupts = <174 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		i2cm1: i2c@sp_i2cm1 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004700 0x80>;
+			reg-names = "i2cm";
+			interrupt-parent = <&intc>;
+			interrupts = <175 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		i2cm2: i2c@sp_i2cm2 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004800 0x80>;
+			reg-names = "i2cm";
+			interrupt-parent = <&intc>;
+			interrupts = <176 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		i2cm3: i2c@sp_i2cm3 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004900 0x80>;
+			reg-names = "i2cm";
+			interrupt-parent = <&intc>;
+			interrupts = <177 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&extclk>;
+		};
+
+		i2cdma0: i2c@sp_i2cdma0 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004680 0x80>;
+			clocks = <&extclk>;
+		};
+
+		i2cdma1: i2c@sp_i2cdma1 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004780 0x80>;
+			clocks = <&extclk>;
+		};
+
+		i2cdma2: i2c@sp_i2cdma2 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004880 0x80>;
+			clocks = <&extclk>;
+		};
+
+		i2cdma3: i2c@sp_i2cdma3 {
+			compatible = "sunplus,sp_i2cm";
+			reg = <0x9c004980 0x80>;
+			clocks = <&extclk>;
+		};
+
+		sp_uphy0: uphy@0x9C004A80 {
+			compatible = "sunplus,sunplus-usb-phy0";
+			reg = <0x9C004A80 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <36 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_uphy1: uphy@0x9C004B00 {
+			compatible = "sunplus,sunplus-usb-phy1";
+			reg = <0x9C004B00 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts = <37 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ehci0: usb@9C102100 {
+			compatible = "sunplus,sunplus-q628-usb-ehci0";
+			reg = <0x9C102100 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <14 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ehci1: usb@9C103100 {
+			compatible = "sunplus,sunplus-q628-usb-ehci1";
+			reg = <0x9C103100 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <17 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ohci0: usb@0x9C102080 {
+			compatible = "sunplus,sunplus-q628-usb-ohci0";
+			reg = <0x9C102080 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <15 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_ohci1: usb@0x9C103080 {
+			compatible = "sunplus,sunplus-q628-usb-ohci1";
+			reg = <0x9C103080 0x68>;
+			interrupt-parent = <&intc>;
+			interrupts = <18 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_udc0: usb@0x9c102800 {
+			compatible = "sunplus,sunplus-q628-usb-udc0";
+			reg = <0x9c102800 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <13 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+
+		l2sw: l2sw@0x9c108000 {
+			compatible = "sunplus,sp-l2sw";
+			reg = <0x9c108000 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <66 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		sp_udc1: usb@0x9c103800 {
+			compatible = "sunplus,sunplus-q628-usb-udc1";
+			reg = <0x9c103800 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <16 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		gpio: gpio@0x9C000300 {
+			compatible = "sunplus,sp_gpio";
+			reg = <0x9C000300 0x80>, <0x9C000380 0x80>, <0x9C0032e4 0x80>;
+			interrupt-parent = <&intc>;
+			interrupts =
+				<120 IRQ_TYPE_LEVEL_HIGH>,
+				<121 IRQ_TYPE_LEVEL_HIGH>,
+				<122 IRQ_TYPE_LEVEL_HIGH>,
+				<123 IRQ_TYPE_LEVEL_HIGH>,
+				<124 IRQ_TYPE_LEVEL_HIGH>,
+				<125 IRQ_TYPE_LEVEL_HIGH>,
+				<126 IRQ_TYPE_LEVEL_HIGH>,
+				<127 IRQ_TYPE_LEVEL_HIGH>;
+		};
+	};
+};
--- a/arch/arm/configs/pentagram_3502_achip_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/configs/pentagram_3502_achip_defconfig	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,1373 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.12.14 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="armv7hf-glibc-linux-"
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_FHANDLE is not set
+CONFIG_USELIB=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rootfs/initramfs/disk/ ../rootfs/initramfs/disk/dev/initramfs.devnodes"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=""
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_MEMBARRIER=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS=8
+# CONFIG_HAVE_ARCH_HASH is not set
+# CONFIG_ISA_BUS_API is not set
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+# CONFIG_CPU_NO_EFFICIENT_FFS is not set
+# CONFIG_HAVE_ARCH_VMAP_STACK is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+# CONFIG_BLOCK is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+CONFIG_ARCH_PENTAGRAM=y
+# CONFIG_MACH_PENTAGRAM_8388_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_8388_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_I136_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_I137_BCHIP is not set
+CONFIG_MACH_PENTAGRAM_3502_ACHIP=y
+# CONFIG_MACH_PENTAGRAM_SC7021_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_BCHIP is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+# CONFIG_VDSO is not set
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+CONFIG_ARM_ERRATA_643719=y
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+
+#
+# DesignWare PCI Core Support
+#
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+# CONFIG_MCPM is not set
+# CONFIG_BIG_LITTLE is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_THUMB2_KERNEL=y
+CONFIG_THUMB2_AVOID_R_ARM_THM_JUMP11=y
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_AEABI=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0x98307000
+CONFIG_ZBOOT_ROM_BSS=0x03400000
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="root=/dev/ram rw init=/init console=ttyS0,115200 earlyprintk mem=256M@0x0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+# CONFIG_KERNEL_MODE_NEON is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# CONFIG_NET is not set
+CONFIG_HAVE_CBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_ARM_CCI400_PMU is not set
+# CONFIG_ARM_CCI5xx_PMU is not set
+# CONFIG_ARM_CCN is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_AFU_DRIVER_OPS is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_SCSI_DMA is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+CONFIG_SERIAL_SP_UART=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# CONFIG_DRM_LIB_RANDOM is not set
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+
+#
+# SPI RTC drivers
+#
+
+#
+# SPI and I2C RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_SUNPLUS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV_TSCPAGE is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_NXP is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_PIC32 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+CONFIG_ARM_GLOBAL_TIMER=y
+# CONFIG_ARM_TIMER_SP804 is not set
+CONFIG_CLKSRC_ARM_GLOBAL_TIMER_SCHED_CLOCK=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+CONFIG_CLKSRC_SP_TIMER=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# i.MX SoC drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_SOC_ZTE is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_SP_INTC is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_PMU=y
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# FSI support
+#
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+CONFIG_HAVE_ARM_SMCCC=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+CONFIG_DEBUG_SP_UART=y
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_DEBUG_UART_PHYS=0x9c000900
+CONFIG_DEBUG_UART_VIRT=0xf8000900
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+CONFIG_EARLY_PRINTK=y
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+# CONFIG_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+# CONFIG_DMA_NOOP_OPS is not set
+# CONFIG_DMA_VIRT_OPS is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+# CONFIG_SG_SPLIT is not set
+# CONFIG_SG_POOL is not set
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_VIRTUALIZATION is not set
--- a/arch/arm/configs/pentagram_8388_achip_emu_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/configs/pentagram_8388_achip_emu_defconfig	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,1420 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.12.14 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="armv7hf-glibc-linux-"
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_FHANDLE is not set
+CONFIG_USELIB=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rootfs/initramfs/disk/ ../rootfs/initramfs/disk/dev/initramfs.devnodes"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=""
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_MEMBARRIER=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS=8
+# CONFIG_HAVE_ARCH_HASH is not set
+# CONFIG_ISA_BUS_API is not set
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+# CONFIG_CPU_NO_EFFICIENT_FFS is not set
+# CONFIG_HAVE_ARCH_VMAP_STACK is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+# CONFIG_BLOCK is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+CONFIG_ARCH_PENTAGRAM=y
+CONFIG_MACH_PENTAGRAM_8388_ACHIP=y
+# CONFIG_MACH_PENTAGRAM_8388_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_I136_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_I137_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_3502_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_BCHIP is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+# CONFIG_VDSO is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0_PMU is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+# CONFIG_PL310_ERRATA_753970 is not set
+# CONFIG_PL310_ERRATA_769419 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_HEAVY_MB=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+CONFIG_ARM_ERRATA_643719=y
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+
+#
+# DesignWare PCI Core Support
+#
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+# CONFIG_MCPM is not set
+# CONFIG_BIG_LITTLE is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_THUMB2_KERNEL=y
+CONFIG_THUMB2_AVOID_R_ARM_THM_JUMP11=y
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_AEABI=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0x98307000
+CONFIG_ZBOOT_ROM_BSS=0x03400000
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="root=/dev/ram rw init=/init console=ttyS0,115200 earlyprintk mem=256M@0x0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+# CONFIG_KERNEL_MODE_NEON is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# CONFIG_NET is not set
+CONFIG_HAVE_CBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_ARM_CCI400_PMU is not set
+# CONFIG_ARM_CCI5xx_PMU is not set
+# CONFIG_ARM_CCN is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_AFU_DRIVER_OPS is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_SCSI_DMA is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+CONFIG_SERIAL_SP_UART=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# CONFIG_DRM_LIB_RANDOM is not set
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+CONFIG_BLOCK=y
+# USB Support
+CONFIG_USB=y
+CONFIG_USB_HID=m
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+#CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+# CONFIG_USB_DEFAULT_PERSIST is not set
+CONFIG_USB_EHCI_HCD=y
+#CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+#CONFIG_NOP_USB_XCEIV=y
+#CONFIG_USB_GPIO_VBUS=y
+#CONFIG_USB_ISP1301=y
+CONFIG_USB_GADGET=y
+#CONFIG_USB_ETH=y
+CONFIG_USB_GADGET_PORT0_ENABLED=y
+CONFIG_USB_LOGO_TEST=y
+CONFIG_USB_HOST_RESET_SP=y
+CONFIG_SWITCH_USB_ROLE=y
+CONFIG_USB_BC=y
+CONFIG_USB_GADGET_8388=y
+#CONFIG_USB_G_ANDROID=y
+#CONFIG_USB_AOA=y
+#CONFIG_USB_USBNET=m
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_SND_USB_AUDIO=m
+CONFIG_USB_USE_PLATFORM_RESOURCE=y
+CONFIG_GEMINI_USB=y
+CONFIG_SUNPLUS_USB_PHY=y
+CONFIG_USB_ZERO=y
+CONFIG_USB_OTG=y
+CONFIG_USB_OHCI_MSI_WORKAROUND=y
+CONFIG_USB_HOST_ENUM_RETRY=y
+#CONFIG_SUPPORT_AOA_INIT_ACCESSORY=y
+#CONFIG_SUPPORT_IOSMIRROR_CONFIGURATION=y
+CONFIG_SUPPORT_APPLE_ROLE_SWITCH=y
+CONFIG_USB_MULTIPLE_RESET_PROBLEM_WORKAROUND=y
+CONFIG_USB_PHY_RX_ACTIVE_QUESTION_WORKAROUND=n
+CONFIG_USB_DEVICE_EP11_NOT_AUTO_SWITCH_WORKAROUN=y
+CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUN=y
+CONFIG_USB_DEVICE_LOSE_PACKET_AFTER_SET_INTERFACE_WORKAROUN=y
+
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+
+#
+# SPI RTC drivers
+#
+
+#
+# SPI and I2C RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_SUNPLUS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV_TSCPAGE is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_NXP is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_PIC32 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+CONFIG_CLKSRC_SP_TIMER=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# i.MX SoC drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_SOC_ZTE is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_SP_INTC is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_PMU=y
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# FSI support
+#
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+CONFIG_HAVE_ARM_SMCCC=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+CONFIG_DEBUG_SP_UART=y
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_DEBUG_UART_PHYS=0x9c000900
+CONFIG_DEBUG_UART_VIRT=0xf8000900
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+CONFIG_EARLY_PRINTK=y
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+# CONFIG_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+# CONFIG_DMA_NOOP_OPS is not set
+# CONFIG_DMA_VIRT_OPS is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+# CONFIG_SG_SPLIT is not set
+# CONFIG_SG_POOL is not set
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_VIRTUALIZATION is not set
--- a/arch/arm/configs/pentagram_8388_bchip_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/configs/pentagram_8388_bchip_defconfig	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,1311 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.12.14 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="armv5-glibc-linux-"
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_FHANDLE is not set
+CONFIG_USELIB=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rootfs/initramfs/disk/ ../rootfs/initramfs/disk/dev/initramfs.devnodes"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=""
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_MEMBARRIER=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS=8
+# CONFIG_HAVE_ARCH_HASH is not set
+# CONFIG_ISA_BUS_API is not set
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+# CONFIG_CPU_NO_EFFICIENT_FFS is not set
+# CONFIG_HAVE_ARCH_VMAP_STACK is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT is not set
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+# CONFIG_BLOCK is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+CONFIG_ARCH_PENTAGRAM=y
+# CONFIG_MACH_PENTAGRAM_8388_ACHIP is not set
+CONFIG_MACH_PENTAGRAM_8388_BCHIP=y
+# CONFIG_MACH_PENTAGRAM_I136_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_I137_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_3502_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_BCHIP is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_NEED_KUSER_HELPERS=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_DEBUG_ALIGN_RODATA=y
+CONFIG_MULTI_IRQ_HANDLER=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+
+#
+# DesignWare PCI Core Support
+#
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0x98307000
+CONFIG_ZBOOT_ROM_BSS=0x03400000
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="root=/dev/ram rw init=/init console=ttyS0,115200 earlyprintk mem=256M@0x0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# CONFIG_NET is not set
+CONFIG_HAVE_CBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_ARM_CCN is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_AFU_DRIVER_OPS is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_SCSI_DMA is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+CONFIG_SERIAL_SP_UART=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# CONFIG_DRM_LIB_RANDOM is not set
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+
+#
+# SPI RTC drivers
+#
+
+#
+# SPI and I2C RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_SUNPLUS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV_TSCPAGE is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_NXP is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_PIC32 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+CONFIG_CLKSRC_SP_TIMER=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# i.MX SoC drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_SOC_ZTE is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+CONFIG_PWM_SC7021=y
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC_MAX_NR=1
+CONFIG_SP_INTC=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_PMU=y
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# FSI support
+#
+# CONFIG_FSI is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+
+#
+# File systems
+#
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+CONFIG_DEBUG_SP_UART=y
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_DEBUG_UART_PHYS=0x9c000900
+CONFIG_DEBUG_UART_VIRT=0xf8000900
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+CONFIG_EARLY_PRINTK=y
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+# CONFIG_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+# CONFIG_DMA_NOOP_OPS is not set
+# CONFIG_DMA_VIRT_OPS is not set
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+# CONFIG_SG_SPLIT is not set
+# CONFIG_SG_POOL is not set
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_VIRTUALIZATION is not set
--- a/arch/arm/configs/pentagram_i136_achip_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/configs/pentagram_i136_achip_defconfig	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,1350 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.12.14 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="armv7hf-glibc-linux-"
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_FHANDLE is not set
+CONFIG_USELIB=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rootfs/initramfs/disk/ ../rootfs/initramfs/disk/dev/initramfs.devnodes"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=""
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_MEMBARRIER=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS=8
+# CONFIG_HAVE_ARCH_HASH is not set
+# CONFIG_ISA_BUS_API is not set
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+# CONFIG_CPU_NO_EFFICIENT_FFS is not set
+# CONFIG_HAVE_ARCH_VMAP_STACK is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+# CONFIG_BLOCK is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+CONFIG_ARCH_PENTAGRAM=y
+# CONFIG_MACH_PENTAGRAM_8388_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_8388_BCHIP is not set
+CONFIG_MACH_PENTAGRAM_I136_ACHIP=y
+# CONFIG_MACH_PENTAGRAM_I137_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_3502_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_BCHIP is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+CONFIG_SWP_EMULATE=y
+CONFIG_CPU_ICACHE_DISABLE=y
+CONFIG_CPU_DCACHE_DISABLE=y
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+# CONFIG_VDSO is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+
+#
+# DesignWare PCI Core Support
+#
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+# CONFIG_SMP is not set
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_ARM_PSCI is not set
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_THUMB2_KERNEL=y
+CONFIG_THUMB2_AVOID_R_ARM_THM_JUMP11=y
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_AEABI=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0x98307000
+CONFIG_ZBOOT_ROM_BSS=0x03400000
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="root=/dev/ram rw init=/init console=ttyS0,115200 earlyprintk mem=256M@0x0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+# CONFIG_KERNEL_MODE_NEON is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# CONFIG_NET is not set
+CONFIG_HAVE_CBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_ARM_CCI400_PMU is not set
+# CONFIG_ARM_CCI5xx_PMU is not set
+# CONFIG_ARM_CCN is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_AFU_DRIVER_OPS is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_SCSI_DMA is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+CONFIG_SERIAL_SP_UART=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# CONFIG_DRM_LIB_RANDOM is not set
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+
+#
+# SPI RTC drivers
+#
+
+#
+# SPI and I2C RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_SUNPLUS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV_TSCPAGE is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_NXP is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_PIC32 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+CONFIG_CLKSRC_SP_TIMER=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# i.MX SoC drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_SOC_ZTE is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+CONFIG_SP_INTC=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_PMU=y
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# FSI support
+#
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+CONFIG_HAVE_ARM_SMCCC=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+CONFIG_DEBUG_SP_UART=y
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_DEBUG_UART_PHYS=0x9c000900
+CONFIG_DEBUG_UART_VIRT=0xf8000900
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+CONFIG_EARLY_PRINTK=y
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+# CONFIG_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+# CONFIG_DMA_NOOP_OPS is not set
+# CONFIG_DMA_VIRT_OPS is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+# CONFIG_SG_SPLIT is not set
+# CONFIG_SG_POOL is not set
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_VIRTUALIZATION is not set
--- a/arch/arm/configs/pentagram_i137_bchip_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/configs/pentagram_i137_bchip_defconfig	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,1309 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.12.14 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="armv5-glibc-linux-"
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_FHANDLE is not set
+CONFIG_USELIB=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rootfs/initramfs/disk/ ../rootfs/initramfs/disk/dev/initramfs.devnodes"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=""
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_MEMBARRIER=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS=8
+# CONFIG_HAVE_ARCH_HASH is not set
+# CONFIG_ISA_BUS_API is not set
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+# CONFIG_CPU_NO_EFFICIENT_FFS is not set
+# CONFIG_HAVE_ARCH_VMAP_STACK is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT is not set
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+# CONFIG_BLOCK is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+CONFIG_ARCH_PENTAGRAM=y
+# CONFIG_MACH_PENTAGRAM_8388_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_8388_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_I136_ACHIP is not set
+CONFIG_MACH_PENTAGRAM_I137_BCHIP=y
+# CONFIG_MACH_PENTAGRAM_3502_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_BCHIP is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_NEED_KUSER_HELPERS=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_DEBUG_ALIGN_RODATA=y
+CONFIG_MULTI_IRQ_HANDLER=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+
+#
+# DesignWare PCI Core Support
+#
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0x98307000
+CONFIG_ZBOOT_ROM_BSS=0x03400000
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="root=/dev/ram rw init=/init console=ttyS0,115200 earlyprintk mem=256M@0x0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# CONFIG_NET is not set
+CONFIG_HAVE_CBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_ARM_CCN is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_AFU_DRIVER_OPS is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_SCSI_DMA is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+CONFIG_SERIAL_SP_UART=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# CONFIG_DRM_LIB_RANDOM is not set
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+
+#
+# SPI RTC drivers
+#
+
+#
+# SPI and I2C RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_SUNPLUS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV_TSCPAGE is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_NXP is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_PIC32 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+CONFIG_CLKSRC_SP_TIMER=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# i.MX SoC drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_SOC_ZTE is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC_MAX_NR=1
+CONFIG_SP_INTC=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_PMU=y
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# FSI support
+#
+# CONFIG_FSI is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+
+#
+# File systems
+#
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+CONFIG_DEBUG_SP_UART=y
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_DEBUG_UART_PHYS=0x9c000900
+CONFIG_DEBUG_UART_VIRT=0xf8000900
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+CONFIG_EARLY_PRINTK=y
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+# CONFIG_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+# CONFIG_DMA_NOOP_OPS is not set
+# CONFIG_DMA_VIRT_OPS is not set
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+# CONFIG_SG_SPLIT is not set
+# CONFIG_SG_POOL is not set
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_VIRTUALIZATION is not set
--- a/arch/arm/configs/pentagram_sc7021_achip_emu_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/configs/pentagram_sc7021_achip_emu_defconfig	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,1932 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.12.14 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="armv7hf-glibc-linux-"
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_FHANDLE is not set
+CONFIG_USELIB=y
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rootfs/initramfs/disk/ ../rootfs/initramfs/disk/dev/initramfs.devnodes"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=""
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_MEMBARRIER=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS=8
+# CONFIG_HAVE_ARCH_HASH is not set
+# CONFIG_ISA_BUS_API is not set
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+# CONFIG_CPU_NO_EFFICIENT_FFS is not set
+# CONFIG_HAVE_ARCH_VMAP_STACK is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+# CONFIG_BLOCK is not set
+CONFIG_BLOCK=y
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+CONFIG_ARCH_PENTAGRAM=y
+# CONFIG_MACH_PENTAGRAM_8388_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_8388_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_I136_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_I137_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_3502_ACHIP is not set
+CONFIG_MACH_PENTAGRAM_SC7021_ACHIP=y
+# CONFIG_MACH_PENTAGRAM_SC7021_BCHIP is not set
+
+#
+# Pentagram options
+#
+# CONFIG_SP_MON is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+# CONFIG_VDSO is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+CONFIG_ARM_ERRATA_643719=y
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+
+#
+# DesignWare PCI Core Support
+#
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+# CONFIG_MCPM is not set
+# CONFIG_BIG_LITTLE is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_THUMB2_KERNEL=y
+CONFIG_THUMB2_AVOID_R_ARM_THM_JUMP11=y
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_AEABI=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0x98307000
+CONFIG_ZBOOT_ROM_BSS=0x03400000
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="root=/dev/ram rw init=/init console=ttyS0,115200 earlyprintk mem=512M@0x0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+# CONFIG_KERNEL_MODE_NEON is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+#CONFIG_SUSPEND=y
+#CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+#CONFIG_PM_SLEEP=y
+#CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+#CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+#CONFIG_CPU_PM=y
+#CONFIG_ARCH_SUSPEND_POSSIBLE=y
+#CONFIG_ARM_CPU_SUSPEND=y
+#CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=m
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_IP_MROUTE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_FOU is not set
+# CONFIG_IPV6_FOU_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_BRIDGE_VLAN_FILTERING is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=m
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_VXCAN is not set
+# CONFIG_CAN_SLCAN is not set
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+# CONFIG_CAN_LEDS is not set
+# CONFIG_CAN_FLEXCAN is not set
+# CONFIG_CAN_GRCAN is not set
+# CONFIG_CAN_TI_HECC is not set
+CONFIG_CAN_XILINXCAN=y
+# CONFIG_CAN_C_CAN is not set
+# CONFIG_CAN_CC770 is not set
+# CONFIG_CAN_IFI_CANFD is not set
+# CONFIG_CAN_M_CAN is not set
+# CONFIG_CAN_PEAK_PCIEFD is not set
+# CONFIG_CAN_RCAR is not set
+# CONFIG_CAN_RCAR_CANFD is not set
+# CONFIG_CAN_SJA1000 is not set
+# CONFIG_CAN_SOFTING is not set
+
+#
+# CAN SPI interfaces
+#
+# CONFIG_CAN_HI311X is not set
+# CONFIG_CAN_MCP251X is not set
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_ESD_USB2 is not set
+# CONFIG_CAN_GS_USB is not set
+# CONFIG_CAN_KVASER_USB is not set
+# CONFIG_CAN_PEAK_USB is not set
+# CONFIG_CAN_8DEV_USB is not set
+# CONFIG_CAN_MCBA_USB is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+# CONFIG_STREAM_PARSER is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+CONFIG_CAIF=y
+# CONFIG_CAIF_DEBUG is not set
+CONFIG_CAIF_NETDEV=y
+# CONFIG_CAIF_USB is not set
+CONFIG_CEPH_LIB=y
+# CONFIG_CEPH_LIB_PRETTYDEBUG is not set
+CONFIG_CEPH_LIB_USE_DNS_RESOLVER=y
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+# CONFIG_NET_DEVLINK is not set
+CONFIG_MAY_USE_DEVLINK=y
+CONFIG_HAVE_CBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_ARM_CCI400_PMU is not set
+# CONFIG_ARM_CCI5xx_PMU is not set
+# CONFIG_ARM_CCN is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+CONFIG_BLK_DEV=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+
+#
+# Misc devices
+#
+# CONFIG_SP_IPC is not set
+# CONFIG_SP_ICM is not set
+# CONFIG_SP_DMA0 is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_AFU_DRIVER_OPS is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_ALTERA_TSE is not set
+CONFIG_NET_VENDOR_AMAZON=y
+CONFIG_NET_VENDOR_AQUANTIA=y
+CONFIG_NET_VENDOR_ARC=y
+# CONFIG_NET_VENDOR_AURORA is not set
+CONFIG_NET_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BCMGENET is not set
+# CONFIG_SYSTEMPORT is not set
+CONFIG_NET_VENDOR_CIRRUS=y
+# CONFIG_CS89x0 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_EZCHIP=y
+# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+# CONFIG_HISI_FEMAC is not set
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+# CONFIG_MVNETA_BM is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_NETRONOME=y
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_QUALCOMM=y
+# CONFIG_QCOM_EMAC is not set
+CONFIG_NET_VENDOR_RENESAS=y
+CONFIG_NET_VENDOR_ROCKER=y
+CONFIG_NET_VENDOR_SAMSUNG=y
+# CONFIG_SXGBE_ETH is not set
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SOLARFLARE=y
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_NET_VENDOR_SYNOPSYS=y
+# CONFIG_DWC_XLGMAC is not set
+CONFIG_L2SW_DRIVER = y
+# CONFIG_MDIO_DEVICE is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_WIRELESS_WDS is not set
+CONFIG_WLAN_VENDOR_ADMTEK=y
+CONFIG_WLAN_VENDOR_ATH=y
+# CONFIG_ATH_DEBUG is not set
+CONFIG_WLAN_VENDOR_ATMEL=y
+CONFIG_WLAN_VENDOR_BROADCOM=y
+CONFIG_WLAN_VENDOR_CISCO=y
+CONFIG_WLAN_VENDOR_INTEL=y
+CONFIG_WLAN_VENDOR_INTERSIL=y
+# CONFIG_HOSTAP is not set
+CONFIG_WLAN_VENDOR_MARVELL=y
+CONFIG_WLAN_VENDOR_MEDIATEK=y
+CONFIG_WLAN_VENDOR_RALINK=y
+CONFIG_WLAN_VENDOR_REALTEK=y
+CONFIG_WLAN_VENDOR_RSI=y
+CONFIG_WLAN_VENDOR_ST=y
+CONFIG_WLAN_VENDOR_TI=y
+CONFIG_WLAN_VENDOR_ZYDAS=y
+CONFIG_L2SW_DRIVER=y
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+CONFIG_SERIAL_SP_UART=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# CONFIG_DRM_LIB_RANDOM is not set
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+CONFIG_USB_HID=y
+#CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+#CONFIG_HID_GENERIC=y
+CONFIG_HIDRAW=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+
+# USB Support
+CONFIG_GEMINI_USB=y
+CONFIG_USB_USE_PLATFORM_RESOURCE=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_ZERO=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_SUNPLUS=y
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_PORT0_ENABLED=y
+CONFIG_SUNPLUS_USB_PHY=y
+CONFIG_USB_OTG=y
+CONFIG_USB_SUNPLUS_OTG=y
+CONFIG_USB_BC=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_SND_USB_AUDIO=m
+CONFIG_USB_LOGO_TEST=y
+CONFIG_USB_HOST_RESET_SP=y
+CONFIG_USB_HOST_ENUM_RETRY=y
+CONFIG_USB_OHCI_MSI_WORKAROUND=y
+CONFIG_USB_MULTIPLE_RESET_PROBLEM_WORKAROUND=y
+CONFIG_USB_PHY_RX_ACTIVE_QUESTION_WORKAROUND=n
+CONFIG_USB_DEVICE_EP11_NOT_AUTO_SWITCH_WORKAROUND=y
+CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND=y
+CONFIG_USB_DEVICE_LOSE_PACKET_AFTER_SET_INTERFACE_WORKAROUND=y
+
+CONFIG_MMC=y
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_SP_SDV2=y
+CONFIG_SP_EMMC=y
+
+# CONFIG_UWB is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+
+#
+# SPI RTC drivers
+#
+
+#
+# SPI and I2C RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+CONFIG_RTC_DRV_SUNPLUS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV_TSCPAGE is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_NXP is not set
+# CONFIG_COMMON_CLK_PWM is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_PIC32 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+CONFIG_CLKSRC_SP_TIMER=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# i.MX SoC drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_SOC_ZTE is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+# CONFIG_PWM_FSL_FTM is not set
+CONFIG_PWM_SC7021=y
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+CONFIG_SP_INTC=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_PMU=y
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# FSI support
+#
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+CONFIG_HAVE_ARM_SMCCC=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_NLS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="utf8"
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DELAYED_SYNC=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+CONFIG_DEBUG_SP_UART=y
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_DEBUG_UART_PHYS=0x9c000900
+CONFIG_DEBUG_UART_VIRT=0xf8000900
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+CONFIG_EARLY_PRINTK=y
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=m
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+CONFIG_CRYPTO_MANAGER=m
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+CONFIG_CRYPTO_ECHAINIV=m
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+CONFIG_CRYPTO_SHA256=m
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=m
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+CONFIG_CRYPTO_DRBG=m
+CONFIG_CRYPTO_JITTERENTROPY=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_SP is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API_DESC is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+# CONFIG_DMA_NOOP_OPS is not set
+# CONFIG_DMA_VIRT_OPS is not set
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+# CONFIG_SG_SPLIT is not set
+# CONFIG_SG_POOL is not set
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_VIRTUALIZATION is not set
--- a/arch/arm/configs/pentagram_sc7021_bchip_emu_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/configs/pentagram_sc7021_bchip_emu_defconfig	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,1981 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.12.14 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="armv5-glibc-linux-"
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_FHANDLE is not set
+CONFIG_USELIB=y
+# CONFIG_AUDIT is not set
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rootfs/initramfs/disk/ ../rootfs/initramfs/disk/dev/initramfs.devnodes"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=""
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_MEMBARRIER=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS=8
+# CONFIG_HAVE_ARCH_HASH is not set
+# CONFIG_ISA_BUS_API is not set
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+# CONFIG_CPU_NO_EFFICIENT_FFS is not set
+# CONFIG_HAVE_ARCH_VMAP_STACK is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT is not set
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+CONFIG_ARCH_PENTAGRAM=y
+# CONFIG_MACH_PENTAGRAM_8388_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_8388_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_I136_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_I137_BCHIP is not set
+# CONFIG_MACH_PENTAGRAM_3502_ACHIP is not set
+# CONFIG_MACH_PENTAGRAM_SC7021_ACHIP is not set
+CONFIG_MACH_PENTAGRAM_SC7021_BCHIP=y
+
+#
+# Pentagram options
+#
+# CONFIG_SP_MON is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_NEED_KUSER_HELPERS=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_DEBUG_ALIGN_RODATA=y
+CONFIG_MULTI_IRQ_HANDLER=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+
+#
+# DesignWare PCI Core Support
+#
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0x98307000
+CONFIG_ZBOOT_ROM_BSS=0x03400000
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="root=/dev/ram rw init=/init console=ttyS0,115200 earlyprintk mem=512M@0x0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+#CONFIG_SUSPEND=y
+#CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+# CONFIG_HIBERNATION is not set
+#CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+#CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+#CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+#CONFIG_CPU_PM=y
+#CONFIG_ARCH_SUSPEND_POSSIBLE=y
+#CONFIG_ARM_CPU_SUSPEND=y
+#CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=m
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_IP_MROUTE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_FOU is not set
+# CONFIG_IPV6_FOU_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_BRIDGE_VLAN_FILTERING is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=m
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+CONFIG_NETLINK_DIAG=y
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_VXCAN is not set
+# CONFIG_CAN_SLCAN is not set
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+# CONFIG_CAN_LEDS is not set
+# CONFIG_CAN_FLEXCAN is not set
+# CONFIG_CAN_GRCAN is not set
+# CONFIG_CAN_TI_HECC is not set
+CONFIG_CAN_XILINXCAN=y
+# CONFIG_CAN_C_CAN is not set
+# CONFIG_CAN_CC770 is not set
+# CONFIG_CAN_IFI_CANFD is not set
+# CONFIG_CAN_M_CAN is not set
+# CONFIG_CAN_PEAK_PCIEFD is not set
+# CONFIG_CAN_RCAR is not set
+# CONFIG_CAN_RCAR_CANFD is not set
+# CONFIG_CAN_SJA1000 is not set
+# CONFIG_CAN_SOFTING is not set
+
+#
+# CAN SPI interfaces
+#
+# CONFIG_CAN_HI311X is not set
+# CONFIG_CAN_MCP251X is not set
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_ESD_USB2 is not set
+# CONFIG_CAN_GS_USB is not set
+# CONFIG_CAN_KVASER_USB is not set
+# CONFIG_CAN_PEAK_USB is not set
+# CONFIG_CAN_8DEV_USB is not set
+# CONFIG_CAN_MCBA_USB is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+# CONFIG_STREAM_PARSER is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+CONFIG_CAIF=y
+# CONFIG_CAIF_DEBUG is not set
+CONFIG_CAIF_NETDEV=y
+# CONFIG_CAIF_USB is not set
+CONFIG_CEPH_LIB=y
+# CONFIG_CEPH_LIB_PRETTYDEBUG is not set
+CONFIG_CEPH_LIB_USE_DNS_RESOLVER=y
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+# CONFIG_NET_DEVLINK is not set
+CONFIG_MAY_USE_DEVLINK=y
+CONFIG_HAVE_CBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+
+#
+# Bus devices
+#
+# CONFIG_ARM_CCN is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_NVME_FC is not set
+
+#
+# Misc devices
+#
+# CONFIG_SP_IPC is not set
+# CONFIG_SP_ICM is not set
+# CONFIG_SP_DMA0 is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_AFU_DRIVER_OPS is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_ALTERA_TSE is not set
+CONFIG_NET_VENDOR_AMAZON=y
+CONFIG_NET_VENDOR_AQUANTIA=y
+CONFIG_NET_VENDOR_ARC=y
+# CONFIG_NET_VENDOR_AURORA is not set
+CONFIG_NET_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BCMGENET is not set
+# CONFIG_SYSTEMPORT is not set
+CONFIG_NET_VENDOR_CIRRUS=y
+# CONFIG_CS89x0 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_EZCHIP=y
+# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+# CONFIG_HISI_FEMAC is not set
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+# CONFIG_MVNETA_BM is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_NETRONOME=y
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_QUALCOMM=y
+# CONFIG_QCOM_EMAC is not set
+CONFIG_NET_VENDOR_RENESAS=y
+CONFIG_NET_VENDOR_ROCKER=y
+CONFIG_NET_VENDOR_SAMSUNG=y
+# CONFIG_SXGBE_ETH is not set
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SOLARFLARE=y
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_NET_VENDOR_SYNOPSYS=y
+# CONFIG_DWC_XLGMAC is not set
+CONFIG_L2SW_DRIVER = y
+# CONFIG_MDIO_DEVICE is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_WIRELESS_WDS is not set
+CONFIG_WLAN_VENDOR_ADMTEK=y
+CONFIG_WLAN_VENDOR_ATH=y
+# CONFIG_ATH_DEBUG is not set
+CONFIG_WLAN_VENDOR_ATMEL=y
+CONFIG_WLAN_VENDOR_BROADCOM=y
+CONFIG_WLAN_VENDOR_CISCO=y
+CONFIG_WLAN_VENDOR_INTEL=y
+CONFIG_WLAN_VENDOR_INTERSIL=y
+# CONFIG_HOSTAP is not set
+CONFIG_WLAN_VENDOR_MARVELL=y
+CONFIG_WLAN_VENDOR_MEDIATEK=y
+CONFIG_WLAN_VENDOR_RALINK=y
+CONFIG_WLAN_VENDOR_REALTEK=y
+CONFIG_WLAN_VENDOR_RSI=y
+CONFIG_WLAN_VENDOR_ST=y
+CONFIG_WLAN_VENDOR_TI=y
+CONFIG_WLAN_VENDOR_ZYDAS=y
+CONFIG_L2SW_DRIVER=y
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+CONFIG_SERIAL_SP_UART=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+CONFIG_SP_I2C=y
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# CONFIG_DRM_LIB_RANDOM is not set
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+CONFIG_USB_HID=y
+#CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+#CONFIG_HID_GENERIC=y
+CONFIG_HIDRAW=y
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+
+# USB Support
+CONFIG_GEMINI_USB=y
+CONFIG_USB_USE_PLATFORM_RESOURCE=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_ZERO=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_SUNPLUS=y
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_PORT0_ENABLED=y
+CONFIG_SUNPLUS_USB_PHY=y
+CONFIG_USB_OTG=y
+CONFIG_USB_SUNPLUS_OTG=y
+CONFIG_USB_BC=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_SND_USB_AUDIO=m
+CONFIG_USB_LOGO_TEST=y
+CONFIG_USB_HOST_RESET_SP=y
+CONFIG_USB_HOST_ENUM_RETRY=y
+CONFIG_USB_OHCI_MSI_WORKAROUND=y
+CONFIG_USB_MULTIPLE_RESET_PROBLEM_WORKAROUND=y
+CONFIG_USB_PHY_RX_ACTIVE_QUESTION_WORKAROUND=n
+CONFIG_USB_DEVICE_EP11_NOT_AUTO_SWITCH_WORKAROUND=y
+CONFIG_USB_HOST_NOT_FINISH_QTD_WHEN_DISC_WORKAROUND=y
+CONFIG_USB_DEVICE_LOSE_PACKET_AFTER_SET_INTERFACE_WORKAROUND=y
+
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_SP_SDV2=y
+CONFIG_SP_EMMC=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+
+#
+# SPI RTC drivers
+#
+
+#
+# SPI and I2C RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+CONFIG_RTC_DRV_SUNPLUS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV_TSCPAGE is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_NXP is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_PIC32 is not set
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+CONFIG_CLKSRC_SP_TIMER=y
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# i.MX SoC drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_SOC_ZTE is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC_MAX_NR=1
+CONFIG_SP_INTC=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_PMU=y
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# FSI support
+#
+# CONFIG_FSI is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="utf8"
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DELAYED_SYNC=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+CONFIG_DEBUG_SP_UART=y
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_DEBUG_UART_PHYS=0x9c000900
+CONFIG_DEBUG_UART_VIRT=0xf8000900
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+CONFIG_EARLY_PRINTK=y
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=m
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+CONFIG_CRYPTO_MANAGER=m
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_NULL2=y
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+CONFIG_CRYPTO_ECHAINIV=m
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+CONFIG_CRYPTO_SHA256=m
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=m
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+CONFIG_CRYPTO_DRBG=m
+CONFIG_CRYPTO_JITTERENTROPY=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_SP is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API_DESC is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+# CONFIG_DMA_NOOP_OPS is not set
+# CONFIG_DMA_VIRT_OPS is not set
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+# CONFIG_SG_SPLIT is not set
+# CONFIG_SG_POOL is not set
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+CONFIG_SBITMAP=y
+# CONFIG_VIRTUALIZATION is not set
--- a/arch/arm/Kconfig	2018-11-23 10:16:13.319975865 +0300
+++ a/arch/arm/Kconfig	2018-11-23 10:31:03.763053072 +0300
@@ -639,8 +639,23 @@
 	help
 	  Support for older TI OMAP1 (omap7xx, omap15xx or omap16xx)
 
+config ARCH_PENTAGRAM
+	bool "Sunplus Pentagram architectures"
+	select CLKSRC_OF
+	select COMMON_CLK
+	select GENERIC_CLOCKEVENTS
+	select GENERIC_IRQ_CHIP
+	select MULTI_IRQ_HANDLER
+	select SERIAL_CORE
+	select SERIAL_CORE_CONSOLE
+	select SERIAL_SP_UART
+	select USE_OF
+	select RTC_CLASS
+
 endchoice
 
+source "arch/arm/mach-pentagram/Kconfig"
+
 menu "Multiple platform selection"
 	depends on ARCH_MULTIPLATFORM
 
--- a/arch/arm/Kconfig.debug	2018-11-23 10:16:13.320975805 +0300
+++ a/arch/arm/Kconfig.debug	2018-11-23 10:31:03.764053012 +0300
@@ -1313,6 +1313,11 @@
 		  options; the platform specific options are deprecated
 		  and will be soon removed.
 
+	config DEBUG_SP_UART
+		bool "Kernel low-level debugging messages via Sunplus UART"
+		help
+		  Say Y here if you want kernel low-level debugging support
+		  on Sunplus based platforms on the UART.
 endchoice
 
 config DEBUG_AT91_UART
@@ -1503,6 +1508,7 @@
 	default 0x80230000 if DEBUG_PICOXCELL_UART
 	default 0x808c0000 if DEBUG_EP93XX || ARCH_EP93XX
 	default 0x90020000 if DEBUG_NSPIRE_CLASSIC_UART || DEBUG_NSPIRE_CX_UART
+	default 0x9c000900 if DEBUG_SP_UART
 	default 0xb0060000 if DEBUG_SIRFPRIMA2_UART1
 	default 0xb0090000 if DEBUG_VEXPRESS_UART0_CRX
 	default 0xc0013000 if DEBUG_U300_UART
@@ -1559,6 +1565,7 @@
 		DEBUG_S3C64XX_UART || \
 		DEBUG_BCM63XX_UART || DEBUG_ASM9260_UART || \
 		DEBUG_SIRFSOC_UART || DEBUG_DIGICOLOR_UA0 || \
+		DEBUG_SP_UART || \
 		DEBUG_AT91_UART
 
 config DEBUG_UART_VIRT
@@ -1595,6 +1602,7 @@
 				DEBUG_S3C2410_UART2)
 	default 0xf7020000 if DEBUG_AT91_SAMA5D2_UART1
 	default 0xf7fc9000 if DEBUG_BERLIN_UART
+	default 0xf8000900 if DEBUG_SP_UART
 	default 0xf8007000 if DEBUG_HIP04_UART
 	default 0xf8009000 if DEBUG_VEXPRESS_UART0_CA9
 	default 0xf8090000 if DEBUG_VEXPRESS_UART0_RS1
@@ -1658,6 +1666,7 @@
 		DEBUG_S3C64XX_UART || \
 		DEBUG_BCM63XX_UART || DEBUG_ASM9260_UART || \
 		DEBUG_SIRFSOC_UART || DEBUG_DIGICOLOR_UA0 || \
+		DEBUG_SP_UART || \
 		DEBUG_AT91_UART
 
 config DEBUG_UART_8250_SHIFT
--- a/arch/arm/kernel/Makefile	2018-11-23 10:16:13.399971113 +0300
+++ a/arch/arm/kernel/Makefile	2018-11-23 10:31:03.765052953 +0300
@@ -13,6 +13,8 @@
 
 CFLAGS_REMOVE_return_address.o = -pg
 
+CFLAGS_devtree.o := -DDEBUG
+
 # Object file lists.
 
 obj-y		:= elf.o entry-common.o irq.o opcodes.o \
--- a/arch/arm/mach-pentagram/8388.c	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/8388.c	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,173 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/memblock.h>
+#include <asm/memory.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <mach/io_map.h>
+#include <mach/misc.h>
+
+#define SYSTEM_BASE		VA_IO_ADDR(0 * 32 * 4)
+
+#ifdef CONFIG_CACHE_L2X0
+
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/cacheflush.h>
+
+static int __init sp_l2_cache_init(void)
+{
+	u32 aux_ctrl = 0;
+	u32 value;
+	void __iomem *l2cache_base;
+
+	//early_printk("%s\n", __func__);
+
+	/* avoid data corruption during l2c init */
+	flush_cache_all();
+
+	/* Static mapping, never released */
+	l2cache_base = (void __iomem *)ioremap(PA_L2CC_REG, 0x1000);
+	if (WARN_ON(!l2cache_base))
+		return -ENOMEM;
+
+	value = *(volatile u32 *)(l2cache_base + 0x0104); /* reg1_aux_control */
+	value |=  (1 << 30);    /* Early BRESP */
+	value &= ~(1 << 25);    /* pseudo random */
+	value |=  (1 <<  0);    /* Enable full line of zero */
+	*(volatile u32 *)(l2cache_base + 0x0104) = value;
+	aux_ctrl = value;
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 1" : "=r"(value)); /* aux control register */
+	value |= (1 << 2);      /* enable L1 prefetch */
+	value |= (1 << 1);      /* enable L2 prefetch hint */
+	asm volatile("mcr p15, 0, %0, c1, c0, 1" : : "r"(value));
+
+	value = *(volatile u32 *)(l2cache_base + 0x0F60); /* reg15_prefetch_ctrl */
+	value |=  (1 << 30);    /* Double linefill */
+	value |=  (1 << 29);    /* Instruction prefetch enable */
+	value |=  (1 << 28);    /* Data prefetch enable */
+	value |=  (1 << 27);    /* Double linefill on WRAP read disable */
+	value |=  (1 << 23);    /* Incr double linefill enable */
+	value |=  (1 << 24);    /* Prefetch drop enable */
+	value &= ~(0x1F << 0);  /* Prefetch offset */
+	value |=  (7 << 0);     /* Prefetch offset */
+	*(volatile u32 *)(l2cache_base + 0x0F60) = value;
+
+	value = *(volatile u32 *)(l2cache_base + 0x0F80); /* reg15_power_ctrl */
+	value |= (1 << 1);      /* dynamic_clk_gating_en */
+	value |= (1 << 0);      /* standby_mode_en */
+	*(volatile u32 *)(l2cache_base + 0x0F80) = value;
+
+	*(volatile u32 *)(l2cache_base + 0x0108) = 0;       /* reg1_tag_ram_control, recommanded by HW designer */
+	*(volatile u32 *)(l2cache_base + 0x010C) = 0x0111;  /* reg1_data_ram_control, recommanded by HW designer */
+
+	l2x0_init(l2cache_base, aux_ctrl, 0xFFFFFFFF);
+
+	/*
+	 * According to L2C-310 TRM r3p3 page 2-37~38,
+	 * CA9 "Full line of zero" should be enabled after L2C enable.
+	 */
+	asm volatile("mrc p15, 0, %0, c1, c0, 1" : "=r"(value)); /* aux control register */
+	value |= (1 << 3); /* enable write full line of zero */
+	asm volatile("mcr p15, 0, %0, c1, c0, 1" : : "r"(value));
+
+	return 0;
+}
+early_initcall(sp_l2_cache_init);
+#endif
+
+static void __init sp_power_off(void)
+{
+	early_printk("%s\n", __func__);
+}
+
+static void __init sp_init(void)
+{
+	early_printk("%s\n", __func__);
+	pm_power_off = sp_power_off;
+
+	sp_prn_uptime();
+}
+
+static struct map_desc sp_io_desc[] __initdata = {
+	{	/* RGST Bus */
+		.virtual = VA_REG,
+		.pfn     = __phys_to_pfn(PA_REG),
+		.length  = SIZE_REG,
+		.type    = MT_DEVICE
+	},
+};
+
+static void __init sp_map_io(void)
+{
+	early_printk("%s\n", __func__);
+	iotable_init(sp_io_desc, ARRAY_SIZE( sp_io_desc));
+	early_printk("%s: done\n", __func__);
+}
+
+void __init sp_reserve(void)
+{
+	early_printk("%s\n", __func__);
+}
+
+static void __init sp_fixup(void)
+{
+	early_printk("%s\n", __func__);
+	memblock_add(PHYS_OFFSET, SZ_64M);
+}
+
+void sp_restart(enum reboot_mode mode, const char *cmd)
+{
+	void __iomem *regs = (void __iomem *)SYSTEM_BASE;
+
+	/* MOON1: enable watchdog reset */
+#ifdef CONFIG_MACH_PENTAGRAM_3502_ACHIP
+	writel(BIT(10) | BIT(1), regs + 0xA0); /* G1.8 */
+#else
+	writel(BIT(10) | BIT(1), regs + 0xA8); /* G1.10 */
+#endif
+
+	/* STC: watchdog control */
+	writel(0x3877, regs + 0x0630); /* stop */
+	writel(0xAB00, regs + 0x0630); /* unlock */
+	writel(0x0001, regs + 0x0634); /* counter */
+	writel(0x4A4B, regs + 0x0630); /* resume */
+}
+
+static char const *achip_compat[] __initconst = {
+	"sunplus,3502-achip",
+	"sunplus,8388-achip",
+	NULL
+};
+
+DT_MACHINE_START(8388_ACHIP_DT, "8388_ACHIP")
+	.dt_compat	= achip_compat,
+	.dt_fixup	= sp_fixup,
+	.reserve	= sp_reserve,
+	.map_io		= sp_map_io,
+	.init_machine	= sp_init,
+	.restart	= sp_restart,
+MACHINE_END
+
+#ifdef CONFIG_MACH_PENTAGRAM_8388_BCHIP
+static char const *bchip_compat[] __initconst = {
+	"sunplus,8388-bchip",
+	NULL
+};
+
+DT_MACHINE_START(8388_BCHIP_DT, "8388_BCHIP")
+	.dt_compat	= bchip_compat,
+	.dt_fixup	= sp_fixup,
+	.reserve	= sp_reserve,
+	.map_io		= sp_map_io,
+	.init_machine	= sp_init,
+	.restart	= sp_restart,
+MACHINE_END
+#endif
--- a/arch/arm/mach-pentagram/i137.c	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/i137.c	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,150 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/memory.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <mach/io_map.h>
+#include <mach/clk.h>
+
+static void __init sp_power_off(void)
+{
+	early_printk("%s\n", __func__);
+}
+
+static void __init sp_init(void)
+{
+	unsigned int b_sysclk, io_ctrl;
+#ifdef CONFIG_MACH_PENTAGRAM_I136_ACHIP
+	unsigned int coreclk, ioclk, sysclk, clk_cfg;
+#endif
+
+	early_printk("%s\n", __func__);
+	pm_power_off = sp_power_off;
+
+	io_ctrl = readl((void __iomem *)B_SYSTEM_BASE + 0x105030);
+	b_sysclk = CLK_B_PLLSYS >> ((readl((void __iomem *)B_SYSTEM_BASE + 0x14) >> 4) & 7);
+
+	early_printk("B: b_sysclk=%uM abio_ctrl=(%ubit, %s)\n", b_sysclk / 1000000,
+		(io_ctrl & 2) ? 16 : 8, (io_ctrl & 1) ? "DDR" : "SDR");
+
+#ifdef CONFIG_MACH_PENTAGRAM_I136_ACHIP
+	clk_cfg = readl((void __iomem *)A_SYSTEM_BASE + 0xc);
+	coreclk = CLK_A_PLLCLK / (1 + ((clk_cfg >> 10) & 1));
+	ioclk = CLK_A_PLLCLK / (20 + 5 * ((clk_cfg >> 4) & 7)) / ((clk_cfg >> 16) & 0xff) * 10;
+	sysclk = coreclk / (1 + ((clk_cfg >> 3) & 1));
+	early_printk("A: coreclk=%uM a_sysclk=%uM abio_bus=%uM\n",
+		coreclk / 1000000, sysclk / 1000000, ioclk / 1000000);
+
+#endif
+}
+
+static struct map_desc sp_io_desc[] __initdata = {
+	{	/* B RGST Bus */
+		.virtual = VA_B_REG,
+		.pfn     = __phys_to_pfn(PA_B_REG),
+		.length  = SIZE_B_REG,
+		.type    = MT_DEVICE
+	},
+	{
+		/* B SRAM0 */
+		.virtual = VA_B_SRAM0,
+		.pfn     = __phys_to_pfn(PA_B_SRAM0),
+		.length  = SIZE_B_SRAM0,
+		.type    = MT_DEVICE
+	},
+#ifdef CONFIG_MACH_PENTAGRAM_I136_ACHIP
+	{	/* A RGST Bus */
+		.virtual = VA_A_REG,
+		.pfn     = __phys_to_pfn(PA_A_REG),
+		.length  = SIZE_A_REG,
+		.type    = MT_DEVICE
+	},
+#endif
+};
+
+static void __init sp_map_io(void)
+{
+	early_printk("%s\n", __func__);
+
+	iotable_init(sp_io_desc, ARRAY_SIZE( sp_io_desc));
+
+	printk("B_REG %08x -> [%08x-%08x]\n", PA_B_REG, VA_B_REG, VA_B_REG + SIZE_B_REG);
+#ifdef CONFIG_MACH_PENTAGRAM_I136_ACHIP
+        printk("A_REG %08x -> [%08x-%08x]\n", PA_A_REG, VA_A_REG, VA_A_REG + SIZE_A_REG);
+#endif
+}
+
+static void __init sp_init_early(void)
+{
+#ifdef CONFIG_MACH_PENTAGRAM_I136_ACHIP
+	/* enable counter before timer_init */
+	writel(3, (void __iomem *)A_SYS_COUNTER_BASE); /* CNTCR: EN=1 HDBG=1 */
+	mb();
+#endif
+}
+
+void __init sp_reserve(void)
+{
+	early_printk("%s\n", __func__);
+	return;
+}
+
+static void __init sp_fixup(void)
+{
+	early_printk("%s\n", __func__);
+}
+
+void sp_restart(enum reboot_mode mode, const char *cmd)
+{
+	void __iomem *regs = (void __iomem *)B_SYSTEM_BASE;
+
+	/* MOON1: enable watchdog reset */
+	writel(BIT(10) | BIT(1), regs + 0xA8); /* G1.10 */
+
+	/* STC: watchdog control */
+	writel(0x3877, regs + 0x0630); /* stop */
+	writel(0xAB00, regs + 0x0630); /* unlock */
+	writel(0x0001, regs + 0x0634); /* counter */
+	writel(0x4A4B, regs + 0x0630); /* resume */
+}
+
+#ifdef CONFIG_MACH_PENTAGRAM_I137_BCHIP
+static char const *bchip_compat[] __initconst = {
+	"sunplus,i137-bchip",
+	NULL
+};
+
+DT_MACHINE_START(I137_BCHIP_DT, "I137_BCHIP")
+	.dt_compat	= bchip_compat,
+	.dt_fixup	= sp_fixup,
+	.reserve	= sp_reserve,
+	.map_io		= sp_map_io,
+	.init_early	= sp_init_early,
+	.init_machine	= sp_init,
+	.restart	= sp_restart,
+MACHINE_END
+#endif
+
+#ifdef CONFIG_MACH_PENTAGRAM_I136_ACHIP
+static char const *achip_compat[] __initconst = {
+	"sunplus,i136-achip",
+	NULL
+};
+
+DT_MACHINE_START(I136_ACHIP_DT, "I136_ACHIP")
+	.dt_compat	= achip_compat,
+	.dt_fixup	= sp_fixup,
+	.reserve	= sp_reserve,
+	.map_io		= sp_map_io,
+	.init_early	= sp_init_early,
+	.init_machine	= sp_init,
+	.restart	= sp_restart,
+MACHINE_END
+#endif
--- a/arch/arm/mach-pentagram/include/mach/clk.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/clk.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,13 @@
+#ifndef __MACH_CLK_H
+#define __MACH_CLK_H
+
+#if defined(CONFIG_MACH_PENTAGRAM_I136_ACHIP) || defined(CONFIG_MACH_PENTAGRAM_I137_BCHIP)
+#define CLK_A_PLLCLK            2000000000      /* 2GHz */
+#define CLK_B_PLLSYS            202500000       /* 202.5MHz */
+#endif
+
+#if defined(CONFIG_MACH_PENTAGRAM_SC7021_ACHIP) || defined(CONFIG_MACH_PENTAGRAM_SC7021_BCHIP)
+#define CLK_B_PLLSYS            202500000       /* 202.5MHz */
+#endif
+
+#endif /* __MACH_CLK_H */
--- a/arch/arm/mach-pentagram/include/mach/debug-macro.S	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/debug-macro.S	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,24 @@
+#include <mach/sp_uart.h>
+
+		.macro	addruart, rp, rv, tmp
+		ldr	\rp, =CONFIG_DEBUG_UART_PHYS @ physical
+		ldr	\rv, =CONFIG_DEBUG_UART_VIRT @ virtual
+		.endm
+
+		.macro	senduart, rd, rx
+		str	\rd, [\rx, #SP_UART_DATA]	@ TXDATA
+		.endm
+
+		/* waituart waits until there is space in the FIFO */
+		.macro	waituart, rd, rx
+1001:		ldr	\rd, [\rx, #SP_UART_LSR]
+		tst	\rd, #SP_UART_LSR_TX	@ 1: Transmit FIFO is not full
+		beq	1001b
+		.endm
+
+		/* busyuart waits until the FIFO is empty (all data is sent) 0: Transmit FIFO is not empty */
+		.macro	busyuart, rd, rx
+1002:		ldr	\rd, [\rx, #SP_UART_LSR]
+		tst	\rd, #SP_UART_LSR_TXE	@ 1: Transmit-ended, transmit FIFO is empty
+		beq	1002b	@ wait if FIFO is not empty
+		.endm
--- a/arch/arm/mach-pentagram/include/mach/io_map_8388.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/io_map_8388.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,16 @@
+#ifndef __IO_MAP_8388_H__
+#define __IO_MAP_8388_H__
+
+/* PA */
+#define	PA_REG			0x9C000000
+#define	SIZE_REG		SZ_32M
+#define PA_IO_ADDR(x)		((x) + PA_REG)
+#define PA_IOB_ADDR(x)		PA_IO_ADDR(x)
+#define PA_L2CC_REG		0x9f000000
+
+/* VA */
+#define VA_REG			0xF8000000
+#define VA_IO_ADDR(x)		((x) + VA_REG)
+#define VA_IOB_ADDR(x)		VA_IO_ADDR(x)
+
+#endif
--- a/arch/arm/mach-pentagram/include/mach/io_map.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/io_map.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,19 @@
+#ifndef __MACH_IO_MAP_H
+#define __MACH_IO_MAP_H
+
+#include <asm/sizes.h>
+
+#if defined(CONFIG_MACH_PENTAGRAM_8388_ACHIP) || defined(CONFIG_MACH_PENTAGRAM_8388_BCHIP) || \
+    defined(CONFIG_MACH_PENTAGRAM_3502_ACHIP)
+#include "io_map_8388.h"
+#endif
+
+#if defined(CONFIG_MACH_PENTAGRAM_I136_ACHIP) || defined(CONFIG_MACH_PENTAGRAM_I137_BCHIP)
+#include "io_map_i137.h"
+#endif
+
+#if defined(CONFIG_MACH_PENTAGRAM_SC7021_ACHIP) || defined(CONFIG_MACH_PENTAGRAM_SC7021_BCHIP)
+#include "io_map_sc7021.h"
+#endif
+
+#endif /* __MACH_IO_MAP_H */
--- a/arch/arm/mach-pentagram/include/mach/io_map_i137.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/io_map_i137.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,47 @@
+#ifndef __IO_MAP_I137_H__
+#define __IO_MAP_I137_H__
+
+/*****************
+ * PA (B)
+ *****************/
+#define	PA_B_REG		0x9C000000
+#define	SIZE_B_REG		SZ_32M
+#ifdef CONFIG_MACH_PENTAGRAM_I137_BCHIP
+#define PA_B_SRAM0		0x9E800000
+#else
+#define PA_B_SRAM0		0x9E000000	/* B_SRAM0 @ A_VIEW */
+#endif
+#define SIZE_B_SRAM0		(40 * SZ_1K)
+
+#define PA_IOB_ADDR(x)		((x) + PA_B_REG)
+
+/*****************
+ * PA (A)
+ *****************/
+#define	PA_A_REG		0x9EC00000
+#define	SIZE_A_REG		SZ_4M
+#define PA_A_WORKMEM_SRAM0_BASE	0x9E000000
+#define SIZE_A_WORKMEM_SRAM0	(SZ_512K)
+
+#define PA_IOA_ADDR(x)		((x) + PA_A_REG)
+
+
+/*****************
+ * VA chain
+ *****************/
+#define VA_B_REG		0xF8000000
+#define VA_A_REG		(VA_B_REG + SIZE_B_REG)
+#define VA_B_SRAM0		(VA_A_REG + SIZE_A_REG)
+#define VA_A_WORKMEM_SRAM0	(VA_B_SRAM0 + SIZE_B_SRAM0)
+
+#define VA_IOB_ADDR(x)		((x) + VA_B_REG)
+#define VA_IOA_ADDR(x)		((x) + VA_A_REG)
+
+/*****************
+ * Global VA
+ *****************/
+#define B_SYSTEM_BASE           VA_IOB_ADDR(0 * 32 * 4)
+#define A_SYSTEM_BASE           VA_IOA_ADDR(0 * 32 * 4)
+#define A_SYS_COUNTER_BASE      (A_SYSTEM_BASE + 0x28000) /* 9ec2_8000 */
+
+#endif
--- a/arch/arm/mach-pentagram/include/mach/io_map_sc7021.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/io_map_sc7021.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,43 @@
+#ifndef __IO_MAP_SC7021_H__
+#define __IO_MAP_SC7021_H__
+
+/*****************
+ * PA (B)
+ *****************/
+#define	PA_B_REG		0x9C000000
+#define	SIZE_B_REG		SZ_32M
+#define PA_B_SRAM0		0x9E800000
+#define SIZE_B_SRAM0		(40 * SZ_1K)
+
+#define PA_IOB_ADDR(x)		((x) + PA_B_REG)
+
+/*****************
+ * PA (A)
+ *****************/
+#define	PA_A_REG		0x9EC00000
+#define	SIZE_A_REG		SZ_4M
+#define PA_A_WORKMEM_SRAM0_BASE	0x9E000000
+#define SIZE_A_WORKMEM_SRAM0	(SZ_512K)
+
+#define PA_IOA_ADDR(x)		((x) + PA_A_REG)
+
+
+/*****************
+ * VA chain
+ *****************/
+#define VA_B_REG		0xF8000000
+#define VA_A_REG		(VA_B_REG + SIZE_B_REG)
+#define VA_B_SRAM0		(VA_A_REG + SIZE_A_REG)
+#define VA_A_WORKMEM_SRAM0	(VA_B_SRAM0 + SIZE_B_SRAM0)
+
+#define VA_IOB_ADDR(x)		((x) + VA_B_REG)
+#define VA_IOA_ADDR(x)		((x) + VA_A_REG)
+
+/*****************
+ * Global VA
+ *****************/
+#define B_SYSTEM_BASE           VA_IOB_ADDR(0 * 32 * 4)
+#define A_SYSTEM_BASE           VA_IOA_ADDR(0 * 32 * 4)
+#define A_SYS_COUNTER_BASE      (A_SYSTEM_BASE + 0x10a000) /* 9ed0_a000 */
+
+#endif
--- a/arch/arm/mach-pentagram/include/mach/irqs.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/irqs.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,6 @@
+#ifndef __MACH_IRQS_H
+#define __MACH_IRQS_H
+
+#define NR_IRQS 205
+
+#endif /* __MACH_IRQS_H */
--- a/arch/arm/mach-pentagram/include/mach/misc.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/misc.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,19 @@
+#ifndef __MACH_MISC_H
+#define __MACH_MISC_H
+
+#include <linux/io.h>
+#include <mach/io_map.h>
+
+/* Latch and print IC uptime */
+inline static void sp_prn_uptime(void)
+{
+	unsigned int base = VA_IOB_ADDR(0);
+
+	writel(0x1234, (void __iomem *)base + 0x30e8);	/* stcl_2 in AV1_STC */
+
+	early_printk("av1_stc(0x%4x, 0x%4x)\n",
+		readl((void __iomem *)base + 0x30e4),	/* stcl_1 */
+		readl((void __iomem *)base + 0x30e0));	/* stcl_0 */
+}
+
+#endif /* __MACH_MISC_H */
--- a/arch/arm/mach-pentagram/include/mach/sp_icm.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/sp_icm.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,67 @@
+#ifndef __SP_ICM_H__
+#define __SP_ICM_H__
+
+// muxsel: input signal source select
+#define ICM_MUXSEL_INPUT0	0 // input signal 0
+#define ICM_MUXSEL_INPUT1	1 // input signal 1
+#define ICM_MUXSEL_INPUT2	2 // input signal 2
+#define ICM_MUXSEL_INPUT3	3 // input signal 3
+#define ICM_MUXSEL_TEST		4 // test signal
+
+// clksel: internal counter clock select
+#define ICM_CLKSEL_EXT0		0 // external clock 0
+#define ICM_CLKSEL_EXT1		1 // external clock 1
+#define ICM_CLKSEL_EXT2		2 // external clock 2
+#define ICM_CLKSEL_EXT3		3 // external clock 3
+#define ICM_CLKSEL_SYS		4 // system clock
+#define ICM_CLKSEL_27M		5 // 27 MHz
+#define ICM_CLKSEL_32K		6 // 32 KHz
+	
+// eemode: edge event mode
+#define ICM_EEMODE_RISING	0 // rising edge
+#define ICM_EEMODE_FALLING	1 // falling edge
+#define ICM_EEMODE_BOTH		2 // both edges
+
+// etimes: edge event times
+// set 0 ~ 15. if set 7, interrupt will be triggered after
+// 8 times edge event.
+
+// dtimes: debounce times of input signal debounce filter
+// 0~6: (dtimes + 1) times
+// 7  : 16 times
+
+// cntscl: internal counter clock prescaler: 0 ~ (2^32-1)
+// cnt_clk = clksel_clk / (cntscl + 1)
+// internal counter +1 @ cnt_clk rising edge
+
+// tstscl: test signal clock prescaler: 0 ~ (2^32-1)
+// tst_clk = sysclk / (tstscl + 1)
+
+struct sp_icm_cfg {
+	u32 muxsel;
+	u32 clksel;
+	u32 eemode;
+	u32 etimes;
+	u32 dtimes;
+	u32 cntscl;
+	u32 tstscl;
+};
+
+// icm fifo state
+#define ICM_FDDROP	0x1000 // fifo data dropped
+#define ICM_FEMPTY	0x4000 // fifo empty
+#define ICM_FFULL	0x8000 // fifo full
+
+// icm callback function
+// cnt   : internal counter
+// fstate: fifo state
+typedef void (*sp_icm_cbf)(int icm, u32 cnt, u32 fstate);
+
+// icm: 0 ~ 3 (icm0 ~ icm3)
+extern int sp_icm_config(int icm, struct sp_icm_cfg *cfg);
+extern int sp_icm_reload(int icm);
+extern int sp_icm_enable(int icm, sp_icm_cbf cbf);
+extern int sp_icm_disable(int icm);
+extern int sp_icm_pwidth(int icm, u32 *pwh, u32 *pwl);
+
+#endif /* __SP_ICM_H__ */
--- a/arch/arm/mach-pentagram/include/mach/sp_ipc.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/sp_ipc.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,218 @@
+/**
+ * @file    sp_ipc.h
+ * @brief   Declaration of Sunplus IPC Linux Driver.
+ * @author  qinjian
+ */
+#ifndef _SP_IPC_H_
+#define _SP_IPC_H_
+
+#define TRACE
+//#define MEM_DEBUG
+#define RPC_DUMP
+//#define IPC_USE_CBDMA
+
+/**************************************************************************
+ *                           C O N S T A N T S                            *
+ **************************************************************************/
+
+/* IPC Error Code */
+#define IPC_SUCCESS			(0)
+#define IPC_FAIL			(-1)
+#define IPC_FAIL_NODEV		(-2)	// ipc device not exist
+#define IPC_FAIL_NOMEM		(-3)	// out of memory
+#define IPC_FAIL_INVALID	(-4)	// invalid arguments
+#define IPC_FAIL_UNSUPPORT	(-5)	// rpc cmd not supported
+#define IPC_FAIL_NOSERV		(-6)	// rpc server not running
+#define IPC_FAIL_BUSY		(-7)	// rpc server busy
+#define IPC_FAIL_TIMEOUT	(-8)	// rpc request timeout
+#define IPC_FAIL_SERVNOTRDY (-9)    // rpc server  not ready
+#define IPC_FAIL_DATANOTRDY (-10)   // rpc remote  data not ready
+#define IPC_FAIL_HWTIMEOUT  (-11)   // rpc hw timeout
+
+/* RPC Request Type */
+enum {
+	REQ_WAIT_REP = 0,		// Wait Response
+	REQ_DEFER_REP,			// Deferred Response
+	REQ_NO_REP,				// No Response
+};
+
+/* RPC Direction */
+enum {
+	RPC_REQUEST = 0,
+	RPC_RESPONSE,
+};
+
+#define IPC_DATA_SIZE_MAX	4096
+#define IPC_WRITE_TIMEOUT	500			// ms
+
+#define SERVER_BITS			3	// highest N bits in CMD
+#define SERVER_NUMS			(1 << SERVER_BITS)
+#define SERVER_ID_OFFSET	(10 - SERVER_BITS)
+#define IPC_SERVER_ID_MASK  ((1 << SERVER_BITS) - 1)
+#define RPC_CMD_MAX			((1 << SERVER_ID_OFFSET) - 1)
+#ifdef IPC_USE_CBDMA
+#define RPC_DATA_REGS		18
+#else
+#define RPC_DATA_REGS		16
+#endif
+#define RPC_DATA_SIZE		(RPC_DATA_REGS * 4)
+#define RPC_HEAD_SIZE		(sizeof(rpc_t) - RPC_DATA_SIZE)
+
+#define MAILBOX_NUM			8
+
+/**************************************************************************
+ *                          D A T A    T Y P E S                          *
+ **************************************************************************/
+
+#ifndef u8
+#define u8		unsigned char
+#define u16		unsigned short
+#define u32		unsigned int
+#endif
+
+typedef struct {
+	void*		REQ_H;					// Request Handler
+	u16 		DATA_LEN;				// In/Out Data Length in Bytes
+	u16			CMD 	: 10;			// Command ID / Return Value
+	u16 		RSV 	: 3;
+	u16 		F_TYPE	: 2;			// Request Type
+	u16 		F_DIR	: 1;			// REQUEST / RESPONSE
+#ifndef IPC_USE_CBDMA
+	void*		SEQ_ADDR;
+	u32 		SEQ;
+#endif
+	union {
+		u32		DATA[RPC_DATA_REGS];	// if DATA_LEN <= RPC_DATA_SIZE
+		struct {						// if DATA_LEN >  RPC_DATA_SIZE
+			void*	DATA_PTR;			// Cache Aligned
+			void*	DATA_PTR_ORG;		// Backup (INTERNAL_USE)
+		};
+	};
+} rpc_t;
+
+typedef struct {
+	u32 timeout;
+}rpc_user_t;
+
+typedef struct {
+	rpc_t rpc;
+	rpc_user_t user;
+}rpc_new_t;
+
+typedef struct {
+	u32			TRIGGER;				// Reg00
+	u32			F_RW;					// Reg01
+	u32			F_OVERWRITE;			// Reg02
+	u32			RSV;					// Reg03
+
+	rpc_t		RPC;					// Reg04~23
+
+	u32			MBOX[MAILBOX_NUM];		// Reg24~31
+} ipc_t;
+
+typedef int (*ipc_func)(void *data);
+typedef void (*ipc_mbfunc)(int id, u32 data);
+
+/**************************************************************************
+ *                              M A C R O S                               *
+ **************************************************************************/
+#ifndef BIT
+#define BIT(x)  (1 << (x))
+#endif
+#ifdef TRACE
+#define print		printf
+#else
+#define print(...)
+#endif
+#define trace()		print("++++ %s(%d) ++++\n", __FUNCTION__, __LINE__)
+
+#ifdef MEM_DEBUG
+#define MALLOC(n) \
+({ \
+	void *_p = malloc(n); \
+	printf("++++++++++ %p %d\n", _p, n); \
+	_p; \
+})
+#define FREE(p) \
+do { \
+	free(p); \
+	printf("---------- %p\n", p); \
+} while (0)
+#else
+#define MALLOC	malloc
+#define FREE	free
+#endif
+
+#define hex_dump(p, l) \
+do { \
+	static char _s[] = "       |       \n"; \
+	char ss[52] = ""; \
+	u8 *_p = (u8 *)(p); \
+	int _l = (l); \
+	int _i = 0, _j; \
+	while (_i < _l) { \
+		_j = _i & 0x0F; \
+		sprintf(ss + _j * 3, "%02x%c", _p[_i], _s[_j]); \
+		_i++; \
+		if (!(_i & 0x0F)) printf(ss); \
+	} \
+	if (_l & 0x0F) printf(ss); \
+} while (0)
+
+#define var_dump(v) \
+do { \
+	printf("%s(%d) %p:\n", __FUNCTION__, __LINE__, &(v)); \
+	hex_dump(&(v), sizeof(v)); \
+} while (0)
+
+#define _rpc_dump(ss, rr) \
+do { \
+	rpc_t *r = (rpc_t *)(rr); \
+	int l; \
+	printf("%s: %s %u\n", ss, (r->F_DIR)?"RES":"REQ", r->CMD); \
+	l = r->DATA_LEN; \
+	hex_dump(r, (l > RPC_DATA_SIZE) ? 24 : (16 + l)); \
+	if (l > RPC_DATA_SIZE) hex_dump(r->DATA_PTR, l + 4); \
+	printf("\n"); \
+} while (0)
+
+#ifdef RPC_DUMP
+#define rpc_dump	_rpc_dump
+#else
+#define rpc_dump(ss, rr)
+#endif
+
+
+#define CACHE_MASK			(32 - 1)
+#define CACHE_ALIGNED(n)	(((u32)(n) & CACHE_MASK) == 0)
+#define CACHE_ALIGN(n)		(((u32)(n) + CACHE_MASK) & (~CACHE_MASK))
+
+/**************************************************************************
+ *               F U N C T I O N    D E C L A R A T I O N S               *
+ **************************************************************************/
+
+int IPC_RegFunc(int cmd, ipc_func pfIPCHandler);
+int IPC_UnregFunc(int cmd);
+int IPC_Init(int server_id);
+void IPC_Finalize(void);
+
+/**
+ * @brief   Sunplus RPC call.
+ * @param   cmd [in] request command id.
+ * @param   data [in] input data buffer.
+ * @param	len [in] input data length in bytes.
+ * @return  success: 0 (IPC_SUCCESS), fail: error code (IPC_FAIL_XXXX)
+ */
+int IPC_FunctionCall(int cmd, void *data, int len);
+
+/**
+ * @brief   Sunplus RPC call.
+ * @param   cmd [in] request command id.
+ * @param   data [in] input data buffer.
+ * @param	len [in] input data length in bytes.
+ * @param	timeout [in] input rpc timeout in ms.
+ * @return  success: 0 (IPC_SUCCESS), fail: error code (IPC_FAIL_XXXX)
+ */
+int IPC_FunctionCall_timeout(int cmd, void *data, int len, u32 timeout);
+
+#endif /* _SP_IPC_H_ */
--- a/arch/arm/mach-pentagram/include/mach/sp_mon.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/sp_mon.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,32 @@
+#ifndef _SP_MON_H_
+#define _SP_MON_H_
+
+#ifdef CONFIG_MAGIC_SYSRQ
+/*
+ * Code can be shared between Linux and U-Boot
+ */
+#define BUF_SIZE	256
+
+#if 0
+#define DBG_PRN		dbg_printf
+#else
+#define DBG_PRN(...)
+#endif
+
+/* Write 4 bytes to a specific register in designated group */
+void write_regs(unsigned int, unsigned int, unsigned int);
+/* Print specific group of registers */
+void prn_regs(unsigned int);
+/* Dump requested physical memory data */
+int dumpPhysMem(unsigned int, unsigned int);
+/* Write 4 bytes to a specific memory address */
+int writeToMem(unsigned int, unsigned int);
+/* Show task info */
+void showTaskInfo(pid_t);
+/* Query if we're in MON shell */
+int is_in_mon_shell(void);
+/* Print to MON debug port */
+int dbg_printf(const char *, ...);
+
+#endif	/* CONFIG_MAGIC_SYSRQ */
+#endif	/* _SP_MON_H_ */
--- a/arch/arm/mach-pentagram/include/mach/sp_uart.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/sp_uart.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,126 @@
+#ifndef __SP_UART_H__
+#define __SP_UART_H__
+
+#include <mach/io_map.h>
+
+#define LL_UART_PADDR		PA_IOB_ADDR(18 * 32 * 4)
+#define LL_UART_VADDR		VA_IOB_ADDR(18 * 32 * 4)
+#define LOGI_ADDR_UART0_REG	VA_IOB_ADDR(18 * 32 * 4)
+
+/* uart register map */
+#define SP_UART_DATA		0x00
+#define SP_UART_LSR		0x04
+#define SP_UART_MSR		0x08
+#define SP_UART_LCR		0x0C
+#define SP_UART_MCR		0x10
+#define SP_UART_DIV_L		0x14
+#define SP_UART_DIV_H		0x18
+#define SP_UART_ISC		0x1C
+
+/* lsr */
+#define SP_UART_LSR_TXE		(1 << 6)	/* 1: trasmit fifo is empty */
+
+/* interrupt */
+#define SP_UART_LSR_BC		(1 << 5)	/* break condition */
+#define SP_UART_LSR_FE		(1 << 4)	/* frame error */
+#define SP_UART_LSR_OE		(1 << 3)	/* overrun error */
+#define SP_UART_LSR_PE		(1 << 2)	/* parity error */
+#define SP_UART_LSR_RX		(1 << 1)	/* 1: receive fifo not empty */
+#define SP_UART_LSR_TX		(1 << 0)	/* 1: transmit fifo is not full */
+
+#define SP_UART_LSR_BRK_ERROR_BITS	\
+	(SP_UART_LSR_PE | SP_UART_LSR_OE | SP_UART_LSR_FE | SP_UART_LSR_BC)
+
+/* lcr */
+#define SP_UART_LCR_WL5		(0 << 0)
+#define SP_UART_LCR_WL6		(1 << 0)
+#define SP_UART_LCR_WL7		(2 << 0)
+#define SP_UART_LCR_WL8		(3 << 0)
+#define SP_UART_LCR_ST		(1 << 2)
+#define SP_UART_LCR_PE		(1 << 3)
+#define SP_UART_LCR_PR		(1 << 4)
+#define SP_UART_LCR_BC		(1 << 5)
+
+/* isc */
+#define SP_UART_ISC_MSM		(1 << 7)	/* Modem status ctrl */
+#define SP_UART_ISC_LSM		(1 << 6)	/* Line status interrupt */
+#define SP_UART_ISC_RXM		(1 << 5)	/* RX interrupt, when got some input data */
+#define SP_UART_ISC_TXM		(1 << 4)	/* TX interrupt, when trans start */
+#define HAS_UART_ISC_FLAGMASK	0x0F
+#define SP_UART_ISC_MS		(1 << 3)
+#define SP_UART_ISC_LS		(1 << 2)
+#define SP_UART_ISC_RX		(1 << 1)
+#define SP_UART_ISC_TX		(1 << 0)
+
+/* modem control register */
+#define SP_UART_MCR_AT		(1 << 7)
+#define SP_UART_MCR_AC		(1 << 6)
+#define SP_UART_MCR_AR		(1 << 5)
+#define SP_UART_MCR_LB		(1 << 4)
+#define SP_UART_MCR_RI		(1 << 3)
+#define SP_UART_MCR_DCD		(1 << 2)
+#define SP_UART_MCR_RTS		(1 << 1)
+#define SP_UART_MCR_DTS		(1 << 0)
+
+/* DMA-RX, dma_enable_sel */
+#define DMA_INT			(1 << 31)
+#define DMA_MSI_ID_SHIFT	12
+#define DMA_MSI_ID_MASK		(0x7F << DMA_MSI_ID_SHIFT)
+#define DMA_SEL_UARTX_SHIFT	8
+#define DMA_SEL_UARTX_MASK	(0x07 << DMA_SEL_UARTX_SHIFT)
+#define DMA_SW_RST_B		(1 << 7)
+#define DMA_INIT		(1 << 6)
+#define DMA_GO			(1 << 5)
+#define DMA_AUTO_ENABLE		(1 << 4)
+#define DMA_TIMEOUT_INT_EN	(1 << 3)
+#define DMA_P_SAFE_DISABLE	(1 << 2)
+#define DMA_PBUS_DATA_SWAP	(1 << 1)
+#define DMA_ENABLE		(1 << 0)
+
+#if !defined(__ASSEMBLY__)
+#define UART_SZ			0x80
+struct regs_uart {
+	volatile u32 uart_data;
+	volatile u32 uart_lsr;
+	volatile u32 uart_msr;
+	volatile u32 uart_lcr;
+	volatile u32 uart_mcr;
+	volatile u32 uart_div_l;
+	volatile u32 uart_div_h;
+	volatile u32 uart_isc;
+	volatile u32 uart_tx_residue;
+	volatile u32 uart_rx_residue;
+	volatile u32 uart_rx_threshold;
+	volatile u32 uart_clk_src;
+};
+typedef struct regs_uart regs_uart_t;
+
+struct regs_uarxdma {
+	volatile u32 rxdma_enable_sel;
+	volatile u32 rxdma_start_addr;
+	volatile u32 rxdma_timeout_set;
+	volatile u32 rxdma_reserved;
+	volatile u32 rxdma_wr_adr;
+	volatile u32 rxdma_rd_adr;
+	volatile u32 rxdma_length_thr;
+	volatile u32 rxdma_end_addr;
+	volatile u32 rxdma_databytes;
+	volatile u32 rxdma_debug_info;
+};
+
+struct regs_uatxdma {
+	volatile u32 txdma_enable;
+	volatile u32 txdma_sel;
+	volatile u32 txdma_start_addr;
+	volatile u32 txdma_end_addr;
+	volatile u32 txdma_wr_adr;
+	volatile u32 txdma_rd_adr;
+	volatile u32 txdma_status;
+	volatile u32 txdma_tmr_unit;
+	volatile u32 txdma_tmr_cnt;
+	volatile u32 txdma_rst_done;
+};
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __SP_UART_H__ */
--- a/arch/arm/mach-pentagram/include/mach/uncompress.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/uncompress.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,22 @@
+#ifndef __UNCOMPRESS_H_
+#define __UNCOMPRESS_H_
+
+#include <mach/sp_uart.h>
+
+static regs_uart_t *uart_base = ((regs_uart_t *)(LL_UART_PADDR));
+
+static void putc(int c)
+{
+	while (!(uart_base->uart_lsr & SP_UART_LSR_TX))
+		barrier();
+	uart_base->uart_data = c;
+	return;
+}
+
+static inline void flush(void)
+{
+}
+
+#define arch_decomp_setup()	/* Do nothing */
+
+#endif /* __UNCOMPRESS_H_ */
--- a/arch/arm/mach-pentagram/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/Kconfig	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,77 @@
+if ARCH_PENTAGRAM
+
+choice
+	prompt "Sunplus Pentagram SOC"
+	default MACH_PENTAGRAM_SC7021_ACHIP
+
+config MACH_PENTAGRAM_8388_ACHIP
+        bool "8388 A support"
+        select CPU_V7
+        select ARM_GIC
+	select HAVE_SMP
+	select MIGHT_HAVE_CACHE_L2X0
+	select CLKSRC_SP_TIMER
+
+config MACH_PENTAGRAM_8388_BCHIP
+        bool "8388 B support"
+        select CPU_ARM926T
+        select SP_INTC
+	select CLKSRC_SP_TIMER
+
+config MACH_PENTAGRAM_I136_ACHIP
+        bool "I136 A+B support"
+        select CPU_V7
+        select ARM_GIC
+	select SP_INTC
+	select HAVE_SMP
+	select HAVE_ARM_ARCH_TIMER
+	select CLKSRC_SP_TIMER
+
+config MACH_PENTAGRAM_I137_BCHIP
+        bool "I137 B support"
+        select CPU_ARM926T
+        select SP_INTC
+	select CLKSRC_SP_TIMER
+
+config MACH_PENTAGRAM_3502_ACHIP
+	bool "3502 A support"
+	select CPU_V7
+	select ARM_GIC
+	select HAVE_SMP
+	select MIGHT_HAVE_CACHE_L2X0
+	select CLKSRC_SP_TIMER
+	select HAVE_ARM_SCU
+	select ARM_GLOBAL_TIMER
+
+config MACH_PENTAGRAM_SC7021_ACHIP
+        bool "SC7021 A+B support"
+        select CPU_V7
+        select ARM_GIC
+        select SP_INTC
+	select HAVE_SMP
+	select CLKSRC_SP_TIMER
+
+config MACH_PENTAGRAM_SC7021_BCHIP
+        bool "SC7021 B support"
+        select CPU_ARM926T
+        select SP_INTC
+	select CLKSRC_SP_TIMER
+
+endchoice
+
+menu "Pentagram options"
+
+config SP_MON
+	bool "Sunplus MON (SysRq:a)"
+	select MAGIC_SYSRQ
+	help
+	  Enable Sunplus MON shell in SysRq.
+
+config SP_DISP_SC7021_TEST
+	tristate "SC7021 DISP Test Code"
+	help
+		TEST display driver for SC7021.
+
+endmenu
+
+endif
--- a/arch/arm/mach-pentagram/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/Makefile	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,13 @@
+obj-$(CONFIG_SMP) += platsmp.o
+obj-$(CONFIG_MACH_PENTAGRAM_I136_ACHIP)		+= i137.o
+obj-$(CONFIG_MACH_PENTAGRAM_I137_BCHIP)		+= i137.o
+obj-$(CONFIG_MACH_PENTAGRAM_3502_ACHIP)		+= 8388.o
+obj-$(CONFIG_MACH_PENTAGRAM_8388_ACHIP)		+= 8388.o
+obj-$(CONFIG_MACH_PENTAGRAM_8388_BCHIP)		+= 8388.o
+obj-$(CONFIG_MACH_PENTAGRAM_SC7021_ACHIP)	+= sc7021.o
+obj-$(CONFIG_MACH_PENTAGRAM_SC7021_BCHIP)	+= sc7021.o
+
+# Monitor utility
+obj-$(CONFIG_SP_MON) += sp_uart_sysrq.o sp_mon.o
+
+obj-$(CONFIG_SP_DISP_SC7021_TEST) += display/
--- a/arch/arm/mach-pentagram/Makefile.boot	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/Makefile.boot	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,2 @@
+#params_phys-y	:= 0x00300100
+zreladdr-y	:= 0x00308000
--- a/arch/arm/mach-pentagram/platsmp.c	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/platsmp.c	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,78 @@
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/memory.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/smp.h>
+#ifdef CONFIG_HAVE_ARM_SCU
+#include <asm/smp_scu.h>
+#endif
+
+#define OF_CPU_BOOT       "cpu-boot-reg"
+
+static u32 secondary_boot_addr_for(unsigned int cpu)
+{
+        u32 secondary_boot_addr = 0;
+        struct device_node *cpu_node = of_get_cpu_node(cpu, NULL);
+
+        if (!cpu_node) {
+                pr_err("Failed to find device tree node for CPU%u\n", cpu);
+                return 0;
+        }
+
+        if (of_property_read_u32(cpu_node, OF_CPU_BOOT, &secondary_boot_addr))
+                pr_err("missed cpu boot in DT for %u\n", cpu);
+
+        of_node_put(cpu_node);
+
+        return secondary_boot_addr;
+}
+
+#ifdef CONFIG_HAVE_ARM_SCU
+static const struct of_device_id sc_scu_match[] __initconst = {
+        { .compatible = "arm,cortex-a9-scu", },
+        {}
+};
+#endif
+
+static void __init sc_smp_prepare_cpus(unsigned int max_cpus)
+{
+#ifdef CONFIG_HAVE_ARM_SCU
+	struct device_node *scu = of_find_matching_node(NULL, sc_scu_match);
+	if (scu) {
+		scu_enable(of_iomap(scu, 0));
+	}
+#endif
+}
+
+static int sc_smp_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+        const u32 wait_addr = secondary_boot_addr_for(cpu);
+	void __iomem *va;
+
+        if (!wait_addr)
+                return -EINVAL;
+
+        va = ioremap_nocache((phys_addr_t)wait_addr, sizeof(phys_addr_t));
+        if (!va) {
+                pr_warn("unable to ioremap cpu start pos\n");
+                return -ENOMEM;
+        }
+
+	writel(__pa_symbol(secondary_startup), va);
+
+        smp_wmb();
+
+        iounmap(va);
+
+	sev();
+
+	return 0;
+}
+
+static const struct smp_operations sc_smp_ops __initconst = {
+	.smp_prepare_cpus	= sc_smp_prepare_cpus,
+	.smp_boot_secondary	= sc_smp_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(sc_smp, "sunplus,sc-smp", &sc_smp_ops);
--- a/arch/arm/mach-pentagram/sc7021.c	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/sc7021.c	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,166 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/memblock.h>
+#include <asm/memory.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <mach/io_map.h>
+#include <mach/clk.h>
+#include <mach/misc.h>
+
+static void __init sp_power_off(void)
+{
+	early_printk("%s\n", __func__);
+}
+
+static unsigned int b_pllsys_get_rate(void)
+{
+	unsigned int reg = readl((void __iomem *)B_SYSTEM_BASE + 0x268); /* G4.26 */
+	unsigned int reg2 = readl((void __iomem *)B_SYSTEM_BASE + 0x26c); /* G4.27 */
+
+	if ((reg >> 9) & 1) /* bypass? */
+		return 27000000;
+	return (((reg & 0xf) + 1) * 13500000) >> ((reg2 >> 4) & 0xf);
+}
+
+static void __init sp_init(void)
+{
+	unsigned int b_sysclk, io_ctrl;
+#ifdef CONFIG_MACH_PENTAGRAM_SC7021_ACHIP
+	unsigned int a_pllclk, coreclk, ioclk, sysclk, clk_cfg, a_pllioclk;
+#endif
+
+	early_printk("%s\n", __func__);
+
+	sp_prn_uptime();
+
+	pm_power_off = sp_power_off;
+
+	io_ctrl = readl((void __iomem *)B_SYSTEM_BASE + 0x105030);
+
+	b_sysclk = b_pllsys_get_rate();
+
+	early_printk("B: b_sysclk=%uM abio_ctrl=(%ubit, %s)\n", b_sysclk / 1000000,
+		(io_ctrl & 2) ? 16 : 8, (io_ctrl & 1) ? "DDR" : "SDR");
+
+#ifdef CONFIG_MACH_PENTAGRAM_SC7021_ACHIP
+	clk_cfg = readl((void __iomem *)A_SYSTEM_BASE + 0xc);
+	a_pllclk = (((readl((void __iomem *)A_SYSTEM_BASE + 0x2c) >> 16) + 1) & 0xff) * (27 * 1000 * 1000);
+	coreclk = a_pllclk / (1 + ((clk_cfg >> 10) & 1));
+	sysclk = coreclk / (1 + ((clk_cfg >> 3) & 1));
+	a_pllioclk = (((readl((void __iomem *)A_SYSTEM_BASE + 0x54) >> 16) & 0xff) + 1) * (27 * 1000 * 1000);
+	ioclk = a_pllioclk / (20 + 5 * ((clk_cfg >> 4) & 7)) / ((clk_cfg >> 16) & 0xff) * 10;
+	early_printk("A: core=%uM a_sysclk=%uM a_pllio=%uM abio_bus=%uM\n",
+		coreclk / 1000000, sysclk / 1000000, a_pllioclk / 1000000, ioclk / 1000000);
+
+#endif
+}
+
+static struct map_desc sp_io_desc[] __initdata = {
+	{	/* B RGST Bus */
+		.virtual = VA_B_REG,
+		.pfn     = __phys_to_pfn(PA_B_REG),
+		.length  = SIZE_B_REG,
+		.type    = MT_DEVICE
+	},
+	{
+		/* B SRAM0 */
+		.virtual = VA_B_SRAM0,
+		.pfn     = __phys_to_pfn(PA_B_SRAM0),
+		.length  = SIZE_B_SRAM0,
+		.type    = MT_DEVICE
+	},
+#ifdef CONFIG_MACH_PENTAGRAM_SC7021_ACHIP
+	{	/* A RGST Bus */
+		.virtual = VA_A_REG,
+		.pfn     = __phys_to_pfn(PA_A_REG),
+		.length  = SIZE_A_REG,
+		.type    = MT_DEVICE
+	},
+#endif
+};
+
+static void __init sp_map_io(void)
+{
+	early_printk("%s\n", __func__);
+
+	iotable_init(sp_io_desc, ARRAY_SIZE( sp_io_desc));
+
+	printk("B_REG %08x -> [%08x-%08x]\n", PA_B_REG, VA_B_REG, VA_B_REG + SIZE_B_REG);
+#ifdef CONFIG_MACH_PENTAGRAM_SC7021_ACHIP
+        printk("A_REG %08x -> [%08x-%08x]\n", PA_A_REG, VA_A_REG, VA_A_REG + SIZE_A_REG);
+#endif
+}
+
+static void __init sp_init_early(void)
+{
+#ifdef CONFIG_MACH_PENTAGRAM_SC7021_ACHIP
+	/* enable counter before timer_init */
+	writel(3, (void __iomem *)A_SYS_COUNTER_BASE); /* CNTCR: EN=1 HDBG=1 */
+	mb();
+#endif
+}
+
+void __init sp_reserve(void)
+{
+}
+
+static void __init sp_fixup(void)
+{
+	early_printk("%s\n", __func__);
+}
+
+void sp_restart(enum reboot_mode mode, const char *cmd)
+{
+	void __iomem *regs = (void __iomem *)B_SYSTEM_BASE;
+
+	/* MOON : enable watchdog reset */
+	writel(0x00120012, regs + 0x0274); /* G4.29 misc_ctl */
+
+	/* STC: watchdog control */
+	writel(0x3877, regs + 0x0630); /* stop */
+	writel(0xAB00, regs + 0x0630); /* unlock */
+	writel(0x0001, regs + 0x0634); /* counter */
+	writel(0x4A4B, regs + 0x0630); /* resume */
+}
+
+#ifdef CONFIG_MACH_PENTAGRAM_SC7021_BCHIP
+static char const *bchip_compat[] __initconst = {
+	"sunplus,sc7021-bchip",
+	NULL
+};
+
+DT_MACHINE_START(SC7021_BCHIP_DT, "SC7021_BCHIP")
+	.dt_compat	= bchip_compat,
+	.dt_fixup	= sp_fixup,
+	.reserve	= sp_reserve,
+	.map_io		= sp_map_io,
+	.init_early	= sp_init_early,
+	.init_machine	= sp_init,
+	.restart	= sp_restart,
+MACHINE_END
+#endif
+
+#ifdef CONFIG_MACH_PENTAGRAM_SC7021_ACHIP
+static char const *achip_compat[] __initconst = {
+	"sunplus,sc7021-achip",
+	NULL
+};
+
+DT_MACHINE_START(SC7021_ACHIP_DT, "SC7021_ACHIP")
+	.dt_compat	= achip_compat,
+	.dt_fixup	= sp_fixup,
+	.reserve	= sp_reserve,
+	.map_io		= sp_map_io,
+	.init_early	= sp_init_early,
+	.init_machine	= sp_init,
+	.restart	= sp_restart,
+MACHINE_END
+#endif
--- a/arch/arm/mach-pentagram/sp_mon.c	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/sp_mon.c	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,253 @@
+/*
+ * Code can be shared between Linux and U-Boot,
+ * just change IS_LINUX accordingly
+ */
+/* Linux: IS_LINUX == 1, U-Boot: IS_LINUX == 0 */
+#ifndef IS_LINUX
+#define IS_LINUX 1
+#endif
+
+#if IS_LINUX
+#include <asm/memory.h>	/* phys_to_virt */
+#include <mach/io_map.h>
+#include <mach/sp_mon.h>
+#include <asm/io.h>
+#include <linux/sched.h>
+#include <linux/sched/signal.h>
+#include <linux/sched/debug.h>
+#else	/* U-Boot */
+#include <asm/arch/hardware.h>
+#include <common.h>
+#include "sp_mon.h"
+#endif
+
+#if IS_LINUX
+extern void dbg_putc(char);
+extern int dbg_printf(const char *, ...);
+#define RGST_OFFSET		PA_IOB_ADDR(0)
+#else	/* U-Boot */
+#define dbg_printf		printf
+#define RGST_OFFSET		SPHE_DEVICE_BASE
+#endif
+
+#if 0
+#define DBG_PRN			dbg_printf
+#else
+#define	DBG_PRN(...)
+#endif
+
+#define DUMP_CHARS_PER_LINE	16
+/* Dump / fill format */
+#define MEM_FORMAT_BYTE		(sizeof(unsigned char))
+#define MEM_FORMAT_WORD		(sizeof(unsigned short))
+#define MEM_FORMAT_DWORD	(sizeof(unsigned int))
+
+/*
+ * getMemAddr() is for compatibility with U-Boot code
+ * Since Linux memory addresses are remapped,
+ * convert the physical to logical address
+ */
+static unsigned int getMemAddr(unsigned int physAddr)
+{
+#if IS_LINUX
+	return (unsigned int)phys_to_virt(physAddr);
+#else	/* U-Boot */
+	return physAddr;
+#endif
+}
+
+/*
+ * Reading memory data safely
+ * (dealing with 8, 16, 32 bit cases separately)
+ */
+static unsigned int safe8bitRead(unsigned int addr, unsigned char *data)
+{
+	*data = *((volatile unsigned char *)addr);
+	return 1;
+}
+
+static unsigned int safe16bitRead(unsigned int addr, unsigned short *data)
+{
+	if (addr & 0x01) {
+		return 0;
+	}
+
+	*data = *((volatile unsigned short *)addr);
+	return 1;
+}
+
+static unsigned int safe32bitRead(unsigned int addr, unsigned int *data)
+{
+	if (addr & 0x03) {
+		return 0;
+	}
+
+	*data = *((volatile unsigned int *)addr);
+	return 1;
+}
+
+/* wreg: Write 4 bytes to a specific register in designated group */
+void write_regs(unsigned int regGroupNum, unsigned int regIndex, unsigned int value)
+{
+	unsigned int targetAddr = 0;
+
+	/* Calculate offset for register group */
+#if IS_LINUX
+	unsigned int va_addr, pa_addr;
+
+	/* unit: bytes */
+	pa_addr = RGST_OFFSET + regGroupNum * 32 * 4 + regIndex * 4;
+	DBG_PRN("\npa:0x%08X\tva:0x%08X\n", pa_addr, va_addr);
+
+	va_addr = (unsigned int)ioremap(pa_addr, 4);
+
+	if (!va_addr)
+		return;
+	DBG_PRN("\npa:0x%08X\tva:0x%08X\n", pa_addr, va_addr);
+	targetAddr = va_addr;
+#else	/* U-Boot */
+	/* unit: bytes */
+	targetAddr = RGST_OFFSET + (regGroupNum * 32 * 4) + regIndex * 4;
+#endif
+
+	dbg_printf("Write G%u.%2u = 0x%08X (%u)\n", regGroupNum, regIndex, value, value);
+	*((volatile unsigned int *)targetAddr) = value;
+
+#if IS_LINUX
+	iounmap((void *)va_addr);
+#endif
+	return;
+}
+
+/* lreg : Print specific group of registers */
+void prn_regs(unsigned int regGroupNum)
+{
+	unsigned int i = 0;
+	unsigned int regBaseAddr = 0;
+
+	/* Calculate register group offset base address */
+#if IS_LINUX
+	unsigned int va_base, pa_base;
+
+	pa_base = RGST_OFFSET + regGroupNum * 32 * 4;
+	va_base = (unsigned int)ioremap(pa_base, 4 * 32);
+
+	if (!va_base)
+		return;
+
+	DBG_PRN("\npa:0x%08X\tva:0x%08X\n", pa_base, va_base);
+	regBaseAddr = va_base;
+#else
+	/* unit: bytes */
+	regBaseAddr = RGST_OFFSET + regGroupNum * 32 * 4;
+#endif
+
+	DBG_PRN("Register group %u base=0x%08X\n", regGroupNum, regBaseAddr);
+	for (i = 0 ; i < 32 ; i++)
+		dbg_printf("Read G%u.%2u = 0x%08X (%u)\n",
+			   regGroupNum, i,
+			   *((volatile unsigned int *)(regBaseAddr) + i),
+			   *((volatile unsigned int *)(regBaseAddr) + i));
+
+#if IS_LINUX
+	iounmap((void *)va_base);
+#endif
+	return;
+}
+
+/* Dumps requested physical memory data */
+int dumpPhysMem(unsigned int physAddr, unsigned int dumpSize)
+{
+	unsigned int dumpFmt = MEM_FORMAT_DWORD;
+	unsigned int baseAddr;
+	unsigned char readMem[DUMP_CHARS_PER_LINE];
+	/* Used to store read data from memory */
+	unsigned char data_8;
+	unsigned short data_16;
+	unsigned int data_32;
+	unsigned int offset = 0;
+
+	baseAddr = getMemAddr(physAddr);
+
+	DBG_PRN("phyAddr, baseAddr, dumpSize = 0x%08X, 0x%08X, %u", physAddr, baseAddr, dumpSize);
+	while (offset < dumpSize) {
+		/* Print the line offset label */
+		if ((offset % DUMP_CHARS_PER_LINE) == 0)
+			dbg_printf("\n%08X:  ", physAddr + offset);
+
+		switch (dumpFmt) {
+		case MEM_FORMAT_BYTE:
+			if (safe8bitRead(baseAddr + offset, &data_8)) {
+				dbg_printf("%02X ", data_8);
+				readMem[(offset % DUMP_CHARS_PER_LINE) + 0] = data_8;
+			} else
+				return 0;
+			break;
+
+		case MEM_FORMAT_WORD:
+			if (safe16bitRead(baseAddr + offset, &data_16)) {
+				dbg_printf("%04X ", data_16);
+				readMem[(offset % DUMP_CHARS_PER_LINE) + 0] = data_16;
+			} else
+				return 0;
+			break;
+
+		case MEM_FORMAT_DWORD:
+			if (safe32bitRead(baseAddr + offset, &data_32)) {
+				dbg_printf("%08X ", data_32);
+				readMem[(offset % DUMP_CHARS_PER_LINE) + 0] = data_32;
+			} else
+				return 0;
+			break;
+		}
+		offset = offset + dumpFmt;
+	}
+	dbg_printf("\n");
+	return 1;
+}
+
+/* Write 4 bytes to a specific memory address */
+int writeToMem(unsigned int physAddr, unsigned int value)
+{
+	unsigned int baseAddr;
+
+	baseAddr = getMemAddr(physAddr);
+	*(volatile unsigned int *)(baseAddr & 0xFFFFFFFC) = value;
+	return 1;
+}
+
+#if IS_LINUX
+void showTaskInfo(pid_t pid)
+{
+	struct task_struct *task, *child;
+	static const char stat_nam[] = TASK_STATE_TO_CHAR_STR;
+	unsigned state;
+
+	/* If no pid, list all tasks */
+	if ((int)pid == 0) {
+		dbg_printf("pid\tppid\tstate\tcommand\n");
+		do_each_thread(task, child) {
+			state = child->state ? __ffs(child->state) + 1 : 0;
+			dbg_printf("[%d]\t[%d]\t%c\t%-15s\n",
+				   task_pid_nr(child),
+				   task_pid_nr(task),
+				   (state < sizeof(stat_nam) - 1) ? stat_nam[state] : '?',
+				   child->comm);
+		}
+		while_each_thread(task, child);
+		return;
+	}
+
+	/* Find the task and show its info */
+	task = find_task_by_vpid(pid);
+	if (task == NULL) {
+		dbg_printf("no such task\n");
+	} else {
+		struct thread_info *info = task_thread_info(task);
+
+		dbg_printf("pid(%d): task_struct@<0x%08X> thread_info@<0x%08X>\n",
+			   (int)pid, (int)task, (int)info);
+		show_stack(task, NULL);
+	}
+}
+#endif
--- a/arch/arm/mach-pentagram/sp_uart_sysrq.c	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/sp_uart_sysrq.c	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,253 @@
+/*
+ * sysrq handler for entering Sunplus MON mode
+ *
+ * "Sunplus MON" masks all TX output to console, while accepting certain
+ * commands which are useful for register/memory debugging
+ */
+
+#include <linux/kernel.h>
+#include <linux/sysrq.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <mach/io_map.h>	/* IO0_ADDRESS */
+#include <mach/sp_mon.h>	/* Actual function implementations */
+#include <linux/serial_core.h>	/* struct uart_port */
+
+#define IO0_ADDRESS(_pa)	VA_IOB_ADDR(_pa)
+
+#define SPACE			0x20
+#define BCKSPACE		0x7F
+#define	IS_DIGIT(c)		((c) >= '0' && (c) <= '9')
+#define	IS_LETTER_LOW(c)	((c) >= 'a' && (c) <= 'z')
+#define	IS_LETTER_UP(c)		((c) >= 'A' && (c) <= 'Z')
+
+/* Functions to help print to uart directly! */
+#define OUTPUT_CONSOLE		0
+#define UART_BASE		uart_base_addrs[OUTPUT_CONSOLE]
+#define UART0_LSR		(UART_BASE + 0x04)
+#define UART0_DATA		(UART_BASE + 0x00)
+
+unsigned int uart0_mask_tx = 0;
+
+static unsigned long uart_base_addrs[] = {
+	IO0_ADDRESS(0x0900), IO0_ADDRESS(0x0980), IO0_ADDRESS(0x0800),
+	IO0_ADDRESS(0x0880), IO0_ADDRESS(0x8780), IO0_ADDRESS(0x8800),
+};
+
+static void dbg_putchar(char c)
+{
+	/* Wait for transmit FIFO to not be full (available for more input) */
+	while (!(*((volatile unsigned short *)(UART0_LSR)) & 0x01))
+		/* wait */;
+	/* Place data to UART data port register */
+	*((volatile unsigned short *)(UART0_DATA)) = c;
+}
+
+void dbg_putc(char c)
+{
+	if (c == '\n')
+		dbg_putchar('\r');
+	dbg_putchar(c);
+}
+
+int dbg_printf(const char *fmt, ...)
+{
+	int i, len;
+	va_list args;
+	char buf[BUF_SIZE];
+
+	va_start(args, fmt);
+	len = vsnprintf(buf, sizeof(buf), fmt, args);
+	va_end(args);
+	for (i = 0; i < len; i++)
+		dbg_putc(buf[i]);
+
+	return len;
+}
+
+int is_in_mon_shell(void)
+{
+	return uart0_mask_tx;
+}
+
+/*
+ * When the user presses 'Ctrl + Break + A' to control UART TX output,
+ * this is the callback we use.
+ */
+static void handle_mask_tx(int key)
+{
+	if (uart0_mask_tx == 1) {
+		dbg_printf("Leaving Sunplus MON\n");
+		uart0_mask_tx = 0;
+	} else {
+		uart0_mask_tx = 1;
+		dbg_printf("Welcome to Sunplus MON\n");
+	}
+}
+
+static struct sysrq_key_op sysrq_mask_tx_op = {
+	.handler	= handle_mask_tx,
+	.help_msg	= "maskTX",
+	.action_msg	= "Console tx mask",
+	.enable_mask	= SYSRQ_ENABLE_LOG
+};
+
+static int pm_sysrq_init(void)
+{
+	register_sysrq_key('a', &sysrq_mask_tx_op);
+	return 1;
+}
+
+static void skipBlanks(char *cmd, unsigned int strnCount, int *currentIdx)
+{
+	/* Blanks were replaced with '\0' for kstrtoul() to work directly */
+	while (cmd[*currentIdx] == '\0' && *currentIdx < strnCount) {
+		*currentIdx = *currentIdx + 1;
+	}
+	return;
+}
+
+static void getNextParam(char *cmd, unsigned int strnCount, int *currentIdx, unsigned long *param)
+{
+	while (cmd[*currentIdx] != '\0' && *currentIdx < strnCount) {
+		*currentIdx = *currentIdx + 1;
+	}
+
+	skipBlanks(cmd, strnCount, currentIdx);
+	if (kstrtoul(&cmd[*currentIdx], 0, param)) {
+		dbg_printf("Err: getNextParam()\n");
+	}
+
+	return;
+}
+
+static void prn_usage(void)
+{
+	dbg_printf("======================================================================\n");
+	dbg_printf("Supported functions:\n");
+
+	dbg_printf("lreg: list registers (by group)\n");
+	dbg_printf("\tlreg [register group #]\n");
+	dbg_printf("\tEx: list registers of group 18\n\t\tlreg 18\n");
+
+	dbg_printf("wreg: write 4 bytes to register\n");
+	dbg_printf("\twreg [register group #] [register # in group] [value (4 bytes)]\n");
+	dbg_printf("\tEx: write value 200 to group 18 register 0\n\t\twreg 18 0 200\n");
+
+	dbg_printf("lw: list 64 bytes of memory data\n");
+	dbg_printf("\tlw [physical address]\n");
+	dbg_printf("\tEx: list 64 bytes from physical memory address 0x00800100\n\t\tlw 0x00800100\n");
+
+	dbg_printf("sw: store 4 bytes to memory\n");
+	dbg_printf("\tsw [physical address] [value (4 bytes)]\n");
+	dbg_printf("\tEx: store value 0xFFFFFFFF to physical memory address 0x00800100\n\t\tsw 0x00800100 0xFFFFFFFF\n");
+
+	dbg_printf("task: show task backtrace info by pid\n");
+	dbg_printf("\ttask [pid]\n");
+
+	dbg_printf("exit: leave \"Sunplus MON\" mode\n");
+
+	dbg_printf("Notes:\n");
+	dbg_printf("1. Entered parameters may be in unsigned decimal (12345) or hex (0xFFFFFFFF) format\n");
+	dbg_printf("2. Register group number X = ((group X base address) - (group 0 base address)) / (32 * 4)\n");
+	dbg_printf("======================================================================\n");
+}
+
+/* Parse which command user entered and execute it */
+static void executeCmd(char *cmd, unsigned int strnCount)
+{
+	int idx = 0, i = 0;
+
+	DBG_PRN("command line :%s", cmd);
+	/* Replace blanks with '\0' for kstrtoul() to work directly */
+	for (i = 0; i < strnCount; i++) {
+		if (cmd[i] == ' ')
+			cmd[i] = '\0';
+	}
+
+	if (strncmp(cmd, "exit", 4) == 0) {
+		uart0_mask_tx = 0;
+		dbg_printf("Leaving Sunplus MON..\n");
+	} else if (strncmp(cmd, "lreg", 4) == 0) {
+		unsigned long regGroupNum = 0;
+
+		getNextParam(cmd, strnCount, &idx, &regGroupNum);
+
+		prn_regs((unsigned int)regGroupNum);
+	} else if (strncmp(cmd, "wreg", 4) == 0) {
+		unsigned long regGroupNum = 0, regIndex = 0, value = 0;
+
+		getNextParam(cmd, strnCount, &idx, &regGroupNum);
+		getNextParam(cmd, strnCount, &idx, &regIndex);
+		getNextParam(cmd, strnCount, &idx, &value);
+
+		write_regs(regGroupNum, regIndex, value);
+	} else if (strncmp(cmd, "lw", 2) == 0) {
+		unsigned long startAddr = 0;
+
+		getNextParam(cmd, strnCount, &idx, &startAddr);
+
+		dumpPhysMem(startAddr, 64);
+	} else if (strncmp(cmd, "sw", 2) == 0) {
+		unsigned long startAddr = 0, value = 0;
+
+		getNextParam(cmd, strnCount, &idx, &startAddr);
+		getNextParam(cmd, strnCount, &idx, &value);
+
+		writeToMem(startAddr, value);
+	} else if (strncmp(cmd, "task", 4) == 0) {
+		unsigned long pid = 0;
+
+		if (strnCount > 4)
+			getNextParam(cmd, strnCount, &idx, &pid);
+
+		showTaskInfo((pid_t)pid);
+	} else {
+		dbg_printf("Unrecognized command!\n");
+		prn_usage();
+	}
+}
+
+int sysrqCheckState(char c, struct uart_port *port)
+{
+	static char cmd[BUF_SIZE] = "";
+	/* This indicates the number of characters currently stored in array */
+	static unsigned int strnCount = 0;
+	int i = 0;
+
+	if (uart0_mask_tx == 0 || port->cons == NULL)
+		return 0;
+
+	dbg_putc(c);
+	/* Pressing "Enter" or buffer is full triggers execution of command */
+	/* We currently only deal with letters, enter key and digits */
+	if (c == '\n' || c == '\r') {
+		dbg_putc('\n');
+		executeCmd(&cmd[0], strnCount);
+		/* Clear command buffer after executing command */
+		strnCount = 0;
+		for (i = 0; i < BUF_SIZE; i++)
+			cmd[i] = '\0';
+	} else if (IS_LETTER_LOW(c) || IS_LETTER_UP(c) || IS_DIGIT(c) || (c == SPACE)) {
+		cmd[strnCount] = c;
+		strnCount++;
+	} else if (c == BCKSPACE) {
+		if (strnCount <= 0)
+			return -1;
+		strnCount--;
+		cmd[strnCount] = '\0';
+	}
+	DBG_PRN("\nindex=%d\tCurrent array: %s\n", strnCount, cmd);
+
+	if (strnCount >= BUF_SIZE) {
+		executeCmd(&cmd[0], strnCount);
+		dbg_printf("Buffer full.. Trying to execute command\n");
+		strnCount = 0;
+
+		for (i = 0; i < BUF_SIZE; i++)
+			cmd[i] = '\0';
+	}
+	return 1;
+}
+
+subsys_initcall(pm_sysrq_init);
--- a/arch/arm/Makefile	2018-11-23 10:16:13.320975805 +0300
+++ a/arch/arm/Makefile	2018-11-23 10:31:03.763053072 +0300
@@ -148,9 +148,11 @@
 textofs-$(CONFIG_ARCH_MSM8X60) := 0x00208000
 textofs-$(CONFIG_ARCH_MSM8960) := 0x00208000
 textofs-$(CONFIG_ARCH_AXXIA) := 0x00308000
+textofs-$(CONFIG_ARCH_PENTAGRAM)  := 0x00308000
 
 # Machine directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
+machine-$(CONFIG_ARCH_PENTAGRAM)	+= pentagram
 machine-$(CONFIG_ARCH_ALPINE)		+= alpine
 machine-$(CONFIG_ARCH_ARTPEC)		+= artpec
 machine-$(CONFIG_ARCH_AT91)		+= at91
--- a/Documentation/devicetree/bindings/vendor-prefixes.txt	2018-11-23 10:16:13.199982993 +0300
+++ a/Documentation/devicetree/bindings/vendor-prefixes.txt	2018-11-23 10:31:03.824049446 +0300
@@ -306,6 +306,7 @@
 stericsson	ST-Ericsson
 summit	Summit microelectronics
 sunchip	Shenzhen Sunchip Technology Co., Ltd
+sunplus	Sunplus Technology Co., Ltd.
 SUNW	Sun Microsystems, Inc
 swir	Sierra Wireless
 syna	Synaptics Inc.
--- a/drivers/clk/clk-sp-q628.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/clk/clk-sp-q628.c	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,716 @@
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <mach/io_map.h>
+#include <dt-bindings/clock/sp-q628.h>
+
+#define TRACE	pr_info("### %s:%d (%d)\n", __FUNCTION__, __LINE__, (clk->reg - REG(4, 0)) / 4)
+//#define TRACE
+
+#define MASK_SET(shift, width, value) \
+({ \
+	u32 m = ((1 << (width)) - 1) << (shift); \
+	(m << 16) | (((value) << (shift)) & m); \
+})
+#define MASK_GET(shift, width, value)	(((value) >> (shift)) & ((1 << (width)) - 1))
+
+#define REG(g, i)	((void __iomem *)VA_IOB_ADDR(((g) * 32 + (i)) * 4))
+
+#define PLLA_CTL	REG(4, 7)
+#define PLLE_CTL	REG(4, 12)
+#define PLLF_CTL	REG(4, 13)
+#define PLLTV_CTL	REG(4, 14)
+#define PLLSYS_CTL	REG(4, 26)
+
+#define EXTCLK		"extclk"
+
+/* speical div_width values for PLLTV/PLLA */
+#define DIV_TV	33
+#define DIV_A	34
+
+/* PLLTV parameters */
+enum {
+	SEL_FRA,
+	SDM_MOD,
+	PH_SEL,
+	NFRA,
+	DIVR,
+	DIVN,
+	DIVM,
+	P_MAX
+};
+
+struct sp_pll {
+	struct clk_hw	hw;
+	void __iomem	*reg;
+	spinlock_t		*lock;
+	int				pd_bit;		/* power down bit idx */
+	int				bp_bit;		/* bypass bit idx */
+	unsigned long	brate;		/* base rate, FIXME: replace brate with muldiv */
+	int				div_shift;
+	int				div_width;
+	u32 			p[P_MAX];	/* for hold PLLTV/PLLA parameters */
+};
+#define to_sp_pll(_hw)	container_of(_hw, struct sp_pll, hw)
+
+static u32 gates[] = {
+	SYSTEM,
+	RTC,
+	IOCTL,
+	IOP,
+	OTPRX,
+	NOC,
+	BR,
+	RBUS_L00,
+	SPIFL,
+	SDCTRL0,
+	PERI0,
+	A926,
+	UMCTL2,
+	PERI1,
+
+	DDR_PHY0,
+	ACHIP,
+	STC0,
+	STC_AV0,
+	STC_AV1,
+	STC_AV2,
+	UA0,
+	UA1,
+	UA2,
+	UA3,
+	UA4,
+	HWUA,
+	DDC0,
+	UADMA,
+
+	CBDMA0,
+	CBDMA1,
+	SPI_COMBO_0,
+	SPI_COMBO_1,
+	SPI_COMBO_2,
+	SPI_COMBO_3,
+	AUD,
+	USBC0,
+	USBC1,
+	UPHY0,
+	UPHY1,
+
+	I2CM0,
+	I2CM1,
+	I2CM2,
+	I2CM3,
+	PMC,
+	CARD_CTL0,
+	CARD_CTL1,
+
+	CARD_CTL4,
+	BCH,
+	DDFCH,
+	CSIIW0,
+	CSIIW1,
+	MIPICSI0,
+	MIPICSI1,
+
+	HDMI_TX,
+	VPOST,
+
+	TGEN,
+	DMIX,
+	TCON,
+	INTERRUPT,
+
+	RGST,
+	GPIO,
+	RBUS_TOP,
+
+	MAILBOX,
+	SPIND,
+	I2C2CBUS,
+
+	OSD0,
+	DISP_PWM,
+	UADBG,
+	DUMMY_MASTER,
+	FIO_CTL,
+	FPGA,
+	L2SW,
+	ICM,
+	AXI_GLOBAL,
+};
+static struct clk *clks[CLK_MAX];
+static struct clk_onecell_data clk_data;
+
+static DEFINE_SPINLOCK(plla_lock);
+static DEFINE_SPINLOCK(plle_lock);
+static DEFINE_SPINLOCK(pllf_lock);
+static DEFINE_SPINLOCK(pllsys_lock);
+static DEFINE_SPINLOCK(plltv_lock);
+
+#define _M			1000000UL
+#define F_27M		(27 * _M)
+
+/************************************************* PLL_TV *************************************************/
+
+//#define PLLTV_STEP_DIR (?) /* Unit: HZ */
+
+/* TODO: set proper FVCO range */
+#define FVCO_MIN	(100 * _M)
+#define FVCO_MAX	(200 * _M)
+
+#define F_MIN		(FVCO_MIN / 8)
+#define F_MAX		(FVCO_MAX)
+
+static long plltv_integer_div(struct sp_pll *clk, unsigned long freq)
+{
+	/* valid m values: 27M must be divisible by m, 0 means end */
+	static const u32 m_table[] = {1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 0};
+	u32 m, n, r;
+#ifdef PLLTV_STEP_DIR
+	u32 step = (PLLTV_STEP_DIR > 0) ? PLLTV_STEP_DIR : -PLLTV_STEP_DIR;
+	int calc_times = 1000000 / step;
+#endif
+	unsigned long fvco, nf;
+
+	TRACE;
+
+	/* check freq */
+	if (freq < F_MIN) {
+		pr_warn("[%s:%d] freq:%lu < F_MIN:%lu, round up\n", __FUNCTION__, __LINE__, freq, F_MIN);
+		freq = F_MIN;
+	} else if (freq > F_MAX) {
+		pr_warn("[%s:%d] freq:%lu > F_MAX:%lu, round down\n", __FUNCTION__, __LINE__, freq, F_MAX);
+		freq = F_MAX;
+	}
+
+#ifdef PLLTV_STEP_DIR
+	if ((freq % step) != 0)
+		freq += step - (freq % step) + ((PLLTV_STEP_DIR > 0) ? 0 : PLLTV_STEP_DIR);
+#endif
+
+#ifdef PLLTV_STEP_DIR
+CALC:
+	if (!calc_times) {
+		pr_err("[%s:%d] freq:%lu out of recalc times\n", __FUNCTION__, __LINE__, freq);
+		return -ETIMEOUT;
+	}
+#endif
+
+	/* DIVR 0~3 */
+	for (r = 0; r <= 3; r++) {
+		fvco = freq << r;
+		if (fvco <= FVCO_MAX)
+			break;
+	}
+
+	/* DIVM */
+	for (m = 0; m_table[m]; m++) {
+		nf = fvco * m_table[m];
+		n = nf / F_27M;
+		if ((n * F_27M) == nf) {
+			break;
+		}
+	}
+	m = m_table[m];
+
+	if (!m) {
+#ifdef PLLTV_STEP_DIR
+		freq += PLLTV_STEP_DIR;
+		calc_times--;
+		goto CALC;
+#else
+		pr_err("[%s:%d] freq:%lu not found a valid setting\n", __FUNCTION__, __LINE__, freq);
+		return -EINVAL;
+#endif
+	}
+
+	/* save parameters */
+	clk->p[SEL_FRA] = 0;
+	clk->p[DIVR]    = r;
+	clk->p[DIVN]    = n;
+	clk->p[DIVM]    = m;
+
+	pr_info("[%s:%d]   M:%u N:%u R:%u   CKREF:%lu  FVCO:%lu  FCKOUT:%lu\n",
+		__FUNCTION__, __LINE__, m, n, r, fvco /m, fvco, freq);
+
+	return freq;
+}
+
+/* paramters for PLLTV fractional divider */
+/* FIXME: better parameter naming */
+static const u32 pt[][5] = {
+	/* conventional fractional */
+	{
+		1,			// factor
+		5,			// 5 * p0 (nint)
+		1,			// 1 * p0
+		F_27M,		// F_27M / p0
+		1,			// p0 / p2
+	},
+	/* phase rotation */
+	{
+		10,			// factor
+		54,			// 5.4 * p0 (nint)
+		2,			// 0.2 * p0
+		F_27M / 10,	// F_27M / p0
+		5,			// p0 / p2
+	},
+};
+static const u32 mods[] = { 91, 55 }; /* SDM_MOD mod values */
+
+static long plltv_fractional_div(struct sp_pll *clk, unsigned long freq)
+{
+	u32 m, r;
+	u32 nint, nfra;
+	u32 diff_min_quotient = 210000000, diff_min_remainder = 0;
+	u32 diff_min_sign = 0;
+	unsigned long fvco, nf, f, fout = 0;
+	int sdm, ph;
+
+	TRACE;
+#if 1
+	/* check freq */
+	if (freq < F_MIN) {
+		pr_warn("[%s:%d] freq:%lu < F_MIN:%lu, round up\n", __FUNCTION__, __LINE__, freq, F_MIN);
+		freq = F_MIN;
+	} else if (freq > F_MAX) {
+		pr_warn("[%s:%d] freq:%lu > F_MAX:%lu, round down\n", __FUNCTION__, __LINE__, freq, F_MAX);
+		freq = F_MAX;
+	}
+#endif
+
+	/* DIVR 0~3 */
+	for (r = 0; r <= 3; r++) {
+		fvco = freq << r;
+		if (fvco <= FVCO_MAX)
+			break;
+	}
+	pr_info("freq:%lu fvco:%lu R:%u\n", freq, fvco, r);
+	f = F_27M >> r;
+
+	/* PH_SEL 1/0 */
+	for (ph = 1; ph >= 0; ph--) {
+		const u32 *pp = pt[ph];
+#if 0
+		/* Q628: for nint == p1, saving time */
+		u32 ms = (F_27M * pp[1] / pp[0]) / fvco;
+		if (ms > 32)
+			ms &= ~1;
+		else if (!ms)
+			ms++;
+#else
+		u32 ms = 1;
+#endif
+
+		/* SDM_MOD 0/1 */
+		for (sdm = 0; sdm <= 1; sdm++) {
+			u32 mod = mods[sdm];
+
+			/* DIVM 1~32 */
+			for (m = ms; m <= 32; m++) {
+				u32 diff_freq;
+				u32 diff_freq_quotient = 0, diff_freq_remainder = 0;
+				u32 diff_freq_sign = 0; /* 0:Positive number, 1:Negative number */
+
+				nf = fvco * m;
+				nint = nf / pp[3];
+
+				if (nint < pp[1])
+					continue;
+				if (nint > pp[1])
+					break;
+
+				nfra = (((nf % pp[3]) * mod * pp[4]) + (F_27M / 2)) / F_27M;
+				if (nfra)
+					diff_freq = (f * (nint + pp[2]) / pp[0]) - (f * (mod - nfra) / mod / pp[4]);
+				else
+					diff_freq = (f * (nint) / pp[0]);
+
+				diff_freq_quotient  = diff_freq / m;
+				diff_freq_remainder = ((diff_freq % m) * 1000) / m;
+
+				pr_info("m = %d N.f = %2d.%03d%03d, nfra = %d/%d  fout = %u\n",
+					m, nint, (nfra * 1000) / mod, (((nfra * 1000) % mod) * 1000) / mod, nfra, mod, diff_freq_quotient);
+
+				if (freq > diff_freq_quotient) {
+					diff_freq_quotient  = freq - diff_freq_quotient - 1;
+					diff_freq_remainder = 1000 - diff_freq_remainder;
+					diff_freq_sign = 1;
+				} else {
+					diff_freq_quotient = diff_freq_quotient - freq;
+					diff_freq_sign = 0;
+				}
+
+				if ((diff_min_quotient > diff_freq_quotient) ||
+					((diff_min_quotient == diff_freq_quotient) && (diff_min_remainder > diff_freq_remainder))) {
+
+					/* found a closer freq, save parameters */
+					TRACE;
+					clk->p[SEL_FRA] = 1;
+					clk->p[SDM_MOD] = sdm;
+					clk->p[PH_SEL]  = ph;
+					clk->p[NFRA]    = nfra;
+					clk->p[DIVR]    = r;
+					clk->p[DIVM]    = m;
+
+					fout = diff_freq / m;
+					diff_min_quotient = diff_freq_quotient;
+					diff_min_remainder = diff_freq_remainder;
+					diff_min_sign = diff_freq_sign;
+				}
+			}
+		}
+	}
+
+	if (!fout) {
+		pr_err("[%s:%d] freq:%lu not found a valid setting\n", __FUNCTION__, __LINE__, freq);
+		return -EINVAL;
+	}
+
+	//pr_info("MOD:%u PH_SEL:%u NFRA:%u M:%u R:%u\n", mods[clk->p[SDM_MOD]], clk->p[PH_SEL], clk->p[NFRA], clk->p[DIVM], clk->p[DIVR]);
+
+	pr_info("[%s:%d] real out:%lu/%lu Hz(%u, %u, sign %u)\n",
+		__FUNCTION__, __LINE__, fout, freq, diff_min_quotient, diff_min_remainder, diff_min_sign);
+
+	return fout;
+}
+
+static long plltv_div(struct sp_pll *clk, unsigned long freq)
+{
+	TRACE;
+	if (freq % 100)
+		return plltv_fractional_div(clk, freq);
+	else
+		return plltv_integer_div(clk, freq);
+}
+
+static void plltv_set_rate(struct sp_pll *clk)
+{
+	u32 reg;
+
+	//pr_info("MOD:%u PH_SEL:%u NFRA:%u M:%u R:%u\n", mods[clk->p[SDM_MOD]], clk->p[PH_SEL], clk->p[NFRA], clk->p[DIVM], clk->p[DIVR]);
+	reg  = MASK_SET(1, 1, clk->p[SEL_FRA]);
+	reg |= MASK_SET(2, 1, clk->p[SDM_MOD]);
+	reg |= MASK_SET(4, 1, clk->p[PH_SEL]);
+	reg |= MASK_SET(6, 7, clk->p[NFRA]);
+	clk_writel(reg, clk->reg);
+
+	reg  = MASK_SET(7, 2, clk->p[DIVR]);
+	clk_writel(reg, clk->reg + 4);
+
+	reg  = MASK_SET(0, 8, clk->p[DIVN] - 1);
+	reg |= MASK_SET(8, 7, clk->p[DIVM] - 1);
+	clk_writel(reg, clk->reg + 8);
+}
+
+/************************************************* PLL_A *************************************************/
+
+/* from Q628_PLLs_REG_setting.xlsx */
+struct {
+	u32 rate;
+	u32 regs[5];
+} pa[] = {
+	{
+		.rate = 135475200,
+		.regs = {
+			0x4801,
+			0x02df,
+			0x248f,
+			0x0211,
+			0x33e9
+		}
+	},
+	{
+		.rate = 147456000,
+		.regs = {
+			0x4801,
+			0x1adf,
+			0x2490,
+			0x0349,
+			0x33e9
+		}
+	},
+};
+
+static void plla_set_rate(struct sp_pll *clk)
+{
+	const u32 *pp = pa[clk->p[0]].regs;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pa->regs); i++) {
+		clk_writel(0xffff0000 | pp[i], clk->reg + (i * 4));
+		pr_info("%04x\n", pp[i]);
+	}
+}
+
+static long plla_round_rate(struct sp_pll *clk, unsigned long rate)
+{
+	clk->p[0] = (rate >= 140000000);
+	return pa[clk->p[0]].rate;
+}
+
+/************************************************* SP_PLL *************************************************/
+
+static long sp_pll_calc_div(struct sp_pll *clk, unsigned long rate)
+{
+	u32 fbdiv;
+	u32 max = 1 << clk->div_width;
+
+    fbdiv = DIV_ROUND_CLOSEST(rate, clk->brate);
+    if (fbdiv > max)
+        fbdiv = max;
+
+	return fbdiv;
+}
+
+static long sp_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *prate)
+{
+	struct sp_pll *clk = to_sp_pll(hw);
+	long ret;
+
+	TRACE;
+	//pr_info("round_rate: %lu %lu\n", rate, *prate);
+
+	if (rate == *prate)
+		ret = *prate; /* bypass */
+	else if (clk->div_width == DIV_A) {
+		ret = plla_round_rate(clk, rate);
+	} else if (clk->div_width == DIV_TV) {
+		ret = plltv_div(clk, rate);
+		if (ret < 0)
+			ret = *prate;
+	} else
+		ret = sp_pll_calc_div(clk, rate) * clk->brate;
+
+	return ret;
+}
+
+static unsigned long sp_pll_recalc_rate(struct clk_hw *hw,
+		unsigned long prate)
+{
+	struct sp_pll *clk = to_sp_pll(hw);
+	u32 reg = clk_readl(clk->reg);
+	unsigned long ret;
+
+	//TRACE;
+	if (reg & BIT(clk->bp_bit))
+		ret = prate; /* bypass */
+	else if (clk->div_width == DIV_A) {
+		ret = pa[clk->p[0]].rate;
+		//reg = clk_readl(clk->reg + 12); // G4.10 K_SDM_A
+	} else if (clk->div_width == DIV_TV) {
+		u32 m, r, reg2;
+
+		//pr_info("!!!!!!! %p:%p %08x\n", clk, clk->reg, reg);
+		r = MASK_GET(7, 2, clk_readl(clk->reg + 4));
+		reg2 = clk_readl(clk->reg + 8);
+		m = MASK_GET(8, 7, reg2) + 1;
+
+		if (reg & BIT(1)) { /* SEL_FRA */
+			/* fractional divider */
+			u32 sdm  = MASK_GET(2, 1, reg);
+			u32 ph   = MASK_GET(4, 1, reg);
+			u32 nfra = MASK_GET(6, 7, reg);
+			const u32 *pp = pt[ph];
+			//pr_info("MOD:%u PH_SEL:%u NFRA:%u M:%u R:%u\n", mods[sdm], ph, nfra, m, r);
+			ret = prate >> r;
+			ret = (ret * (pp[1] + pp[2]) / pp[0]) - (ret * (mods[sdm] - nfra) / mods[sdm] / pp[4]);
+			ret /= m;
+		} else {
+			/* integer divider */
+			u32 n = MASK_GET(0, 8, reg2) + 1;
+			ret = (prate / m * n) >> r;
+		}
+	} else {
+		u32 fbdiv = MASK_GET(clk->div_shift, clk->div_width, reg) + 1;
+ 		ret = clk->brate * fbdiv;
+ 	}
+	//pr_info("recalc_rate: %lu -> %lu\n", prate, ret);
+
+	return ret;
+}
+
+static int sp_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	struct sp_pll *clk = to_sp_pll(hw);
+	unsigned long flags;
+	u32 reg;
+
+	//TRACE;
+	pr_info("set_rate: %lu -> %lu\n", prate, rate);
+
+	spin_lock_irqsave(clk->lock, flags);
+
+	reg = BIT(clk->bp_bit + 16); /* HIWORD_MASK */
+
+	if (rate == prate)
+		reg |= BIT(clk->bp_bit); /* bypass */
+	else if (clk->div_width == DIV_A)
+		plla_set_rate(clk);
+	else if (clk->div_width == DIV_TV)
+		plltv_set_rate(clk);
+	else if (clk->div_width) {
+		u32 fbdiv = sp_pll_calc_div(clk, rate);
+		reg |= MASK_SET(clk->div_shift, clk->div_width, fbdiv - 1);
+	}
+
+	clk_writel(reg, clk->reg);
+
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+static int sp_pll_enable(struct clk_hw *hw)
+{
+	struct sp_pll *clk = to_sp_pll(hw);
+	unsigned long flags;
+
+	TRACE;
+	spin_lock_irqsave(clk->lock, flags);
+	clk_writel(BIT(clk->pd_bit + 16) | BIT(clk->pd_bit), clk->reg); /* power up */
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+static void sp_pll_disable(struct clk_hw *hw)
+{
+	struct sp_pll *clk = to_sp_pll(hw);
+	unsigned long flags;
+
+	TRACE;
+	spin_lock_irqsave(clk->lock, flags);
+	clk_writel(BIT(clk->pd_bit + 16), clk->reg); /* power down */
+	spin_unlock_irqrestore(clk->lock, flags);
+}
+
+static int sp_pll_is_enabled(struct clk_hw *hw)
+{
+	struct sp_pll *clk = to_sp_pll(hw);
+	return clk_readl(clk->reg) & BIT(clk->pd_bit);
+}
+
+static const struct clk_ops sp_pll_ops = {
+	.enable = sp_pll_enable,
+	.disable = sp_pll_disable,
+	.is_enabled = sp_pll_is_enabled,
+	.round_rate = sp_pll_round_rate,
+	.recalc_rate = sp_pll_recalc_rate,
+	.set_rate = sp_pll_set_rate
+};
+
+static const struct clk_ops sp_pll_sub_ops = {
+	.enable = sp_pll_enable,
+	.disable = sp_pll_disable,
+	.is_enabled = sp_pll_is_enabled,
+	.recalc_rate = sp_pll_recalc_rate,
+};
+
+struct clk *clk_register_sp_pll(const char *name, const char *parent,
+		void __iomem *reg, int pd_bit, int bp_bit,
+		unsigned long brate, int shift, int width,
+		spinlock_t *lock)
+{
+	struct sp_pll *pll;
+	struct clk *clk;
+	//unsigned long flags = 0;
+	struct clk_init_data initd = {
+		.name = name,
+		.parent_names = &parent,
+		.ops = (bp_bit >= 0) ? &sp_pll_ops : &sp_pll_sub_ops,
+		.num_parents = 1,
+		.flags = CLK_IGNORE_UNUSED
+	};
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+
+	if (reg == PLLSYS_CTL)
+		initd.flags |= CLK_IS_CRITICAL;
+
+	pll->hw.init = &initd;
+	pll->reg = reg;
+	pll->pd_bit = pd_bit;
+	pll->bp_bit = bp_bit;
+	pll->brate = brate;
+	pll->div_shift = shift;
+	pll->div_width = width;
+	pll->lock = lock;
+
+	clk = clk_register(NULL, &pll->hw);
+	if (WARN_ON(IS_ERR(clk))) {
+		kfree(pll);
+	} else {
+		pr_info("%-20s%lu\n", name, clk_get_rate(clk));
+		clk_register_clkdev(clk, NULL, name);
+	}
+
+	return clk;
+}
+
+static void __init sp_clk_setup(struct device_node *np)
+{
+	int i, j;
+	pr_info("@@@ Sunplus clock init\n");
+
+	/* TODO: PLLs initial */
+
+	/* PLL_A */
+	clks[PLL_A] = clk_register_sp_pll("plla", EXTCLK,
+			PLLA_CTL, 11, 12, 27000000, 0, DIV_A, &plla_lock);
+
+	/* PLL_E */
+	clks[PLL_E] = clk_register_sp_pll("plle", EXTCLK,
+			PLLE_CTL, 6, 2, 50000000, 0, 0, &plle_lock);
+	clks[PLL_E_2P5] = clk_register_sp_pll("plle_2p5", "plle",
+			PLLE_CTL, 13, -1, 2500000, 0, 0, &plle_lock);
+	clks[PLL_E_25] = clk_register_sp_pll("plle_25", "plle",
+			PLLE_CTL, 12, -1, 25000000, 0, 0, &plle_lock);
+	clks[PLL_E_112P5] = clk_register_sp_pll("plle_112p5", "plle",
+			PLLE_CTL, 11, -1, 112500000, 0, 0, &plle_lock);
+
+	/* PLL_F */
+	clks[PLL_F] = clk_register_sp_pll("pllf", EXTCLK,
+			PLLF_CTL, 0, 10, 13500000, 1, 4, &pllf_lock);
+
+	/* PLL_TV */
+	clks[PLL_TV] = clk_register_sp_pll("plltv", EXTCLK,
+			PLLTV_CTL, 0, 15, 27000000, 0, DIV_TV, &plltv_lock);
+	clks[PLL_TV_A] = clk_register_divider(NULL, "plltv_a", "plltv", 0,
+			PLLTV_CTL + 4, 5, 1,
+			CLK_DIVIDER_POWER_OF_TWO, &plltv_lock);
+	clk_register_clkdev(clks[PLL_TV_A], NULL, "plltv_a");
+
+	/* PLL_SYS */
+	clks[PLL_SYS] = clk_register_sp_pll("pllsys", EXTCLK,
+			PLLSYS_CTL, 10, 9, 13500000, 0, 4, &pllsys_lock);
+
+	/* gates */
+	for (i = 0; i < ARRAY_SIZE(gates); i++) {
+		char s[10];
+		j = gates[i];
+		sprintf(s, "clken%02x", j);
+		clks[j] = clk_register_gate(NULL, s, "pllsys", CLK_IGNORE_UNUSED,
+			REG(0, j >> 4), j & 0x0f,
+			CLK_GATE_HIWORD_MASK, NULL);
+		//printk("%02x %p %p.%d\n", j, clks[j], REG(0, j >> 4), j & 0x0f);
+	}
+
+	clk_data.clks = clks;
+	clk_data.clk_num = ARRAY_SIZE(clks);
+	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
+}
+
+CLK_OF_DECLARE(sp_clkc, "sunplus,sp-clkc", sp_clk_setup);
+
--- a/drivers/clk/Makefile	2018-11-23 10:16:14.153926323 +0300
+++ a/drivers/clk/Makefile	2018-11-23 10:31:03.813050099 +0300
@@ -42,6 +42,7 @@
 obj-$(CONFIG_COMMON_CLK_SI5351)		+= clk-si5351.o
 obj-$(CONFIG_COMMON_CLK_SI514)		+= clk-si514.o
 obj-$(CONFIG_COMMON_CLK_SI570)		+= clk-si570.o
+obj-$(CONFIG_ARCH_PENTAGRAM)	+= clk-sp-q628.o
 obj-$(CONFIG_ARCH_STM32)		+= clk-stm32f4.o
 obj-$(CONFIG_ARCH_TANGO)		+= clk-tango4.o
 obj-$(CONFIG_CLK_TWL6040)		+= clk-twl6040.o
--- a/drivers/clocksource/Kconfig	2018-11-23 10:16:14.184924482 +0300
+++ a/drivers/clocksource/Kconfig	2018-11-23 10:31:03.770052656 +0300
@@ -612,4 +612,7 @@
 	  Enable this option to use the Low Power controller timer
 	  as clocksource.
 
+config CLKSRC_SP_TIMER
+	bool "Clocksource using Sunplus STC timer"
+
 endmenu
--- a/drivers/clocksource/Makefile	2018-11-23 10:16:14.184924482 +0300
+++ a/drivers/clocksource/Makefile	2018-11-23 10:31:03.770052656 +0300
@@ -73,3 +73,4 @@
 obj-$(CONFIG_H8300_TPU)			+= h8300_tpu.o
 obj-$(CONFIG_CLKSRC_ST_LPC)		+= clksrc_st_lpc.o
 obj-$(CONFIG_X86_NUMACHIP)		+= numachip.o
+obj-$(CONFIG_CLKSRC_SP_TIMER)		+= sp_timer.o
--- a/drivers/clocksource/sp_stc.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/clocksource/sp_stc.h	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,102 @@
+#ifndef __SP_STC_H__
+#define __SP_STC_H__
+
+#include <mach/io_map.h>
+
+#if 0 // moved to DT
+#define LOGI_ADDR_INT_CTRL_G0_REG		(VA_IOB_ADDR(0) +  9 * 32 * 4)
+#define LOGI_ADDR_INT_CTRL_G1_REG		(VA_IOB_ADDR(0) + 10 * 32 * 4)
+#define LOGI_ADDR_STC_REG			(VA_IOB_ADDR(0) + 12 * 32 * 4)
+#define LOGI_ADDR_STC_AV1_REG			(VA_IOB_ADDR(0) + 97 * 32 * 4)
+#define LOGI_ADDR_STC_AV2_REG			(VA_IOB_ADDR(0) + 99 * 32 * 4)
+#endif
+
+typedef struct stcReg_s {
+	/* Group 12: STC */
+	volatile unsigned int stc_15_0;
+	volatile unsigned int stc_31_16;
+	volatile unsigned int stc_32;
+	volatile unsigned int stc_divisor;
+	volatile unsigned int rtc_15_0;
+	volatile unsigned int rtc_23_16;
+	volatile unsigned int rtc_divisor;
+	volatile unsigned int stc_config;
+	volatile unsigned int timer0_ctrl;
+	volatile unsigned int timer0_cnt;
+	volatile unsigned int timer1_ctrl;
+	volatile unsigned int timer1_cnt;
+	volatile unsigned int timerw_ctrl;
+	volatile unsigned int timerw_cnt;
+	volatile unsigned int g12_reserved_0[2];
+	volatile unsigned int timer2_ctrl;
+	volatile unsigned int timer2_divisor;
+	volatile unsigned int timer2_reload;
+	volatile unsigned int timer2_cnt;
+	volatile unsigned int timer3_ctrl;
+	volatile unsigned int timer3_divisor;
+	volatile unsigned int timer3_reload;
+	volatile unsigned int timer3_cnt;
+	volatile unsigned int stcl_0;
+	volatile unsigned int stcl_1;
+	volatile unsigned int stcl_2;
+	volatile unsigned int atc_0;
+	volatile unsigned int atc_1;
+	volatile unsigned int atc_2;
+	volatile unsigned int g12_reserved_1[2];
+} stcReg_t;
+
+typedef struct stc_avReg_s {
+	/* Group 96, 97, 99: STC_AV0 - STC_AV2 */
+	volatile unsigned int stc_15_0;
+	volatile unsigned int stc_31_16;
+	volatile unsigned int stc_64;
+	volatile unsigned int stc_divisor;
+	volatile unsigned int rtc_15_0;
+	volatile unsigned int rtc_23_16;
+	volatile unsigned int rtc_divisor;
+	volatile unsigned int stc_config;
+	volatile unsigned int timer0_ctrl;
+	volatile unsigned int timer0_cnt;
+	volatile unsigned int timer1_ctrl;
+	volatile unsigned int timer1_cnt;
+	volatile unsigned int rsv_12;
+	volatile unsigned int rsv_13;
+	volatile unsigned int stc_47_32;
+	volatile unsigned int stc_63_48;
+	volatile unsigned int timer2_ctrl;
+	volatile unsigned int timer2_divisor;
+	volatile unsigned int timer2_reload;
+	volatile unsigned int timer2_cnt;
+	volatile unsigned int timer3_ctrl;
+	volatile unsigned int timer3_divisor;
+	volatile unsigned int timer3_reload;
+	volatile unsigned int timer3_cnt;
+	volatile unsigned int stcl_0;
+	volatile unsigned int stcl_1;
+	volatile unsigned int stcl_2;
+	volatile unsigned int atc_0;
+	volatile unsigned int atc_1;
+	volatile unsigned int atc_2;
+	volatile unsigned int rsv_30;
+	volatile unsigned int rsv_31;
+} stc_avReg_t;
+
+#define SP_STC_TIMER0CTL_SRC_STC		(1 << 14)
+#define SP_STC_TIMER0CTL_SRC_RTC		(2 << 14)
+#define SP_STC_TIMER0CTL_RTP			(1 << 13)
+#define SP_STC_TIMER0CTL_GO			(1 << 11)
+#define SP_STC_TIMER0CTL_TM0_RELOAD_MASK	(0x07FF << 0)
+
+#define SP_STC_AV_TIMER01_CTL_SRC_SYS		(0 << 14)
+#define SP_STC_AV_TIMER01_CTL_SRC_STC		(1 << 14)
+#define SP_STC_AV_TIMER01_CTL_SRC_RTC		(2 << 14)
+#define SP_STC_AV_TIMER01_CTL_RTP		(1 << 13)
+#define SP_STC_AV_TIMER01_CTL_GO		(1 << 11)
+#define SP_STC_AV_TIMER01_CTL_RELOAD_MASK	(0x07FF << 0)
+
+#define SP_STC_AV_TIMER23_CTL_SRC_SYS		(0 << 2)
+#define SP_STC_AV_TIMER23_CTL_SRC_STC		(1 << 2)
+#define SP_STC_AV_TIMER23_CTL_RPT		(1 << 1)
+#define SP_STC_AV_TIMER23_CTL_GO		(1 << 0)
+
+#endif /* __SP_STC_H__ */
--- a/drivers/clocksource/sp_timer.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/clocksource/sp_timer.c	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,273 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/jiffies.h>
+#include <linux/uaccess.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/sched_clock.h>
+#include <asm/mach/time.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include "sp_stc.h"
+
+#define SP_STC_AV2_FREQ	(13500000)		/* 13.5 MHz */
+
+static void __iomem *sp_timer_base;
+
+enum {
+	SP_TIMER_AV2_TIMER0,
+	SP_TIMER_AV2_TIMER1,
+	SP_TIMER_AV2_TIMER2,
+	SP_TIMER_AV2_TIMER3,
+	SP_TIMER_NR_IRQS,
+};
+static int sp_timer_irqs[SP_TIMER_NR_IRQS];
+
+/***************************
+ * Timer3
+ ***************************/
+
+static void sp_stc_av2_timer3_start(struct clock_event_device *evt, unsigned long cycles, int periodic)
+{
+	stc_avReg_t *pstc_avReg = (stc_avReg_t *)sp_timer_base;
+	u32 div;
+
+	/* printk(KERN_INFO "%s: mode: %d, cycles = %u\n", __func__, (int)(evt->mode), (u32)(cycles)); */
+
+	pstc_avReg->timer3_ctrl = 0;
+
+	if (!periodic) {
+		/*
+		 * timer3_cnt only has 16 bits.
+		 * When (cycles > (1 << 16)), timer3_divisor is required.
+		 * => the precision is lower.
+		 */
+		div = (cycles >> 16) + 1;
+		pstc_avReg->timer3_divisor = div - 1;
+		/* a little larger than setting, make sure the ISR will see tasks' timeout as expected */
+		pstc_avReg->timer3_reload = ((u32)(cycles) + div) / div - 1;
+
+		pstc_avReg->timer3_cnt = pstc_avReg->timer3_reload;
+		pstc_avReg->timer3_ctrl = SP_STC_AV_TIMER23_CTL_SRC_STC | SP_STC_AV_TIMER23_CTL_GO;
+	} else { //if (evt->mode == CLOCK_EVT_MODE_PERIODIC) {
+#if (SP_STC_AV2_FREQ == 1000000)
+		pstc_avReg->timer3_divisor = 0;	/* CLKthis = CLKstc*/
+		pstc_avReg->timer3_reload = SP_STC_AV2_FREQ/HZ - 1;
+#elif (SP_STC_AV2_FREQ == 13500000)
+		pstc_avReg->timer3_divisor = 3;	/* CLKthis = CLKstc / 4 */
+		pstc_avReg->timer3_reload = (SP_STC_AV2_FREQ / HZ / 4) - 1;
+#elif (SP_STC_AV2_FREQ == 270000000)
+		pstc_avReg->timer3_divisor = 1000 - 1;	/* CLKthis = CLKstc / 1000 */
+		pstc_avReg->timer3_reload = ((SP_STC_AV2_FREQ / 1000) / HZ) - 1;
+#else
+#error Unexpected STC frequency
+#endif
+		pstc_avReg->timer3_cnt = pstc_avReg->timer3_reload;
+		pstc_avReg->timer3_ctrl = SP_STC_AV_TIMER23_CTL_SRC_STC | SP_STC_AV_TIMER23_CTL_RPT | SP_STC_AV_TIMER23_CTL_GO;
+	}
+}
+
+static int sp_stc_av2_timer3_event_set_next_event(unsigned long cycles, struct clock_event_device *evt)
+{
+	sp_stc_av2_timer3_start(evt, cycles, 0);
+	return 0;
+}
+
+static int sp_stc_av2_timer3_set_oneshot(struct clock_event_device *evt)
+{
+	sp_stc_av2_timer3_start(evt, ~0, 0);	/* max. cycle, should be updated by .set_next_event() */
+	return 0;
+}
+
+static int sp_stc_av2_timer3_set_period(struct clock_event_device *evt)
+{
+	sp_stc_av2_timer3_start(evt, ~0, 1);	/* max. cycle, should be updated by .set_next_event() */
+	return 0;
+}
+
+static int sp_stc_av2_timer3_shutdown(struct clock_event_device *clkevt)
+{
+	stc_avReg_t *pstc_avReg = (stc_avReg_t *)sp_timer_base;
+	pstc_avReg->timer3_ctrl = 0;
+	return 0;
+}
+
+static struct clock_event_device sp_clockevent_dev_av2_timer3 = {
+	.name		= "sp_stc_av2_timer3_event",
+	.features	= CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC,
+	.rating		= 350,
+	.set_next_event	= sp_stc_av2_timer3_event_set_next_event,
+	.set_state_periodic = sp_stc_av2_timer3_set_period,
+	.set_state_oneshot = sp_stc_av2_timer3_set_oneshot,
+	.set_state_shutdown = sp_stc_av2_timer3_shutdown,
+};
+
+static irqreturn_t sp_stc_av2_timer3_isr(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &sp_clockevent_dev_av2_timer3;
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction sp_stc_av2_timer3_irq = {
+	.name		= "sp_stc_av2_timer3",
+	.flags		= IRQF_TIMER | IRQF_IRQPOLL | IRQF_TRIGGER_RISING,
+	.handler	= sp_stc_av2_timer3_isr,
+	.dev_id		= &sp_clockevent_dev_av2_timer3,
+};
+
+static void sp_clockevent_init(void)
+{
+	int ret;
+	stc_avReg_t *pstc_avReg = (stc_avReg_t *)sp_timer_base;
+	int bc_late = 0;
+
+	pstc_avReg->timer3_ctrl = 0;
+
+	sp_stc_av2_timer3_irq.irq = sp_timer_irqs[SP_TIMER_AV2_TIMER3];
+	BUG_ON(!sp_stc_av2_timer3_irq.irq);
+
+	sp_clockevent_dev_av2_timer3.irq = sp_stc_av2_timer3_irq.irq;
+	if (irq_can_set_affinity(sp_clockevent_dev_av2_timer3.irq)) {
+		sp_clockevent_dev_av2_timer3.cpumask = cpu_possible_mask;
+	} else {
+		sp_clockevent_dev_av2_timer3.cpumask = cpumask_of(0);
+		bc_late = 1;
+	}
+
+#if (SP_STC_AV2_FREQ == 1000000)
+	clockevents_config_and_register(&sp_clockevent_dev_av2_timer3, SP_STC_AV2_FREQ, 1, ((1 << 16) - 1));
+#elif (SP_STC_AV2_FREQ == 13500000)
+	/* 28 bits > 16 bits counter => timer3_divisor is required. */
+	clockevents_config_and_register(&sp_clockevent_dev_av2_timer3, SP_STC_AV2_FREQ, 1, ((1 << 28) - 1));
+#elif (SP_STC_AV2_FREQ == 270000000)
+	/* 28 bits > 16 bits counter => timer3_divisor is required. */
+	clockevents_config_and_register(&sp_clockevent_dev_av2_timer3, SP_STC_AV2_FREQ, 1, ((1 << 28) - 1));
+#else
+#error Unexpected STC frequency
+#endif
+
+	if (bc_late)
+		sp_clockevent_dev_av2_timer3.cpumask = cpu_possible_mask;
+
+	ret = setup_irq(sp_stc_av2_timer3_irq.irq, &sp_stc_av2_timer3_irq);
+	if (ret) {
+		printk(KERN_ERR "%s, %d: reg = %d\n", __FILE__, __LINE__, ret);
+		BUG();
+	}
+}
+
+u64 sp_read_sched_clock(void)
+{
+	stc_avReg_t *pstc_avReg = (stc_avReg_t *)sp_timer_base;
+
+	pstc_avReg->stcl_2 = 0;
+	wmb();		/* Let the STC register accesses be in-order */
+
+	return ((pstc_avReg->stcl_0) | ((pstc_avReg->stcl_1) << 16));
+}
+
+u64 sp_clocksource_hz_read(struct clocksource *cs)
+{
+	return sp_read_sched_clock();
+}
+
+static void sp_clocksource_hw_init(void)
+{
+	stc_avReg_t *pstc_avReg = (stc_avReg_t *)sp_timer_base;
+	//u32 system_clk = 0; // Read freq from DT if needed
+
+	/*
+	 * STC_AV2 (Group 99):
+	 * STC: clock source for scheduler and jiffies (HZ)
+	 * timer0/1: Unused.
+	 * timer2: event for jiffies (if ENABLE_SP_STC_AV2_TIMER2 defined)
+	 * timer3: event for jiffies/hrtimer
+	 */
+#if (SP_STC_AV2_FREQ == 1000000)
+	pstc_avReg->stc_divisor = (system_clk / SP_STC_AV2_FREQ) - 1;	/* CLKstc = 1 us */
+#elif (SP_STC_AV2_FREQ == 13500000)
+	pstc_avReg->stc_divisor = (1 << 15);				/* CLKstc = (1 / 13500000) s */
+#elif (SP_STC_AV2_FREQ == 270000000)
+	system_clk = sp_clk_get(SP_CLK_SYSSLOW);
+	pstc_avReg->stc_divisor = (system_clk / SP_STC_AV2_FREQ) - 1;	/* CLKstc = CLKsys */
+#else
+#error Unexpected STC frequency
+#endif
+	pstc_avReg->stc_64 = 0;	/* reset STC and start counting*/
+}
+
+static void sp_clocksource_resume(struct clocksource *cs)
+{
+	sp_clocksource_hw_init();
+}
+
+struct clocksource sp_clocksource_hz = {
+	.name	= "sp_clocksource_hz",
+#if (SP_STC_AV2_FREQ == 1000000)
+	.rating	= 250,
+#elif (SP_STC_AV2_FREQ == 13500000)
+	.rating	= 350,
+#elif (SP_STC_AV2_FREQ == 270000000)
+	.rating	= 350,
+#else
+#error Unexpected STC frequency
+#endif
+	.read	= sp_clocksource_hz_read,
+	.mask	= CLOCKSOURCE_MASK(32),
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+	.resume	= sp_clocksource_resume,
+};
+
+static void __init sp_clocksource_init(void)
+{
+	u64 (*func_ptr)(void);
+
+	func_ptr = sp_read_sched_clock;
+	sp_clocksource_hw_init();
+	sched_clock_register(func_ptr, 32, SP_STC_AV2_FREQ);
+
+	if (clocksource_register_hz(&sp_clocksource_hz, SP_STC_AV2_FREQ))
+		panic("%s: can't register clocksource\n", sp_clocksource_hz.name);
+}
+
+void __init sp_timer_init(void)
+{
+	sp_clocksource_init();
+	sp_clockevent_init();
+}
+
+static int __init sp_timer_init_of(struct device_node *np)
+{
+	u32 nr_irqs, i;
+
+	nr_irqs = of_irq_count(np);
+
+	for (i = SP_TIMER_AV2_TIMER0; i < nr_irqs; i++) {
+		sp_timer_irqs[i] = irq_of_parse_and_map(np, i);
+		WARN(!sp_timer_irqs[i], "%s: no IRQ for timer%d", __func__, i);
+	}
+
+	sp_timer_base = of_iomap(np, 0);
+	if (!sp_timer_base)
+		panic("%s: Could not ioremap system timer base\n", __func__);
+
+	sp_clocksource_init();
+	sp_clockevent_init();
+
+	return 0;
+}
+
+CLOCKSOURCE_OF_DECLARE(sp_timer, "sunplus,sp-stc", sp_timer_init_of);
--- a/drivers/irqchip/irq-sp-intc.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/irqchip/irq-sp-intc.c	2018-11-12 06:42:53.000000000 +0300
@@ -0,0 +1,321 @@
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <asm/io.h>
+#include <asm/exception.h>
+#include <asm/mach/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#define dprn(...)            /* empty */
+//#define dprn(fmt, arg...)  early_printk(fmt, ##arg)
+
+#define SP_INTC_HWIRQ_MIN     0
+#define SP_INTC_HWIRQ_MAX     223
+
+struct intG0Reg_st {
+	/* Interrupt G0 */
+	volatile unsigned int intr_type[7];
+	volatile unsigned int intr_polarity[7];
+	volatile unsigned int priority[7];
+	volatile unsigned int intr_mask[7];
+	volatile unsigned int g15_reserved_0[4];
+};
+
+struct intG1Reg_st {
+	/* Interrupt G1 */
+	volatile unsigned int intr_clr[7];
+	volatile unsigned int masked_fiqs[7];
+	volatile unsigned int masked_irqs[7];
+	volatile unsigned int g21_reserved_0[10];
+	volatile unsigned int intr_group;
+};
+
+static struct sp_intctl {
+	__iomem struct intG0Reg_st *g0;
+	__iomem struct intG1Reg_st *g1;
+	 int hwirq_start;
+	 int hwirq_end;   /* exclude */
+	 struct irq_domain *domain;
+} sp_intc;
+
+
+static void sp_intc_ack_irq(struct irq_data *data);
+static void sp_intc_mask_irq(struct irq_data *data);
+static void sp_intc_unmask_irq(struct irq_data *data);
+static int sp_intc_set_type(struct irq_data *data, unsigned int flow_type);
+
+static struct irq_chip sp_intc_chip = {
+	.name = "sp_intc",
+	.irq_ack = sp_intc_ack_irq,
+	.irq_mask = sp_intc_mask_irq,
+	.irq_unmask = sp_intc_unmask_irq,
+	.irq_set_type = sp_intc_set_type,
+};
+
+static void sp_intc_ack_irq(struct irq_data *data)
+{
+	u32 idx, mask;
+
+	dprn("%s: hwirq=%lu\n", __func__, data->hwirq);
+
+	if ((data->hwirq < sp_intc.hwirq_start) || (data->hwirq >= sp_intc.hwirq_end))
+		return;
+
+	idx = data->hwirq / 32;
+	mask = (1 << (data->hwirq % 32));
+
+	writel(mask, &sp_intc.g1->intr_clr[idx]);
+}
+
+static void sp_intc_mask_irq(struct irq_data *data)
+{
+	u32 idx, mask;
+
+	dprn("%s: hwirq=%lu\n", __func__, data->hwirq);
+
+	if ((data->hwirq < sp_intc.hwirq_start) || (data->hwirq >= sp_intc.hwirq_end))
+		return;
+
+	idx = data->hwirq / 32;
+	mask = readl(&sp_intc.g0->intr_mask[idx]);
+	mask &= ~(1 << (data->hwirq % 32));
+	writel(mask, &sp_intc.g0->intr_mask[idx]);
+}
+
+static void sp_intc_unmask_irq(struct irq_data *data)
+{
+	u32 idx, mask;
+
+	dprn("%s: hwirq=%lu\n", __func__, data->hwirq);
+
+	if ((data->hwirq < sp_intc.hwirq_start) || (data->hwirq >= sp_intc.hwirq_end))
+		return;
+
+	idx = data->hwirq / 32;
+	mask = readl(&sp_intc.g0->intr_mask[idx]);
+	mask |= (1 << (data->hwirq % 32));
+	writel(mask, &sp_intc.g0->intr_mask[idx]);
+}
+
+static int sp_intc_set_type(struct irq_data *data, unsigned int flow_type)
+{
+	u32 idx, mask;
+	u32 edge_type; /* 0=level, 1=edge */
+	u32 trig_lvl;  /* 0=high, 1=low */
+
+	dprn("%s: hwirq=%lu type=%u\n", __func__, data->hwirq, flow_type);
+
+	if ((data->hwirq < sp_intc.hwirq_start) || (data->hwirq >= sp_intc.hwirq_end))
+		return -EBADR;
+
+	/* update the chip/handler */
+	if (flow_type & IRQ_TYPE_LEVEL_MASK)
+		irq_set_chip_handler_name_locked(data, &sp_intc_chip,
+						   handle_level_irq, NULL);
+	else
+		irq_set_chip_handler_name_locked(data, &sp_intc_chip,
+						   handle_edge_irq, NULL);
+
+	idx = data->hwirq / 32;
+	edge_type = readl(&sp_intc.g0->intr_type[idx]);
+	trig_lvl = readl(&sp_intc.g0->intr_polarity[idx]);
+	mask = (1 << (data->hwirq % 32));
+
+	switch (flow_type) {
+	case IRQ_TYPE_EDGE_RISING:
+		writel((edge_type | mask), &sp_intc.g0->intr_type[idx]);
+		writel((trig_lvl & ~mask), &sp_intc.g0->intr_polarity[idx]);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		writel((edge_type | mask), &sp_intc.g0->intr_type[idx]);
+		writel((trig_lvl | mask), &sp_intc.g0->intr_polarity[idx]);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		writel((edge_type & ~mask), &sp_intc.g0->intr_type[idx]);
+		writel((trig_lvl & ~mask), &sp_intc.g0->intr_polarity[idx]);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		writel((edge_type & ~mask), &sp_intc.g0->intr_type[idx]);
+		writel((trig_lvl | mask), &sp_intc.g0->intr_polarity[idx]);
+		break;
+	default:
+		pr_err("%s: type=%d\n", __func__, flow_type);
+		return -EBADR;
+	}
+
+	return IRQ_SET_MASK_OK;
+}
+
+/* return -1 if no interrupt */
+static int sp_intc_get_hwirq(void)
+{
+	int hwirq, mask;
+	int i;
+
+	/* look up reg number i */
+#if defined(CONFIG_MACH_PENTAGRAM_SC7021_ACHIP) || defined(CONFIG_MACH_PENTAGRAM_SC7021_BCHIP)
+	mask = (readl(&sp_intc.g1->intr_group) >> 8) & 0x7f; /* [14:8] for irq group */
+	if (mask) {
+		i = fls(mask) - 1;
+#else
+	for (i = 0; i < 7; i++) {
+#endif
+		mask = readl(&sp_intc.g1->masked_irqs[i]);
+		if (mask) {
+			hwirq = (i << 5) + fls(mask) - 1;
+			dprn(" [%d]", hwirq);
+			return hwirq;
+		}
+	}
+	return -1;
+}
+
+static void sp_intc_handle_irq_cascaded(struct irq_desc *desc)
+{
+        struct irq_chip *host_chip = irq_desc_get_chip(desc);
+	int hwirq;
+
+        chained_irq_enter(host_chip, desc);
+
+	while ((hwirq = sp_intc_get_hwirq()) >= 0) {
+                generic_handle_irq(irq_find_mapping(sp_intc.domain, (unsigned int)hwirq));
+        }
+
+        chained_irq_exit(host_chip, desc);
+}
+
+static int sp_intc_handle_one_round(struct pt_regs *regs)
+{
+	int ret = -EINVAL;
+	int hwirq;
+
+	while ((hwirq = sp_intc_get_hwirq()) >= 0) {
+		handle_domain_irq(sp_intc.domain, hwirq, regs);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/* 8388: level-triggered hwirq# may come slower than IRQ */
+#define SPURIOUS_RETRY  30
+
+static void __exception_irq_entry sp_intc_handle_irq(struct pt_regs *regs)
+{
+	int err;
+	int first_int = 1;
+	int retry = 0;
+
+	dprn("%s\n", __func__);
+	do {
+		err = sp_intc_handle_one_round(regs);
+
+		if (!err)
+			first_int = 0;
+
+		if (first_int && err) { /* spurious irq */
+			dprn("+");
+			if (retry++ < SPURIOUS_RETRY)
+				continue;
+		}
+	} while (!err);
+}
+
+static int sp_intc_irq_domain_map(struct irq_domain *domain, unsigned int irq,
+                                  irq_hw_number_t hwirq)
+{
+	dprn("%s: irq=%d hwirq=%lu\n", __func__, irq, hwirq);
+
+	irq_set_chip_and_handler(irq, &sp_intc_chip, handle_level_irq);
+	irq_set_chip_data(irq, &sp_intc_chip);
+	irq_set_noprobe(irq);
+
+	return 0;
+}
+
+static void __init sp_intc_chip_init(int hwirq_start, int hwirq_end,
+				     void __iomem *base0, void __iomem *base1)
+{
+	int i;
+
+	sp_intc.g0 = base0;
+	sp_intc.g1 = base1;
+	sp_intc.hwirq_start = hwirq_start;
+	sp_intc.hwirq_end = hwirq_end;
+
+	for (i = 0; i < 7; i++) {
+		/* all mask */
+		writel_relaxed(0, &sp_intc.g0->intr_mask[i]);
+		/* all edge */
+		writel_relaxed(~0, &sp_intc.g0->intr_type[i]);
+		/* all high-active */
+		writel_relaxed(0, &sp_intc.g0->intr_polarity[i]);
+		/* all irq */
+		writel_relaxed(~0, &sp_intc.g0->priority[i]);
+		/* all clear */
+		writel_relaxed(~0, &sp_intc.g1->intr_clr[i]);
+	}
+}
+
+static struct irq_domain_ops sp_intc_dm_ops = {
+	.xlate = irq_domain_xlate_twocell,
+	.map = sp_intc_irq_domain_map,
+};
+
+int __init sp_intc_init(int hwirq_start, int irqs, void __iomem *base0, void __iomem *base1)
+{
+	dprn("%s\n", __func__);
+
+	sp_intc_chip_init(hwirq_start, hwirq_start + irqs, base0, base1);
+
+	sp_intc.domain = irq_domain_add_legacy(NULL, irqs, hwirq_start,
+			sp_intc.hwirq_start, &sp_intc_dm_ops, &sp_intc);
+	if (!sp_intc.domain)
+		panic("%s: unable to create legacy domain\n", __func__);
+
+	set_handle_irq(sp_intc_handle_irq);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+int __init sp_intc_init_dt(struct device_node *node, struct device_node *parent)
+{
+	void __iomem *base0, *base1;
+	int irq;
+
+	dprn("%s\n", __func__);
+
+	base0 = of_iomap(node, 0);
+	if (!base0)
+		panic("unable to map sp-intc base 0\n");
+
+	base1 = of_iomap(node, 1);
+	if (!base1)
+		panic("unable to map sp-intc base 1\n");
+
+	sp_intc_chip_init(SP_INTC_HWIRQ_MIN, SP_INTC_HWIRQ_MAX, base0, base1);
+
+	sp_intc.domain = irq_domain_add_linear(node, sp_intc.hwirq_end - sp_intc.hwirq_start,
+			&sp_intc_dm_ops, &sp_intc);
+	if (!sp_intc.domain)
+		panic("%s: unable to create linear domain\n", __func__);
+
+        if (parent) {
+		irq = irq_of_parse_and_map(node, 0);
+		if (irq) {
+			irq_set_chained_handler_and_data(irq,
+				sp_intc_handle_irq_cascaded, &sp_intc);
+		} else {
+			panic("%s: missed irq in DT\n", __func__);
+		}
+	} else {
+		set_handle_irq(sp_intc_handle_irq);
+	}
+
+        return 0;
+}
+IRQCHIP_DECLARE(sp_intc, "sunplus,sp-intc", sp_intc_init_dt);
+#endif
--- a/drivers/irqchip/Kconfig	2018-11-23 10:16:14.753890682 +0300
+++ a/drivers/irqchip/Kconfig	2018-11-23 10:31:03.778052180 +0300
@@ -301,3 +301,6 @@
 	help
 	  Say yes here to add support for the IRQ combiner devices embedded
 	  in Qualcomm Technologies chips.
+
+config SP_INTC
+	bool "Sunplus interrupt controller"
--- a/drivers/irqchip/Makefile	2018-11-23 10:16:14.753890682 +0300
+++ a/drivers/irqchip/Makefile	2018-11-23 10:31:03.778052180 +0300
@@ -76,3 +76,4 @@
 obj-$(CONFIG_ARCH_ASPEED)		+= irq-aspeed-vic.o
 obj-$(CONFIG_STM32_EXTI) 		+= irq-stm32-exti.o
 obj-$(CONFIG_QCOM_IRQ_COMBINER)		+= qcom-irq-combiner.o
+obj-$(CONFIG_SP_INTC)			+= irq-sp-intc.o
--- a/drivers/misc/Kconfig	2018-11-23 10:16:15.076871495 +0300
+++ a/drivers/misc/Kconfig	2018-11-23 10:31:03.772052537 +0300
@@ -4,6 +4,38 @@
 
 menu "Misc devices"
 
+config SP_IPC
+	tristate "Sunplus Mailbox (IPC) driver"
+	depends on ARCH_PENTAGRAM
+	default n
+
+config SP_IPC_TEST
+	bool "Sunplus Mailbox (IPC) test"
+	depends on SP_IPC
+	help
+	  echo 0 > /sys/module/sp_ipc/parameters/test
+
+config SP_ICM
+	tristate "Sunplus Input Capture (ICM) driver"
+	depends on ARCH_PENTAGRAM
+	default n
+
+config SP_ICM_TEST
+	bool "Sunplus Input Capture (ICM) test"
+	depends on SP_ICM
+	help
+	  echo h > /sys/module/sp_icm/parameters/test
+
+config SP_DMA0
+	tristate "Sunplus DMA0 driver"
+	depends on ARCH_PENTAGRAM
+
+config SP_DMA0_TEST
+	bool "Sunplus DMA0 test"
+	depends on SP_DMA0
+	help
+	  echo h > /sys/module/sp_dma0/parameters/test
+
 config SENSORS_LIS3LV02D
 	tristate
 	depends on INPUT
--- a/drivers/misc/Makefile	2018-11-23 10:16:15.076871495 +0300
+++ a/drivers/misc/Makefile	2018-11-23 10:31:03.771052596 +0300
@@ -59,6 +59,13 @@
 obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_ASPEED_LPC_CTRL)	+= aspeed-lpc-ctrl.o
 obj-$(CONFIG_PCI_ENDPOINT_TEST)	+= pci_endpoint_test.o
+# obj-y				+= sp_timer_test.o
+# obj-y				+= sp_cbdma_test.o
+# obj-y				+= sp_rtc_isr_test.o
+
+obj-$(CONFIG_SP_IPC) += sp_ipc.o
+obj-$(CONFIG_SP_ICM) += sp_icm.o
+obj-$(CONFIG_SP_DMA0) += sp_dma0.o
 
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_core.o
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_bugs.o
--- a/drivers/misc/sp_cbdma_test.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/misc/sp_cbdma_test.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,1097 @@
+/*
+ * Sunplus CBDMA test driver
+ *
+ * Copyright (C) 2018 Sunplus Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/atomic.h>
+
+struct cbdma_reg {
+	volatile unsigned int hw_ver;
+	volatile unsigned int config;
+	volatile unsigned int length;
+	volatile unsigned int src_adr;
+	volatile unsigned int des_adr;
+	volatile unsigned int int_flag;
+	volatile unsigned int int_en;
+	volatile unsigned int memset_val;
+	volatile unsigned int sdram_size_config;
+	volatile unsigned int illegle_record;
+	volatile unsigned int sg_idx;
+	volatile unsigned int sg_cfg;
+	volatile unsigned int sg_length;
+	volatile unsigned int sg_src_adr;
+	volatile unsigned int sg_des_adr;
+	volatile unsigned int sg_memset_val;
+	volatile unsigned int sg_en_go;
+	volatile unsigned int sg_lp_mode;
+	volatile unsigned int sg_lp_sram_start;
+	volatile unsigned int sg_lp_sram_size;
+	volatile unsigned int sg_chk_mode;
+	volatile unsigned int sg_chk_sum;
+	volatile unsigned int sg_chk_xor;
+	volatile unsigned int rsv_23_31[9];
+};
+
+/* Unaligned test */
+#define UNALIGNED_DROP_S	0	/* 0, 1, 2, 3 */
+#define UNALIGNED_DROP_E	0	/* 0, 1, 2, 3 */
+#define UNALIGNED_ADDR_S(X)	(X + UNALIGNED_DROP_S)
+#define UNALIGNED_ADDR_E(X)	(X - UNALIGNED_DROP_E)
+
+
+#define NUM_CBDMA		2
+#define BUF_SIZE_DRAM		(PAGE_SIZE * 2)
+
+#define PATTERN4TEST(X)		((((u32)(X)) << 24) | (((u32)(X)) << 16) | (((u32)(X)) << 8) | (((u32)(X)) << 0))
+
+#define CBDMA_CONFIG_DEFAULT	0x00030000
+#define CBDMA_CONFIG_GO		(0x01 << 8)
+#define CBDMA_CONFIG_MEMSET	(0x00 << 0)
+#define CBDMA_CONFIG_WR		(0x01 << 0)
+#define CBDMA_CONFIG_RD		(0x02 << 0)
+#define CBDMA_CONFIG_CP		(0x03 << 0)
+
+#define CBDMA_INT_FLAG_DONE	(1 << 0)
+
+#define CBDMA_SG_CFG_NOT_LAST	(0x00 << 2)
+#define CBDMA_SG_CFG_LAST	(0x01 << 2)
+#define CBDMA_SG_CFG_MEMSET	(0x00 << 0)
+#define CBDMA_SG_CFG_WR		(0x01 << 0)
+#define CBDMA_SG_CFG_RD		(0x02 << 0)
+#define CBDMA_SG_CFG_CP		(0x03 << 0)
+#define CBDMA_SG_EN_GO_EN	(0x01 << 31)
+#define CBDMA_SG_EN_GO_GO	(0x01 << 0)
+#define CBDMA_SG_LP_MODE_LP	(0x01 << 0)
+#define CBDMA_SG_LP_SZ_1KB	(0 << 0)
+#define CBDMA_SG_LP_SZ_2KB	(1 << 0)
+#define CBDMA_SG_LP_SZ_4KB	(2 << 0)
+#define CBDMA_SG_LP_SZ_8KB	(3 << 0)
+#define CBDMA_SG_LP_SZ_16KB	(4 << 0)
+#define CBDMA_SG_LP_SZ_32KB	(5 << 0)
+#define CBDMA_SG_LP_SZ_64KB	(6 << 0)
+
+#define NUM_SG_IDX		32
+
+struct cbdma_sg_lli {
+	u32 sg_cfg;
+	u32 sg_length;
+	u32 sg_src_adr;
+	u32 sg_des_adr;
+	u32 sg_memset_val;
+	u32 sg_lp_mode;
+};
+
+#define MIN(X, Y)		((X) < (Y) ? (X): (Y))
+
+struct cbdma_info_s {
+	char name[32];
+	struct platform_device *pdev;
+	char irq_name[32];
+	int irq;
+	volatile struct cbdma_reg *cbdma_ptr;
+	u32 sram_addr;
+	u32 sram_size;
+	void *buf_va;
+	dma_addr_t dma_handle;
+};
+static struct cbdma_info_s cbdma_info[NUM_CBDMA];
+
+static struct task_struct *thread_ptr = NULL;
+atomic_t isr_cnt = ATOMIC_INIT(0);
+
+void dump_data(u8 *ptr, u32 size)
+{
+	u32 i, addr_begin;
+	int length;
+	char buffer[256];
+
+	addr_begin = (u32)(ptr);
+	for (i = 0; i < size; i++) {
+		if ((i & 0x0F) == 0x00) {
+			length = sprintf(buffer, "%08x: ", i + addr_begin);
+		}
+		length += sprintf(&buffer[length], "%02x ", *ptr);
+		ptr++;
+
+		if ((i & 0x0F) == 0x0F) {
+			printk(KERN_INFO "%s\n", buffer);
+		}
+	}
+	printk(KERN_INFO "\n");
+}
+
+static void sp_cbdma_tst_basic(void *data)
+{
+	int i, j, val;
+	u32 *u32_ptr, expected_u32, val_u32, test_size;
+	u32 *sram_ptr;
+
+	printk(KERN_INFO "%s(), start\n", __func__);
+
+	for (i = 0; i < NUM_CBDMA; i++) {
+		if (cbdma_info[i].sram_size) {
+			printk(KERN_INFO "Test for %s ------------------------\n", cbdma_info[i].name);
+
+			printk(KERN_INFO "MEMSET test\n");
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+			cbdma_info[i].cbdma_ptr->length = BUF_SIZE_DRAM - UNALIGNED_DROP_S - UNALIGNED_DROP_E;
+			cbdma_info[i].cbdma_ptr->src_adr = UNALIGNED_ADDR_S((u32)(cbdma_info[i].dma_handle));
+			cbdma_info[i].cbdma_ptr->des_adr = UNALIGNED_ADDR_S((u32)(cbdma_info[i].dma_handle));
+			cbdma_info[i].cbdma_ptr->memset_val = PATTERN4TEST(i ^ 0xaa);
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->config = CBDMA_CONFIG_DEFAULT | CBDMA_CONFIG_GO | CBDMA_CONFIG_MEMSET;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->config & CBDMA_CONFIG_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+
+				break;
+			}
+			dump_data(cbdma_info[i].buf_va, 0x20);
+#if ((UNALIGNED_DROP_S | UNALIGNED_DROP_E) != 0)
+			dump_data(((u8 *)cbdma_info[i].buf_va + BUF_SIZE_DRAM - 0x20), 0x20);
+#endif
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			expected_u32 = PATTERN4TEST(i ^ 0xaa);
+			for (j = 0 ; j < (BUF_SIZE_DRAM >> 2); j++) {
+#if ((UNALIGNED_DROP_S | UNALIGNED_DROP_E) != 0)
+				if ((j == 0) || ((j + 1) >= (BUF_SIZE_DRAM >> 2))) {
+					u32_ptr++;
+					continue;
+				}
+#endif
+				BUG_ON(*u32_ptr != expected_u32);
+				u32_ptr++;
+			}
+			printk(KERN_INFO "MEMSET test: OK\n\n");
+
+			printk(KERN_INFO "SRAM r/w test\n");
+			sram_ptr = (u32 *)ioremap(cbdma_info[i].sram_addr, cbdma_info[i].sram_size);
+			BUG_ON(!sram_ptr);
+			u32_ptr = sram_ptr;
+			val_u32 = (u32)(cbdma_info[i].sram_addr);
+			test_size = cbdma_info[i].sram_size - 256; /* last 256 bytes is reserved for COPY, access it will trigger a ISR */
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				*u32_ptr = val_u32;
+				u32_ptr++;
+				val_u32 += 4;
+			}
+			dump_data((u8 *)sram_ptr, 0x20);
+			u32_ptr = sram_ptr;
+			val_u32 = (u32)(cbdma_info[i].sram_addr);
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				BUG_ON(*u32_ptr != val_u32);
+				u32_ptr++;
+				val_u32 += 4;
+			}
+			printk(KERN_INFO "SRAM r/w test: OK\n\n");
+
+			printk(KERN_INFO "R/W test\n");
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			val_u32 = (u32)(u32_ptr);
+			test_size = MIN(cbdma_info[i].sram_size, BUF_SIZE_DRAM) >> 1;
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				/* Fill (test_size) bytes of data to DRAM */
+				*u32_ptr = val_u32;
+				u32_ptr++;
+				val_u32 += 4;
+			}
+			dump_data(cbdma_info[i].buf_va, 0x20);
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+			cbdma_info[i].cbdma_ptr->length = test_size - UNALIGNED_DROP_S - UNALIGNED_DROP_E;
+			cbdma_info[i].cbdma_ptr->des_adr = 0;
+			cbdma_info[i].cbdma_ptr->src_adr = UNALIGNED_ADDR_S((u32)(cbdma_info[i].dma_handle));
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->config = CBDMA_CONFIG_DEFAULT | CBDMA_CONFIG_GO | CBDMA_CONFIG_RD;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->config & CBDMA_CONFIG_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+				break;
+			}
+
+			dump_data((u8 *)(sram_ptr), 0x20);
+#if ((UNALIGNED_DROP_S | UNALIGNED_DROP_E) == 0)
+			u32_ptr = sram_ptr;
+			val_u32 = (u32)(cbdma_info[i].buf_va);
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				/* Compare (test_size) bytes of data in DRAM */
+				BUG_ON(*u32_ptr != val_u32);
+				u32_ptr++;
+				val_u32 += 4;
+			}
+			printk(KERN_INFO "Data in SRAM: OK\n");
+#endif
+			iounmap(sram_ptr);
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+			cbdma_info[i].cbdma_ptr->length = test_size - UNALIGNED_DROP_S - UNALIGNED_DROP_E;
+#if ((UNALIGNED_DROP_S | UNALIGNED_DROP_E) == 0)
+			cbdma_info[i].cbdma_ptr->des_adr = ((u32)(cbdma_info[i].dma_handle)) + test_size;
+#else
+			cbdma_info[i].cbdma_ptr->des_adr = ((u32)(cbdma_info[i].dma_handle)) + test_size - (4 - UNALIGNED_DROP_S);
+#endif
+			cbdma_info[i].cbdma_ptr->src_adr = 0;
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->config = CBDMA_CONFIG_DEFAULT | CBDMA_CONFIG_GO | CBDMA_CONFIG_WR;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->config & CBDMA_CONFIG_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+
+				break;
+			}
+			dump_data(cbdma_info[i].buf_va + test_size, 0x20);
+#if ((UNALIGNED_DROP_S | UNALIGNED_DROP_E) != 0)
+			dump_data((u8 *)((u32)(cbdma_info[i].buf_va) + test_size * 2 - 0x20), 0x20);
+#endif
+
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va + test_size);
+			val_u32 = (u32)(cbdma_info[i].buf_va);
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				/* Compare (test_size) bytes of data in DRAM */
+#if ((UNALIGNED_DROP_S | UNALIGNED_DROP_E) != 0)
+				if (j == 0) {
+					val_u32 += 4;
+				} else if ((j + 2) >= (test_size >> 2)) {
+					break;
+				}
+#endif
+				BUG_ON(*u32_ptr != val_u32);
+				u32_ptr++;
+				val_u32 += 4;
+			}
+			printk(KERN_INFO "R/W test: OK\n\n");
+
+			printk(KERN_INFO "COPY test\n");
+			test_size = BUF_SIZE_DRAM >> 1;
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va + test_size);
+			val_u32 = (u32)(u32_ptr);
+			for (j = 0 ; (j < test_size >> 2); j++) {
+				*u32_ptr = cpu_to_be32(val_u32);
+				u32_ptr++;
+				val_u32 += 4;
+			}
+			dump_data(cbdma_info[i].buf_va + test_size, 0x20);
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+			cbdma_info[i].cbdma_ptr->length = test_size - UNALIGNED_DROP_S;
+			cbdma_info[i].cbdma_ptr->src_adr = UNALIGNED_ADDR_S((u32)(cbdma_info[i].dma_handle) + test_size);
+			cbdma_info[i].cbdma_ptr->des_adr = UNALIGNED_ADDR_S((u32)(cbdma_info[i].dma_handle));
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->config = CBDMA_CONFIG_DEFAULT | CBDMA_CONFIG_GO | CBDMA_CONFIG_CP;
+			wmb();
+
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->config & CBDMA_CONFIG_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+
+				break;
+			}
+			dump_data(cbdma_info[i].buf_va, 0x20);
+
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			expected_u32 = (u32)(cbdma_info[i].buf_va) + test_size;
+			for (j = 0 ; (j < test_size >> 2); j++) {
+#if ((UNALIGNED_DROP_S | UNALIGNED_DROP_E) != 0)
+				if (j != 0) {
+					BUG_ON(*u32_ptr != cpu_to_be32(expected_u32));
+				}
+#else
+				BUG_ON(*u32_ptr != cpu_to_be32(expected_u32));
+#endif
+				u32_ptr++;
+				expected_u32 += 4;
+			}
+			printk(KERN_INFO "COPY test: OK\n\n");
+		}
+	}
+	printk(KERN_INFO "%s(), end\n", __func__);
+}
+
+static void sp_cbdma_sg_lli(u32 sg_idx, volatile struct cbdma_reg *cbdma_ptr, struct cbdma_sg_lli *cbdma_sg_lli_ptr)
+{
+	if (cbdma_sg_lli_ptr->sg_lp_mode) {
+		cbdma_ptr->sg_lp_mode = 0x00000001;
+		cbdma_ptr->sg_lp_sram_start = 0x00000000;
+		cbdma_ptr->sg_lp_sram_size = CBDMA_SG_LP_SZ_4KB;
+	} else {
+		cbdma_ptr->sg_lp_mode = 0x00000000;
+	}
+
+	cbdma_ptr->sg_en_go	 = CBDMA_SG_EN_GO_EN;
+	cbdma_ptr->sg_idx	 = sg_idx;
+	cbdma_ptr->sg_length	 = cbdma_sg_lli_ptr->sg_length;
+	cbdma_ptr->sg_src_adr	 = cbdma_sg_lli_ptr->sg_src_adr;
+	cbdma_ptr->sg_des_adr	 = cbdma_sg_lli_ptr->sg_des_adr;
+	cbdma_ptr->sg_memset_val = cbdma_sg_lli_ptr->sg_memset_val;
+	cbdma_ptr->sg_cfg	 = cbdma_sg_lli_ptr->sg_cfg;
+}
+
+static void sp_cbdma_tst_sg_memset_00(void *data)
+{
+	int i, j, val;
+	u32 sg_idx, test_size, expected_u32;
+	u32 *u32_ptr;
+	struct cbdma_sg_lli sg_lli;
+
+	printk(KERN_INFO "%s(), start\n", __func__);
+
+	memset(&sg_lli, 0, sizeof(sg_lli));
+	for (i = 0; i < NUM_CBDMA; i++) {
+		if (cbdma_info[i].sram_size) {
+			printk(KERN_INFO "Test for %s ------------------------\n", cbdma_info[i].name);
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+
+			test_size = 1 << 10;
+
+			/* 1st of LLI */
+			sg_idx = 0;
+			sg_lli.sg_length	= test_size;
+			sg_lli.sg_src_adr	= (u32)(cbdma_info[i].dma_handle);
+			sg_lli.sg_des_adr	= (u32)(cbdma_info[i].dma_handle);
+			sg_lli.sg_memset_val	= PATTERN4TEST(0x5A);
+			sg_lli.sg_cfg		= CBDMA_SG_CFG_NOT_LAST | CBDMA_SG_CFG_MEMSET;
+			sp_cbdma_sg_lli(sg_idx, cbdma_info[i].cbdma_ptr, &sg_lli);
+
+			/* 2nd of LLI, last one */
+			sg_idx++;
+			sg_lli.sg_length	= test_size;
+			sg_lli.sg_src_adr	= (u32)(cbdma_info[i].dma_handle) + test_size * sg_idx;
+			sg_lli.sg_des_adr	= (u32)(cbdma_info[i].dma_handle) + test_size * sg_idx;
+			sg_lli.sg_memset_val	= PATTERN4TEST(0xA5);
+			sg_lli.sg_cfg		= CBDMA_SG_CFG_LAST | CBDMA_SG_CFG_MEMSET;
+			sp_cbdma_sg_lli(sg_idx, cbdma_info[i].cbdma_ptr, &sg_lli);
+
+			cbdma_info[i].cbdma_ptr->sg_idx = 0;	/* Start from index-0 */
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->sg_en_go = CBDMA_SG_EN_GO_EN | CBDMA_SG_EN_GO_GO;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->sg_en_go & CBDMA_SG_EN_GO_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+
+				break;
+			}
+
+			/* Verification of the 1st of LLI */
+			dump_data(cbdma_info[i].buf_va, 0x20);
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			expected_u32 = PATTERN4TEST(0x5A);
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				BUG_ON(*u32_ptr != expected_u32);
+				u32_ptr++;
+			}
+
+			/* Verification of the 2nd of LLI */
+			dump_data(cbdma_info[i].buf_va + test_size, 0x20);
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va + test_size);
+			expected_u32 = PATTERN4TEST(0xA5);
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				BUG_ON(*u32_ptr != expected_u32);
+				u32_ptr++;
+			}
+
+		}
+	}
+	printk(KERN_INFO "%s(), end\n", __func__);
+}
+
+static void sp_cbdma_tst_sg_memset_01(void *data)
+{
+	int i, j, k, val;
+	u32 sg_idx, test_size, expected_u32;
+	u32 *u32_ptr;
+	struct cbdma_sg_lli sg_lli;
+
+	printk(KERN_INFO "%s(), start\n", __func__);
+
+	memset(&sg_lli, 0, sizeof(sg_lli));
+	for (i = 0; i < NUM_CBDMA; i++) {
+		if (cbdma_info[i].sram_size) {
+			printk(KERN_INFO "Test for %s ------------------------\n", cbdma_info[i].name);
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+
+			test_size = BUF_SIZE_DRAM / NUM_SG_IDX;
+
+			for (j = 0; j < NUM_SG_IDX; j++) {
+				sg_idx = j;
+				sg_lli.sg_length	= test_size;
+				sg_lli.sg_src_adr	= (u32)(cbdma_info[i].dma_handle) + j * test_size;
+				sg_lli.sg_des_adr	= (u32)(cbdma_info[i].dma_handle) + j * test_size;
+				sg_lli.sg_memset_val	= PATTERN4TEST((((i << 4) | j) ^ 0x5A) & 0xFF);
+				sg_lli.sg_cfg		= (j != (NUM_SG_IDX - 1)) ?
+							  (CBDMA_SG_CFG_NOT_LAST | CBDMA_SG_CFG_MEMSET) :
+							  (CBDMA_SG_CFG_LAST | CBDMA_SG_CFG_MEMSET);
+				sp_cbdma_sg_lli(sg_idx, cbdma_info[i].cbdma_ptr, &sg_lli);
+			}
+
+			cbdma_info[i].cbdma_ptr->sg_idx = 0;	/* Start from index-0 */
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->sg_en_go = CBDMA_SG_EN_GO_EN | CBDMA_SG_EN_GO_GO;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->sg_en_go & CBDMA_SG_EN_GO_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+
+				break;
+			}
+
+			/* Verification */
+			for (j = 0; j < NUM_SG_IDX; j++) {
+				dump_data(cbdma_info[i].buf_va + j * test_size, 0x20);
+				u32_ptr = (u32 *)((u32)(cbdma_info[i].buf_va) + j * test_size);
+				expected_u32 = PATTERN4TEST((((i << 4) | j) ^ 0x5A) & 0xFF);
+				for (k = 0 ; k < (test_size >> 2); k++) {
+					BUG_ON(*u32_ptr != expected_u32);
+					u32_ptr++;
+				}
+			}
+		}
+	}
+	printk(KERN_INFO "%s(), end\n", __func__);
+}
+
+static void sp_cbdma_tst_sg_rw_00(void *data)
+{
+	int i, j, k, val;
+	u32 sg_idx, test_size, expected_u32, val_u32;
+	u32 *u32_ptr;
+	struct cbdma_sg_lli sg_lli;
+	const u32 sg_idx_used = 4;
+
+	printk(KERN_INFO "%s(), start\n", __func__);
+
+	memset(&sg_lli, 0, sizeof(sg_lli));
+	for (i = 0; i < NUM_CBDMA; i++) {
+		if (cbdma_info[i].sram_size) {
+			printk(KERN_INFO "Test for %s ------------------------\n", cbdma_info[i].name);
+			test_size = MIN(BUF_SIZE_DRAM, cbdma_info[i].sram_size) / sg_idx_used / 2;
+
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			val_u32 = (u32)(u32_ptr);
+			expected_u32 = val_u32;
+			for (k = 0; k < sg_idx_used; k++) {
+				for (j = 0; j < (test_size >> 2); j++) {
+					/* Fill (test_size) bytes of data to DRAM */
+					*u32_ptr = val_u32;
+					u32_ptr++;
+					val_u32 += 4;
+				}
+			}
+
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			for (k = 0; k < sg_idx_used; k++) {
+				dump_data((u8 *)u32_ptr, 0x20);
+				u32_ptr += (test_size >> 2);
+			}
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+
+			for (j = 0; j < sg_idx_used; j++) {
+				sg_idx = j;
+				sg_lli.sg_length	= test_size;
+				sg_lli.sg_src_adr	= (u32)(cbdma_info[i].dma_handle) + j * test_size;
+				sg_lli.sg_des_adr	= j * test_size;
+				sg_lli.sg_cfg		= (j != (sg_idx_used - 1)) ?
+							  (CBDMA_SG_CFG_NOT_LAST | CBDMA_SG_CFG_RD) :
+							  (CBDMA_SG_CFG_LAST | CBDMA_SG_CFG_RD);
+				sp_cbdma_sg_lli(sg_idx, cbdma_info[i].cbdma_ptr, &sg_lli);
+			}
+
+			cbdma_info[i].cbdma_ptr->sg_idx = 0;	/* Start from index-0 */
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->sg_en_go = CBDMA_SG_EN_GO_EN | CBDMA_SG_EN_GO_GO;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->sg_en_go & CBDMA_SG_EN_GO_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+
+				break;
+			}
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+
+			for (j = 0; j < sg_idx_used; j++) {
+				sg_idx = j;
+				sg_lli.sg_length	= test_size;
+				sg_lli.sg_src_adr	= j * test_size;
+				sg_lli.sg_des_adr	= (u32)(cbdma_info[i].dma_handle) + (j + sg_idx_used) * test_size;
+				sg_lli.sg_cfg		= (j != (sg_idx_used - 1)) ?
+							  (CBDMA_SG_CFG_NOT_LAST | CBDMA_SG_CFG_WR) :
+							  (CBDMA_SG_CFG_LAST | CBDMA_SG_CFG_WR);
+				sp_cbdma_sg_lli(sg_idx, cbdma_info[i].cbdma_ptr, &sg_lli);
+			}
+
+			cbdma_info[i].cbdma_ptr->sg_idx = 0;	/* Start from index-0 */
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->sg_en_go = CBDMA_SG_EN_GO_EN | CBDMA_SG_EN_GO_GO;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->sg_en_go & CBDMA_SG_EN_GO_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+
+				break;
+			}
+
+			u32_ptr = (u32 *)((u32)(cbdma_info[i].buf_va) + sg_idx_used * test_size);
+			for (k = 0; k < sg_idx_used; k++) {
+				dump_data((u8 *)u32_ptr, 0x20);
+				for (j = 0; j < (test_size >> 2); j++) {
+					BUG_ON(*u32_ptr != expected_u32);
+					u32_ptr++;
+					expected_u32 += 4;
+				}
+			}
+		}
+	}
+	printk(KERN_INFO "%s(), end\n", __func__);
+}
+
+static void sp_cbdma_tst_sg_cp_00(void *data)
+{
+	int i, j, val;
+	u32 sg_idx, test_size, expected_u32, val_u32;
+	u32 *u32_ptr;
+	struct cbdma_sg_lli sg_lli;
+
+	printk(KERN_INFO "%s(), start\n", __func__);
+
+	memset(&sg_lli, 0, sizeof(sg_lli));
+	for (i = 0; i < NUM_CBDMA; i++) {
+		if (cbdma_info[i].sram_size) {
+			printk(KERN_INFO "Test for %s ------------------------\n", cbdma_info[i].name);
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			val_u32 = (u32)(u32_ptr);
+			expected_u32 = val_u32;
+			test_size = BUF_SIZE_DRAM >> 1;
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				/* Fill (test_size) bytes of data to DRAM */
+				*u32_ptr = val_u32;
+				u32_ptr++;
+				val_u32 += 4;
+			}
+			dump_data(cbdma_info[i].buf_va, 0x20);
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+
+			/* 1st of LLI, last one */
+			sg_idx = 0;
+			sg_lli.sg_length	= test_size;
+			sg_lli.sg_src_adr	= (u32)(cbdma_info[i].dma_handle);
+			sg_lli.sg_des_adr	= (u32)(cbdma_info[i].dma_handle) + test_size;
+			sg_lli.sg_cfg		= CBDMA_SG_CFG_LAST | CBDMA_SG_CFG_CP;
+
+			sp_cbdma_sg_lli(sg_idx, cbdma_info[i].cbdma_ptr, &sg_lli);
+
+			cbdma_info[i].cbdma_ptr->sg_idx = 0;	/* Start from index-0 */
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->sg_en_go = CBDMA_SG_EN_GO_EN | CBDMA_SG_EN_GO_GO;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->sg_en_go & CBDMA_SG_EN_GO_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+				break;
+			}
+
+			/* Verification of the 1st of LLI */
+			dump_data(cbdma_info[i].buf_va + test_size, 0x20);
+			u32_ptr = (u32 *)((u32)(cbdma_info[i].buf_va) + test_size);
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				BUG_ON(*u32_ptr != expected_u32);
+				u32_ptr++;
+				expected_u32 += 4;
+			}
+		}
+	}
+	printk(KERN_INFO "%s(), end\n", __func__);
+}
+
+static void sp_cbdma_tst_sg_cp_01(void *data)
+{
+	int i, j, k, val;
+	u32 sg_idx, test_size, expected_u32, val_u32;
+	u32 *u32_ptr;
+	struct cbdma_sg_lli sg_lli;
+	const u32 sg_idx_used = 8;
+
+	printk(KERN_INFO "%s(), start\n", __func__);
+
+	memset(&sg_lli, 0, sizeof(sg_lli));
+	for (i = 0; i < NUM_CBDMA; i++) {
+		if (cbdma_info[i].sram_size) {
+			printk(KERN_INFO "Test for %s ------------------------\n", cbdma_info[i].name);
+			test_size = BUF_SIZE_DRAM / sg_idx_used / 2;
+
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			val_u32 = (u32)(u32_ptr);
+			expected_u32 = val_u32;
+			for (k = 0; k < sg_idx_used; k++) {
+				for (j = 0; j < (test_size >> 2); j++) {
+					/* Fill (test_size) bytes of data to DRAM */
+					*u32_ptr = val_u32;
+					u32_ptr++;
+					val_u32 += 4;
+				}
+			}
+
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			for (k = 0; k < sg_idx_used; k++) {
+				dump_data((u8 *)u32_ptr, 0x20);
+				u32_ptr += (test_size >> 2);
+			}
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+
+			for (j = 0; j < sg_idx_used; j++) {
+				sg_idx = j;
+				sg_lli.sg_length	= test_size;
+				sg_lli.sg_src_adr	= (u32)(cbdma_info[i].dma_handle) + j * test_size;
+				sg_lli.sg_des_adr	= (u32)(cbdma_info[i].dma_handle) + (j + sg_idx_used) * test_size;
+				sg_lli.sg_cfg		= (j != (sg_idx_used - 1)) ?
+							  (CBDMA_SG_CFG_NOT_LAST | CBDMA_SG_CFG_CP) :
+							  (CBDMA_SG_CFG_LAST | CBDMA_SG_CFG_CP);
+				sp_cbdma_sg_lli(sg_idx, cbdma_info[i].cbdma_ptr, &sg_lli);
+			}
+
+			cbdma_info[i].cbdma_ptr->sg_idx = 0;	/* Start from index-0 */
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->sg_en_go = CBDMA_SG_EN_GO_EN | CBDMA_SG_EN_GO_GO;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->sg_en_go & CBDMA_SG_EN_GO_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+
+				break;
+			}
+
+			u32_ptr = (u32 *)((u32)(cbdma_info[i].buf_va) + sg_idx_used * test_size);
+			for (k = 0; k < sg_idx_used; k++) {
+				dump_data((u8 *)u32_ptr, 0x20);
+				for (j = 0; j < (test_size >> 2); j++) {
+					BUG_ON(*u32_ptr != expected_u32);
+					u32_ptr++;
+					expected_u32 += 4;
+				}
+			}
+		}
+	}
+	printk(KERN_INFO "%s(), end\n", __func__);
+}
+
+static void sp_cbdma_tst_sg_lp_cp_00(void *data)
+{
+	int i, j, val;
+	u32 sg_idx, test_size, expected_u32, val_u32;
+	u32 *u32_ptr;
+	struct cbdma_sg_lli sg_lli;
+
+	printk(KERN_INFO "%s(), start\n", __func__);
+
+	memset(&sg_lli, 0, sizeof(sg_lli));
+	for (i = 0; i < NUM_CBDMA; i++) {
+		if (cbdma_info[i].sram_size) {
+			printk(KERN_INFO "Test for %s ------------------------\n", cbdma_info[i].name);
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			val_u32 = (u32)(u32_ptr);
+			expected_u32 = val_u32;
+			test_size = BUF_SIZE_DRAM >> 1;
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				/* Fill (test_size) bytes of data to DRAM */
+				*u32_ptr = val_u32;
+				u32_ptr++;
+				val_u32 += 4;
+			}
+			dump_data(cbdma_info[i].buf_va, 0x20);
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+
+			/* 1st of LLI, last one */
+			sg_idx = 0;
+			sg_lli.sg_length	= test_size;
+			sg_lli.sg_src_adr	= (u32)(cbdma_info[i].dma_handle);
+			sg_lli.sg_des_adr	= (u32)(cbdma_info[i].dma_handle) + test_size;
+			sg_lli.sg_cfg		= CBDMA_SG_CFG_LAST | CBDMA_SG_CFG_CP;
+			sg_lli.sg_lp_mode	= 1;
+
+			sp_cbdma_sg_lli(sg_idx, cbdma_info[i].cbdma_ptr, &sg_lli);
+
+			cbdma_info[i].cbdma_ptr->sg_idx = 0;	/* Start from index-0 */
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->sg_en_go = CBDMA_SG_EN_GO_EN | CBDMA_SG_EN_GO_GO;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->sg_en_go & CBDMA_SG_EN_GO_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+				break;
+			}
+
+			/* Verification of the 1st of LLI */
+			dump_data(cbdma_info[i].buf_va + test_size, 0x20);
+			u32_ptr = (u32 *)((u32)(cbdma_info[i].buf_va) + test_size);
+			for (j = 0 ; j < (test_size >> 2); j++) {
+				BUG_ON(*u32_ptr != expected_u32);
+				u32_ptr++;
+				expected_u32 += 4;
+			}
+		}
+	}
+	printk(KERN_INFO "%s(), end\n", __func__);
+}
+
+static void sp_cbdma_tst_sg_lp_cp_01(void *data)
+{
+	int i, j, k, val;
+	u32 sg_idx, test_size, expected_u32, val_u32;
+	u32 *u32_ptr;
+	struct cbdma_sg_lli sg_lli;
+	const u32 sg_idx_used = 8;
+
+	printk(KERN_INFO "%s(), start\n", __func__);
+
+	memset(&sg_lli, 0, sizeof(sg_lli));
+	for (i = 0; i < NUM_CBDMA; i++) {
+		if (cbdma_info[i].sram_size) {
+			printk(KERN_INFO "Test for %s ------------------------\n", cbdma_info[i].name);
+			test_size = BUF_SIZE_DRAM / sg_idx_used / 2;
+
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			val_u32 = (u32)(u32_ptr);
+			expected_u32 = val_u32;
+			for (k = 0; k < sg_idx_used; k++) {
+				for (j = 0; j < (test_size >> 2); j++) {
+					/* Fill (test_size) bytes of data to DRAM */
+					*u32_ptr = val_u32;
+					u32_ptr++;
+					val_u32 += 4;
+				}
+			}
+
+			u32_ptr = (u32 *)(cbdma_info[i].buf_va);
+			for (k = 0; k < sg_idx_used; k++) {
+				dump_data((u8 *)u32_ptr, 0x20);
+				u32_ptr += (test_size >> 2);
+			}
+
+			val = atomic_read(&isr_cnt);
+			cbdma_info[i].cbdma_ptr->int_en = 0;
+
+			for (j = 0; j < sg_idx_used; j++) {
+				sg_idx = j;
+				sg_lli.sg_length	= test_size;
+				sg_lli.sg_src_adr	= (u32)(cbdma_info[i].dma_handle) + j * test_size;
+				sg_lli.sg_des_adr	= (u32)(cbdma_info[i].dma_handle) + (j + sg_idx_used) * test_size;
+				sg_lli.sg_cfg		= (j != (sg_idx_used - 1)) ?
+							  (CBDMA_SG_CFG_NOT_LAST | CBDMA_SG_CFG_CP) :
+							  (CBDMA_SG_CFG_LAST | CBDMA_SG_CFG_CP);
+				sg_lli.sg_lp_mode	= 1;
+				sp_cbdma_sg_lli(sg_idx, cbdma_info[i].cbdma_ptr, &sg_lli);
+			}
+
+			cbdma_info[i].cbdma_ptr->sg_idx = 0;	/* Start from index-0 */
+			cbdma_info[i].cbdma_ptr->int_en = ~0;	/* Enable all interrupts */
+			wmb();
+			cbdma_info[i].cbdma_ptr->sg_en_go = CBDMA_SG_EN_GO_EN | CBDMA_SG_EN_GO_GO;
+			wmb();
+			while (1) {
+				if (cbdma_info[i].cbdma_ptr->sg_en_go & CBDMA_SG_EN_GO_GO) {
+					/* Still running */
+					continue;
+				}
+				if (atomic_read(&isr_cnt) == val) {
+					/* ISR not served */
+					continue;
+				}
+
+				break;
+			}
+
+			u32_ptr = (u32 *)((u32)(cbdma_info[i].buf_va) + sg_idx_used * test_size);
+			for (k = 0; k < sg_idx_used; k++) {
+				dump_data((u8 *)u32_ptr, 0x20);
+				for (j = 0; j < (test_size >> 2); j++) {
+					BUG_ON(*u32_ptr != expected_u32);
+					u32_ptr++;
+					expected_u32 += 4;
+				}
+			}
+		}
+	}
+	printk(KERN_INFO "%s(), end\n", __func__);
+}
+
+static int sp_cbdma_tst_thread(void *data)
+{
+	int i;
+
+	msleep(100);	/* let console be available */
+	printk(KERN_INFO "%s, %d\n", __func__, __LINE__);
+
+	sp_cbdma_tst_basic(data);
+#if ((UNALIGNED_DROP_S | UNALIGNED_DROP_E) != 0)
+	return 0;
+#endif
+	sp_cbdma_tst_sg_memset_00(data);
+	sp_cbdma_tst_sg_memset_01(data);
+	sp_cbdma_tst_sg_rw_00(data);
+	sp_cbdma_tst_sg_cp_00(data);
+	sp_cbdma_tst_sg_cp_01(data);
+	sp_cbdma_tst_sg_lp_cp_00(data);
+	sp_cbdma_tst_sg_lp_cp_01(data);
+
+	for (i = 0; i < NUM_CBDMA; i++) {
+		if (cbdma_info[i].buf_va) {
+			dma_free_coherent(&(cbdma_info[i].pdev->dev), BUF_SIZE_DRAM, cbdma_info[i].buf_va, cbdma_info[i].dma_handle);
+		}
+	}
+
+	return 0;
+}
+
+static const struct platform_device_id sp_cbdma_tst_devtypes[] = {
+	{
+		.name = "sp_cbdma_tst",
+	}, {
+		/* sentinel */
+	}
+};
+
+static const struct of_device_id sp_cbdma_tst_dt_ids[] = {
+	{
+		.compatible = "sunplus,sp-cbdma-tst",
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, sp_cbdma_tst_dt_ids);
+
+static irqreturn_t sp_cbdma_tst_irq(int irq, void *args)
+{
+	struct cbdma_info_s *ptr;
+	u32 int_flag;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	atomic_inc(&isr_cnt);
+
+	ptr = (struct cbdma_info_s *)(args);
+	int_flag = ptr->cbdma_ptr->int_flag;
+	printk(KERN_INFO  "%s, %d, %s, int_flag: 0x%x, isr_cnt: %d\n", __func__, __LINE__, ptr->irq_name, int_flag, atomic_read(&isr_cnt));
+	BUG_ON(int_flag != CBDMA_INT_FLAG_DONE);
+	ptr->cbdma_ptr->int_flag = int_flag;
+
+	local_irq_restore(flags);
+
+	return IRQ_HANDLED;
+}
+
+static int sp_cbdma_tst_probe(struct platform_device *pdev)
+{
+	static int idx_cbdma = 0;
+	struct resource *res_mem;
+	const struct of_device_id *match;
+	void __iomem *membase;
+	int ret, num_irq;
+
+	if (idx_cbdma >= NUM_CBDMA) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "%s, %d\n", __func__, __LINE__);
+
+	if (idx_cbdma == 0) {
+		memset(&cbdma_info, 0, sizeof(cbdma_info));
+	}
+
+	if (pdev->dev.of_node) {
+		match = of_match_node(sp_cbdma_tst_dt_ids, pdev->dev.of_node);
+		if (match == NULL) {
+			printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+			return -ENODEV;
+		}
+		num_irq = of_irq_count(pdev->dev.of_node);
+		if (num_irq != 1) {
+			printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		}
+	}
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(res_mem)) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return PTR_ERR(res_mem);
+	}
+
+	membase = devm_ioremap_resource(&pdev->dev, res_mem);
+	if (IS_ERR(membase)) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return PTR_ERR(membase);
+	}
+
+	cbdma_info[idx_cbdma].pdev = pdev;
+	cbdma_info[idx_cbdma].cbdma_ptr = (volatile struct cbdma_reg *)(membase);
+	cbdma_info[idx_cbdma].cbdma_ptr->int_flag = ~0;	/* clear all interrupt flags */
+	cbdma_info[idx_cbdma].irq = platform_get_irq(pdev, 0);
+	if (cbdma_info[idx_cbdma].irq < 0) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+	sprintf(cbdma_info[idx_cbdma].name, "CBDMA_%x", (u32)(res_mem->start));
+	sprintf(cbdma_info[idx_cbdma].irq_name, "irq_%x", (u32)(res_mem->start));
+	ret = request_irq(cbdma_info[idx_cbdma].irq, sp_cbdma_tst_irq, 0, cbdma_info[idx_cbdma].irq_name, &cbdma_info[idx_cbdma]);
+	if (ret) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return ret;
+	}
+	printk(KERN_INFO "%s, %d, irq: %d, %s\n", __func__, __LINE__, cbdma_info[idx_cbdma].irq, cbdma_info[idx_cbdma].irq_name);
+	if (((u32)(res_mem->start)) == 0x9C000D00) {
+		/* CBDMA0 */
+		cbdma_info[idx_cbdma].sram_addr = 0x9E800000;
+		cbdma_info[idx_cbdma].sram_size = 40 << 10;
+	} else {
+		/* CBDMA1 */
+		cbdma_info[idx_cbdma].sram_addr = 0x9E820000;
+		cbdma_info[idx_cbdma].sram_size = 4 << 10;
+	}
+	printk(KERN_INFO "%s, %d, SRAM: 0x%x bytes @ 0x%x\n", __func__, __LINE__, cbdma_info[idx_cbdma].sram_size, cbdma_info[idx_cbdma].sram_addr);
+
+	/* Allocate uncached memory for test */
+	cbdma_info[idx_cbdma].buf_va = dma_alloc_coherent(&(pdev->dev), BUF_SIZE_DRAM, &(cbdma_info[idx_cbdma].dma_handle), GFP_KERNEL);
+	if (cbdma_info[idx_cbdma].buf_va == NULL) {
+		printk(KERN_INFO "%s, %d, Can't allocation buffer for %s\n", __func__, __LINE__, cbdma_info[idx_cbdma].name);
+		/* Skip error handling here */
+		ret = -ENOMEM;
+	}
+	printk(KERN_INFO "DMA buffer for %s, VA: 0x%p, PA: 0x%x\n", cbdma_info[idx_cbdma].name, cbdma_info[idx_cbdma].buf_va, (u32)(cbdma_info[idx_cbdma].dma_handle));
+
+	if (thread_ptr == NULL) {
+		printk(KERN_INFO "Start a thread for test ...\n");
+		thread_ptr = kthread_run(sp_cbdma_tst_thread, cbdma_info, "sp_cbdma_tst_thread");
+	}
+
+	idx_cbdma++;
+	return 0;
+
+}
+
+static struct platform_driver ssc_driver = {
+	.driver		= {
+		.name		= "sp_cbdma_tst",
+		.of_match_table	= of_match_ptr(sp_cbdma_tst_dt_ids),
+	},
+	.id_table	= sp_cbdma_tst_devtypes,
+	.probe		= sp_cbdma_tst_probe,
+};
+module_platform_driver(ssc_driver);
+
+MODULE_DESCRIPTION("CBDMA test driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sp_cbdma_tst");
--- a/drivers/misc/sp_dma0.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/misc/sp_dma0.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,324 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <mach/io_map.h>
+#include <asm/cacheflush.h>
+
+//#define TRACE
+#define TRACE			printk("%s:%d\n", __FUNCTION__, __LINE__)
+#define MSLEEP(n)		usleep_range((n)*1000, (n)*1000)
+
+#define DMA0_IRQS		9
+#define DMA0_RUN		(1 << 31) // owner bit
+#define WAIT(c)			while (c) { MSLEEP(1); }
+#define DMA0_WAIT(c)	WAIT((c)->cfg1 & DMA0_RUN)
+
+#define WORKMEM_BASE	0x9ea00000
+#define WORKMEM_SIZE	SZ_512K
+#define WORKMEM_VA(pa)	(sp_dma0.membase + ((pa) - WORKMEM_BASE))
+#define IS_WORKMEM(a)	(((u32)(a) - WORKMEM_BASE) < WORKMEM_SIZE)
+
+typedef volatile u32 REG;
+
+struct dma_cfg {
+	REG cfg0;	// len/src_offset/dst_offset
+	REG cfg1;	// owner/dir/loops
+	REG addr0;
+	REG addr1;
+};
+
+struct urgent_cfg {
+	REG cfg0;
+	REG cfg1;
+};
+
+struct bio_cfg {
+	REG addr;
+	REG ctrl;
+};
+
+struct sp_dma0_reg {
+	// G11~G12
+	REG cfgs[2][32];
+	// G13
+	struct urgent_cfg ug[6];
+	REG glb_ctrl;
+	REG arb_wt;
+	REG ch_loop_sts0;
+	REG ch_loop_sts1;
+	REG ch_loop_sts2;
+	REG glb_sts;
+	REG intr_ctrl;
+};
+
+struct sp_dma0_dev {
+    struct sp_dma0_reg *reg;
+	struct bio_cfg *bio;
+    int irq;
+	void *membase;
+};
+
+static struct sp_dma0_dev sp_dma0;
+
+int sp_dma0_copy(u32 ch, u32 dst, u32 src, u32 size, bool wait)
+{
+	struct sp_dma0_reg *reg = sp_dma0.reg;
+	REG *cfgs = reg->cfgs[0];
+	struct dma_cfg *cfg;
+	u32 dir = IS_WORKMEM(dst); // DMA0 direction 0:out 1:in
+	u32 ab = (ch < 6); // 0:A<->A 1:A<->B
+
+	BUG_ON(ch > 7);
+	BUG_ON(!IS_WORKMEM(src) && !IS_WORKMEM(dst));
+    BUG_ON(ab && IS_WORKMEM(src) && IS_WORKMEM(dst));
+	BUG_ON(!ab && !(IS_WORKMEM(src) && IS_WORKMEM(dst)));
+
+    //flush_cache_all();
+
+	size = (size + 15) / 16; // DMA length: 128 bits aligned
+
+	cfg = (struct dma_cfg *)&cfgs[ab ? (ch * 3) : (ch * 4 - 6)];
+	DMA0_WAIT(cfg);
+
+	if (ab) {
+		cfg->cfg0 = size << 17;
+		cfg->addr0 = dir ? dst : src;
+		if (!dir) {
+			sp_dma0.bio[ch].addr = dst;
+			sp_dma0.bio[ch].ctrl = DMA0_RUN | (0 << 16) | size; // start bio read
+		}
+	} else {
+		cfg->cfg0 = size << 16;
+		cfg->addr0 = src;
+		cfg->addr1 = dst;
+	}
+
+	cfg->cfg1 = DMA0_RUN | (dir << 30) | 1;
+
+	if (ab && dir) {
+		sp_dma0.bio[ch].addr = src;
+		sp_dma0.bio[ch].ctrl = DMA0_RUN | (1 << 16) | size; // start bio write
+	}
+
+	if (wait) DMA0_WAIT(cfg); // wait dma done
+
+	return 0;
+}
+EXPORT_SYMBOL(sp_dma0_copy);
+
+void sp_dma0_wait(u32 ch)
+{
+	struct dma_cfg *cfg;
+	cfg = (struct dma_cfg *)&sp_dma0.reg->cfgs[0][(ch < 6) ? (ch * 3) : (ch * 4 - 6)];
+	DMA0_WAIT(cfg);
+}
+EXPORT_SYMBOL(sp_dma0_wait);
+
+void sp_dma0_pause(u32 ch)
+{
+	sp_dma0.reg->glb_ctrl |= (1 << ch);
+}
+EXPORT_SYMBOL(sp_dma0_pause);
+
+void sp_dma0_resume(u32 ch)
+{
+	sp_dma0.reg->glb_ctrl &= ~(1 << ch);
+}
+EXPORT_SYMBOL(sp_dma0_resume);
+
+void sp_dma0_reset(u32 ch)
+{
+	u32 m = (1 << (ch + 8));
+	sp_dma0.reg->glb_ctrl |= m;
+	WAIT(sp_dma0.reg->glb_ctrl & m); // wait reset done
+}
+EXPORT_SYMBOL(sp_dma0_reset);
+
+#ifdef CONFIG_SP_DMA0_TEST // test & example
+
+#if 0
+static void dump_buf(u8 *buf, u32 len)
+{
+    static char s[] = "       |       \n";
+    char ss[52] = "";
+    u32 i = 0, j;
+    printk("buf:%p, len:%d\n", buf, len);
+    while (i < len) {
+        j = i & 0x0F;
+        sprintf(ss + j * 3, "%02x%c", buf[i], s[j]);
+        i++;
+        if ((i & 0x0F) == 0) {
+            printk(ss);
+            ss[0] = 0;
+        }
+    }
+    if (i & 0x0F) {
+        printk(ss);
+    }
+}
+
+#define RESULT \
+({ \
+	int ret = memcmp(src, dst, size); \
+	if (ret) dump_buf(dst, size); \
+	ret ? "FAIL" : "PASS"; \
+})
+#else
+#define RESULT	(memcmp(src, dst, size) ? "FAIL" : "PASS")
+#endif
+
+#define UG_SLOP		0x4
+#define UG_BD_UP	0x200
+#define UG_BD_DOWN	0x0
+#define UG_DATA_TH	0x2b0
+#define UG_CTRL0	((1<<31) | (UG_SLOP<<20) | (UG_BD_UP<<10) | UG_BD_DOWN)
+
+static int test_set(const char *val, const struct kernel_param *kp)
+{
+	u32 src_pa, dst_pa, size, sz;
+	void *src, *dst;
+	int i;
+
+	// A -> A
+	size   = SZ_128K;
+	src_pa = WORKMEM_BASE + SZ_32K; // workmem head 32 KB maybe security
+	dst_pa = src_pa + size;
+	src    = WORKMEM_VA(src_pa);
+	dst    = WORKMEM_VA(dst_pa);
+
+	memset(src, 0xa5, size);
+	memset(dst, 0xdd, size);
+
+	sp_dma0_copy(6, dst_pa, src_pa, size, true);
+	printk("DMA0 A:%08x -> A:%08x test: %s\n", src_pa, dst_pa, RESULT);
+
+	// A -> B
+	dst = dma_alloc_coherent(NULL, size, &dst_pa, GFP_KERNEL);
+	memset(dst, 0xee, size);
+
+    sp_dma0_copy(0, dst_pa, src_pa, size, false);
+#if 0 // RESET
+	sp_dma0_reset(0);
+	sp_dma0_copy(0, dst_pa, src_pa, size, true);
+#else // PAUSE/RESUME
+	sp_dma0_pause(0);
+	MSLEEP(1);
+	sp_dma0_resume(0);
+	sp_dma0_wait(0);
+#endif
+	printk("DMA0 A:%08x -> B:%08x test (pause/resume): %s\n", src_pa, dst_pa, RESULT);
+
+	// B -> A
+	memset(src, 0xff, size);
+
+	sp_dma0_copy(1, src_pa, dst_pa, size, true);
+	printk("DMA0 B:%08x -> A:%08x test: %s\n", dst_pa, src_pa, RESULT);
+
+	// A -> B (Urgent)
+	sz = SZ_16K;
+	memset(dst, 0xdd, 6 * sz);
+
+	// initial urgent config for 6 channels
+	for (i = 0; i < 6; i++) {
+		sp_dma0.reg->ug[i].cfg0 = UG_CTRL0;
+		sp_dma0.reg->ug[i].cfg1 = UG_DATA_TH;
+	}
+
+	// start 6 channels to transfer 6*16KB data
+	for (i = 0; i < 6; i++) {
+		sp_dma0_copy(i, dst_pa + (i * sz), src_pa + (i * sz), sz, false);
+	}
+	// wait all 6 channels done
+	for (i = 0; i < 6; i++) {
+		sp_dma0_wait(i);
+	}
+    printk("DMA0 A:%08x -> B:%08x test (urgent): %s\n", src_pa, dst_pa, RESULT);
+
+	dma_free_coherent(NULL, size, dst, dst_pa);
+
+	return 0;
+}
+
+static const struct kernel_param_ops test_ops = {
+	.set = test_set,
+};
+module_param_cb(test, &test_ops, NULL, 0600);
+#endif
+
+static irqreturn_t sp_dma0_isr(int irq, void *dev_id)
+{
+    int i = irq - sp_dma0.irq;
+	if (i < 8) {
+		early_printk("!DMA0 Ch#%d Job Done!\n", i);
+	} else {
+		early_printk("!DMA0 Address Expired Error: %08x\n", sp_dma0.reg->glb_sts);
+	}
+
+	return IRQ_HANDLED;
+}
+	
+static int sp_dma0_probe(struct platform_device *pdev)
+{
+	struct sp_dma0_dev *dev = &sp_dma0;
+	struct resource *res_mem, *res_irq;
+	void __iomem *membase;
+	int i = 0;
+	int ret = 0;
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res_mem)
+		return -ENODEV;
+
+	membase = devm_ioremap_resource(&pdev->dev, res_mem);
+	if (IS_ERR(membase))
+		return PTR_ERR(membase);
+
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res_irq) {
+		return -ENODEV;
+	}
+
+	dev->reg = membase;
+	dev->irq = res_irq->start;
+	dev->bio = (struct bio_cfg *)(VA_B_REG + 261 * 4096);
+	dev->membase = devm_ioremap(&pdev->dev, WORKMEM_BASE, WORKMEM_SIZE); // workmem sram
+	//dev->membase = devm_memremap(&pdev->dev, WORKMEM_BASE, WORKMEM_SIZE, MEMREMAP_WB);
+	//*(REG *)(VA_A_REG + 83 * 128 + 4) = 0xffffffff; // disable workmem security
+	platform_set_drvdata(pdev, dev);
+
+	while (i < DMA0_IRQS) {
+		ret = devm_request_irq(&pdev->dev, dev->irq + i, sp_dma0_isr, IRQF_TRIGGER_RISING, "sp_dma0", dev);
+		if (ret) {
+			return -ENODEV;
+		}
+		i++;
+	}
+	TRACE;
+
+	return ret;
+}
+
+static const struct of_device_id sp_dma0_of_match[] = {
+	{ .compatible = "sunplus,sp-dma0" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sp_dma0_of_match);
+
+static struct platform_driver sp_dma0_driver = {
+	.probe		= sp_dma0_probe,
+	.driver		= {
+		.name	= "sp_dma0",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(sp_dma0_of_match),
+	},
+};
+
+module_platform_driver(sp_dma0_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sunplus Technology");
+MODULE_DESCRIPTION("Sunplus DMA0 driver");
--- a/drivers/misc/sp_icm.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/misc/sp_icm.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,427 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <mach/io_map.h>
+#include <mach/sp_icm.h>
+
+#define NUM_ICM 4
+
+//#define TRACE(s) printk("### %s:%d %s\n", __FUNCTION__, __LINE__, s)
+#define TRACE(s)
+
+#define RPM_GET(dev) \
+do { \
+	TRACE("RPM_GET"); \
+	pm_runtime_get_sync(dev); \
+} while (0)
+
+#define RPM_PUT(dev) \
+do { \
+	TRACE("RPM_PUT"); \
+	pm_runtime_put(dev); \
+} while (0)
+
+// cfg0
+#define ICM_ENABLE		0x00010001	// enable icm
+#define ICM_DISABLE		0x00010000	// disable icm
+#define ICM_RELOAD		0x00020002	// reload icm settings
+#define ICM_INTCLR		0x00040004	// clear icm interrupt
+
+#define MUXSEL_OFS	3
+#define MUXSEL_BITS	3
+#define CLKSEL_OFS	6
+#define CLKSEL_BITS	3
+
+// cfg1
+#define EEMODE_OFS	0
+#define EEMODE_BITS	2
+#define ETIMES_OFS	2
+#define ETIMES_BITS	4
+#define DTIMES_OFS	6
+#define DTIMES_BITS	3
+
+#define ICM_FCLEAR	0x20002000	// clear fifo, also fddrop=0, fempty=1, ffull=0
+#define ICM_FMASK	(ICM_FDDROP | ICM_FEMPTY | ICM_FFULL)
+
+#define ICM_MSK(field)  (((1 << field##_BITS) - 1) << field##_OFS)
+
+#define ICM_SETCFG(_cfg, field, val) \
+	do { \
+		icm->cfg##_cfg = ((val) << field##_OFS) | (ICM_MSK(field) << 16); \
+	} while (0)
+#define ICM_GETCFG(_cfg, field) \
+	(((icm->cfg##_cfg) & ICM_MSK(field)) >> field##_OFS)
+
+struct sp_icm_reg {
+	/*
+	u32 enable:1;
+	u32 reload:1; // reload setting
+	u32 intclr:1; // write 1 clear interrupt
+	u32 muxsel:3; // select input signal source
+	u32 clksel:3; // select clock source for counter
+	u32 rsv0:7;
+	u32 msk0:16;
+	*/
+	u32 cfg0;
+
+	/*
+	u32 eemode:2; // edge mode: 0 rising / 1 falling / 2 both
+	u32 etimes:4; // event times (0~15)
+	u32 dtimes:3; // debounce times (0~7)
+	u32 rsv1:3;
+	u32 fddrop:1; // fifo data drop
+	u32 fclear:1; // fifo clear
+	u32 fempty:1; // fifo empty
+	u32 ffull :1; // fifo full
+	u32 msk1:16;
+	*/
+	u32 cfg1;
+
+	u32 cntscl;	// counter clock prescaler: cnt_clk = ext_clk / (cnt_scl + 1)
+	u32 tstscl;	// test signal clock prescaler: tst_clk = sysclk / (tst_scl + 1)
+	u32 cnt;	// counter, read from fifo
+
+	u32 pwh;	// pulse width high
+	u32 pwl;	// pulse width low
+};
+
+struct sp_icm_dev {
+	volatile struct sp_icm_reg *reg;
+	int irq;
+	struct clk *clk;
+	struct device *dev;
+};
+
+static struct sp_icm_dev sp_icm;
+static sp_icm_cbf cbfs[NUM_ICM];
+
+static irqreturn_t sp_icm_isr(int irq, void *dev_id)
+{
+	int i = irq - sp_icm.irq;
+	volatile struct sp_icm_reg *icm = &sp_icm.reg[i];
+	u32 cnt, fstate;
+
+	//TRACE("");
+	icm->cfg0 = ICM_INTCLR; // clear interrupt
+
+	while (!((fstate = icm->cfg1) & ICM_FEMPTY)) { // fifo not empty
+		cnt = icm->cnt; // read counter from fifo
+		if (cbfs[i]) {
+			(*cbfs[i])(i, cnt, fstate & ICM_FMASK); // callback
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+
+
+int sp_icm_setcfg(int i, struct sp_icm_cfg *cfg)
+{
+	volatile struct sp_icm_reg *icm;
+
+	if (i < 0 || i >= NUM_ICM) return -EINVAL;
+
+	RPM_GET(sp_icm.dev);
+	icm = &sp_icm.reg[i];
+	ICM_SETCFG(0, MUXSEL, cfg->muxsel);
+	ICM_SETCFG(0, CLKSEL, cfg->clksel);
+	ICM_SETCFG(1, EEMODE, cfg->eemode);
+	ICM_SETCFG(1, ETIMES, cfg->etimes);
+	ICM_SETCFG(1, DTIMES, cfg->dtimes);
+	icm->cntscl = cfg->cntscl;
+	icm->tstscl = cfg->tstscl;
+	RPM_PUT(sp_icm.dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(sp_icm_setcfg);
+
+int sp_icm_getcfg(int i, struct sp_icm_cfg *cfg)
+{
+	volatile struct sp_icm_reg *icm;
+
+	if (i < 0 || i >= NUM_ICM) return -EINVAL;
+
+	RPM_GET(sp_icm.dev);
+	icm = &sp_icm.reg[i];
+	cfg->muxsel = ICM_GETCFG(0, MUXSEL);
+	cfg->clksel = ICM_GETCFG(0, CLKSEL);
+	cfg->eemode = ICM_GETCFG(1, EEMODE);
+	cfg->etimes = ICM_GETCFG(1, ETIMES);
+	cfg->dtimes = ICM_GETCFG(1, DTIMES);
+	cfg->cntscl = icm->cntscl;
+	cfg->tstscl = icm->tstscl;
+	RPM_PUT(sp_icm.dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(sp_icm_getcfg);
+
+int sp_icm_reload(int i)
+{
+	if (i < 0 || i >= NUM_ICM) return -EINVAL;
+	RPM_GET(sp_icm.dev);
+	sp_icm.reg[i].cfg0 = ICM_RELOAD;
+	RPM_PUT(sp_icm.dev);
+	return 0;
+}
+EXPORT_SYMBOL(sp_icm_reload);
+
+int sp_icm_enable(int i, sp_icm_cbf cbf)
+{
+	if (i < 0 || i >= NUM_ICM) return -EINVAL;
+	cbfs[i] = cbf;
+	RPM_GET(sp_icm.dev);
+	sp_icm.reg[i].cfg0 = ICM_ENABLE;
+	return 0;
+}
+EXPORT_SYMBOL(sp_icm_enable);
+
+int sp_icm_disable(int i)
+{
+	if (i < 0 || i >= NUM_ICM) return -EINVAL;
+	sp_icm.reg[i].cfg0 = ICM_DISABLE;
+	sp_icm.reg[i].cfg1 = ICM_FCLEAR; // clear fifo
+	RPM_PUT(sp_icm.dev);
+	cbfs[i] = NULL;
+	return 0;
+}
+EXPORT_SYMBOL(sp_icm_disable);
+
+int sp_icm_fstate(int i, u32 *fstate)
+{
+	if (i < 0 || i >= NUM_ICM) return -EINVAL;
+	RPM_GET(sp_icm.dev);
+	*fstate = sp_icm.reg[i].cfg1 & ICM_FMASK;
+	RPM_PUT(sp_icm.dev);
+	return 0;
+}
+EXPORT_SYMBOL(sp_icm_fstate);
+
+int sp_icm_pwidth(int i, u32 *pwh, u32 *pwl)
+{
+	if (i < 0 || i >= NUM_ICM) return -EINVAL;
+	RPM_GET(sp_icm.dev);
+	*pwh = sp_icm.reg[i].pwh;
+	*pwl = sp_icm.reg[i].pwl;
+	RPM_PUT(sp_icm.dev);
+	return 0;
+}
+EXPORT_SYMBOL(sp_icm_pwidth);
+
+
+#ifdef CONFIG_SP_ICM_TEST // test & example
+static u32 tscnt = 0; // test signal counter
+
+static void test_cbf(int i, u32 cnt, u32 fstate)
+{
+	u32 pwh, pwl;
+	sp_icm_pwidth(i, &pwh, &pwl);
+	printk("icm%d_%05u: %10u %04x %u %u\n", i, ++tscnt, cnt, fstate, pwh, pwl);
+}
+
+static void test_help(void)
+{
+	printk(
+		"sp_icm test:\n"
+		"  echo <icm:0~3> [function] [params...] > /sys/module/sp_icm/parameters/test\n"
+		"  * if no function & params, dump icm cfg & state\n"
+		"  function:\n"
+		"    0: disable icm, no params\n"
+		"    1: enable icm\n"
+		"    2: reload icm\n"
+		"  params in order:\n"
+		"    muxsel, clksel, eemode, etimes, dtimes, cntscl, tstscl, tstime(ms)\n"
+		"    * -1 means no change\n"
+	);
+}
+
+static int test_set(const char *val, const struct kernel_param *kp)
+{
+	int i, f, muxsel, clksel, eemode, etimes, dtimes, cntscl, tstscl, tstime;
+	u32 fstate, pwh, pwl;
+	struct sp_icm_cfg cfg;
+
+	i = f = muxsel = clksel = eemode = etimes = dtimes = cntscl = tstscl = tstime = -1;
+	sscanf(val, "%d %d %d %d %d %d %d %d %d %d",
+		&i, &f, &muxsel, &clksel, &eemode, &etimes, &dtimes, &cntscl, &tstscl, &tstime);
+
+	if (i >= 0 && i < NUM_ICM) {
+		switch (f) {
+		case 0: // disable
+disable:
+			sp_icm_disable(i);
+			printk("icm%d: tscnt = %u\n", i, tscnt);
+			tscnt = 0;
+			return 0;
+
+		case 1: // enable
+		case 2: // reload
+			sp_icm_getcfg(i, &cfg);
+			if (muxsel != -1) cfg.muxsel = (u32)muxsel;
+			if (clksel != -1) cfg.clksel = (u32)clksel;
+			if (eemode != -1) cfg.eemode = (u32)eemode;
+			if (etimes != -1) cfg.etimes = (u32)etimes;
+			if (dtimes != -1) cfg.dtimes = (u32)dtimes;
+			if (cntscl != -1) cfg.cntscl = (u32)cntscl;
+			if (tstscl != -1) cfg.tstscl = (u32)tstscl;
+			sp_icm_setcfg(i, &cfg);
+			if (f == 1) {
+				sp_icm_enable(i, test_cbf);
+				if (tstime > 0) {
+					mdelay(tstime);
+					goto disable;
+				}
+			} else
+				sp_icm_reload(i);
+			return 0;
+
+		case -1:
+			sp_icm_getcfg(i, &cfg);
+			sp_icm_fstate(i, &fstate);
+			sp_icm_pwidth(i, &pwh, &pwl);
+			printk("sp_icm%d cfg & state:", i);
+			printk("muxsel: %u", cfg.muxsel);
+			printk("clksel: %u", cfg.clksel);
+			printk("eemode: %u", cfg.eemode);
+			printk("etimes: %u", cfg.etimes);
+			printk("dtimes: %u", cfg.dtimes);
+			printk("cntscl: %u", cfg.cntscl);
+			printk("tstscl: %u", cfg.tstscl);
+			printk("fstate: %04x", fstate);
+			printk("pwidth: %u %u\n", pwh, pwl);
+			return 0;
+		}
+	}
+
+	test_help();
+	return 0;
+}
+
+static const struct kernel_param_ops test_ops = {
+	.set = test_set,
+};
+module_param_cb(test, &test_ops, NULL, 0600);
+#endif
+
+
+static const struct of_device_id sp_icm_of_match[] = {
+	{ .compatible = "sunplus,sp-icm" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sp_icm_of_match);
+
+static int sp_icm_probe(struct platform_device *pdev)
+{
+	struct sp_icm_dev *dev = &sp_icm;
+	struct resource *res_mem, *res_irq;
+	int i = 0;
+	int ret = 0;
+
+	TRACE("");
+	dev->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(dev->clk)) {
+		dev_err(&pdev->dev, "not found clk source\n");
+		return PTR_ERR(dev->clk);
+	}
+	clk_prepare(dev->clk);
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res_mem)
+		return -ENODEV;
+
+	dev->reg = devm_ioremap_resource(&pdev->dev, res_mem);
+	if (IS_ERR((void *)dev->reg))
+		return PTR_ERR((void *)dev->reg);
+
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res_irq) {
+		return -ENODEV;
+	}
+
+	dev->irq = res_irq->start;
+	platform_set_drvdata(pdev, dev);
+
+	dev->dev = &pdev->dev;
+	pm_runtime_set_active(dev->dev);
+	pm_runtime_enable(dev->dev);
+	RPM_GET(dev->dev);
+	RPM_PUT(dev->dev);
+
+	while (i < NUM_ICM) {
+		ret = devm_request_irq(&pdev->dev, dev->irq + i, sp_icm_isr, IRQF_TRIGGER_RISING, "sp_icm", dev);
+		if (ret) {
+			return -ENODEV;
+		}
+		i++;
+	}
+
+	return ret;
+}
+
+static int __maybe_unused sp_icm_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int irq = platform_get_irq(pdev, 0);
+	struct irq_data *data = irq_get_irq_data(irq);
+
+	if (!irqd_is_wakeup_set(data))
+		return pm_runtime_force_suspend(dev);
+
+	return 0;
+}
+
+static int __maybe_unused sp_icm_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int irq = platform_get_irq(pdev, 0);
+	struct irq_data *data = irq_get_irq_data(irq);
+
+	if (!irqd_is_wakeup_set(data))
+		return pm_runtime_force_resume(dev);
+
+	return 0;
+}
+
+static int __maybe_unused sp_icm_runtime_suspend(struct device *dev)
+{
+	TRACE("");
+	clk_disable(sp_icm.clk);
+	return 0;
+}
+
+static int __maybe_unused sp_icm_runtime_resume(struct device *dev)
+{
+	TRACE("");
+	clk_enable(sp_icm.clk);
+	return 0;
+}
+
+static const struct dev_pm_ops sp_icm_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sp_icm_suspend, sp_icm_resume)
+	SET_RUNTIME_PM_OPS(sp_icm_runtime_suspend,
+		sp_icm_runtime_resume, NULL)
+};
+
+static struct platform_driver sp_icm_driver = {
+	.probe		= sp_icm_probe,
+	.driver		= {
+		.name	= "sp_icm",
+		.owner	= THIS_MODULE,
+		.pm     = &sp_icm_pm_ops,
+		.of_match_table = of_match_ptr(sp_icm_of_match),
+	},
+};
+
+module_platform_driver(sp_icm_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sunplus Technology");
+MODULE_DESCRIPTION("Sunplus ICM driver");
--- a/drivers/misc/sp_ipc.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/misc/sp_ipc.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,1146 @@
+/**
+ * @file    sp_ipc.c
+ * @brief   Implement of Sunplus IPC Linux driver.
+ * @author  qinjian
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/of_platform.h>
+#include <linux/miscdevice.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/kthread.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+//#include "sp_cbdma.h"
+#include <mach/sp_ipc.h>
+
+//#define IPC_TIMEOUT_DEBUG
+//#define IPC_REG_OVERWRITE
+#ifdef CONFIG_ARCH_ZYNQ
+#define LOCAL_TEST
+#endif
+/**************************************************************************
+ *                           C O N S T A N T S                            *
+ **************************************************************************/
+
+/* IPC Reg Group */
+#ifndef CONFIG_ARCH_ZYNQ
+#include <mach/io_map.h>
+#define REG_GROUP(g)		VA_IOB_ADDR((g)*32*4)
+#endif
+#ifdef LOCAL_TEST
+#define REG_GROUP_A2B		(&ipc->local)
+#define REG_GROUP_B2A		(&ipc->local)
+#else
+#define REG_GROUP_A2B		REG_GROUP(258)
+#define REG_GROUP_B2A		REG_GROUP(259)
+#endif
+
+#define IPC_LOCAL			((ipc_t *)REG_GROUP_A2B)
+#define IPC_REMOTE			((ipc_t *)REG_GROUP_B2A)
+
+#ifdef IPC_USE_CBDMA
+#define IPC_CBDMA_NAME      "sp_cbdma.0"
+#define CBDMA_NAND_BUFF_MAX  (19 << 10)
+#define IPC_CBDMA_BUFF_MAX	(8 << 10)
+#define IPC_CBDMA_BUFF_ADDR (0x9E800000 + CBDMA_NAND_BUFF_MAX + (1 << 10))
+#endif
+#define IPC_SEQ_LEN         (4)
+/* IPC Interrupt Number */
+#ifdef CONFIG_ARCH_ZYNQ
+#define CA9_DIRECT_INT0		(60)
+#else
+#define CA9_DIRECT_INT0		(182)
+#endif
+#define CA9_DIRECT_INT1		(CA9_DIRECT_INT0 + 1)
+#define CA9_DIRECT_INT2		(CA9_DIRECT_INT0 + 2)
+#define CA9_DIRECT_INT3		(CA9_DIRECT_INT0 + 3)
+#define CA9_DIRECT_INT4		(CA9_DIRECT_INT0 + 4)
+#define CA9_DIRECT_INT5		(CA9_DIRECT_INT0 + 5)
+#define CA9_DIRECT_INT6		(CA9_DIRECT_INT0 + 6)
+#define CA9_DIRECT_INT7		(CA9_DIRECT_INT0 + 7)
+#define A926_DIRECT_INT0	(CA9_DIRECT_INT0 + 8)
+#define A926_DIRECT_INT1	(CA9_DIRECT_INT0 + 9)
+#define A926_DIRECT_INT2	(CA9_DIRECT_INT0 + 10)
+#define A926_DIRECT_INT3	(CA9_DIRECT_INT0 + 11)
+#define A926_DIRECT_INT4	(CA9_DIRECT_INT0 + 12)
+#define A926_DIRECT_INT5	(CA9_DIRECT_INT0 + 13)
+#define A926_DIRECT_INT6	(CA9_DIRECT_INT0 + 14)
+#define A926_DIRECT_INT7	(CA9_DIRECT_INT0 + 15)
+#define CA9_INT				(CA9_DIRECT_INT0 + 16)
+#define A926_INT			(CA9_DIRECT_INT0 + 17)
+
+#define IRQ_RPC				CA9_INT
+
+/* IPC Driver Defines */
+#define RPC_TIMEOUT			7000	// ms
+#define RPC_NO_TIMEOUT		0		// ms
+
+#define FIFO_SIZE			16		// must be 2^n
+#define FIFO_MASK			(FIFO_SIZE - 1)
+
+/**************************************************************************
+ *                              M A C R O S                               *
+ **************************************************************************/
+#define REG_ALIGN(len)      (((len) + 3)&(~3))
+#define printf				printk
+#define malloc(n)			kmalloc(n, GFP_KERNEL)
+#define free				kfree
+
+#define ZALLOC(n)			kzalloc(n, GFP_KERNEL)
+
+#define MSLEEP(n)			usleep_range((n)*1000, (n)*1000)
+
+#define WAIT_INIT(wait, t) \
+{ \
+	wait_t *w = (wait_t *)(wait); \
+	if ((w->timeout = msecs_to_jiffies(t))) { \
+		w->waked = 0; \
+		init_waitqueue_head(&w->wq); \
+	} else { \
+		sema_init(&w->sem, 0); \
+	} \
+}
+#define DOWN(wait) \
+{ \
+	wait_t *w = (wait_t *)(wait); \
+	if (w->timeout) { \
+		long r; \
+		r = wait_event_interruptible_timeout(w->wq, w->waked, w->timeout); \
+		if (r == 0) return IPC_FAIL_TIMEOUT; \
+		if (r < 0) return IPC_FAIL; \
+	} else { \
+		if (down_killable(&w->sem)) return IPC_FAIL; \
+	} \
+}
+#define UP(wait) \
+{ \
+	wait_t *w = (wait_t *)(wait); \
+	if (w->timeout) { \
+		w->waked = 1; \
+		if (!list_empty(&w->wq.task_list)) wake_up_interruptible(&w->wq); \
+	} else { \
+		up(&w->sem); \
+	} \
+}
+
+#define RESPONSE(rpc, ret) \
+{ \
+	(rpc)->F_DIR = RPC_RESPONSE; \
+	(rpc)->CMD = ret; \
+	if (rpc_fifo_put(&ipc->res_fifo, rpc) != IPC_SUCCESS) { \
+		printf("RES FIFO FULL!!!\n"); \
+	} \
+}
+
+#ifdef _SP_CHUNKMEM_H_
+#define __PA(addr) \
+({ \
+	u32 t = sp_chunk_pa((void *)(addr)); \
+	(t ? t : __pa(addr)); \
+})
+#define __VA(addr) \
+({ \
+	void *t = sp_chunk_va((u32)(addr)); \
+	(t ? t : __va(addr)); \
+})
+#else
+#define __PA(addr)	__pa(addr)
+#define __VA(addr)	__va(addr)
+#endif
+
+/**************************************************************************
+ *                          D A T A    T Y P E S                          *
+ **************************************************************************/
+
+typedef struct {
+	u32 timeout;
+	union {
+		struct {
+			u32	waked;
+			wait_queue_head_t wq;
+		};
+		struct semaphore sem;
+	};
+} wait_t;
+
+typedef struct {
+	rpc_t	rpc;
+	wait_t	wait_response;
+} request_t;
+
+typedef struct {
+	rpc_t	data[FIFO_SIZE];
+	u32		in;						// write pointer
+	u32		out;					// read pointer
+	wait_t	wait;
+} rpc_fifo_t;
+#ifdef IPC_USE_CBDMA
+typedef struct ipc_cbdma_t {
+	struct device *cbdma_device;
+	u32 phy_addr;
+	u32 size;
+	void  *vir_addr;
+	struct mutex  cbdma_lock;
+}ipc_cbdma_t;
+#else
+typedef struct {
+	u32 seq;
+	struct mutex lock;
+}ipc_sequense_t;
+#endif
+
+typedef struct {
+	struct miscdevice dev;			// ipc device
+	struct mutex write_lock;
+	struct task_struct *rpc_res;	// rpc RESPONSE thread
+	rpc_fifo_t	res_fifo;			// rpc RESPONSE fifo
+	rpc_fifo_t	*fifo[SERVER_NUMS];	// server fifo
+	u32	pid[SERVER_NUMS];			// server pid
+#ifdef IPC_USE_CBDMA
+	struct ipc_cbdma_t cbdma;
+#else
+	ipc_sequense_t seq;
+#endif
+#ifdef LOCAL_TEST
+	ipc_t	local;
+#endif
+} sp_ipc_t;
+
+/**************************************************************************
+ *                 E X T E R N A L    R E F E R E N C E S                 *
+ **************************************************************************/
+
+/**************************************************************************
+ *               F U N C T I O N    D E C L A R A T I O N S               *
+ **************************************************************************/
+
+/**************************************************************************
+ *                         G L O B A L    D A T A                         *
+ **************************************************************************/
+
+static sp_ipc_t *ipc;
+
+/******************************* CACHE FUNCS ******************************/
+
+#include <asm/cacheflush.h>
+
+void DCACHE_CLEAN(u32 pa, void *start, int size)
+{
+	unsigned long oldIrq;
+
+	local_irq_save(oldIrq);
+	arm_dma_ops.sync_single_for_device(NULL, pa, size, DMA_TO_DEVICE);
+	local_irq_restore(oldIrq);
+}
+
+void DCACHE_INVALIDATE(u32 pa, void *start, int size)
+{
+	unsigned long oldIrq;
+
+	local_irq_save(oldIrq);
+	arm_dma_ops.sync_single_for_cpu(NULL, pa, size, DMA_FROM_DEVICE);
+	local_irq_restore(oldIrq);
+}
+
+#ifdef CONFIG_SP_IPC_TEST // test & example
+/*************************** IPC KERNEL API TEST **************************/
+
+#ifdef _SP_CHUNKMEM_H_
+#define TEST_CHUNKMEM
+#endif
+
+#define CA7_READY   (0xca700001)
+
+static irqreturn_t mbox_isr(int irq, void *dev_id)
+{
+	int i = irq - CA9_DIRECT_INT0;
+	u32 d = IPC_REMOTE->MBOX[i];
+	early_printk("[MBOX_%d] %08x (%u)\n", i, d, d);
+	return IRQ_HANDLED;
+}
+
+static int test_set(const char *val, const struct kernel_param *kp)
+{
+	int i, ret;
+	u32 len, timeout;
+	void *p;
+
+	len = timeout = 16;
+	sscanf(val, "%u %u", &len, &timeout);
+
+	if (len < 8) {
+		// test direct int
+		for (i = 0; i < 8; i++)
+			request_irq(CA9_DIRECT_INT0 + i, mbox_isr, IRQF_TRIGGER_RISING, "mbox", NULL);
+
+		IPC_LOCAL->MBOX[7] = CA7_READY; // notify B
+		mdelay(100); // wait B2A
+
+		for (i = 0; i < 8; i++)
+			free_irq(CA9_DIRECT_INT0 + i, NULL);
+		return 0;
+	}
+
+#ifdef TEST_CHUNKMEM
+	if (len > 4096) {
+		printk("len error %d\n", len);
+		return -EINVAL;
+	}
+	p = sp_chunk_malloc_nocache(0, 0, len);
+#else
+	p = (void *)MALLOC(len);;
+#endif
+	memset(p, 0x11, len);
+	*(u32 *)p = 0;
+	*((u32 *)p + 1) = len;
+	if ((0 < timeout) && (timeout <= RPC_TIMEOUT)) {
+		ret = IPC_FunctionCall(0, p, len);
+	} else {
+		ret = IPC_FunctionCall_timeout(0, p, len, timeout);
+	}
+	while(!ret && (len--)){
+		if(((u8 *)p)[len] != 0) {
+			printk("check error,  0x%0x, len:%0x\n", ((u8 *)p)[len], len);
+			ret = IPC_FAIL;
+			break;
+		}
+	}
+	printf("RET = %d\n", ret);
+
+#ifdef TEST_CHUNKMEM
+	sp_chunk_free(p);
+#else
+	FREE(p);
+#endif
+	return 0;
+}
+
+static const struct kernel_param_ops test_ops = {
+    .set = test_set,
+};
+module_param_cb(test, &test_ops, NULL, 0600);
+#endif
+
+/**************************************************************************/
+
+#ifdef LOCAL_TEST
+#include <asm/hardware/gic.h>
+static irqreturn_t rpc_isr(int irq, void *dev_id);
+
+static void irq_trigger(int irq)
+{
+#if 0
+	writel_relaxed(1 << (irq % 32), gic_base(GIC_DIST_BASE) + GIC_DIST_PENDING_SET + (irq / 32) * 4);
+#else
+	rpc_isr(IRQ_RPC, NULL);
+#endif
+}
+#endif
+
+/********************************* RPC HAL ********************************/
+
+#ifndef IPC_USE_CBDMA
+static void ipc_seq_init(ipc_sequense_t *seq) {
+	seq->seq = 0;
+	mutex_init(&seq->lock);
+}
+static void ipc_seq_finit(ipc_sequense_t *seq)
+{
+	seq->seq = 0;
+	mutex_destroy(&seq->lock);
+}
+static inline u32 ipc_seq_inc(ipc_sequense_t *seq)
+{
+	u32 s;
+	mutex_lock(&seq->lock);
+	seq->seq++;
+	s = seq->seq;
+	mutex_unlock(&seq->lock);
+	return s;
+}
+static inline void rpc_add_seq(rpc_t *rpc)
+{
+	u32 seq = ipc_seq_inc(&ipc->seq);
+	u16 len = rpc->DATA_LEN;
+	u32 *addr = (u32 *)((u8 *)rpc->DATA_PTR + REG_ALIGN(len));
+	rpc->SEQ_ADDR = (void *)__PA(addr);
+	*addr = seq;
+	rpc->SEQ = seq;
+}
+
+static int rpc_check_seq(rpc_t *rpc)
+{
+	u32 seq = rpc->SEQ;
+	u32 *addr = __VA(rpc->SEQ_ADDR);
+	unsigned long timeout = jiffies + msecs_to_jiffies(10); // 10ms
+	while(*addr != seq) {
+		void *va = rpc->DATA_PTR;
+		u32 pa = __PA(va);
+		if(time_after(jiffies, timeout)) {
+			printk("seq:0x%x, seq_data:%0x\n", seq, *addr);
+			rpc_dump("RPC_CHECK_ERR:", rpc);
+			return IPC_FAIL_DATANOTRDY;
+		}
+		printk("seq:0x%x, seq_data:%0x\n", seq, *addr);
+		DCACHE_INVALIDATE(pa, va, CACHE_ALIGN(rpc->DATA_LEN + IPC_SEQ_LEN));
+		udelay(1);
+	}
+
+	return IPC_SUCCESS;
+}
+
+#endif
+
+
+/* len must 4 btyes align */
+static void ipc_memcpy(void *dst, void *src, u32 len)
+{
+	u32 *d = (u32 *)dst;
+	u32 *s = (u32 *)src;
+	while(len) {
+		*d++ = *s++;
+		len -= 4;
+	}
+}
+
+static void rpc_copy(rpc_t *dst, rpc_t *src)
+{
+	int len;
+
+	ipc_memcpy(dst, src, REG_ALIGN(RPC_HEAD_SIZE));
+	if (src == &IPC_REMOTE->RPC) {	// reg read IMPORTANT: DON'T read IPC_REMOTE twice!!!
+#ifdef IPC_REG_OVERWRITE
+		if (IPC_REMOTE->F_OVERWRITE) {
+			printk("F_OVERWRITE:%08x\n", IPC_REMOTE->F_OVERWRITE);
+		}
+#endif
+		len = dst->DATA_LEN;
+		if (len > RPC_DATA_SIZE) {
+			u32 pa = (u32) src->DATA_PTR;
+			dst->DATA_PTR = __VA(pa);
+			print("pa->va: %08x -> %p\n", pa, dst->DATA_PTR);
+			DCACHE_INVALIDATE(pa, dst->DATA_PTR, CACHE_ALIGN(len + IPC_SEQ_LEN));
+		} else {
+			ipc_memcpy(dst->DATA, src->DATA, REG_ALIGN(len));
+		}
+	} else if (dst == &IPC_LOCAL->RPC) {	// reg write   IMPORTANT: DON'T write IPC_LOCAL twice!!!
+		len = src->DATA_LEN;
+		if (len > RPC_DATA_SIZE) {
+			u32 pa = __PA(src->DATA_PTR);
+			dst->DATA_PTR = (void *)pa;
+			print("va->pa: %p -> %08x\n", src->DATA_PTR, pa);
+#ifndef IPC_USE_CBDMA
+			DCACHE_CLEAN(pa, src->DATA_PTR, CACHE_ALIGN(len + IPC_SEQ_LEN));
+#endif
+		} else {
+			ipc_memcpy(dst->DATA, src->DATA, REG_ALIGN(len));
+		}
+	} else {		// nomal copy
+		len = src->DATA_LEN;
+		if (len > RPC_DATA_SIZE) {
+			dst->DATA_PTR = src->DATA_PTR;
+		} else {
+			memcpy(dst->DATA, src->DATA, len);
+		}
+	}
+}
+
+static void rpc_read_hw(rpc_t *rpc)
+{
+	rpc_copy(rpc, &IPC_REMOTE->RPC);
+	rpc_dump("RD_HW", rpc);
+}
+
+static int WAIT_IPC_WRITEABLE(u32 mask)
+{
+	int ret = IPC_SUCCESS;
+	int _i = IPC_WRITE_TIMEOUT;
+	while (IPC_LOCAL->F_RW & (mask)) {
+		MSLEEP(1);
+		if (!_i--) {
+			printf("write IPC HW timeout!\n");
+			ret = IPC_FAIL_HWTIMEOUT;
+			break;
+		}
+	}
+	return ret;
+}
+
+static int rpc_write_hw(rpc_t *rpc)
+{
+	int ret = IPC_SUCCESS;
+#ifndef IPC_USE_CBDMA
+	if(rpc->DATA_LEN > RPC_DATA_SIZE) {
+		rpc_add_seq(rpc);
+	}
+#endif
+	mutex_lock(&ipc->write_lock);				// lock for concurrent write
+
+#ifndef LOCAL_TEST
+	ret = WAIT_IPC_WRITEABLE(0xFFFFF0);
+	if (unlikely(ret))
+		goto out;
+#endif
+	rpc_copy(&IPC_LOCAL->RPC, rpc);
+	rpc_dump("WR_HW", rpc);
+	smp_wmb();
+	IPC_LOCAL->TRIGGER = 1;
+#ifdef LOCAL_TEST
+	irq_trigger(IRQ_RPC);
+#else
+out:
+#endif
+
+	mutex_unlock(&ipc->write_lock);
+	return ret;
+}
+
+/******************************** RPC FIFO ********************************/
+
+static int rpc_fifo_get(rpc_fifo_t *fifo, rpc_t *rpc)
+{
+	DOWN(&fifo->wait);
+
+	if ((fifo->in - fifo->out) == 0) {				// fifo is empty
+		return IPC_FAIL;
+	}
+
+	rpc_copy(rpc, &fifo->data[fifo->out & FIFO_MASK]);
+	smp_wmb();
+	fifo->out++;
+
+	return IPC_SUCCESS;
+}
+
+static int rpc_fifo_put(rpc_fifo_t *fifo, rpc_t *rpc)
+{
+	if ((fifo->in - fifo->out) == FIFO_SIZE) {		// fifo is full
+		return IPC_FAIL;
+	}
+
+	rpc_copy(&fifo->data[fifo->in & FIFO_MASK], rpc);
+	smp_wmb();
+	fifo->in++;
+
+	UP(&fifo->wait);
+
+	return IPC_SUCCESS;
+}
+
+/************************** MAILBOX INTR HANDLER **************************/
+
+// TODO:
+
+/**************************** RPC INTR HANDLER ****************************/
+
+static irqreturn_t rpc_isr(int irq, void *dev_id)
+{
+	rpc_t rpc;
+
+	trace();
+	rpc_read_hw(&rpc);
+
+	if (rpc.F_DIR == RPC_REQUEST) {
+		int sid = rpc.CMD >> SERVER_ID_OFFSET;		// server id
+		rpc_fifo_t *fifo = ipc->fifo[sid];
+
+		if (fifo == NULL) {
+			print("RPC SERVER #%d NOT RUNNING!!!\n", sid);
+			RESPONSE(&rpc, IPC_FAIL_NOSERV);
+			trace();
+		} else
+		if (rpc_fifo_put(fifo, &rpc) != IPC_SUCCESS) {	// put new rpc into fifo
+			print("RPC SERVER #%d FIFO FULL!!!\n", sid);
+			RESPONSE(&rpc, IPC_FAIL_BUSY);
+		}
+	}
+	else {
+		request_t *req = (request_t *)rpc.REQ_H;
+		if (rpc.F_TYPE != REQ_NO_REP) {
+			rpc_copy(&req->rpc, &rpc);
+			UP(&req->wait_response);
+		}
+		else {
+			if (rpc.DATA_LEN > RPC_DATA_SIZE) {
+				FREE(req->rpc.DATA_PTR_ORG);
+			}
+			FREE(req);
+		}
+ 	}
+
+	return IRQ_HANDLED;
+}
+
+static int rpc_res_thread(void *param)
+{
+	WAIT_INIT(&ipc->res_fifo.wait, 0);
+
+	while (!kthread_should_stop()) {
+		rpc_t rpc;
+		if (rpc_fifo_get(&ipc->res_fifo, &rpc) == IPC_SUCCESS) {
+			rpc_write_hw(&rpc);
+		}
+	}
+	return 0;
+}
+
+/**************************************************************************/
+
+static int rpc_from_user(rpc_t *rpc, rpc_t __user *rpc_user)
+{
+	u32 len;
+#ifdef IPC_USE_CBDMA
+	dma_addr_t dst;
+#endif
+	copy_from_user(rpc, rpc_user, RPC_HEAD_SIZE);
+	len = rpc->DATA_LEN;
+	if (len > RPC_DATA_SIZE) {
+		if (rpc->F_DIR == RPC_REQUEST) {
+			rpc->DATA_PTR_ORG = MALLOC(len + IPC_SEQ_LEN + CACHE_MASK * 2);
+			rpc->DATA_PTR = (void *)CACHE_ALIGN(rpc->DATA_PTR_ORG);
+		}
+		else {
+			get_user(rpc->DATA_PTR, &rpc_user->DATA_PTR_ORG);	// restore DATA_PTR
+		}
+#ifdef IPC_USE_CBDMA
+		mutex_lock(& ipc->cbdma.cbdma_lock);
+		copy_from_user( ipc->cbdma.vir_addr, rpc_user->DATA_PTR, len);
+		dst = dma_map_single(NULL, (void *)(rpc->DATA_PTR), len, DMA_TO_DEVICE);
+		if(0 > sp_cbdma_write( ipc->cbdma.cbdma_device,
+				(dma_addr_t) ipc->cbdma.phy_addr,
+				dst, len)) {
+			printf("cbdma error\n");
+		}
+		dma_unmap_single(NULL, dst, len, DMA_TO_DEVICE);
+		mutex_unlock(& ipc->cbdma.cbdma_lock);
+#else
+		copy_from_user(rpc->DATA_PTR, rpc_user->DATA_PTR, len);
+#endif
+
+	}
+	else {
+		copy_from_user(rpc->DATA, rpc_user->DATA, len);
+	}
+
+	return IPC_SUCCESS;
+}
+
+static int rpc_from_user_new(rpc_t *rpc, rpc_user_t *user, rpc_new_t __user *rpc_user)
+{
+	rpc_from_user(rpc, &rpc_user->rpc);
+	copy_from_user(user, &rpc_user->user, sizeof(rpc_user_t));
+	return IPC_SUCCESS;
+}
+#define RET(r)	((r > 511) ? (r - 1024) : r)
+
+static int rpc_to_user(rpc_t __user *rpc_user, rpc_t *rpc)
+{
+	int ret = IPC_SUCCESS;
+	u32 len = rpc->DATA_LEN;
+
+	if (rpc->F_DIR == RPC_REQUEST) {
+		if (len > RPC_DATA_SIZE) {
+#ifndef IPC_USE_CBDMA
+			ret = rpc_check_seq(rpc);
+			if(ret) {
+				return ret;
+			}
+#endif
+			copy_to_user(rpc_user, rpc, RPC_HEAD_SIZE);
+			put_user(rpc->DATA_PTR, &rpc_user->DATA_PTR_ORG);	// backup DATA_PTR
+			copy_to_user(rpc_user->DATA_PTR, rpc->DATA_PTR, len);
+		}
+		else {
+			copy_to_user(rpc_user, rpc, RPC_HEAD_SIZE + len);
+		}
+	}
+	else {
+		ret = RET(rpc->CMD);
+		if (ret == IPC_SUCCESS) {
+			if (len > RPC_DATA_SIZE) {
+#ifndef IPC_USE_CBDMA
+				ret = rpc_check_seq(rpc);
+				if(ret) {
+					FREE(rpc->DATA_PTR_ORG);
+					return ret;
+				}
+#endif
+				copy_to_user(rpc_user->DATA_PTR, rpc->DATA_PTR, len);
+			}
+			else {
+				copy_to_user(rpc_user->DATA, rpc->DATA, len);
+			}
+		}
+		if (len > RPC_DATA_SIZE) {
+			FREE(rpc->DATA_PTR_ORG);
+		}
+	}
+
+	return ret;
+}
+
+/****************************** RPC INTERFACE ******************************/
+
+static int rpc_read(rpc_t __user *rpc_user)
+{
+	request_t *req;
+	int ret = get_user(req, &rpc_user->REQ_H);
+	u32 sid = (u32)req;								// server id
+
+	if (sid > SERVER_NUMS) {						// read deferred response
+		DOWN(&req->wait_response);
+		ret = rpc_to_user(rpc_user, &req->rpc);
+		FREE(req);
+	}
+	else {											// read request
+		rpc_t rpc;
+		if (rpc_fifo_get(ipc->fifo[sid], &rpc) == IPC_SUCCESS) {	// get a rpc from fifo
+			rpc_to_user(rpc_user, &rpc);
+		}
+	}
+
+	return ret;
+}
+
+static int rpc_write(rpc_t __user *rpc_user)
+{
+	request_t *req = (request_t *)MALLOC(sizeof(request_t));
+	rpc_t *rpc = &req->rpc;
+	int ret = rpc_from_user(rpc, rpc_user);
+
+	if (rpc->F_DIR == RPC_REQUEST) {
+		rpc->REQ_H = req;
+		if (rpc->F_TYPE != REQ_NO_REP) {
+			WAIT_INIT(&req->wait_response, RPC_TIMEOUT);
+		}
+		ret = rpc_write_hw(rpc);						// write request
+		if (unlikely(ret)) {
+			FREE(req);
+			return ret;
+		}
+		if (rpc->F_TYPE == REQ_WAIT_REP) {
+			DOWN(&req->wait_response);			// wait response
+			ret = rpc_to_user(rpc_user, rpc);
+			FREE(req);
+		}
+		else if (rpc->F_TYPE == REQ_DEFER_REP) {
+			put_user(req, &rpc_user->REQ_H);	// return REQ_H
+		}
+	}
+	else {
+		ret = rpc_write_hw(rpc);						// write response
+		FREE(req);
+	}
+
+	return ret;
+}
+
+static int rpc_write_new(rpc_new_t __user *rpc_user)
+{
+	request_t *req = (request_t *)MALLOC(sizeof(request_t));
+	rpc_user_t user = {0};
+	rpc_t *rpc = &req->rpc;
+	int ret = rpc_from_user_new(rpc, &user,rpc_user);
+	if (rpc->F_DIR == RPC_REQUEST) {
+		rpc->REQ_H = req;
+		if (rpc->F_TYPE != REQ_NO_REP) {
+		#ifdef IPC_TIMEOUT_DEBUG
+			printk("timeout = %d\n", user.timeout);
+		#endif
+			WAIT_INIT(&req->wait_response, user.timeout);
+		}
+		ret = rpc_write_hw(rpc);						// write request
+		if (unlikely(ret)) {
+			FREE(req);
+			return ret;
+		}
+		if (rpc->F_TYPE == REQ_WAIT_REP) {
+			DOWN(&req->wait_response);			// wait response
+			ret = rpc_to_user(&rpc_user->rpc, rpc);
+			FREE(req);
+		}
+		else if (rpc->F_TYPE == REQ_DEFER_REP) {
+			put_user(req, &rpc_user->rpc.REQ_H);	// return REQ_H
+		}
+	}
+	else {
+		ret = rpc_write_hw(rpc);						// write response
+		FREE(req);
+	}
+	return ret;
+}
+/***************************** IPC KERNEL API *****************************/
+
+int IPC_FunctionCall(int cmd, void *data, int len)
+{
+	int ret;
+	request_t *req = (request_t *)MALLOC(sizeof(request_t));
+	rpc_t *rpc = &req->rpc;
+	void *p = NULL;						// temp buffer for cache align
+#ifdef IPC_USE_CBDMA
+	dma_addr_t dst;
+#endif
+	if (len > IPC_DATA_SIZE_MAX) {
+		return IPC_FAIL_INVALID;
+	}
+
+	/* init rpc */
+	rpc->REQ_H    = req;
+	rpc->F_DIR    = RPC_REQUEST;
+	rpc->F_TYPE   = REQ_WAIT_REP;
+	rpc->CMD      = cmd;
+	rpc->DATA_LEN = len;
+	if (len <= RPC_DATA_SIZE) {
+		memcpy(rpc->DATA, data, len);
+	}
+#if 0
+	else if (CACHE_ALIGNED(data) && CACHE_ALIGNED(len)) {
+		rpc->DATA_PTR = data;
+	}
+#endif
+	else {								// do cache align
+		p = MALLOC(len + IPC_SEQ_LEN + CACHE_MASK * 2);
+		rpc->DATA_PTR = (void *)CACHE_ALIGN(p);
+#ifdef IPC_USE_CBDMA
+		mutex_lock(& ipc->cbdma.cbdma_lock);
+		copy_from_user(ipc->cbdma.vir_addr, data, len);
+		dst = dma_map_single(NULL, (void *)(rpc->DATA_PTR), len, DMA_TO_DEVICE);
+		if(0 > sp_cbdma_write( ipc->cbdma.cbdma_device,
+				(dma_addr_t) ipc->cbdma.phy_addr,
+				dst, len)) {
+			printf("cbdma error\n");
+		}
+		dma_unmap_single(NULL, dst, len, DMA_TO_DEVICE);
+		mutex_unlock(& ipc->cbdma.cbdma_lock);
+#else
+		memcpy(rpc->DATA_PTR, data, len);
+#endif
+	}
+
+	/* do rpc */
+	rpc_dump("REQ", rpc);
+	WAIT_INIT(&req->wait_response, RPC_TIMEOUT);
+	rpc_write_hw(rpc);					// write request
+	DOWN(&req->wait_response);			// wait response
+	ret = RET(rpc->CMD);
+	rpc_dump("RES", rpc);
+
+	/* return data */
+	if (ret == IPC_SUCCESS) {
+		if (len <= RPC_DATA_SIZE) {
+			memcpy(data, rpc->DATA, len);
+		}
+		else if (p) {
+#ifndef IPC_USE_CBDMA
+			ret = rpc_check_seq(rpc);
+			if(ret) {
+				FREE(p);
+				FREE(req);
+				return ret;
+			}
+#endif
+			memcpy(data, rpc->DATA_PTR, len);
+		}
+	}
+	if (p) FREE(p);						// free temp buffer
+	FREE(req);
+	return ret;
+}
+EXPORT_SYMBOL(IPC_FunctionCall);
+
+int IPC_FunctionCall_timeout(int cmd, void *data, int len, u32 timeout)
+{
+	int ret;
+	request_t *req = (request_t *)MALLOC(sizeof(request_t));
+	rpc_t *rpc = &req->rpc;
+	void *p = NULL;						// temp buffer for cache align
+#ifdef IPC_USE_CBDMA
+	dma_addr_t dst;
+#endif
+	if (len > IPC_DATA_SIZE_MAX) {
+		return IPC_FAIL_INVALID;
+	}
+	if ((timeout < RPC_TIMEOUT) && (timeout != RPC_NO_TIMEOUT)) {
+		timeout = RPC_TIMEOUT;
+	}
+	/* init rpc */
+	rpc->REQ_H    = req;
+	rpc->F_DIR    = RPC_REQUEST;
+	rpc->F_TYPE   = REQ_WAIT_REP;
+	rpc->CMD      = cmd;
+	rpc->DATA_LEN = len;
+	if (len <= RPC_DATA_SIZE) {
+		memcpy(rpc->DATA, data, len);
+	}
+#if 0
+	else if (CACHE_ALIGNED(data) && CACHE_ALIGNED(len)) {
+		rpc->DATA_PTR = data;
+	}
+#endif
+	else {								// do cache align
+		p = MALLOC(len + IPC_SEQ_LEN + CACHE_MASK * 2);
+		rpc->DATA_PTR = (void *)CACHE_ALIGN(p);
+#ifdef IPC_USE_CBDMA
+		mutex_lock(& ipc->cbdma.cbdma_lock);
+		copy_from_user(ipc->cbdma.vir_addr, data, len);
+		dst = dma_map_single(NULL, (void *)(rpc->DATA_PTR), len, DMA_TO_DEVICE);
+		if(0 > sp_cbdma_write( ipc->cbdma.cbdma_device,
+				(dma_addr_t) ipc->cbdma.phy_addr,
+				dst, len)) {
+			printf("cbdma error\n");
+		}
+		dma_unmap_single(NULL, dst, len, DMA_TO_DEVICE);
+		mutex_unlock(& ipc->cbdma.cbdma_lock);
+#else
+		memcpy(rpc->DATA_PTR, data, len);
+#endif
+	}
+
+	/* do rpc */
+	rpc_dump("REQ", rpc);
+	WAIT_INIT(&req->wait_response, timeout);
+	rpc_write_hw(rpc);					// write request
+	DOWN(&req->wait_response);			// wait response
+	ret = RET(rpc->CMD);
+	rpc_dump("RES", rpc);
+
+	/* return data */
+	if (ret == IPC_SUCCESS) {
+		if (len <= RPC_DATA_SIZE) {
+			memcpy(data, rpc->DATA, len);
+		}
+		else if (p) {
+#ifndef IPC_USE_CBDMA
+			ret = rpc_check_seq(rpc);
+			if(ret) {
+				FREE(p);
+				FREE(req);
+				return ret;
+			}
+#endif
+			memcpy(data, rpc->DATA_PTR, len);
+		}
+	}
+	if (p) FREE(p);						// free temp buffer
+
+	FREE(req);
+	return ret;
+}
+EXPORT_SYMBOL(IPC_FunctionCall_timeout);
+
+
+/**************************************************************************/
+
+static int reg_server(int sid)
+{
+	rpc_fifo_t *fifo = ipc->fifo[sid];
+
+	if (fifo) {
+		struct task_struct *task;
+		rcu_read_lock();
+		task = find_task_by_vpid(ipc->pid[sid]);
+		if (task && !task_is_stopped(task) && !(task->exit_state)) {
+			rcu_read_unlock();
+			return IPC_FAIL_BUSY;		// already running
+		}
+		rcu_read_unlock();
+		memset(fifo, 0, sizeof(rpc_fifo_t));
+	}
+	else {
+		fifo = ZALLOC(sizeof(rpc_fifo_t));
+		if (fifo == NULL) {
+			return IPC_FAIL_NOMEM;
+		}
+	}
+
+	WAIT_INIT(&fifo->wait, 0);
+	ipc->pid[sid] = current->tgid;		// new server
+	ipc->fifo[sid] = fifo;
+
+	return IPC_SUCCESS;
+}
+
+static int sp_ipc_release(struct inode *inode, struct file *file)
+{
+	u32 pid = current->tgid;
+	int i = SERVER_NUMS;
+
+	while (i--) {
+		if (ipc->pid[i] == pid) {		// remove server
+			FREE(ipc->fifo[i]);
+			ipc->fifo[i] = NULL;
+			ipc->pid[i] = 0;
+		}
+	}
+	return 0;
+}
+
+#define RET_K(r)	((r > 0) ? (r - 1024) : r)
+
+static ssize_t sp_ipc_read(struct file *filp, char __user *buffer,
+							 size_t length, loff_t *offset)
+{
+	int ret = IPC_FAIL_INVALID;
+
+	if (length == sizeof(rpc_t)) {
+		ret = rpc_read((rpc_t __user *)buffer);
+	}
+
+	return (ret ? RET_K(ret) : length);
+}
+
+static ssize_t sp_ipc_write(struct file *filp, const char __user *buffer,
+							 size_t length, loff_t *offset)
+{
+	int ret = IPC_FAIL_INVALID;
+
+	if (length == sizeof(int)) {		// register server
+		int sid;
+		get_user(sid, (int __user *)buffer);
+		ret = reg_server(sid);
+	}
+	else if (length == sizeof(rpc_t)) {
+		ret = rpc_write((rpc_t __user *)buffer);
+	}else if (length == sizeof(rpc_new_t)) {
+		ret = rpc_write_new((rpc_new_t __user *)buffer);
+	}
+
+	return (ret ? RET_K(ret) : length);
+}
+
+static int sp_ipc_mmap(struct file *file, struct vm_area_struct *vma)
+{
+#ifdef IO0_START
+	if (vma->vm_pgoff >= __phys_to_pfn(IO0_START) &&
+		vma->vm_pgoff <= __phys_to_pfn(IO0_START + IO0_SIZE)) {
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	}
+#endif
+	return io_remap_pfn_range(vma,
+							  vma->vm_start,
+							  vma->vm_pgoff,
+							  vma->vm_end - vma->vm_start,
+							  vma->vm_page_prot);
+}
+
+static struct file_operations sp_ipc_fops = {
+    .owner          = THIS_MODULE,
+	.release		= sp_ipc_release,
+    .read           = sp_ipc_read,
+	.write			= sp_ipc_write,
+	.mmap			= sp_ipc_mmap,
+};
+
+/**************************************************************************/
+
+/**
+ * @brief   IPC driver probe function
+ */
+static int sp_ipc_probe(struct platform_device *pdev)
+{
+	int ret = -ENXIO;
+
+	ipc = (sp_ipc_t *)devm_kzalloc(&pdev->dev, sizeof(sp_ipc_t), GFP_KERNEL);
+	if (ipc == NULL) {
+		printf("sp_ipc_t malloc fail\n");
+		ret	= -ENOMEM;
+		goto fail_kmalloc;
+	}
+
+	/* init */
+    mutex_init(&ipc->write_lock);
+	ipc->rpc_res = kthread_run(rpc_res_thread, NULL, "RpcRes");
+
+	ret = devm_request_irq(&pdev->dev, IRQ_RPC, rpc_isr, IRQF_TRIGGER_RISING, "rpc", NULL);
+	if (ret != 0) {
+		printf("sp_ipc request_irq fail!\n");
+		goto fail_reqirq;
+	}
+
+	/* register device */
+	ipc->dev.name  = "sp_ipc";
+	ipc->dev.minor = MISC_DYNAMIC_MINOR;
+	ipc->dev.fops  = &sp_ipc_fops;
+	ret = misc_register(&ipc->dev);
+	if (ret != 0) {
+		printf("sp_ipc device register fail\n");
+		goto fail_regdev;
+	}
+#ifdef IPC_USE_CBDMA
+	printk("[ipc info] use cbdma \n");
+	ipc->cbdma.cbdma_device = sp_cbdma_getbyname(IPC_CBDMA_NAME);
+	if(!ipc->cbdma.cbdma_device) {
+		printf("find cbdma device error\n");
+		goto fail_findcbdmadev;
+	}
+	mutex_init(&ipc->cbdma.cbdma_lock);
+	ipc->cbdma.phy_addr = IPC_CBDMA_BUFF_ADDR;
+	ipc->cbdma.size = IPC_CBDMA_BUFF_MAX;
+	ipc->cbdma.vir_addr = ioremap(ipc->cbdma.phy_addr,  ipc->cbdma.size);
+#else
+	ipc_seq_init(&ipc->seq);
+#endif
+
+	return 0;
+
+    /* error rollback */
+#ifdef IPC_USE_CBDMA
+fail_findcbdmadev:
+	misc_deregister(&ipc->dev);
+#endif
+fail_regdev:
+fail_reqirq:
+	kthread_stop(ipc->rpc_res);
+    mutex_destroy(&ipc->write_lock);
+fail_kmalloc:
+	return ret;
+}
+
+/**
+ * @brief   IPC driver exit function
+ */
+static int sp_ipc_remove(struct platform_device *pdev)
+{
+	misc_deregister(&ipc->dev);
+	kthread_stop(ipc->rpc_res);
+    mutex_destroy(&ipc->write_lock);
+#ifdef IPC_USE_CBDMA
+    mutex_destroy(&ipc->cbdma.cbdma_lock);
+#else
+	ipc_seq_finit(&ipc->seq);
+#endif
+
+	return 0;
+}
+
+static const struct of_device_id sp_ipc_of_match[] = {
+	{ .compatible = "sunplus,sp-ipc" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sp_ipc_of_match);
+
+static struct platform_driver sp_ipc_driver = {
+    .probe      = sp_ipc_probe,
+    .remove     = sp_ipc_remove,
+    .driver     = {
+        .name   = "sp_ipc",
+        .owner  = THIS_MODULE,
+        .of_match_table = of_match_ptr(sp_ipc_of_match),
+    },
+};
+
+module_platform_driver(sp_ipc_driver);
+
+/**************************************************************************
+ *                  M O D U L E    D E C L A R A T I O N                  *
+ **************************************************************************/
+
+MODULE_AUTHOR("Sunplus Technology");
+MODULE_DESCRIPTION("Sunplus IPC Driver");
+MODULE_LICENSE("GPL");
--- a/drivers/misc/sp_rtc_isr_test.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/misc/sp_rtc_isr_test.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,147 @@
+/*
+ * Sunplus RTC ISR test driver
+ *
+ * Copyright (C) 2018 Sunplus Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This code is used for testing ISR wiring only.
+ * Because RISC(s) is/are power-off, there is no way to wakeup system from RTC's ISR.
+ * It must be done through IOP.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+
+struct sp_rtc_reg {
+	volatile unsigned int rsv00;
+	volatile unsigned int rsv01;
+	volatile unsigned int rsv02;
+	volatile unsigned int rsv03;
+	volatile unsigned int rsv04;
+	volatile unsigned int rsv05;
+	volatile unsigned int rsv06;
+	volatile unsigned int rsv07;
+	volatile unsigned int rsv08;
+	volatile unsigned int rsv09;
+	volatile unsigned int rsv10;
+	volatile unsigned int rsv11;
+	volatile unsigned int rsv12;
+	volatile unsigned int rsv13;
+	volatile unsigned int rsv14;
+	volatile unsigned int rsv15;
+	volatile unsigned int rtc_ctrl;
+	volatile unsigned int rtc_timer_out;
+	volatile unsigned int rtc_divider;
+	volatile unsigned int rtc_timer_set;
+	volatile unsigned int rtc_alarm_set;
+	volatile unsigned int rtc_user_data;
+	volatile unsigned int rtc_reset_record;
+	volatile unsigned int rtc_battery_ctrl;
+	volatile unsigned int rtc_trim_ctrl;
+	volatile unsigned int rsv25;
+	volatile unsigned int rsv26;
+	volatile unsigned int rsv27;
+	volatile unsigned int rsv28;
+	volatile unsigned int rsv29;
+	volatile unsigned int rsv30;
+	volatile unsigned int rsv31;
+};
+
+static const struct platform_device_id sp_rtc_isr_tst_devtypes[] = {
+	{
+		.name = "sp_rtc_isr_tst",
+	}, {
+		/* sentinel */
+	}
+};
+
+static const struct of_device_id sp_rtc_isr_tst_dt_ids[] = {
+	{
+		.compatible = "sunplus,sp-rtc-isr-tst",
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, sp_rtc_isr_tst_dt_ids);
+
+static irqreturn_t sp_rtc_isr_tst_irq(int irq, void *args)
+{
+	printk(KERN_INFO "%s\n", __func__);
+	return IRQ_HANDLED;
+}
+
+static int sp_rtc_isr_tst_probe(struct platform_device *pdev)
+{
+	struct resource *res_mem;
+	const struct of_device_id *match;
+	int ret, num_irq;
+	int irq;
+	struct sp_rtc_reg *sp_rtc_ptr;
+	void __iomem *membase;
+
+	printk(KERN_INFO "%s, %d\n", __func__, __LINE__);
+
+	if (pdev->dev.of_node) {
+		match = of_match_node(sp_rtc_isr_tst_dt_ids, pdev->dev.of_node);
+		if (match == NULL) {
+			printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+			return -ENODEV;
+		}
+		num_irq = of_irq_count(pdev->dev.of_node);
+		if (num_irq != 1) {
+			printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		}
+	}
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(res_mem)) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return PTR_ERR(res_mem);
+	}
+
+	membase = devm_ioremap_resource(&pdev->dev, res_mem);
+	if (IS_ERR(membase)) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return PTR_ERR(membase);
+	}
+
+	sp_rtc_ptr = (struct sp_rtc_reg *)(membase);
+	irq = platform_get_irq(pdev, 0);
+	ret = request_irq(irq, sp_rtc_isr_tst_irq, 0, NULL, NULL);
+
+	sp_rtc_ptr->rtc_timer_set = 0x12345678;
+	sp_rtc_ptr->rtc_alarm_set = sp_rtc_ptr->rtc_timer_set + 1;
+
+	sp_rtc_ptr->rtc_user_data = (0xFFFF << 16) | 0xabcd;
+	sp_rtc_ptr->rtc_ctrl = (0x003F << 16) | 0x0017;
+
+	return 0;
+
+}
+
+static struct platform_driver rtc_isr_test_driver = {
+	.driver		= {
+		.name		= "sp_rtc_isr_tst",
+		.of_match_table	= of_match_ptr(sp_rtc_isr_tst_dt_ids),
+	},
+	.id_table	= sp_rtc_isr_tst_devtypes,
+	.probe		= sp_rtc_isr_tst_probe,
+};
+module_platform_driver(rtc_isr_test_driver);
+
+MODULE_DESCRIPTION("RTC ISR test driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sp_rtc_isr_tst");
--- a/drivers/misc/sp_timer_test.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/misc/sp_timer_test.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,242 @@
+/*
+ * Sunplus timer test driver
+ *
+ * Copyright (C) 2018 Sunplus Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+
+#define WATCHDOG_CMD_CNT_WR_UNLOCK	0xAB00
+#define WATCHDOG_CMD_CNT_WR_LOCK	0xAB01
+#define WATCHDOG_CMD_CNT_WR_MAX		0xDEAF
+#define WATCHDOG_CMD_PAUSE		0x3877
+#define WATCHDOG_CMD_RESUME		0x4A4B
+#define WATCHDOG_CMD_INTR_CLR		0x7482
+
+struct stc_reg {
+	volatile unsigned int stc_15_0;
+	volatile unsigned int stc_31_16;
+	volatile unsigned int stc_64;
+	volatile unsigned int stc_divisor;
+	volatile unsigned int rtc_15_0;
+	volatile unsigned int rtc_23_16;
+	volatile unsigned int rtc_divisor;
+	volatile unsigned int stc_config;
+	volatile unsigned int timer0_ctrl;
+	volatile unsigned int timer0_cnt;
+	volatile unsigned int timer1_ctrl;
+	volatile unsigned int timer1_cnt;
+	volatile unsigned int timerw_ctrl;	/* Only STCs @ 0x9C000600 and 0x9C003000 */
+	volatile unsigned int timerw_cnt;	/* Only STCs @ 0x9C000600 and 0x9C003000 */
+	volatile unsigned int stc_47_32;
+	volatile unsigned int stc_63_48;
+	volatile unsigned int timer2_ctrl;
+	volatile unsigned int timer2_divisor;
+	volatile unsigned int timer2_reload;
+	volatile unsigned int timer2_cnt;
+	volatile unsigned int timer3_ctrl;
+	volatile unsigned int timer3_divisor;
+	volatile unsigned int timer3_reload;
+	volatile unsigned int timer3_cnt;
+	volatile unsigned int stcl_0;
+	volatile unsigned int stcl_1;
+	volatile unsigned int stcl_2;
+	volatile unsigned int atc_0;
+	volatile unsigned int atc_1;
+	volatile unsigned int atc_2;
+	volatile unsigned int timer0_reload;
+	volatile unsigned int timer1_reload;
+};
+
+#define NUM_STC		4
+#define NUM_IRQ		5	/* max. number of interrupts for each STC */
+
+struct stc_info_s {
+	char irq_name[NUM_IRQ][32];
+	int irq[NUM_IRQ];
+	u32 interrupt_cnt[NUM_IRQ];
+};
+static struct stc_info_s stc_info[NUM_STC];
+
+static const struct platform_device_id sp_tmr_tst_devtypes[] = {
+	{
+		.name = "sp_tmr_tst",
+	}, {
+		/* sentinel */
+	}
+};
+
+static const struct of_device_id sp_tmr_tst_dt_ids[] = {
+	{
+		.compatible = "sunplus,sp-tmr-tst",
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, sp_tmr_tst_dt_ids);
+
+static irqreturn_t sp_tmr_tst_irq(int irq, void *args)
+{
+	int i, j;
+	struct stc_info_s *ptr;
+
+	ptr = (struct stc_info_s *)(args);
+	for (i = 0; i < NUM_STC; i++) {
+		if (ptr == &stc_info[i]) {
+			for (j = 0; j < NUM_IRQ; j++) {
+				if (irq == stc_info[i].irq[j]) {
+					stc_info[i].interrupt_cnt[j]++;
+					if (j == (NUM_IRQ - 1)) {
+						panic("Watchdog timeout, die here\n");
+						while(1);
+					} else  if ((stc_info[i].interrupt_cnt[j] & 0x003F) == 0) {	/* limits output messages */
+						printk(KERN_INFO "%s, %s, %u\n", __func__, stc_info[i].irq_name[j], stc_info[i].interrupt_cnt[j]);
+					}
+				}
+			}
+			break;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sp_tmr_tst_probe(struct platform_device *pdev)
+{
+	struct resource *res_mem;
+	const struct of_device_id *match;
+	int ret, num_irq;
+	int i;
+	u32 val;
+	static int idx_stc = 0;
+	struct stc_reg *stc_ptr;
+	void __iomem *membase;
+	u32 counter_src;
+
+	if (idx_stc >= NUM_STC) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "%s, %d\n", __func__, __LINE__);
+
+	memset(&stc_info[idx_stc], 0, sizeof(stc_info[0]));
+	if (pdev->dev.of_node) {
+		match = of_match_node(sp_tmr_tst_dt_ids, pdev->dev.of_node);
+		if (match == NULL) {
+			printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+			return -ENODEV;
+		}
+		num_irq = of_irq_count(pdev->dev.of_node);
+		if (num_irq > NUM_IRQ) {
+			printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		}
+	}
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(res_mem)) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return PTR_ERR(res_mem);
+	}
+
+	membase = devm_ioremap_resource(&pdev->dev, res_mem);
+	if (IS_ERR(membase)) {
+		printk(KERN_ERR "Error: %s, %d\n", __func__, __LINE__);
+		return PTR_ERR(membase);
+	}
+
+	stc_ptr = (struct stc_reg *)(membase);
+	writel((0x1000 - 1), &(stc_ptr->stc_divisor));
+	writel(0, &(stc_ptr->stc_64));		/* reset STC */
+
+	writel((0x0002 - 1), &(stc_ptr->rtc_divisor));
+	writel(0, &(stc_ptr->rtc_23_16));	/* reset RTC */
+
+	counter_src = 1;	/* 0: system clock, 1: STC, 2: RTC, 3: ... */
+
+	/* timer0: repeat mode, start */
+	val = 0x0100 - 1;
+	writel(val, &(stc_ptr->timer0_cnt));
+	writel(val, &(stc_ptr->timer0_reload));
+	writel((counter_src << 14) | (1 << 13) | (1 << 11), &(stc_ptr->timer0_ctrl));
+
+	/* timer1: repeat mode, start */
+	val = 0x0100 - 1;
+	writel(val, &(stc_ptr->timer1_cnt));
+	writel(val, &(stc_ptr->timer1_reload));
+	writel((counter_src << 14) | (1 << 13) | (1 << 11), &(stc_ptr->timer1_ctrl));
+
+	/* timer2: repeat mode, start */
+	writel(0x0002 - 1, &(stc_ptr->timer2_divisor));
+	val = 0x0100 - 1;
+	writel(val, &(stc_ptr->timer2_cnt));
+	writel(val, &(stc_ptr->timer2_reload));
+	writel((counter_src << 2) | (1 << 1) | (1 << 0), &(stc_ptr->timer2_ctrl));
+
+	/* timer3: repeat mode, start */
+	writel(0x0004 - 1, &(stc_ptr->timer3_divisor));
+	val = 0x0100 - 1;
+	writel(val, &(stc_ptr->timer3_cnt));
+	writel(val, &(stc_ptr->timer3_reload));
+	writel((counter_src << 2) | (1 << 1) | (1 << 0), &(stc_ptr->timer3_ctrl));
+
+	for (i = 0; i < num_irq; i++) {
+		stc_info[idx_stc].irq[i] = platform_get_irq(pdev, i);
+		if (stc_info[idx_stc].irq[i] < 0) {
+			printk(KERN_ERR "Error: %s, %d, irq[%d]\n", __func__, __LINE__, i);
+			return -ENODEV;
+		}
+		sprintf(stc_info[idx_stc].irq_name[i], "irq%d_%x", i, (u32)(res_mem->start));
+		ret = request_irq(stc_info[idx_stc].irq[i], sp_tmr_tst_irq, 0, stc_info[idx_stc].irq_name[i], &stc_info[idx_stc]);
+		if (ret) {
+			printk(KERN_ERR "Error: %s, %d, irq[%d]\n", __func__, __LINE__, i);
+			return ret;
+		}
+		printk(KERN_INFO "%s, %d, irq[%d]: %d, %s\n", __func__, __LINE__, i, stc_info[idx_stc].irq[i], stc_info[idx_stc].irq_name[i]);
+	}
+#if 0
+	/* Watchdog timer */
+	/* Need to enable bit 2 and 4 of G(4, 29) to cause chip reset:
+	 * If set them in iboot:
+	 *     MOON4_REG->misc_ctl_0 = RF_MASK_V((0x1 << 2), (1 << 2));
+	 *     MOON4_REG->misc_ctl_0 = RF_MASK_V((0x1 << 4), (1 << 4));
+	 * Or enable them in U-Boot's arch_misc_init() in arch/arm/mach-pentagram/cpu.c:
+	 *     ptr = (volatile unsigned int *)(PENTAGRAM_BASE_ADDR + (4 << 7) + (29 << 2));
+	 *     *ptr = (0x0014 << 16) | (0x0014);
+	 */
+	writel(WATCHDOG_CMD_CNT_WR_UNLOCK, &(stc_ptr->timerw_ctrl));
+	writel(WATCHDOG_CMD_PAUSE, &(stc_ptr->timerw_ctrl));
+	writel(0x0800, &(stc_ptr->timerw_cnt));
+	writel(WATCHDOG_CMD_RESUME, &(stc_ptr->timerw_ctrl));
+	writel(WATCHDOG_CMD_CNT_WR_LOCK, &(stc_ptr->timerw_ctrl));
+#endif
+	idx_stc++;
+	return 0;
+
+}
+
+static struct platform_driver ssc_driver = {
+	.driver		= {
+		.name		= "sp_tmr_tst",
+		.of_match_table	= of_match_ptr(sp_tmr_tst_dt_ids),
+	},
+	.id_table	= sp_tmr_tst_devtypes,
+	.probe		= sp_tmr_tst_probe,
+};
+module_platform_driver(ssc_driver);
+
+MODULE_DESCRIPTION("Timer test driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sp_tmr_tst");
--- a/drivers/rtc/Kconfig	2018-11-23 10:16:15.589841022 +0300
+++ a/drivers/rtc/Kconfig	2018-11-23 10:31:03.810050278 +0300
@@ -846,6 +846,13 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-cmos.
 
+config RTC_DRV_SUNPLUS
+	bool "RTC for Sunplus Pentagram Platform"
+	depends on ARCH_PENTAGRAM
+	default y
+	help
+	  RTC for Sunplus Pentagram platform.
+
 config RTC_DRV_ALPHA
 	bool "Alpha PC-style CMOS"
 	depends on ALPHA
--- a/drivers/rtc/Makefile	2018-11-23 10:16:15.589841022 +0300
+++ a/drivers/rtc/Makefile	2018-11-23 10:31:03.810050278 +0300
@@ -151,6 +151,7 @@
 obj-$(CONFIG_RTC_DRV_ST_LPC)	+= rtc-st-lpc.o
 obj-$(CONFIG_RTC_DRV_SUN4V)	+= rtc-sun4v.o
 obj-$(CONFIG_RTC_DRV_SUN6I)	+= rtc-sun6i.o
+obj-$(CONFIG_RTC_DRV_SUNPLUS)	+= rtc-sunplus.o
 obj-$(CONFIG_RTC_DRV_SUNXI)	+= rtc-sunxi.o
 obj-$(CONFIG_RTC_DRV_TEGRA)	+= rtc-tegra.o
 obj-$(CONFIG_RTC_DRV_TEST)	+= rtc-test.o
--- a/drivers/rtc/rtc-sunplus.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/rtc/rtc-sunplus.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,246 @@
+/*
+ * How to test RTC:
+ *
+ * hwclock - query and set the hardware clock (RTC)
+ *
+ * (for i in `seq 5`; do (echo ------ && echo -n 'date      : ' && date && echo -n 'hwclock -r: ' && hwclock -r; sleep 1); done)
+ * date 121209002014 # Set system to 2014/Dec/12 09:00
+ * (for i in `seq 5`; do (echo ------ && echo -n 'date      : ' && date && echo -n 'hwclock -r: ' && hwclock -r; sleep 1); done)
+ * hwclock -s # Set the System Time from the Hardware Clock
+ * (for i in `seq 5`; do (echo ------ && echo -n 'date      : ' && date && echo -n 'hwclock -r: ' && hwclock -r; sleep 1); done)
+ * date 121213002014 # Set system to 2014/Dec/12 13:00
+ * (for i in `seq 5`; do (echo ------ && echo -n 'date      : ' && date && echo -n 'hwclock -r: ' && hwclock -r; sleep 1); done)
+ * hwclock -w # Set the Hardware Clock to the current System Time
+ * (for i in `seq 10000`; do (echo ------ && echo -n 'date      : ' && date && echo -n 'hwclock -r: ' && hwclock -r; sleep 1); done)
+ *
+ *
+ * How to setup alarm (e.g., 10 sec later):
+ *     echo 0 > /sys/class/rtc/rtc0/wakealarm && \
+ *     nnn=`date '+%s'` && echo $nnn && nnn=`expr $nnn + 10` && echo $nnn > /sys/class/rtc/rtc0/wakealarm
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/rtc.h>
+#include <linux/platform_device.h>
+#include <mach/io_map.h>
+
+#if 0
+/* For code development on SPHE8388 */
+#define VA_B_REG		0xF8000000
+#endif
+
+#define VIRT_ADDR_RTC		(VA_B_REG + (116 << 7))
+
+struct sp_rtc_reg {
+	volatile unsigned int rsv00;
+	volatile unsigned int rsv01;
+	volatile unsigned int rsv02;
+	volatile unsigned int rsv03;
+	volatile unsigned int rsv04;
+	volatile unsigned int rsv05;
+	volatile unsigned int rsv06;
+	volatile unsigned int rsv07;
+	volatile unsigned int rsv08;
+	volatile unsigned int rsv09;
+	volatile unsigned int rsv10;
+	volatile unsigned int rsv11;
+	volatile unsigned int rsv12;
+	volatile unsigned int rsv13;
+	volatile unsigned int rsv14;
+	volatile unsigned int rsv15;
+	volatile unsigned int rtc_ctrl;
+	volatile unsigned int rtc_timer_out;
+	volatile unsigned int rtc_divider;
+	volatile unsigned int rtc_timer_set;
+	volatile unsigned int rtc_alarm_set;
+	volatile unsigned int rtc_user_data;
+	volatile unsigned int rtc_reset_record;
+	volatile unsigned int rtc_battery_ctrl;
+	volatile unsigned int rtc_trim_ctrl;
+	volatile unsigned int rsv25;
+	volatile unsigned int rsv26;
+	volatile unsigned int rsv27;
+	volatile unsigned int rsv28;
+	volatile unsigned int rsv29;
+	volatile unsigned int rsv30;
+	volatile unsigned int rsv31;
+};
+static volatile struct sp_rtc_reg *rtc_reg_ptr = NULL;
+
+static struct platform_device *sp_rtc_device0;
+
+static void sp_get_seconds(unsigned long *secs)
+{
+	*secs = (unsigned long)(rtc_reg_ptr->rtc_timer_out);
+}
+
+static void sp_set_seconds(unsigned long secs)
+{
+	rtc_reg_ptr->rtc_timer_set = (u32)(secs);
+}
+
+static int sp_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long secs;
+
+	sp_get_seconds(&secs);
+	rtc_time_to_tm(secs, tm);
+#if 0
+	printk("%s:  RTC date/time to %d-%d-%d, %02d:%02d:%02d.\r\n",
+	       __func__, tm->tm_mday, tm->tm_mon + 1, tm->tm_year, tm->tm_hour, tm->tm_min, tm->tm_sec);
+#endif
+	return rtc_valid_tm(tm);
+}
+
+int sp_rtc_get_time(struct rtc_time *tm)
+{
+	unsigned long secs;
+
+	sp_get_seconds(&secs);
+	rtc_time_to_tm(secs, tm);
+
+	return 0;
+}
+EXPORT_SYMBOL(sp_rtc_get_time);
+
+static int sp_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	printk("%s\n", __func__);
+	rtc_reg_ptr->rtc_ctrl |= 1 << 4;	/* Keep RTC from system reset */
+
+	return 0;
+}
+
+static int sp_rtc_resume(struct platform_device *pdev)
+{
+	/*
+	 * Because RTC is still powered during suspend,
+	 * there is nothing to do here.
+	 */
+	printk("%s\n", __func__);
+	rtc_reg_ptr->rtc_ctrl |= 1 << 4;	/* Keep RTC from system reset */
+	return 0;
+}
+
+static int sp_rtc_set_mmss(struct device *dev, unsigned long secs)
+{
+	dev_info(dev, "%s, secs = %lu\n", __func__, secs);
+	sp_set_seconds(secs);
+	return 0;
+}
+
+
+static int sp_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	unsigned long alarm_time;
+
+	alarm_time = rtc_tm_to_time64(&alrm->time);
+	printk("%s, alarm_time: %u\n", __func__, (u32)(alarm_time));
+
+	if (alarm_time > 0xFFFFFFFF)
+		return -EINVAL;
+
+	rtc_reg_ptr->rtc_alarm_set = (u32)(alarm_time);
+	rtc_reg_ptr->rtc_ctrl = (0x003F << 16) | 0x0017;
+
+	return 0;
+}
+
+static int sp_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	unsigned int alarm_time;
+
+	alarm_time = rtc_reg_ptr->rtc_alarm_set;
+	printk("%s, alarm_time: %u\n", __func__, alarm_time);
+	rtc_time64_to_tm((unsigned long)(alarm_time), &alrm->time);
+
+	return 0;
+}
+
+
+static const struct rtc_class_ops sp_rtc_ops = {
+	.read_time = sp_rtc_read_time,
+	.set_mmss = sp_rtc_set_mmss,
+	.set_alarm = sp_rtc_set_alarm,
+	.read_alarm = sp_rtc_read_alarm,
+};
+
+static int sp_rtc_probe(struct platform_device *plat_dev)
+{
+	int err;
+	struct rtc_device *rtc;
+
+	rtc_reg_ptr = (volatile struct sp_rtc_reg *)(VIRT_ADDR_RTC);
+	rtc_reg_ptr->rtc_ctrl |= 1 << 4;	/* Keep RTC from system reset */
+
+	rtc = rtc_device_register("sp-rtc", &plat_dev->dev, &sp_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		err = PTR_ERR(rtc);
+		return err;
+	}
+
+	platform_set_drvdata(plat_dev, rtc);
+
+	return 0;
+}
+
+static int sp_rtc_remove(struct platform_device *plat_dev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(plat_dev);
+	rtc_device_unregister(rtc);
+	return 0;
+}
+
+static struct platform_driver sp_rtc_driver = {
+	.probe		= sp_rtc_probe,
+	.remove 	= sp_rtc_remove,
+	.suspend	= sp_rtc_suspend,
+	.resume 	= sp_rtc_resume,
+	.driver 	= {
+		.name = "sp-rtc",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sp_rtc_init(void)
+{
+	int err;
+
+	if ((err = platform_driver_register(&sp_rtc_driver)))
+		return err;
+
+	if ((sp_rtc_device0 = platform_device_alloc("sp-rtc", 0)) == NULL) {
+		err = -ENOMEM;
+		goto exit_driver_unregister;
+	}
+
+	if ((err = platform_device_add(sp_rtc_device0)))
+		goto exit_free_sp_rtc_device0;
+
+	if (device_init_wakeup(&(sp_rtc_device0->dev), true)) {
+		printk(KERN_WARNING "dev_init_wakeup() fails.\n");
+	}
+
+	return 0;
+
+exit_free_sp_rtc_device0:
+	platform_device_put(sp_rtc_device0);
+
+exit_driver_unregister:
+	platform_driver_unregister(&sp_rtc_driver);
+	return err;
+}
+
+static void __exit sp_rtc_exit(void)
+{
+	platform_device_unregister(sp_rtc_device0);
+	platform_driver_unregister(&sp_rtc_driver);
+}
+
+MODULE_AUTHOR("Sunplus");
+MODULE_DESCRIPTION("Sunplus RTC driver");
+MODULE_LICENSE("GPL");
+
+module_init(sp_rtc_init);
+module_exit(sp_rtc_exit);
--- a/drivers/rtc/rtc-sysfs.c	2018-11-23 10:16:15.598840487 +0300
+++ a/drivers/rtc/rtc-sysfs.c	2018-11-23 10:31:03.811050218 +0300
@@ -265,8 +265,18 @@
  */
 static bool rtc_does_wakealarm(struct rtc_device *rtc)
 {
+#ifdef CONFIG_ARCH_PENTAGRAM
+	/*
+	 * Ignore to check if its parent can wakeup system.
+	 * Low-power mode doesn't go through suspend/resume flow.
+	 * Just uses /sys/clock/rtc/rtc0/wakealarm to set up RTC wakeup time.
+	 * Procedure:
+	 * Set up RTC wakeup time -> Low-power mode -> RTC wakes up PMU -> IOP -> power-on chip.
+	 */
+#else
 	if (!device_can_wakeup(rtc->dev.parent))
 		return false;
+#endif
 
 	return rtc->ops->set_alarm != NULL;
 }
--- a/drivers/tty/serial/Kconfig	2018-11-23 10:16:15.934820528 +0300
+++ a/drivers/tty/serial/Kconfig	2018-11-23 10:31:03.812050159 +0300
@@ -1688,6 +1688,9 @@
 	  and warnings and which allows logins in single user mode)
 	  Otherwise, say 'N'.
 
+config SERIAL_SP_UART
+	bool "Sunplus UART serial port support"
+
 endmenu
 
 config SERIAL_MCTRL_GPIO
--- a/drivers/tty/serial/Makefile	2018-11-23 10:16:15.934820528 +0300
+++ a/drivers/tty/serial/Makefile	2018-11-23 10:31:03.812050159 +0300
@@ -92,6 +92,7 @@
 obj-$(CONFIG_SERIAL_MVEBU_UART)	+= mvebu-uart.o
 obj-$(CONFIG_SERIAL_PIC32)	+= pic32_uart.o
 obj-$(CONFIG_SERIAL_MPS2_UART)	+= mps2-uart.o
+obj-$(CONFIG_SERIAL_SP_UART)	+= sp_uart.o
 
 # GPIOLIB helpers for modem control lines
 obj-$(CONFIG_SERIAL_MCTRL_GPIO)	+= serial_mctrl_gpio.o
--- a/drivers/tty/serial/sp_hwbuf_tst.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/tty/serial/sp_hwbuf_tst.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,1940 @@
+/*
+ * This code is for h/w test only, therefore there is no configuration for it.
+ * Please use B-chip eMMC configuration with following changes:
+ *
+ *	arch/arm/boot/dts/pentagram-sc7021-bchip-emu.dts:
+ *		-#include "pentagram-sc7021-bchip.dtsi"
+ *		+#include "pentagram-sc7021-bchip-hwbuf-tst.dtsi"
+ *
+ *	drivers/tty/serial/Makefile:
+ *		-obj-$(CONFIG_SERIAL_SP_UART)	+= sp_uart.o
+ *		+obj-$(CONFIG_SERIAL_SP_UART)	+= sp_hwbuf_tst.o
+ */
+
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/of_platform.h>
+#include <asm/irq.h>
+#if defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#include <linux/sysrq.h>
+#endif
+#include <linux/serial_core.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <mach/sp_uart.h>
+
+#define NUM_UART	6	/* serial0,  ... */
+#define NUM_UARTDMARX	2	/* serial10, ... */
+#define NUM_HWBUF	2	/* serial20, ... */
+
+#define ID_BASE_DMARX	10
+#define ID_BASE_HWBUF	20
+
+#define IS_UARTDMARX_ID(X)		(((X) >= (ID_BASE_DMARX)) && ((X) < (ID_BASE_DMARX + NUM_UARTDMARX)))
+#define IS_UARTHWBUF_ID(X)		(((X) >= (ID_BASE_HWBUF)) && ((X) < (ID_BASE_HWBUF + NUM_HWBUF)))
+/* ---------------------------------------------------------------------------------------------- */
+#define TTYS_KDBG_INFO
+#define TTYS_KDBG_ERR
+
+#ifdef TTYS_KDBG_INFO
+#define DBG_INFO(fmt, args ...)	printk(KERN_INFO "K_TTYS: " fmt, ## args)
+#else
+#define DBG_INFO(fmt, args ...)
+#endif
+
+#ifdef TTYS_KDBG_ERR
+#define DBG_ERR(fmt, args ...)	printk(KERN_ERR "K_TTYS: " fmt, ## args)
+#else
+#define DBG_ERR(fmt, args ...)
+#endif
+/* ---------------------------------------------------------------------------------------------- */
+#define DEVICE_NAME			"ttyS"
+#define SP_UART_MAJOR			TTY_MAJOR
+#define SP_UART_MINOR_START		64
+
+#define SP_UART_CREAD_DISABLED		(1 << 16)
+/* ---------------------------------------------------------------------------------------------- */
+#define UARXDMA_BUF_SZ			PAGE_SIZE
+#define MAX_SZ_RXDMA_ISR		(1 << 9)
+#define UATXDMA_BUF_SZ			PAGE_SIZE
+/* ---------------------------------------------------------------------------------------------- */
+#define CLK_HIGH_UART			202500000
+/* ---------------------------------------------------------------------------------------------- */
+#if defined(CONFIG_SP_MON)
+extern unsigned int uart0_mask_tx;	/* Used for masking uart0 tx output */
+#endif
+
+struct regs_gdma {
+	volatile u32 hw_ver;
+	volatile u32 config;
+	volatile u32 length;
+	volatile u32 mem_adr;
+	volatile u32 port_mux;
+	volatile u32 int_flag;
+	volatile u32 int_en;
+	volatile u32 sw_rst_state;
+	volatile u32 rsv_8;
+	volatile u32 rsv_9;
+	volatile u32 sg_idx;
+	volatile u32 sg_cfg;
+	volatile u32 sg_length;
+	volatile u32 sg_mem_adr;
+	volatile u32 rsv_14;
+	volatile u32 sg_setting;
+	volatile u32 sg_threshold;
+	volatile u32 rsv_17;
+	volatile u32 mem_rd_timeout;
+	volatile u32 mem_wr_timeout;
+	volatile u32 ip_rd_timeout;
+	volatile u32 ip_wr_timeout;
+	volatile u32 wr_cnt_dbg;
+	volatile u32 wr_byte_en_dbg;
+	volatile u32 sw_rst_wr_cnt_dbg;
+	volatile u32 rsv_25_31[7];
+};
+
+#define GDMA_CFG_VAL		0x0105		/* Go, not buffered, DMA_WR */
+
+#define GDMA_INT_FLG_IP_TO	(1 << 4)
+#define GDMA_INT_FLG_DONE	(1 << 0)
+
+#define GDMA_INT_EN_IP_TO	(1 << 4)
+#define GDMA_INT_EN_DONE	(1 << 0)
+
+struct regs_hwbuf {
+	volatile u32 hwbuf_enable;
+	volatile u32 hwbuf_sel;
+	volatile u32 hwbuf_start_addr;
+	volatile u32 hwbuf_end_addr;
+	volatile u32 hwbuf_wr_adr;
+	volatile u32 hwbuf_rd_adr;
+	volatile u32 hwbuf_status;
+	volatile u32 hwbuf_tmr_unit;
+	volatile u32 hwbuf_tmr_cnt;
+	volatile u32 hwbuf_rst_done;
+};
+
+struct sunplus_uart_port {
+	char name[16];	/* Sunplus_UARTx */
+	struct uart_port uport;
+	struct sunplus_uartdma_info *uartdma_rx;
+	struct sunplus_uartdma_info *hwbuf_tx;
+	struct sunplus_uartdma_info *hwbuf_rx;
+};
+struct sunplus_uart_port sunplus_uart_ports[NUM_UART];
+
+struct sunplus_uartdma_info {
+	void __iomem *membase;		/* virtual address */
+	void __iomem *membase_gdma;	/* virtual address */
+	unsigned long addr_phy;
+	unsigned long addr_phy_gdma;
+	int irq;
+	int which_uart;
+	struct sunplus_uart_port *binding_port;
+	void *buf_va;
+	dma_addr_t dma_handle;
+	int tx_1_rx_0;
+	int current_buf;		/* for HWBUF-Rx mode, the buffer is split into two buffers, each of them is (UARXDMA_BUF_SZ >> 1) bytes */
+};
+
+static struct sunplus_uartdma_info sunplus_uartdma[NUM_UARTDMARX + NUM_HWBUF];
+
+static inline void sp_uart_set_int_en(unsigned char __iomem *base, unsigned int_state)
+{
+	writel(int_state, &((struct regs_uart *)base)->uart_isc);
+}
+
+static inline unsigned sp_uart_get_int_en(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_isc);
+}
+
+static inline int sp_uart_get_char(unsigned char __iomem *base)
+{
+	return readl_relaxed(&((struct regs_uart *)base)->uart_data);
+}
+
+static inline void sp_uart_put_char(struct uart_port *port, unsigned ch)
+{
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *hwbuf_tx = sp_port->hwbuf_tx;
+	volatile struct regs_hwbuf *hwbuf_reg;
+	unsigned char __iomem *base = port->membase;
+	u32 addr_sw, addr_start;
+	u32 offset_sw;
+	u8 *byte_ptr;
+
+#if defined(CONFIG_SP_MON)
+	if ((uart0_mask_tx == 1) && ((u32)base == LOGI_ADDR_UART0_REG)) {
+		return;
+	}
+#endif
+
+	if (!hwbuf_tx) {
+		writel_relaxed(ch,  &((struct regs_uart *)base)->uart_data);
+	} else {
+		hwbuf_reg = (volatile struct regs_hwbuf *)(hwbuf_tx->membase);
+		addr_sw = readl(&(hwbuf_reg->hwbuf_wr_adr));
+		addr_start = readl(&(hwbuf_reg->hwbuf_start_addr));
+		offset_sw = addr_sw - addr_start;
+		byte_ptr = (u8 *)(hwbuf_tx->buf_va + offset_sw);
+		*byte_ptr = (u8)(ch);
+		if (offset_sw == (UATXDMA_BUF_SZ - 1)) {
+			writel((u32)(hwbuf_tx->dma_handle), &(hwbuf_reg->hwbuf_wr_adr));
+		}  else {
+			writel((addr_sw + 1), &(hwbuf_reg->hwbuf_wr_adr));
+		}
+	}
+}
+
+static inline unsigned sp_uart_get_line_status(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_lsr);
+}
+
+static inline u32 sp_uart_line_status_tx_buf_not_full(struct uart_port *port)
+{
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *hwbuf_tx = sp_port->hwbuf_tx;
+	volatile struct regs_hwbuf *hwbuf_reg;
+	unsigned char __iomem *base = port->membase;
+	u32 addr_sw, addr_hw;
+
+	if (hwbuf_tx) {
+		hwbuf_reg = (volatile struct regs_hwbuf *)(hwbuf_tx->membase);
+		addr_sw = readl(&(hwbuf_reg->hwbuf_wr_adr));
+		addr_hw = readl(&(hwbuf_reg->hwbuf_rd_adr));
+		if (addr_sw == addr_hw) {
+			return UATXDMA_BUF_SZ;
+		} else if (addr_sw >= addr_hw) {
+			return (UATXDMA_BUF_SZ - (addr_sw - addr_hw));
+		} else {
+			return (addr_hw - addr_sw);
+		}
+	} else {
+		if (readl(&((struct regs_uart *)base)->uart_lsr) & SP_UART_LSR_TX) {
+			/* In PIO mode, just return 1 byte becauase exactly number is unknown */
+			return 1;
+		} else {
+			return 0;
+		}
+	}
+}
+
+static inline void sp_uart_set_line_ctrl(unsigned char __iomem *base, unsigned ctrl)
+{
+	writel(ctrl, &((struct regs_uart *)base)->uart_lcr);
+}
+
+static inline unsigned sp_uart_get_line_ctrl(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_lcr);
+}
+
+static inline void sp_uart_set_divider_low_register(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_div_l);
+}
+
+static inline unsigned sp_uart_get_divider_low_register(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_div_l);
+}
+
+static inline void sp_uart_set_divider_high_register(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_div_h);
+}
+
+static inline unsigned sp_uart_get_divider_high_register(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_div_h);
+}
+
+static inline void sp_uart_set_rx_residue(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_rx_residue);
+}
+
+static inline void sp_uart_set_modem_ctrl(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_mcr);
+}
+
+static inline unsigned sp_uart_get_modem_ctrl(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_mcr);
+}
+
+static inline void sp_uart_set_clk_src(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_clk_src);
+}
+
+/* ---------------------------------------------------------------------------------------------- */
+
+/*
+ * Note:
+ * When (uart0_as_console == 0), please make sure:
+ *     There is no "console=ttyS0,115200", "earlyprintk", ... in kernel command line.
+ *     In /etc/inittab, there is no something like "ttyS0::respawn:/bin/sh"
+ */
+unsigned int uart0_as_console = ~0;
+unsigned int uart_enable_status = ~0;	/* bit 0: UART0, bit 1: UART1, ... */
+
+#if defined(CONFIG_SP_MON)
+extern int sysrqCheckState(char, struct uart_port *);
+#endif
+
+static struct sunplus_uartdma_info *sunplus_uartdma_rx_binding(int id)
+{
+	int i;
+
+	for (i = 0; i < NUM_UARTDMARX; i++) {
+		if ((sunplus_uartdma[i].which_uart == id) && (sunplus_uartdma[i].membase)) {
+			sunplus_uartdma[i].binding_port = &sunplus_uart_ports[id];
+			return (&sunplus_uartdma[i]);
+		}
+	}
+	return NULL;
+}
+
+static struct sunplus_uartdma_info *sunplus_hwbuf_tx_binding(int id)
+{
+	int i;
+
+	for (i = NUM_UARTDMARX; i < (NUM_UARTDMARX + NUM_HWBUF); i++) {
+		if ((sunplus_uartdma[i].which_uart == id) && (sunplus_uartdma[i].membase) && (sunplus_uartdma[i].tx_1_rx_0 == 1)) {
+			sunplus_uartdma[i].binding_port = &sunplus_uart_ports[id];
+			return (&sunplus_uartdma[i]);
+		}
+	}
+	return NULL;
+}
+
+static struct sunplus_uartdma_info *sunplus_hwbuf_rx_binding(int id)
+{
+	int i;
+
+	for (i = NUM_UARTDMARX; i < (NUM_UARTDMARX + NUM_HWBUF); i++) {
+		if ((sunplus_uartdma[i].which_uart == id) && (sunplus_uartdma[i].membase) && (sunplus_uartdma[i].tx_1_rx_0 == 0)) {
+			sunplus_uartdma[i].binding_port = &sunplus_uart_ports[id];
+			return (&sunplus_uartdma[i]);
+		}
+	}
+	return NULL;
+}
+
+static inline void wait_for_xmitr(struct uart_port *port)
+{
+	while (1) {
+		if (sp_uart_line_status_tx_buf_not_full(port)) {
+			break;
+		}
+	}
+}
+
+static void sunplus_uart_console_putchar(struct uart_port *port, int ch)
+{
+	wait_for_xmitr(port);
+	sp_uart_put_char(port, ch);
+}
+
+static void sunplus_console_write(struct console *co, const char *s, unsigned count)
+{
+	unsigned long flags;
+	int locked = 1;
+
+	local_irq_save(flags);
+
+#if defined(SUPPORT_SYSRQ)
+	if (sunplus_uart_ports[co->index].uport.sysrq)
+#else
+	if (0)
+#endif
+	{
+		locked = 0;
+	} else if (oops_in_progress) {
+		locked = spin_trylock(&sunplus_uart_ports[co->index].uport.lock);
+	} else {
+		spin_lock(&sunplus_uart_ports[co->index].uport.lock);
+	}
+
+	uart_console_write(&sunplus_uart_ports[co->index].uport, s, count, sunplus_uart_console_putchar);
+
+	if (locked) {
+		spin_unlock(&sunplus_uart_ports[co->index].uport.lock);
+	}
+
+	local_irq_restore(flags);
+}
+
+static int __init sunplus_console_setup(struct console *co, char *options)
+{
+	int ret = 0;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+	/* char string_console_setup[] = "\n\nsunplus_console_setup()\n\n"; */
+
+	if ((co->index >= NUM_UART) || (co->index < 0)) {
+		return -EINVAL;
+	}
+
+	if (options) {
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	}
+
+	ret = uart_set_options(&sunplus_uart_ports[co->index].uport, co, baud, parity, bits, flow);
+	/* sunplus_console_write(co, string_console_setup, sizeof(string_console_setup)); */
+	return ret;
+}
+
+/*
+ * Documentation/serial/driver:
+ * tx_empty(port)
+ * This function tests whether the transmitter fifo and shifter
+ * for the port described by 'port' is empty.  If it is empty,
+ * this function should return TIOCSER_TEMT, otherwise return 0.
+ * If the port does not support this operation, then it should
+ * return TIOCSER_TEMT.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+static unsigned int sunplus_uart_ops_tx_empty(struct uart_port *port)
+{
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *hwbuf_tx = sp_port->hwbuf_tx;
+	volatile struct regs_hwbuf *hwbuf_reg;
+
+	if (hwbuf_tx) {
+		hwbuf_reg = (volatile struct regs_hwbuf *)(hwbuf_tx->membase);
+		if (readl(&(hwbuf_reg->hwbuf_wr_adr)) == readl(&(hwbuf_reg->hwbuf_rd_adr))) {
+			return TIOCSER_TEMT;
+		} else {
+			return 0;
+		}
+
+	} else {
+		return ((sp_uart_get_line_status(port->membase) & SP_UART_LSR_TXE) ? TIOCSER_TEMT : 0);
+	}
+}
+
+/*
+ * Documentation/serial/driver:
+ * set_mctrl(port, mctrl)
+ * This function sets the modem control lines for port described
+ * by 'port' to the state described by mctrl.  The relevant bits
+ * of mctrl are:
+ *     - TIOCM_RTS     RTS signal.
+ *     - TIOCM_DTR     DTR signal.
+ *     - TIOCM_OUT1    OUT1 signal.
+ *     - TIOCM_OUT2    OUT2 signal.
+ *     - TIOCM_LOOP    Set the port into loopback mode.
+ * If the appropriate bit is set, the signal should be driven
+ * active.  If the bit is clear, the signal should be driven
+ * inactive.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	unsigned char mcr = sp_uart_get_modem_ctrl(port->membase);
+
+	if (mctrl & TIOCM_DTR) {
+		mcr |= SP_UART_MCR_DTS;
+	} else {
+		mcr &= ~SP_UART_MCR_DTS;
+	}
+
+	if (mctrl & TIOCM_RTS) {
+		mcr |= SP_UART_MCR_RTS;
+	} else {
+		mcr &= ~SP_UART_MCR_RTS;
+	}
+
+	if (mctrl & TIOCM_CAR) {
+		mcr |= SP_UART_MCR_DCD;
+	} else {
+		mcr &= ~SP_UART_MCR_DCD;
+	}
+
+	if (mctrl & TIOCM_RI) {
+		mcr |= SP_UART_MCR_RI;
+	} else {
+		mcr &= ~SP_UART_MCR_RI;
+	}
+
+	if (mctrl & TIOCM_LOOP) {
+		mcr |= SP_UART_MCR_LB;
+	} else {
+		mcr &= ~SP_UART_MCR_LB;
+	}
+
+	sp_uart_set_modem_ctrl(port->membase, mcr);
+}
+
+/*
+ * Documentation/serial/driver:
+ * get_mctrl(port)
+ * Returns the current state of modem control inputs.  The state
+ * of the outputs should not be returned, since the core keeps
+ * track of their state.  The state information should include:
+ *     - TIOCM_CAR     state of DCD signal
+ *     - TIOCM_CTS     state of CTS signal
+ *     - TIOCM_DSR     state of DSR signal
+ *     - TIOCM_RI      state of RI signal
+ * The bit is set if the signal is currently driven active.  If
+ * the port does not support CTS, DCD or DSR, the driver should
+ * indicate that the signal is permanently active.  If RI is
+ * not available, the signal should not be indicated as active.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static unsigned int sunplus_uart_ops_get_mctrl(struct uart_port *port)
+{
+	unsigned char status;
+	unsigned int ret = 0;
+
+	status = sp_uart_get_modem_ctrl(port->membase);
+
+	if (status & SP_UART_MCR_DTS) {
+		ret |= TIOCM_DTR;
+	}
+
+	if (status & SP_UART_MCR_RTS) {
+		ret |= TIOCM_RTS;
+	}
+
+	if (status & SP_UART_MCR_DCD) {
+		ret |= TIOCM_CAR;
+	}
+
+	if (status & SP_UART_MCR_RI) {
+		ret |= TIOCM_RI;
+	}
+
+	if (status & SP_UART_MCR_LB) {
+		ret |= TIOCM_LOOP;
+	}
+
+	if (status & SP_UART_MCR_AC) {
+		ret |= TIOCM_CTS;
+	}
+
+	return ret;
+}
+
+/*
+ * Documentation/serial/driver:
+ * stop_tx(port)
+ * Stop transmitting characters.  This might be due to the CTS
+ * line becoming inactive or the tty layer indicating we want
+ * to stop transmission due to an XOFF character.
+ *
+ * The driver should stop transmitting characters as soon as
+ * possible.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_stop_tx(struct uart_port *port)
+{
+	unsigned int isc = sp_uart_get_int_en(port->membase);
+
+	/* Even if (hwbuf_tx != NULL), "BUF_NOT_FULL" interrupt is used for getting into ISR */
+	isc &= ~SP_UART_ISC_TXM;
+	sp_uart_set_int_en(port->membase, isc);
+}
+
+/*
+ * Documentation/serial/driver:
+ * start_tx(port)
+ * Start transmitting characters.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_start_tx(struct uart_port *port)
+{
+	unsigned int isc;
+
+	/* Even if (hwbuf_tx != NULL), "BUF_NOT_FULL" interrupt is used for getting into ISR */
+	isc = sp_uart_get_int_en(port->membase) | SP_UART_ISC_TXM;
+	sp_uart_set_int_en(port->membase, isc);
+}
+
+/*
+ * Documentation/serial/driver:
+ * send_xchar(port,ch)
+ * Transmit a high priority character, even if the port is stopped.
+ * This is used to implement XON/XOFF flow control and tcflow().  If
+ * the serial driver does not implement this function, the tty core
+ * will append the character to the circular buffer and then call
+ * start_tx() / stop_tx() to flush the data out.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+#if 0
+static void sunplus_uart_ops_send_xchar(struct uart_port *port, char ch)
+{
+}
+#endif
+
+/*
+ * Documentation/serial/driver:
+ * stop_rx(port)
+ * Stop receiving characters; the port is in the process of
+ * being closed.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_stop_rx(struct uart_port *port)
+{
+	unsigned int isc;
+
+	isc = sp_uart_get_int_en(port->membase);
+	isc &= ~SP_UART_ISC_RXM;
+	sp_uart_set_int_en(port->membase, isc);
+}
+
+/*
+ * Documentation/serial/driver:
+ *
+ * enable_ms(port)
+ * Enable the modem status interrupts.
+ *
+ * This method may be called multiple times.  Modem status
+ * interrupts should be disabled when the shutdown method is
+ * called.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_enable_ms(struct uart_port *port)
+{
+	/* Do nothing */
+}
+
+/*
+ * Documentation/serial/driver:
+ * break_ctl(port,ctl)
+ * Control the transmission of a break signal.  If ctl is
+ * nonzero, the break signal should be transmitted.  The signal
+ * should be terminated when another call is made with a zero
+ * ctl.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_break_ctl(struct uart_port *port, int ctl)
+{
+	unsigned long flags;
+	unsigned int h_lcr;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	h_lcr = sp_uart_get_line_ctrl(port->membase);
+	if (ctl != 0) {
+		h_lcr |= SP_UART_LCR_BC;	/* start break */
+	} else {
+		h_lcr &= ~SP_UART_LCR_BC;	/* stop break */
+	}
+	sp_uart_set_line_ctrl(port->membase, h_lcr);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void transmit_chars(struct uart_port *port)	/* called by ISR */
+{
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *hwbuf_tx = sp_port->hwbuf_tx;
+	u32 tx_buf_available;
+	volatile struct regs_hwbuf *hwbuf_reg;
+	u32 addr_sw, addr_start;
+	u32 offset_sw;
+	u8 *byte_ptr;
+	struct circ_buf *xmit = &port->state->xmit;
+
+	if (port->x_char) {
+		sp_uart_put_char(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		sunplus_uart_ops_stop_tx(port);
+		return;
+	}
+
+	if (hwbuf_tx) {
+		hwbuf_reg = (volatile struct regs_hwbuf *)(hwbuf_tx->membase);
+		addr_sw = readl(&(hwbuf_reg->hwbuf_wr_adr));
+		addr_start = readl(&(hwbuf_reg->hwbuf_start_addr));
+		offset_sw = addr_sw - addr_start;
+		byte_ptr = (u8 *)(hwbuf_tx->buf_va + offset_sw);
+		tx_buf_available = sp_uart_line_status_tx_buf_not_full(port);
+		while (tx_buf_available) {
+			*byte_ptr = xmit->buf[xmit->tail];
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			port->icount.tx++;
+
+			byte_ptr++;
+			addr_sw++;
+			offset_sw++;
+			tx_buf_available--;
+			if (offset_sw == UATXDMA_BUF_SZ) {
+				offset_sw = 0;
+				addr_sw = (u32)(hwbuf_tx->dma_handle);
+				byte_ptr = (u8 *)(hwbuf_tx->buf_va);
+			}
+
+			if (uart_circ_empty(xmit)) {
+				break;
+			}
+		}
+		writel(addr_sw, &(hwbuf_reg->hwbuf_wr_adr));
+	} else {
+		do {
+			sp_uart_put_char(port, xmit->buf[xmit->tail]);
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			port->icount.tx++;
+
+			if (uart_circ_empty(xmit))
+				break;
+		} while (sp_uart_line_status_tx_buf_not_full(port));
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		uart_write_wakeup(port);
+	}
+
+	if (uart_circ_empty(xmit)) {
+		sunplus_uart_ops_stop_tx(port);
+	}
+}
+
+static void receive_chars(struct uart_port *port)	/* called by ISR */
+{
+	struct tty_struct *tty = port->state->port.tty;
+	unsigned char lsr = sp_uart_get_line_status(port->membase);
+	unsigned int ch, flag;
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *hwbuf_rx;
+	volatile struct regs_hwbuf *hwbuf_reg;
+	volatile struct regs_gdma *gdma_reg;
+	u32 int_flag;
+
+	hwbuf_rx = sp_port->hwbuf_rx;
+	if (hwbuf_rx) {
+		gdma_reg = (volatile struct regs_gdma *)(hwbuf_rx->membase_gdma);
+		int_flag = readl(&(gdma_reg->int_flag));
+
+		hwbuf_reg = (volatile struct regs_hwbuf *)(hwbuf_rx->membase);
+		if (int_flag) {
+			DBG_INFO("HWBUF-Rx, int_flag: 0x%x\n", int_flag);
+
+			if (int_flag & GDMA_INT_FLG_IP_TO) {
+				DBG_INFO("HWBUF-Rx, sw_rst_wr_cnt_dbg: 0x%x\n", readl(&(gdma_reg->sw_rst_wr_cnt_dbg)));
+
+				writel(GDMA_INT_FLG_IP_TO, &(gdma_reg->int_flag));
+
+				sp_uart_set_rx_residue(port->membase, 0);	/* flush rx data FIFO */
+				while (!(readl(&(hwbuf_reg->hwbuf_rst_done)) & 0x0001)) {
+					/* wait for s/w reset done */
+				}
+				while (!(readl(&(gdma_reg->sw_rst_state)) & 0x0001)) {
+					/* wait for s/w reset done */
+				}
+			}
+
+			/* clean other flags */
+			int_flag = readl(&(gdma_reg->int_flag));
+			writel(int_flag, &(gdma_reg->int_flag));
+
+			// DEBUG_HWBUF
+			{
+				int i;
+				u32 *ptr = hwbuf_rx->buf_va;
+
+				for (i = 0; i < 4; i++) {
+					DBG_INFO("Rx data: 0x%08x\n", *ptr);
+					ptr++;
+				}
+
+				ptr = hwbuf_rx->buf_va;
+				for (i = 0; i < 4; i++) {
+					*ptr = 0x20202020;
+					ptr++;
+				}
+			}
+
+
+			// TBD: switch buffer, pass data, ...
+
+			/* Start GDMA again */
+			writel(GDMA_CFG_VAL, &(gdma_reg->config));
+		}
+	}
+#if 0	// DEBUG_HWBUF
+			// = readl(&(gdma_reg->));
+			// = readl(&(gdma_reg->));
+			//
+			// = readl(&(hwbuf_reg->));
+			// = readl(&(hwbuf_reg->));
+			//
+			// writel((u32)(hwbuf_rx->dma_handle), &(gdma_reg->));
+			// writel((u32)(hwbuf_rx->dma_handle), &(gdma_reg->));
+			// writel((u32)(hwbuf_rx->dma_handle), &(hwbuf_reg->));
+#endif
+
+if (hwbuf_rx == NULL) { // DEBUG_HWBUF
+
+	do {
+		ch = sp_uart_get_char(port->membase);
+
+#if defined(CONFIG_SP_MON)
+		if (sysrqCheckState(ch, port) != 0)
+			goto ignore_char;
+#endif
+
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		if (unlikely(lsr & SP_UART_LSR_BRK_ERROR_BITS)) {
+			if (port->cons == NULL)
+				DBG_ERR("UART%d, SP_UART_LSR_BRK_ERROR_BITS, lsr = 0x%08X\n", port->line, lsr);
+
+			if (lsr & SP_UART_LSR_BC) {
+				lsr &= ~(SP_UART_LSR_FE | SP_UART_LSR_PE);
+				port->icount.brk++;
+				if (uart_handle_break(port))
+					goto ignore_char;
+			} else if (lsr & SP_UART_LSR_PE) {
+				if (port->cons == NULL)
+					DBG_ERR("UART%d, SP_UART_LSR_PE\n", port->line);
+				port->icount.parity++;
+			} else if (lsr & SP_UART_LSR_FE) {
+				if (port->cons == NULL)
+					DBG_ERR("UART%d, SP_UART_LSR_FE\n", port->line);
+				port->icount.frame++;
+			}
+			if (lsr & SP_UART_LSR_OE) {
+				if (port->cons == NULL)
+					DBG_ERR("UART%d, SP_UART_LSR_OE\n", port->line);
+				port->icount.overrun++;
+			}
+
+			/*
+			 * Mask off conditions which should be ignored.
+			 */
+
+			/* lsr &= port->read_status_mask; */
+
+			if (lsr & SP_UART_LSR_BC)
+				flag = TTY_BREAK;
+			else if (lsr & SP_UART_LSR_PE)
+				flag = TTY_PARITY;
+			else if (lsr & SP_UART_LSR_FE)
+				flag = TTY_FRAME;
+		}
+
+		if (port->ignore_status_mask & SP_UART_CREAD_DISABLED) {
+			goto ignore_char;
+		}
+
+		if (uart_handle_sysrq_char(port, ch))
+			goto ignore_char;
+
+		uart_insert_char(port, lsr, SP_UART_LSR_OE, ch, flag);
+
+ignore_char:
+		lsr = sp_uart_get_line_status(port->membase);
+	} while (lsr & SP_UART_LSR_RX);
+
+} // DEBUG_HWBUF
+
+	spin_unlock(&port->lock);
+	tty_flip_buffer_push(tty->port);
+	spin_lock(&port->lock);
+}
+
+static irqreturn_t sunplus_uart_irq(int irq, void *args)
+{
+	struct uart_port *port = (struct uart_port *)args;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+#if 0	/* force Tx data loopbacks to Rx except UART0 */
+	if (((u32)(port->membase)) != LOGI_ADDR_UART0_REG) {
+		sp_uart_set_modem_ctrl(port->membase, (sp_uart_get_modem_ctrl(port->membase)) | (1 << 4));
+	}
+#endif
+
+	if (sp_uart_get_int_en(port->membase) & SP_UART_ISC_RX) {
+		receive_chars(port);
+	}
+
+	if (sp_uart_get_int_en(port->membase) & SP_UART_ISC_TX) {
+		transmit_chars(port);
+	}
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static void receive_chars_rxdma(struct uart_port *port)	/* called by ISR */
+{
+	struct sunplus_uart_port *sp_port =
+		(struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_rx;
+	volatile struct regs_uarxdma *rxdma_reg;
+	struct tty_struct *tty = port->state->port.tty;
+	u32 offset_sw, offset_hw, rx_size;
+	u8 *sw_ptr, *buf_end_ptr, *u8_ptr;
+	u32 icount_rx;
+	u32 tmp_u32;
+	u8 tmp_buf[32];
+	int i;
+
+	uartdma_rx = sp_port->uartdma_rx;
+	rxdma_reg = (volatile struct regs_uarxdma *)(uartdma_rx->membase);
+
+	offset_sw = readl(&(rxdma_reg->rxdma_rd_adr)) - readl(&(rxdma_reg->rxdma_start_addr));
+	offset_hw = readl(&(rxdma_reg->rxdma_wr_adr)) - readl(&(rxdma_reg->rxdma_start_addr));
+
+	if (offset_hw >= offset_sw) {
+		rx_size = offset_hw - offset_sw;
+	} else {
+		rx_size = offset_hw + UARXDMA_BUF_SZ - offset_sw;
+	}
+
+	sw_ptr = (u8 *)(uartdma_rx->buf_va + offset_sw);
+	buf_end_ptr = (u8 *)(uartdma_rx->buf_va + UARXDMA_BUF_SZ);
+
+	/*
+	 * Retrive all data in ISR.
+	 * The max. received size is (buffer_size - threshold_size)
+	 * = (rxdma_length_thr[31:16] - rxdma_length_thr[15:0]) = MAX_SZ_RXDMA_ISR
+	 * In order to limit the execution time in this ISR:
+	 * => Increase rxdma_length_thr[15:0] to shorten each ISR execution time.
+	 * => Don't need to set a small threshold_size,
+	 *    and split a long ISR into several shorter ISRs.
+	 */
+	icount_rx = 0;
+	while (rx_size > icount_rx) {
+		if (!(((u32)(sw_ptr)) & (32 - 1))	/* 32-byte aligned */
+		    && ((rx_size - icount_rx) >= 32)) {
+			/*
+			 * Copy 32 bytes data from non cache area to cache area.
+			 * => It should use less DRAM controller's read command.
+			 */
+			memcpy(tmp_buf, sw_ptr, 32);
+			u8_ptr = (u8 *)(tmp_buf);
+			for (i = 0; i < 32; i++) {
+				port->icount.rx++;
+				uart_insert_char(port, 0, SP_UART_LSR_OE, (unsigned int)(*u8_ptr), TTY_NORMAL);
+				u8_ptr++;
+			}
+			sw_ptr += 32;
+			icount_rx += 32;
+		} else {
+			port->icount.rx++;
+			uart_insert_char(port, 0, SP_UART_LSR_OE, (unsigned int)(*sw_ptr), TTY_NORMAL);
+			sw_ptr++;
+			icount_rx++;
+		}
+		if (sw_ptr >= buf_end_ptr) {
+			sw_ptr = (u8 *)(uartdma_rx->buf_va);
+		}
+	}
+	tmp_u32 = readl(&(rxdma_reg->rxdma_rd_adr)) + rx_size;
+	if (tmp_u32 <= readl(&(rxdma_reg->rxdma_end_addr))) {
+		writel(tmp_u32, &(rxdma_reg->rxdma_rd_adr));
+	} else {
+		writel((tmp_u32 - UARXDMA_BUF_SZ), &(rxdma_reg->rxdma_rd_adr));
+	}
+
+	spin_unlock(&port->lock);
+	tty_flip_buffer_push(tty->port);
+	spin_lock(&port->lock);
+
+	writel(readl(&(rxdma_reg->rxdma_enable_sel)) | DMA_INT, &(rxdma_reg->rxdma_enable_sel));
+	writel(readl(&(rxdma_reg->rxdma_enable_sel)) | DMA_GO, &(rxdma_reg->rxdma_enable_sel));
+}
+
+static irqreturn_t sunplus_uart_rxdma_irq(int irq, void *args)
+{
+	struct uart_port *port = (struct uart_port *)args;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	receive_chars_rxdma(port);
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Documentation/serial/driver:
+ * startup(port)
+ * Grab any interrupt resources and initialise any low level driver
+ * state.  Enable the port for reception.  It should not activate
+ * RTS nor DTR; this will be done via a separate call to set_mctrl.
+ *
+ * This method will only be called when the port is initially opened.
+ *
+ * Locking: port_sem taken.
+ * Interrupts: globally disabled.
+ */
+static int sunplus_uart_ops_startup(struct uart_port *port)
+{
+	int ret;
+	u32 timeout, interrupt_en;
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_rx, *hwbuf_tx, *hwbuf_rx;
+	volatile struct regs_uarxdma *rxdma_reg;
+	volatile struct regs_hwbuf *hwbuf_reg;
+	volatile struct regs_gdma *gdma_reg;
+	unsigned int ch;
+
+	ret = request_irq(port->irq, sunplus_uart_irq, 0, sp_port->name, port);
+	if (ret) {
+		return ret;
+	}
+
+	uartdma_rx = sp_port->uartdma_rx;
+	if (uartdma_rx) {
+		rxdma_reg = (volatile struct regs_uarxdma *)(uartdma_rx->membase);
+
+		if (uartdma_rx->buf_va == NULL) {
+			/* Drop data in Rx FIFO (PIO mode) */
+			while (sp_uart_get_line_status(port->membase) & SP_UART_LSR_RX) {
+				ch = sp_uart_get_char(port->membase);
+			}
+
+			uartdma_rx->buf_va = dma_alloc_coherent(port->dev, UARXDMA_BUF_SZ, &(uartdma_rx->dma_handle), GFP_KERNEL);
+			if (uartdma_rx->buf_va == NULL) {
+				DBG_ERR("%s, %d, Can't allocation buffer for %s\n", __func__, __LINE__, sp_port->name);
+				ret = -ENOMEM;
+				goto error_01;
+			}
+			DBG_INFO("DMA buffer (Rx) for %s: VA: 0x%p, PA: 0x%x\n", sp_port->name, uartdma_rx->buf_va, (u32)(uartdma_rx->dma_handle));
+
+			writel((u32)(uartdma_rx->dma_handle), &(rxdma_reg->rxdma_start_addr));
+			writel((u32)(uartdma_rx->dma_handle), &(rxdma_reg->rxdma_rd_adr));
+
+			/* Force to use CLK_HIGH_UART in this mode */
+			/* Switch clock source when setting baud rate */
+			timeout = (CLK_HIGH_UART / 2) / 1000;		/* 1 msec */
+
+			/* DBG_INFO("timeout: 0x%x\n", timeout); */
+			writel(timeout, &(rxdma_reg->rxdma_timeout_set));
+
+			/*
+			 * When there are only rxdma_length_thr[15:0] bytes of free buffer
+			 * => Trigger interrupt
+			 */
+			writel(((UARXDMA_BUF_SZ << 16) | (UARXDMA_BUF_SZ - MAX_SZ_RXDMA_ISR)),
+			       &(rxdma_reg->rxdma_length_thr));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) & (~DMA_SEL_UARTX_MASK)),
+			       &(rxdma_reg->rxdma_enable_sel));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) | (DMA_INIT | (uartdma_rx->which_uart << DMA_SEL_UARTX_SHIFT))),
+			       &(rxdma_reg->rxdma_enable_sel));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) & (~DMA_INIT)),
+			       &(rxdma_reg->rxdma_enable_sel));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) | (DMA_SW_RST_B | DMA_AUTO_ENABLE | DMA_TIMEOUT_INT_EN | DMA_ENABLE)),
+			       &(rxdma_reg->rxdma_enable_sel));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) | (DMA_GO)),
+			       &(rxdma_reg->rxdma_enable_sel));
+		}
+		DBG_INFO("Enalbe RXDMA for %s (irq=%d)\n", sp_port->name, uartdma_rx->irq);
+		ret = request_irq(uartdma_rx->irq, sunplus_uart_rxdma_irq, 0, "UARTDMA_RX", port);
+		if (ret) {
+			dma_free_coherent(port->dev, UARXDMA_BUF_SZ, uartdma_rx->buf_va, uartdma_rx->dma_handle);
+			goto error_00;
+		}
+	}
+
+	hwbuf_rx = sp_port->hwbuf_rx;
+	if (hwbuf_rx) {
+		hwbuf_reg = (volatile struct regs_hwbuf *)(hwbuf_rx->membase);
+		DBG_INFO("Enalbe DMA (HWBUF-Rx) for %s\n", sp_port->name);
+
+		if (hwbuf_rx->buf_va == NULL) {
+			hwbuf_rx->buf_va = dma_alloc_coherent(port->dev, UARXDMA_BUF_SZ, &(hwbuf_rx->dma_handle), GFP_KERNEL);
+			if (hwbuf_rx->buf_va == NULL) {
+				DBG_ERR("%s, %d, Can't allocation buffer for %s\n", __func__, __LINE__, sp_port->name);
+				ret = -ENOMEM;
+				goto error_01;
+			}
+			DBG_INFO("DMA buffer (HWBUF-Rx) for %s: VA: 0x%p, PA: 0x%x\n", sp_port->name, hwbuf_rx->buf_va, (u32)(hwbuf_rx->dma_handle));
+
+			// DEBUG_HWBUF
+			{
+				int i;
+				u32 *ptr = hwbuf_rx->buf_va;
+				for (i = 0; i < 4; i++) {
+					*ptr = 0x20202020;
+					ptr++;
+				}
+			}
+
+			writel((hwbuf_rx->which_uart << 16), &(hwbuf_reg->hwbuf_sel));
+			writel(0x00000002, &(hwbuf_reg->hwbuf_enable));		/* Use GDMA's write => UART's Rx */
+
+			gdma_reg = (volatile struct regs_gdma *)(hwbuf_rx->membase_gdma);
+
+			hwbuf_rx->current_buf = 0;
+			writel((u32)(hwbuf_rx->dma_handle), &(gdma_reg->mem_adr));
+			writel((UARXDMA_BUF_SZ >> 1), &(gdma_reg->length));		/* double buffers */
+			writel((UARXDMA_BUF_SZ << 1), &(gdma_reg->sg_threshold));	/* make it never happen */
+
+			timeout = (CLK_HIGH_UART / 2) / 1000;		/* 1 msec */
+			writel(timeout, &(gdma_reg->ip_rd_timeout));
+			writel(timeout, &(gdma_reg->ip_wr_timeout));
+
+			writel((GDMA_INT_EN_IP_TO | GDMA_INT_EN_DONE), &(gdma_reg->int_en));
+			writel(GDMA_CFG_VAL, &(gdma_reg->config));
+		}
+	}
+
+	hwbuf_tx = sp_port->hwbuf_tx;
+	if (hwbuf_tx) {
+		hwbuf_reg = (volatile struct regs_hwbuf *)(hwbuf_tx->membase);
+		DBG_INFO("Enalbe DMA (HWBUF-Tx) for %s\n", sp_port->name);
+
+		if (hwbuf_tx->buf_va == NULL) {
+			hwbuf_tx->buf_va = dma_alloc_coherent(port->dev, UATXDMA_BUF_SZ, &(hwbuf_tx->dma_handle), GFP_KERNEL);
+			if (hwbuf_tx->buf_va == NULL) {
+				DBG_ERR("%s, %d, Can't allocation buffer for %s\n", __func__, __LINE__, sp_port->name);
+				ret = -ENOMEM;
+				goto error_01;
+			}
+			DBG_INFO("DMA buffer (HWBUF-Tx) for %s: VA: 0x%p, PA: 0x%x\n", sp_port->name, hwbuf_tx->buf_va, (u32)(hwbuf_tx->dma_handle));
+
+			writel((u32)(hwbuf_tx->dma_handle), &(hwbuf_reg->hwbuf_wr_adr));	/* must be set before hwbuf_start_addr */
+			writel((u32)(hwbuf_tx->dma_handle), &(hwbuf_reg->hwbuf_start_addr));	/* hwbuf_reg->hwbuf_rd_adr is updated by h/w too */
+			writel(((u32)(hwbuf_tx->dma_handle) + UATXDMA_BUF_SZ - 1), &(hwbuf_reg->hwbuf_end_addr));
+
+			writel(0x00000005, &(hwbuf_reg->hwbuf_enable));		/* Use ring buffer for UART's Tx */
+			writel(hwbuf_tx->which_uart, &(hwbuf_reg->hwbuf_sel));
+		}
+	}
+
+	spin_lock_irq(&port->lock);	/* don't need to use spin_lock_irqsave() because interrupts are globally disabled */
+
+	interrupt_en |= SP_UART_ISC_TXM;	/* Even if (hwbuf_tx != NULL), "BUF_NOT_FULL" interrupt is used for getting into ISR */
+	if (uartdma_rx == NULL) {
+		interrupt_en |= SP_UART_ISC_RXM;
+	}
+	sp_uart_set_int_en(port->membase, interrupt_en);
+
+	spin_unlock_irq(&port->lock);
+	return 0;
+
+error_01:
+	if (uartdma_rx) {
+		dma_free_coherent(port->dev, UARXDMA_BUF_SZ, uartdma_rx->buf_va, uartdma_rx->dma_handle);
+		free_irq(uartdma_rx->irq, port);
+	}
+error_00:
+	free_irq(port->irq, port);
+	return ret;
+}
+
+/*
+ * Documentation/serial/driver:
+ * shutdown(port)
+ * Disable the port, disable any break condition that may be in
+ * effect, and free any interrupt resources.  It should not disable
+ * RTS nor DTR; this will have already been done via a separate
+ * call to set_mctrl.
+ *
+ * Drivers must not access port->info once this call has completed.
+ *
+ * This method will only be called when there are no more users of
+ * this port.
+ *
+ * Locking: port_sem taken.
+ * Interrupts: caller dependent.
+ */
+static void sunplus_uart_ops_shutdown(struct uart_port *port)
+{
+	unsigned long flags;
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_rx;
+	volatile struct regs_uarxdma *rxdma_reg;
+	// struct sunplus_uartdma_info *hwbuf_tx, *hwbuf_rx;
+	// volatile struct regs_hwbuf *hwbuf_reg;
+
+	spin_lock_irqsave(&port->lock, flags);
+	sp_uart_set_int_en(port->membase, 0);	/* disable all interrupt */
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	free_irq(port->irq, port);
+
+	uartdma_rx = sp_port->uartdma_rx;
+	if (uartdma_rx) {
+		rxdma_reg = (volatile struct regs_uarxdma *)(uartdma_rx->membase);
+
+		/* Drop whatever is still in buffer */
+		writel(readl(&(rxdma_reg->rxdma_wr_adr)), &(rxdma_reg->rxdma_rd_adr));
+		// writel((readl(&(rxdma_reg->rxdma_enable_sel)) | (DMA_SW_RST_B)), &(rxdma_reg->rxdma_enable_sel));
+
+		free_irq(uartdma_rx->irq, port);
+		DBG_INFO("free_irq(%d)\n", uartdma_rx->irq);
+#if 0
+		dma_free_coherent(port->dev, UARXDMA_BUF_SZ, uartdma_rx->buf_va, uartdma_rx->dma_handle);
+		uartdma_rx->buf_va = NULL;
+#endif
+	}
+
+#if 0
+	hwbuf_rx = sp_port->hwbuf_rx;
+	if (hwbuf_rx) {
+		dma_free_coherent(port->dev, UARXDMA_BUF_SZ, hwbuf_rx->buf_va, hwbuf_rx->dma_handle);
+		hwbuf_tx->buf_va = NULL;
+	}
+#endif
+
+	/* Disable flow control of Tx, so that queued data can be sent out */
+	/* There is no way for s/w to let h/w abort in the middle of transaction. */
+	/* Don't reset module except it's in idle state. Otherwise, it might cause bus to hang. */
+	sp_uart_set_modem_ctrl(port->membase, sp_uart_get_modem_ctrl(port->membase) & (~(SP_UART_MCR_AC)));
+
+#if 0
+	hwbuf_tx = sp_port->hwbuf_tx;
+	if (hwbuf_tx) {
+		dma_free_coherent(port->dev, UARXDMA_BUF_SZ, hwbuf_tx->buf_va, hwbuf_tx->dma_handle);
+		hwbuf_tx->buf_va = NULL;
+	}
+#endif
+}
+
+/*
+ * Documentation/serial/driver:
+ * flush_buffer(port)
+ * Flush any write buffers, reset any DMA state and stop any
+ * ongoing DMA transfers.
+ *
+ * This will be called whenever the port->info->xmit circular
+ * buffer is cleared.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ *
+ */
+#if 0
+static void sunplus_uart_ops_flush_buffer(struct uart_port *port)
+{
+}
+#endif
+
+/*
+ * Documentation/serial/driver:
+ * set_termios(port,termios,oldtermios)
+ * Change the port parameters, including word length, parity, stop
+ * bits.  Update read_status_mask and ignore_status_mask to indicate
+ * the types of events we are interested in receiving.  Relevant
+ * termios->c_cflag bits are:
+ *     CSIZE   - word size
+ *     CSTOPB  - 2 stop bits
+ *     PARENB  - parity enable
+ *     PARODD  - odd parity (when PARENB is in force)
+ *     CREAD   - enable reception of characters (if not set,
+ *               still receive characters from the port, but
+ *               throw them away.
+ *     CRTSCTS - if set, enable CTS status change reporting
+ *     CLOCAL  - if not set, enable modem status change
+ *               reporting.
+ * Relevant termios->c_iflag bits are:
+ *     INPCK   - enable frame and parity error events to be
+ *               passed to the TTY layer.
+ *     BRKINT
+ *     PARMRK  - both of these enable break events to be
+ *               passed to the TTY layer.
+ *
+ *     IGNPAR  - ignore parity and framing errors
+ *     IGNBRK  - ignore break errors,  If IGNPAR is also
+ *               set, ignore overrun errors as well.
+ * The interaction of the iflag bits is as follows (parity error
+ * given as an example):
+ * Parity error    INPCK   IGNPAR
+ * n/a     0       n/a     character received, marked as
+ *                         TTY_NORMAL
+ * None            1       n/a character received, marked as
+ *                         TTY_NORMAL
+ * Yes     1       0       character received, marked as
+ *                         TTY_PARITY
+ * Yes     1       1       character discarded
+ *
+ * Other flags may be used (eg, xon/xoff characters) if your
+ * hardware supports hardware "soft" flow control.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+
+static void sunplus_uart_ops_set_termios(struct uart_port *port, struct ktermios *termios,
+					 struct ktermios *oldtermios)
+{
+	u32 clk, ext, div, div_l, div_h, baud;
+	u32 lcr;
+	unsigned long flags;
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+
+	baud = uart_get_baud_rate(port, termios, oldtermios, 0, (CLK_HIGH_UART >> 4));
+
+#if 0	/* For Zebu only, disable this in real chip */
+	if (baud == 921600) {
+		/*
+		 * Refer to Zebu's testbench/uart.cc
+		 * UART_RATIO should be 220 (CLK_HIGH_UART / 921600)
+		 * If change it to correct value, IBOOT must be changed.
+		 * (Clock should be switched to CLK_HIGH_UART)
+		 * For real chip, the baudrate is 115200.
+		 * */
+		baud = CLK_HIGH_UART / 232;
+	}
+#endif
+
+
+	clk = port->uartclk;
+	if ((baud > 115200) || (sp_port->uartdma_rx) || (sp_port->hwbuf_rx)) {
+		while (!(sp_uart_get_line_status(port->membase) & SP_UART_LSR_TXE)) {
+			/* Send all data in Tx FIFO before changing clock source, it should be UART0 only */
+		}
+
+		clk = CLK_HIGH_UART;
+		/* Don't change port->uartclk to CLK_HIGH_UART, keep the value of lower clk src */
+		/* Switch clock source */
+		sp_uart_set_clk_src(port->membase, 0);
+	} else {
+		sp_uart_set_clk_src(port->membase, ~0);
+	}
+
+	/* printk("UART clock: %d, baud: %d\n", clk, baud); */
+	clk += baud >> 1;
+	div = clk / baud;
+	ext = div & 0x0F;
+	div = (div >> 4) - 1;
+	div_l = (div & 0xFF) | (ext << 12);
+	div_h = div >> 8;
+	/* printk("div_l = %X, div_h: %X\n", div_l, div_h); */
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		lcr = SP_UART_LCR_WL5;
+		break;
+	case CS6:
+		lcr = SP_UART_LCR_WL6;
+		break;
+	case CS7:
+		lcr = SP_UART_LCR_WL7;
+		break;
+	default:	/* CS8 */
+		lcr = SP_UART_LCR_WL8;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB) {
+		lcr |= SP_UART_LCR_ST;
+	}
+
+	if (termios->c_cflag & PARENB) {
+		lcr |= SP_UART_LCR_PE;
+
+		if (!(termios->c_cflag & PARODD)) {
+			lcr |= SP_UART_LCR_PR;
+		}
+	}
+	/* printk("lcr = %X, \n", lcr); */
+
+	/* printk("Updating UART registers...\n"); */
+	spin_lock_irqsave(&port->lock, flags);
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	port->read_status_mask = 0;
+	if (termios->c_iflag & INPCK) {
+		port->read_status_mask |= SP_UART_LSR_PE | SP_UART_LSR_FE;
+	}
+	if (termios->c_iflag & (BRKINT | PARMRK)) {
+		port->read_status_mask |= SP_UART_LSR_BC;
+	}
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR) {
+		port->ignore_status_mask |= SP_UART_LSR_FE | SP_UART_LSR_PE;
+	}
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= SP_UART_LSR_BC;
+
+		if (termios->c_iflag & IGNPAR) {
+			port->ignore_status_mask |= SP_UART_LSR_OE;
+		}
+	}
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((termios->c_cflag & CREAD) == 0) {
+		port->ignore_status_mask |= SP_UART_CREAD_DISABLED;
+		sp_uart_set_rx_residue(port->membase, 0);	/* flush rx data FIFO */
+	}
+
+#if 0	/* No modem pin in chip */
+	if (UART_ENABLE_MS(port, termios->c_cflag))
+		enable_modem_status_irqs(port);
+#endif
+
+	if (termios->c_cflag & CRTSCTS) {
+		sp_uart_set_modem_ctrl(port->membase,
+				       sp_uart_get_modem_ctrl(port->membase) | (SP_UART_MCR_AC | SP_UART_MCR_AR));
+	} else {
+		sp_uart_set_modem_ctrl(port->membase,
+				       sp_uart_get_modem_ctrl(port->membase) & (~(SP_UART_MCR_AC | SP_UART_MCR_AR)));
+	}
+
+	/* do not set these in emulation */
+	sp_uart_set_divider_high_register(port->membase, div_h);
+	sp_uart_set_divider_low_register(port->membase, div_l);
+	sp_uart_set_line_ctrl(port->membase, lcr);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/*
+ * Documentation/serial/driver:
+ * N/A.
+ */
+static void sunplus_uart_ops_set_ldisc(struct uart_port *port,
+				       struct ktermios *termios)
+{
+	int new = termios->c_line;
+	if (new == N_PPS) {
+		port->flags |= UPF_HARDPPS_CD;
+		sunplus_uart_ops_enable_ms(port);
+	} else {
+		port->flags &= ~UPF_HARDPPS_CD;
+	}
+}
+
+/*
+ * Documentation/serial/driver:
+ * pm(port,state,oldstate)
+ * Perform any power management related activities on the specified
+ * port.  State indicates the new state (defined by
+ * enum uart_pm_state), oldstate indicates the previous state.
+ *
+ * This function should not be used to grab any resources.
+ *
+ * This will be called when the port is initially opened and finally
+ * closed, except when the port is also the system console.  This
+ * will occur even if CONFIG_PM is not set.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+#if 0
+static void sunplus_uart_ops_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+}
+#endif
+
+/*
+ * Documentation/serial/driver:
+ * set_wake(port,state)
+ * Enable/disable power management wakeup on serial activity.  Not
+ * currently implemented.
+ */
+#if 0
+static int sunplus_uart_ops_set_wake(struct uart_port *port, unsigned int state)
+{
+}
+#endif
+
+/*
+ * Documentation/serial/driver:
+ * type(port)
+ * Return a pointer to a string constant describing the specified
+ * port, or return NULL, in which case the string 'unknown' is
+ * substituted.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static const char *sunplus_uart_ops_type(struct uart_port *port)
+{
+	struct sunplus_uart_port *sunplus_uart_port =
+		(struct sunplus_uart_port *)port->private_data;
+	return (sunplus_uart_port->name);
+}
+
+/*
+ * Documentation/serial/driver:
+ * release_port(port)
+ * Release any memory and IO region resources currently in use by
+ * the port.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static void sunplus_uart_ops_release_port(struct uart_port *port)
+{
+#if 1
+	/* counterpart of sunplus_uart_ops_request_port() */
+#else
+	release_mem_region((resource_size_t)port->mapbase, UART_SZ);
+#endif
+}
+
+/*
+ * Documentation/serial/driver:
+ * request_port(port)
+ * Request any memory and IO region resources required by the port.
+ * If any fail, no resources should be registered when this function
+ * returns, and it should return -EBUSY on failure.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static int sunplus_uart_ops_request_port(struct uart_port *port)
+{
+#if 1
+	return 0;	/* register area has been mapped in sunplus_uart_platform_driver_probe_of() */
+#else
+	struct sunplus_uart_port *sunplus_uart_port =
+		(struct sunplus_uart_port *)port->private_data;
+
+	/* /proc/iomem */
+	if (request_mem_region((resource_size_t)port->mapbase,
+			       UART_SZ,
+			       sunplus_uart_port->name) == NULL) {
+		return -EBUSY;
+	} else {
+		return 0;
+	}
+#endif
+}
+
+/*
+ * Documentation/serial/driver:
+ * config_port(port,type)
+ * Perform any autoconfiguration steps required for the port.  `type`
+ * contains a bit mask of the required configuration.  UART_CONFIG_TYPE
+ * indicates that the port requires detection and identification.
+ * port->type should be set to the type found, or PORT_UNKNOWN if
+ * no port was detected.
+ *
+ * UART_CONFIG_IRQ indicates autoconfiguration of the interrupt signal,
+ * which should be probed using standard kernel autoprobing techniques.
+ * This is not necessary on platforms where ports have interrupts
+ * internally hard wired (eg, system on a chip implementations).
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static void sunplus_uart_ops_config_port(struct uart_port *port, int type)
+{
+	if (type & UART_CONFIG_TYPE) {
+		port->type = PORT_SP;
+		sunplus_uart_ops_request_port(port);
+	}
+}
+
+/*
+ * Documentation/serial/driver:
+ * verify_port(port,serinfo)
+ * Verify the new serial port information contained within serinfo is
+ * suitable for this port type.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static int sunplus_uart_ops_verify_port(struct uart_port *port, struct serial_struct *serial)
+{
+	return -EINVAL;	/* Modification *serial is not allowed */
+}
+
+/*
+ * Documentation/serial/driver:
+ * ioctl(port,cmd,arg)
+ * Perform any port specific IOCTLs.  IOCTL commands must be defined
+ * using the standard numbering system found in <asm/ioctl.h>
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+#if 0
+static int sunplus_uart_ops_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+}
+#endif
+
+#ifdef CONFIG_CONSOLE_POLL
+
+/*
+ * Documentation/serial/driver:
+ * poll_init(port)
+ * Called by kgdb to perform the minimal hardware initialization needed
+ * to support poll_put_char() and poll_get_char().  Unlike ->startup()
+ * this should not request interrupts.
+ *
+ * Locking: tty_mutex and tty_port->mutex taken.
+ * Interrupts: n/a.
+ */
+static int sunplus_uart_ops_poll_init(struct uart_port *port)
+{
+	return 0;
+}
+
+/*
+ * Documentation/serial/driver:
+ * poll_put_char(port,ch)
+ * Called by kgdb to write a single character directly to the serial
+ * port.  It can and should block until there is space in the TX FIFO.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_poll_put_char(struct uart_port *port, unsigned char data)
+{
+	wait_for_xmitr(port);
+	sp_uart_put_char(port, data);
+}
+
+/*
+ * Documentation/serial/driver:
+ * poll_get_char(port)
+ * Called by kgdb to read a single character directly from the serial
+ * port.  If data is available, it should be returned; otherwise
+ * the function should return NO_POLL_CHAR immediately.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+static int sunplus_uart_ops_poll_get_char(struct uart_port *port)
+{
+	unsigned int status;
+	unsigned char data;
+
+	do {
+		status = sp_uart_get_line_status(port->membase);
+	} while (!(status & SP_UART_LSR_RX));
+
+	data = sp_uart_get_char(port->membase);
+	return (int)data;
+}
+
+#endif /* CONFIG_CONSOLE_POLL */
+
+static struct uart_ops sunplus_uart_ops = {
+	.tx_empty		= sunplus_uart_ops_tx_empty,
+	.set_mctrl		= sunplus_uart_ops_set_mctrl,
+	.get_mctrl		= sunplus_uart_ops_get_mctrl,
+	.stop_tx		= sunplus_uart_ops_stop_tx,
+	.start_tx		= sunplus_uart_ops_start_tx,
+	/* .send_xchar		= sunplus_uart_ops_send_xchar, */
+	.stop_rx		= sunplus_uart_ops_stop_rx,
+	.enable_ms		= sunplus_uart_ops_enable_ms,
+	.break_ctl		= sunplus_uart_ops_break_ctl,
+	.startup		= sunplus_uart_ops_startup,
+	.shutdown		= sunplus_uart_ops_shutdown,
+	/* .flush_buffer	= sunplus_uart_ops_flush_buffer, */
+	.set_termios		= sunplus_uart_ops_set_termios,
+	.set_ldisc		= sunplus_uart_ops_set_ldisc,
+	/* .pm			= sunplus_uart_ops_pm, */
+	/* .set_wake		= sunplus_uart_ops_set_wake, */
+	.type			= sunplus_uart_ops_type,
+	.release_port		= sunplus_uart_ops_release_port,
+	.request_port		= sunplus_uart_ops_request_port,
+	.config_port		= sunplus_uart_ops_config_port,
+	.verify_port		= sunplus_uart_ops_verify_port,
+	/* .ioctl				= sunplus_uart_ops_ioctl, */
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_init		= sunplus_uart_ops_poll_init,
+	.poll_put_char		= sunplus_uart_ops_poll_put_char,
+	.poll_get_char		= sunplus_uart_ops_poll_get_char,
+#endif /* CONFIG_CONSOLE_POLL */
+};
+
+static struct uart_driver sunplus_uart_driver;
+
+static struct console sunplus_console = {
+	.name		= DEVICE_NAME,
+	.write		= sunplus_console_write,
+	.device		= uart_console_device,	/* default */
+	.setup		= sunplus_console_setup,
+	/* .early_setup	= , */
+	/*
+	 * CON_ENABLED,
+	 * CON_CONSDEV: preferred console,
+	 * CON_BOOT: primary boot console,
+	 * CON_PRINTBUFFER: used for printk buffer
+	 */
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	/* .cflag	= , */
+	.data		= &sunplus_uart_driver
+};
+
+static struct uart_driver sunplus_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "Sunplus_UART",
+	.dev_name	= DEVICE_NAME,
+	.major		= SP_UART_MAJOR,
+	.minor		= SP_UART_MINOR_START,
+	.nr		= NUM_UART,
+	.cons		= &sunplus_console
+};
+
+struct platform_device *sunpluse_uart_platform_device;
+
+static int sunplus_uart_platform_driver_probe_of(struct platform_device *pdev)
+{
+	struct resource *res_mem;
+	struct uart_port *port;
+	struct clk *clk;
+	int ret, irq;
+	int idx_offset, idx;
+	int idx_which_uart;
+	int tx_1_rx_0;
+
+	if (pdev->dev.of_node) {
+		pdev->id = of_alias_get_id(pdev->dev.of_node, "serial");
+		if (pdev->id < 0) {
+			pdev->id = of_alias_get_id(pdev->dev.of_node, "uart");
+		}
+	}
+
+	idx_offset = -1;
+	if (IS_UARTDMARX_ID(pdev->id)) {
+		idx_offset = 0;
+		DBG_INFO("Setup DMA Rx %d\n", (pdev->id - ID_BASE_DMARX));
+	} else if (IS_UARTHWBUF_ID(pdev->id)) {
+		idx_offset = NUM_UARTDMARX;
+		DBG_INFO("Setup HW_BUF_UA %d\n", (pdev->id - ID_BASE_HWBUF));
+	}
+	if (idx_offset >= 0) {
+		if (idx_offset == 0) {
+			idx = idx_offset + pdev->id - ID_BASE_DMARX;
+		} else {
+			idx = idx_offset + pdev->id - ID_BASE_HWBUF;
+		}
+
+		res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res_mem) {
+			return -ENODEV;
+		}
+
+		sunplus_uartdma[idx].addr_phy = (unsigned long)(res_mem->start);
+		sunplus_uartdma[idx].membase = devm_ioremap_resource(&pdev->dev, res_mem);
+		if (IS_ERR(sunplus_uartdma[idx].membase)) {
+			return PTR_ERR(sunplus_uartdma[idx].membase);
+		}
+
+		if (IS_UARTDMARX_ID(pdev->id)) {
+			irq = platform_get_irq(pdev, 0);
+			if (irq < 0) {
+				return -ENODEV;
+			}
+			sunplus_uartdma[idx].irq = irq;
+		}
+
+		if (of_property_read_u32(pdev->dev.of_node, "which-uart", &idx_which_uart) != 0) {
+			DBG_ERR("\"which-uart\" is not assigned.");
+			return -EINVAL;
+		}
+		if (idx_which_uart >= NUM_UART) {
+			DBG_ERR("\"which-uart\" is not valid.");
+			return -EINVAL;
+		}
+		sunplus_uartdma[idx].which_uart = idx_which_uart;
+
+		if (of_property_read_u32(pdev->dev.of_node, "tx-1-rx-0", &tx_1_rx_0) != 0) {
+			tx_1_rx_0 = 0;	/* uartdmarx0/1 */
+		} else {
+			if ((tx_1_rx_0 != 0) && (tx_1_rx_0 != 1)) {
+				DBG_ERR("\"tx-1-rx-0\" is not valid.");
+				return -EINVAL;
+			}
+		}
+		sunplus_uartdma[idx].tx_1_rx_0 = tx_1_rx_0;
+
+		DBG_INFO("addr_phy: 0x%lx, membase: 0x%p, irq: %d, which-uart: %d, direction: %s\n",
+			 sunplus_uartdma[idx].addr_phy,
+			 sunplus_uartdma[idx].membase,
+			 sunplus_uartdma[idx].irq,
+			 sunplus_uartdma[idx].which_uart,
+			 (sunplus_uartdma[idx].tx_1_rx_0 ? "Tx" : "Rx"));
+
+		if (sunplus_uartdma[idx].irq == 0) {	/* HW_BUF_UA's irq requiest is sent to CPU through original UART's IRQ */
+			res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+			if (!res_mem) {
+				return -ENODEV;
+			}
+
+			sunplus_uartdma[idx].addr_phy_gdma = (unsigned long)(res_mem->start);
+			sunplus_uartdma[idx].membase_gdma = devm_ioremap_resource(&pdev->dev, res_mem);
+			if (IS_ERR(sunplus_uartdma[idx].membase_gdma)) {
+				return PTR_ERR(sunplus_uartdma[idx].membase_gdma);
+			}
+
+			DBG_INFO("GDMA: addr_phy_gdma: 0x%lx, membase_gdma: 0x%p\n",
+				 sunplus_uartdma[idx].addr_phy_gdma,
+				 sunplus_uartdma[idx].membase_gdma);
+		}
+		return 0;
+	} else if (pdev->id < 0 || pdev->id >= NUM_UART) {
+		return -EINVAL;
+	}
+
+	port = &sunplus_uart_ports[pdev->id].uport;
+	if (port->membase) {
+		return -EBUSY;
+	}
+	memset(port, 0, sizeof(*port));
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res_mem) {
+		return -ENODEV;
+	}
+
+	port->mapbase = res_mem->start;
+	port->membase = devm_ioremap_resource(&pdev->dev, res_mem);
+	if (IS_ERR(port->membase))
+		return PTR_ERR(port->membase);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return -ENODEV;
+
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk)) {
+		port->uartclk = (27 * 1000 * 1000); /* default */
+	} else {
+		port->uartclk = clk_get_rate(clk);
+	}
+
+	port->iotype = UPIO_MEM;
+	port->irq = irq;
+	port->ops = &sunplus_uart_ops;
+	port->flags = UPF_BOOT_AUTOCONF;
+	port->dev = &pdev->dev;
+	port->fifosize = 16;
+	port->line = pdev->id;
+
+	if (pdev->id == 0)
+		port->cons = &sunplus_console;
+
+	port->private_data = container_of(&sunplus_uart_ports[pdev->id].uport, struct sunplus_uart_port, uport);
+	sprintf(sunplus_uart_ports[pdev->id].name, "sp_uart%d", pdev->id);
+
+	sunplus_uart_ports[pdev->id].uartdma_rx = sunplus_uartdma_rx_binding(pdev->id);
+	if (sunplus_uart_ports[pdev->id].uartdma_rx) {
+		DBG_INFO("%s's Rx is in DMA (UADMA) mode.\n", sunplus_uart_ports[pdev->id].name);
+	} else {
+		sunplus_uart_ports[pdev->id].hwbuf_rx = sunplus_hwbuf_rx_binding(pdev->id);
+		if (sunplus_uart_ports[pdev->id].hwbuf_rx) {
+			DBG_INFO("%s's Rx is in DMA (HWBUF) mode.\n", sunplus_uart_ports[pdev->id].name);
+		} else {
+			DBG_INFO("%s's Rx is in PIO mode.\n", sunplus_uart_ports[pdev->id].name);
+		}
+	}
+
+	sunplus_uart_ports[pdev->id].hwbuf_tx = sunplus_hwbuf_tx_binding(pdev->id);
+	if (sunplus_uart_ports[pdev->id].hwbuf_tx) {
+		DBG_INFO("%s's Tx is in DMA (HWBUF) mode.\n", sunplus_uart_ports[pdev->id].name);
+	} else {
+		DBG_INFO("%s's Tx is in PIO mode.\n", sunplus_uart_ports[pdev->id].name);
+	}
+
+	ret = uart_add_one_port(&sunplus_uart_driver, port);
+	if (ret) {
+		port->membase = NULL;
+		return ret;
+	}
+	platform_set_drvdata(pdev, port);
+	return 0;
+}
+
+static const struct of_device_id sp_uart_of_match[] = {
+	{ .compatible = "sunplus,sp-uart" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sp_uart_of_match);
+
+static struct platform_driver sunplus_uart_platform_driver = {
+	.probe		= sunplus_uart_platform_driver_probe_of,
+	.driver = {
+		.name	= DEVICE_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(sp_uart_of_match),
+	}
+};
+
+static int __init sunplus_uart_init(void)
+{
+	int ret;
+
+	memset(sunplus_uart_ports, 0, sizeof(sunplus_uart_ports));
+	memset(sunplus_uartdma, 0, sizeof(sunplus_uartdma));
+
+	/* DBG_INFO("uart0_as_console: %X\n", uart0_as_console); */
+	if (!uart0_as_console || !(uart_enable_status & 0x01))
+		sunplus_uart_driver.cons = NULL;
+
+	/* /proc/tty/driver/(sunplus_uart_driver->driver_name) */
+	ret = uart_register_driver(&sunplus_uart_driver);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&sunplus_uart_platform_driver);
+	if (ret != 0) {
+		uart_unregister_driver(&sunplus_uart_driver);
+		return ret;
+	}
+
+	return 0;
+}
+__initcall(sunplus_uart_init);
+
+module_param(uart0_as_console, uint, S_IRUGO);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sunplus Technology");
+MODULE_DESCRIPTION("Sunplus UART driver");
--- a/drivers/tty/serial/sp_uart.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/tty/serial/sp_uart.c	2018-11-12 06:42:55.000000000 +0300
@@ -0,0 +1,1700 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/of_platform.h>
+#include <asm/irq.h>
+#if defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#include <linux/sysrq.h>
+#endif
+#include <linux/serial_core.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <mach/sp_uart.h>
+
+#define NUM_UART	6	/* serial0,  ... */
+#define NUM_UARTDMARX	2	/* serial10, ... */
+#define NUM_UARTDMATX	2	/* serial20, ... */
+
+#define ID_BASE_DMARX	10
+#define ID_BASE_DMATX	20
+
+#define IS_UARTDMARX_ID(X)		(((X) >= (ID_BASE_DMARX)) && ((X) < (ID_BASE_DMARX + NUM_UARTDMARX)))
+#define IS_UARTDMATX_ID(X)		(((X) >= (ID_BASE_DMATX)) && ((X) < (ID_BASE_DMATX + NUM_UARTDMATX)))
+/* ---------------------------------------------------------------------------------------------- */
+#define TTYS_KDBG_INFO
+#define TTYS_KDBG_ERR
+
+#ifdef TTYS_KDBG_INFO
+#define DBG_INFO(fmt, args ...)	printk(KERN_INFO "K_TTYS: " fmt, ## args)
+#else
+#define DBG_INFO(fmt, args ...)
+#endif
+
+#ifdef TTYS_KDBG_ERR
+#define DBG_ERR(fmt, args ...)	printk(KERN_ERR "K_TTYS: " fmt, ## args)
+#else
+#define DBG_ERR(fmt, args ...)
+#endif
+/* ---------------------------------------------------------------------------------------------- */
+#define DEVICE_NAME			"ttyS"
+#define SP_UART_MAJOR			TTY_MAJOR
+#define SP_UART_MINOR_START		64
+
+#define SP_UART_CREAD_DISABLED	(1 << 16)
+/* ---------------------------------------------------------------------------------------------- */
+#define UARXDMA_BUF_SZ			PAGE_SIZE
+#define MAX_SZ_RXDMA_ISR		(1 << 9)
+#define UATXDMA_BUF_SZ			PAGE_SIZE
+/* ---------------------------------------------------------------------------------------------- */
+#define CLK_HIGH_UART			202500000
+/* ---------------------------------------------------------------------------------------------- */
+#if defined(CONFIG_SP_MON)
+extern unsigned int uart0_mask_tx;	/* Used for masking uart0 tx output */
+#endif
+
+struct sunplus_uart_port {
+	char name[16];	/* Sunplus_UARTx */
+	struct uart_port uport;
+	struct sunplus_uartdma_info *uartdma_rx;
+	struct sunplus_uartdma_info *uartdma_tx;
+};
+struct sunplus_uart_port sunplus_uart_ports[NUM_UART];
+
+struct sunplus_uartdma_info {
+	void __iomem *membase;	/* virtual address */
+	unsigned long addr_phy;
+	int irq;
+	int which_uart;
+	struct sunplus_uart_port *binding_port;
+	void *buf_va;
+	dma_addr_t dma_handle;
+};
+static struct sunplus_uartdma_info sunplus_uartdma[NUM_UARTDMARX + NUM_UARTDMATX];
+
+static inline void sp_uart_set_int_en(unsigned char __iomem *base, unsigned int_state)
+{
+	writel(int_state, &((struct regs_uart *)base)->uart_isc);
+}
+
+static inline unsigned sp_uart_get_int_en(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_isc);
+}
+
+static inline int sp_uart_get_char(unsigned char __iomem *base)
+{
+	return readl_relaxed(&((struct regs_uart *)base)->uart_data);
+}
+
+static inline void sp_uart_put_char(struct uart_port *port, unsigned ch)
+{
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_tx = sp_port->uartdma_tx;
+	volatile struct regs_uatxdma *txdma_reg;
+	unsigned char __iomem *base = port->membase;
+	u32 addr_sw, addr_start;
+	u32 offset_sw;
+	u8 *byte_ptr;
+
+#if defined(CONFIG_SP_MON)
+	if ((uart0_mask_tx == 1) && ((u32)base == LOGI_ADDR_UART0_REG)) {
+		return;
+	}
+#endif
+
+	if (!uartdma_tx) {
+		writel_relaxed(ch,  &((struct regs_uart *)base)->uart_data);
+	} else {
+		txdma_reg = (volatile struct regs_uatxdma *)(uartdma_tx->membase);
+		addr_sw = readl(&(txdma_reg->txdma_wr_adr));
+		addr_start = readl(&(txdma_reg->txdma_start_addr));
+		offset_sw = addr_sw - addr_start;
+		byte_ptr = (u8 *)(uartdma_tx->buf_va + offset_sw);
+		*byte_ptr = (u8)(ch);
+		if (offset_sw == (UATXDMA_BUF_SZ - 1)) {
+			writel((u32)(uartdma_tx->dma_handle), &(txdma_reg->txdma_wr_adr));
+		}  else {
+			writel((addr_sw + 1), &(txdma_reg->txdma_wr_adr));
+		}
+	}
+}
+
+static inline unsigned sp_uart_get_line_status(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_lsr);
+}
+
+static inline u32 sp_uart_line_status_tx_buf_not_full(struct uart_port *port)
+{
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_tx = sp_port->uartdma_tx;
+	volatile struct regs_uatxdma *txdma_reg;
+	unsigned char __iomem *base = port->membase;
+	u32 addr_sw, addr_hw;
+
+	if (uartdma_tx) {
+		txdma_reg = (volatile struct regs_uatxdma *)(uartdma_tx->membase);
+		addr_sw = readl(&(txdma_reg->txdma_wr_adr));
+		addr_hw = readl(&(txdma_reg->txdma_rd_adr));
+		if (addr_sw == addr_hw) {
+			return UATXDMA_BUF_SZ;
+		} else if (addr_sw >= addr_hw) {
+			return (UATXDMA_BUF_SZ - (addr_sw - addr_hw));
+		} else {
+			return (addr_hw - addr_sw);
+		}
+	} else {
+		if (readl(&((struct regs_uart *)base)->uart_lsr) & SP_UART_LSR_TX) {
+			/* In PIO mode, just return 1 byte becauase exactly number is unknown */
+			return 1;
+		} else {
+			return 0;
+		}
+	}
+}
+
+static inline void sp_uart_set_line_ctrl(unsigned char __iomem *base, unsigned ctrl)
+{
+	writel(ctrl, &((struct regs_uart *)base)->uart_lcr);
+}
+
+static inline unsigned sp_uart_get_line_ctrl(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_lcr);
+}
+
+static inline void sp_uart_set_divider_low_register(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_div_l);
+}
+
+static inline unsigned sp_uart_get_divider_low_register(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_div_l);
+}
+
+static inline void sp_uart_set_divider_high_register(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_div_h);
+}
+
+static inline unsigned sp_uart_get_divider_high_register(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_div_h);
+}
+
+static inline void sp_uart_set_rx_residue(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_rx_residue);
+}
+
+static inline void sp_uart_set_modem_ctrl(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_mcr);
+}
+
+static inline unsigned sp_uart_get_modem_ctrl(unsigned char __iomem *base)
+{
+	return readl(&((struct regs_uart *)base)->uart_mcr);
+}
+
+static inline void sp_uart_set_clk_src(unsigned char __iomem *base, unsigned val)
+{
+	writel(val, &((struct regs_uart *)base)->uart_clk_src);
+}
+
+/* ---------------------------------------------------------------------------------------------- */
+
+/*
+ * Note:
+ * When (uart0_as_console == 0), please make sure:
+ *     There is no "console=ttyS0,115200", "earlyprintk", ... in kernel command line.
+ *     In /etc/inittab, there is no something like "ttyS0::respawn:/bin/sh"
+ */
+unsigned int uart0_as_console = ~0;
+unsigned int uart_enable_status = ~0;	/* bit 0: UART0, bit 1: UART1, ... */
+
+#if defined(CONFIG_SP_MON)
+extern int sysrqCheckState(char, struct uart_port *);
+#endif
+
+static struct sunplus_uartdma_info *sunplus_uartdma_rx_binding(int id)
+{
+	int i;
+
+	for (i = 0; i < NUM_UARTDMARX; i++) {
+		if ((sunplus_uartdma[i].which_uart == id) && (sunplus_uartdma[i].membase)) {
+			sunplus_uartdma[i].binding_port = &sunplus_uart_ports[id];
+			return (&sunplus_uartdma[i]);
+		}
+	}
+	return NULL;
+}
+
+static struct sunplus_uartdma_info *sunplus_uartdma_tx_binding(int id)
+{
+	int i;
+
+	for (i = NUM_UARTDMARX; i < (NUM_UARTDMARX + NUM_UARTDMATX); i++) {
+		if ((sunplus_uartdma[i].which_uart == id) && (sunplus_uartdma[i].membase)) {
+			sunplus_uartdma[i].binding_port = &sunplus_uart_ports[id];
+			return (&sunplus_uartdma[i]);
+		}
+	}
+	return NULL;
+}
+
+static inline void wait_for_xmitr(struct uart_port *port)
+{
+	while (1) {
+		if (sp_uart_line_status_tx_buf_not_full(port)) {
+			break;
+		}
+	}
+}
+
+static void sunplus_uart_console_putchar(struct uart_port *port, int ch)
+{
+	wait_for_xmitr(port);
+	sp_uart_put_char(port, ch);
+}
+
+static void sunplus_console_write(struct console *co, const char *s, unsigned count)
+{
+	unsigned long flags;
+	int locked = 1;
+
+	local_irq_save(flags);
+
+#if defined(SUPPORT_SYSRQ)
+	if (sunplus_uart_ports[co->index].uport.sysrq)
+#else
+	if (0)
+#endif
+	{
+		locked = 0;
+	} else if (oops_in_progress) {
+		locked = spin_trylock(&sunplus_uart_ports[co->index].uport.lock);
+	} else {
+		spin_lock(&sunplus_uart_ports[co->index].uport.lock);
+	}
+
+	uart_console_write(&sunplus_uart_ports[co->index].uport, s, count, sunplus_uart_console_putchar);
+
+	if (locked) {
+		spin_unlock(&sunplus_uart_ports[co->index].uport.lock);
+	}
+
+	local_irq_restore(flags);
+}
+
+static int __init sunplus_console_setup(struct console *co, char *options)
+{
+	int ret = 0;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+	/* char string_console_setup[] = "\n\nsunplus_console_setup()\n\n"; */
+
+	if ((co->index >= NUM_UART) || (co->index < 0)) {
+		return -EINVAL;
+	}
+
+	if (options) {
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	}
+
+	ret = uart_set_options(&sunplus_uart_ports[co->index].uport, co, baud, parity, bits, flow);
+	/* sunplus_console_write(co, string_console_setup, sizeof(string_console_setup)); */
+	return ret;
+}
+
+/*
+ * Documentation/serial/driver:
+ * tx_empty(port)
+ * This function tests whether the transmitter fifo and shifter
+ * for the port described by 'port' is empty.  If it is empty,
+ * this function should return TIOCSER_TEMT, otherwise return 0.
+ * If the port does not support this operation, then it should
+ * return TIOCSER_TEMT.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+static unsigned int sunplus_uart_ops_tx_empty(struct uart_port *port)
+{
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_tx = sp_port->uartdma_tx;
+	volatile struct regs_uatxdma *txdma_reg;
+
+	if (uartdma_tx) {
+		txdma_reg = (volatile struct regs_uatxdma *)(uartdma_tx->membase);
+		if (readl(&(txdma_reg->txdma_wr_adr)) == readl(&(txdma_reg->txdma_rd_adr))) {
+			return TIOCSER_TEMT;
+		} else {
+			return 0;
+		}
+
+	} else {
+		return ((sp_uart_get_line_status(port->membase) & SP_UART_LSR_TXE) ? TIOCSER_TEMT : 0);
+	}
+}
+
+/*
+ * Documentation/serial/driver:
+ * set_mctrl(port, mctrl)
+ * This function sets the modem control lines for port described
+ * by 'port' to the state described by mctrl.  The relevant bits
+ * of mctrl are:
+ *     - TIOCM_RTS     RTS signal.
+ *     - TIOCM_DTR     DTR signal.
+ *     - TIOCM_OUT1    OUT1 signal.
+ *     - TIOCM_OUT2    OUT2 signal.
+ *     - TIOCM_LOOP    Set the port into loopback mode.
+ * If the appropriate bit is set, the signal should be driven
+ * active.  If the bit is clear, the signal should be driven
+ * inactive.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	unsigned char mcr = sp_uart_get_modem_ctrl(port->membase);
+
+	if (mctrl & TIOCM_DTR) {
+		mcr |= SP_UART_MCR_DTS;
+	} else {
+		mcr &= ~SP_UART_MCR_DTS;
+	}
+
+	if (mctrl & TIOCM_RTS) {
+		mcr |= SP_UART_MCR_RTS;
+	} else {
+		mcr &= ~SP_UART_MCR_RTS;
+	}
+
+	if (mctrl & TIOCM_CAR) {
+		mcr |= SP_UART_MCR_DCD;
+	} else {
+		mcr &= ~SP_UART_MCR_DCD;
+	}
+
+	if (mctrl & TIOCM_RI) {
+		mcr |= SP_UART_MCR_RI;
+	} else {
+		mcr &= ~SP_UART_MCR_RI;
+	}
+
+	if (mctrl & TIOCM_LOOP) {
+		mcr |= SP_UART_MCR_LB;
+	} else {
+		mcr &= ~SP_UART_MCR_LB;
+	}
+
+	sp_uart_set_modem_ctrl(port->membase, mcr);
+}
+
+/*
+ * Documentation/serial/driver:
+ * get_mctrl(port)
+ * Returns the current state of modem control inputs.  The state
+ * of the outputs should not be returned, since the core keeps
+ * track of their state.  The state information should include:
+ *     - TIOCM_CAR     state of DCD signal
+ *     - TIOCM_CTS     state of CTS signal
+ *     - TIOCM_DSR     state of DSR signal
+ *     - TIOCM_RI      state of RI signal
+ * The bit is set if the signal is currently driven active.  If
+ * the port does not support CTS, DCD or DSR, the driver should
+ * indicate that the signal is permanently active.  If RI is
+ * not available, the signal should not be indicated as active.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static unsigned int sunplus_uart_ops_get_mctrl(struct uart_port *port)
+{
+	unsigned char status;
+	unsigned int ret = 0;
+
+	status = sp_uart_get_modem_ctrl(port->membase);
+
+	if (status & SP_UART_MCR_DTS) {
+		ret |= TIOCM_DTR;
+	}
+
+	if (status & SP_UART_MCR_RTS) {
+		ret |= TIOCM_RTS;
+	}
+
+	if (status & SP_UART_MCR_DCD) {
+		ret |= TIOCM_CAR;
+	}
+
+	if (status & SP_UART_MCR_RI) {
+		ret |= TIOCM_RI;
+	}
+
+	if (status & SP_UART_MCR_LB) {
+		ret |= TIOCM_LOOP;
+	}
+
+	if (status & SP_UART_MCR_AC) {
+		ret |= TIOCM_CTS;
+	}
+
+	return ret;
+}
+
+/*
+ * Documentation/serial/driver:
+ * stop_tx(port)
+ * Stop transmitting characters.  This might be due to the CTS
+ * line becoming inactive or the tty layer indicating we want
+ * to stop transmission due to an XOFF character.
+ *
+ * The driver should stop transmitting characters as soon as
+ * possible.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_stop_tx(struct uart_port *port)
+{
+	unsigned int isc = sp_uart_get_int_en(port->membase);
+
+	/* Even if (uartdma_tx != NULL), "BUF_NOT_FULL" interrupt is used for getting into ISR */
+	isc &= ~SP_UART_ISC_TXM;
+	sp_uart_set_int_en(port->membase, isc);
+}
+
+/*
+ * Documentation/serial/driver:
+ * start_tx(port)
+ * Start transmitting characters.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_start_tx(struct uart_port *port)
+{
+	unsigned int isc;
+
+	/* Even if (uartdma_tx != NULL), "BUF_NOT_FULL" interrupt is used for getting into ISR */
+	isc = sp_uart_get_int_en(port->membase) | SP_UART_ISC_TXM;
+	sp_uart_set_int_en(port->membase, isc);
+}
+
+/*
+ * Documentation/serial/driver:
+ * send_xchar(port,ch)
+ * Transmit a high priority character, even if the port is stopped.
+ * This is used to implement XON/XOFF flow control and tcflow().  If
+ * the serial driver does not implement this function, the tty core
+ * will append the character to the circular buffer and then call
+ * start_tx() / stop_tx() to flush the data out.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+#if 0
+static void sunplus_uart_ops_send_xchar(struct uart_port *port, char ch)
+{
+}
+#endif
+
+/*
+ * Documentation/serial/driver:
+ * stop_rx(port)
+ * Stop receiving characters; the port is in the process of
+ * being closed.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_stop_rx(struct uart_port *port)
+{
+	unsigned int isc;
+
+	isc = sp_uart_get_int_en(port->membase);
+	isc &= ~SP_UART_ISC_RXM;
+	sp_uart_set_int_en(port->membase, isc);
+}
+
+/*
+ * Documentation/serial/driver:
+ *
+ * enable_ms(port)
+ * Enable the modem status interrupts.
+ *
+ * This method may be called multiple times.  Modem status
+ * interrupts should be disabled when the shutdown method is
+ * called.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_enable_ms(struct uart_port *port)
+{
+	/* Do nothing */
+}
+
+/*
+ * Documentation/serial/driver:
+ * break_ctl(port,ctl)
+ * Control the transmission of a break signal.  If ctl is
+ * nonzero, the break signal should be transmitted.  The signal
+ * should be terminated when another call is made with a zero
+ * ctl.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_break_ctl(struct uart_port *port, int ctl)
+{
+	unsigned long flags;
+	unsigned int h_lcr;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	h_lcr = sp_uart_get_line_ctrl(port->membase);
+	if (ctl != 0) {
+		h_lcr |= SP_UART_LCR_BC;	/* start break */
+	} else {
+		h_lcr &= ~SP_UART_LCR_BC;	/* stop break */
+	}
+	sp_uart_set_line_ctrl(port->membase, h_lcr);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void transmit_chars(struct uart_port *port)	/* called by ISR */
+{
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_tx = sp_port->uartdma_tx;
+	u32 tx_buf_available;
+	volatile struct regs_uatxdma *txdma_reg;
+	u32 addr_sw, addr_start;
+	u32 offset_sw;
+	u8 *byte_ptr;
+	struct circ_buf *xmit = &port->state->xmit;
+
+	if (port->x_char) {
+		sp_uart_put_char(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		sunplus_uart_ops_stop_tx(port);
+		return;
+	}
+
+	if (uartdma_tx) {
+		txdma_reg = (volatile struct regs_uatxdma *)(uartdma_tx->membase);
+		addr_sw = readl(&(txdma_reg->txdma_wr_adr));
+		addr_start = readl(&(txdma_reg->txdma_start_addr));
+		offset_sw = addr_sw - addr_start;
+		byte_ptr = (u8 *)(uartdma_tx->buf_va + offset_sw);
+		tx_buf_available = sp_uart_line_status_tx_buf_not_full(port);
+		while (tx_buf_available) {
+			*byte_ptr = xmit->buf[xmit->tail];
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			port->icount.tx++;
+
+			byte_ptr++;
+			addr_sw++;
+			offset_sw++;
+			tx_buf_available--;
+			if (offset_sw == UATXDMA_BUF_SZ) {
+				offset_sw = 0;
+				addr_sw = (u32)(uartdma_tx->dma_handle);
+				byte_ptr = (u8 *)(uartdma_tx->buf_va);
+			}
+
+			if (uart_circ_empty(xmit)) {
+				break;
+			}
+		}
+		writel(addr_sw, &(txdma_reg->txdma_wr_adr));
+	} else {
+		do {
+			sp_uart_put_char(port, xmit->buf[xmit->tail]);
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+			port->icount.tx++;
+
+			if (uart_circ_empty(xmit))
+				break;
+		} while (sp_uart_line_status_tx_buf_not_full(port));
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		uart_write_wakeup(port);
+	}
+
+	if (uart_circ_empty(xmit)) {
+		sunplus_uart_ops_stop_tx(port);
+	}
+}
+
+static void receive_chars(struct uart_port *port)	/* called by ISR */
+{
+	struct tty_struct *tty = port->state->port.tty;
+	unsigned char lsr = sp_uart_get_line_status(port->membase);
+	unsigned int ch, flag;
+
+	do {
+		ch = sp_uart_get_char(port->membase);
+
+#if defined(CONFIG_SP_MON)
+		if (sysrqCheckState(ch, port) != 0)
+			goto ignore_char;
+#endif
+
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		if (unlikely(lsr & SP_UART_LSR_BRK_ERROR_BITS)) {
+			if (port->cons == NULL)
+				DBG_ERR("UART%d, SP_UART_LSR_BRK_ERROR_BITS, lsr = 0x%08X\n", port->line, lsr);
+
+			if (lsr & SP_UART_LSR_BC) {
+				lsr &= ~(SP_UART_LSR_FE | SP_UART_LSR_PE);
+				port->icount.brk++;
+				if (uart_handle_break(port))
+					goto ignore_char;
+			} else if (lsr & SP_UART_LSR_PE) {
+				if (port->cons == NULL)
+					DBG_ERR("UART%d, SP_UART_LSR_PE\n", port->line);
+				port->icount.parity++;
+			} else if (lsr & SP_UART_LSR_FE) {
+				if (port->cons == NULL)
+					DBG_ERR("UART%d, SP_UART_LSR_FE\n", port->line);
+				port->icount.frame++;
+			}
+			if (lsr & SP_UART_LSR_OE) {
+				if (port->cons == NULL)
+					DBG_ERR("UART%d, SP_UART_LSR_OE\n", port->line);
+				port->icount.overrun++;
+			}
+
+			/*
+			 * Mask off conditions which should be ignored.
+			 */
+
+			/* lsr &= port->read_status_mask; */
+
+			if (lsr & SP_UART_LSR_BC)
+				flag = TTY_BREAK;
+			else if (lsr & SP_UART_LSR_PE)
+				flag = TTY_PARITY;
+			else if (lsr & SP_UART_LSR_FE)
+				flag = TTY_FRAME;
+		}
+
+		if (port->ignore_status_mask & SP_UART_CREAD_DISABLED) {
+			goto ignore_char;
+		}
+
+		if (uart_handle_sysrq_char(port, ch))
+			goto ignore_char;
+
+		uart_insert_char(port, lsr, SP_UART_LSR_OE, ch, flag);
+
+ignore_char:
+		lsr = sp_uart_get_line_status(port->membase);
+	} while (lsr & SP_UART_LSR_RX);
+
+	spin_unlock(&port->lock);
+	tty_flip_buffer_push(tty->port);
+	spin_lock(&port->lock);
+}
+
+static irqreturn_t sunplus_uart_irq(int irq, void *args)
+{
+	struct uart_port *port = (struct uart_port *)args;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+#if 0	/* force Tx data loopbacks to Rx except UART0 */
+	if (((u32)(port->membase)) != LOGI_ADDR_UART0_REG) {
+		sp_uart_set_modem_ctrl(port->membase, (sp_uart_get_modem_ctrl(port->membase)) | (1 << 4));
+	}
+#endif
+
+	if (sp_uart_get_int_en(port->membase) & SP_UART_ISC_RX) {
+		receive_chars(port);
+	}
+
+	if (sp_uart_get_int_en(port->membase) & SP_UART_ISC_TX) {
+		transmit_chars(port);
+	}
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static void receive_chars_rxdma(struct uart_port *port)	/* called by ISR */
+{
+	struct sunplus_uart_port *sp_port =
+		(struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_rx;
+	volatile struct regs_uarxdma *rxdma_reg;
+	struct tty_struct *tty = port->state->port.tty;
+	u32 offset_sw, offset_hw, rx_size;
+	u8 *sw_ptr, *buf_end_ptr, *u8_ptr;
+	u32 icount_rx;
+	u32 tmp_u32;
+	u8 tmp_buf[32];
+	int i;
+
+	uartdma_rx = sp_port->uartdma_rx;
+	rxdma_reg = (volatile struct regs_uarxdma *)(uartdma_rx->membase);
+
+	offset_sw = readl(&(rxdma_reg->rxdma_rd_adr)) - readl(&(rxdma_reg->rxdma_start_addr));
+	offset_hw = readl(&(rxdma_reg->rxdma_wr_adr)) - readl(&(rxdma_reg->rxdma_start_addr));
+
+	if (offset_hw >= offset_sw) {
+		rx_size = offset_hw - offset_sw;
+	} else {
+		rx_size = offset_hw + UARXDMA_BUF_SZ - offset_sw;
+	}
+
+	sw_ptr = (u8 *)(uartdma_rx->buf_va + offset_sw);
+	buf_end_ptr = (u8 *)(uartdma_rx->buf_va + UARXDMA_BUF_SZ);
+
+	/*
+	 * Retrive all data in ISR.
+	 * The max. received size is (buffer_size - threshold_size)
+	 * = (rxdma_length_thr[31:16] - rxdma_length_thr[15:0]) = MAX_SZ_RXDMA_ISR
+	 * In order to limit the execution time in this ISR:
+	 * => Increase rxdma_length_thr[15:0] to shorten each ISR execution time.
+	 * => Don't need to set a small threshold_size,
+	 *    and split a long ISR into several shorter ISRs.
+	 */
+	icount_rx = 0;
+	while (rx_size > icount_rx) {
+		if (!(((u32)(sw_ptr)) & (32 - 1))	/* 32-byte aligned */
+		    && ((rx_size - icount_rx) >= 32)) {
+			/*
+			 * Copy 32 bytes data from non cache area to cache area.
+			 * => It should use less DRAM controller's read command.
+			 */
+			memcpy(tmp_buf, sw_ptr, 32);
+			u8_ptr = (u8 *)(tmp_buf);
+			for (i = 0; i < 32; i++) {
+				port->icount.rx++;
+				uart_insert_char(port, 0, SP_UART_LSR_OE, (unsigned int)(*u8_ptr), TTY_NORMAL);
+				u8_ptr++;
+			}
+			sw_ptr += 32;
+			icount_rx += 32;
+		} else {
+			port->icount.rx++;
+			uart_insert_char(port, 0, SP_UART_LSR_OE, (unsigned int)(*sw_ptr), TTY_NORMAL);
+			sw_ptr++;
+			icount_rx++;
+		}
+		if (sw_ptr >= buf_end_ptr) {
+			sw_ptr = (u8 *)(uartdma_rx->buf_va);
+		}
+	}
+	tmp_u32 = readl(&(rxdma_reg->rxdma_rd_adr)) + rx_size;
+	if (tmp_u32 <= readl(&(rxdma_reg->rxdma_end_addr))) {
+		writel(tmp_u32, &(rxdma_reg->rxdma_rd_adr));
+	} else {
+		writel((tmp_u32 - UARXDMA_BUF_SZ), &(rxdma_reg->rxdma_rd_adr));
+	}
+
+	spin_unlock(&port->lock);
+	tty_flip_buffer_push(tty->port);
+	spin_lock(&port->lock);
+
+	writel(readl(&(rxdma_reg->rxdma_enable_sel)) | DMA_INT, &(rxdma_reg->rxdma_enable_sel));
+	writel(readl(&(rxdma_reg->rxdma_enable_sel)) | DMA_GO, &(rxdma_reg->rxdma_enable_sel));
+}
+
+static irqreturn_t sunplus_uart_rxdma_irq(int irq, void *args)
+{
+	struct uart_port *port = (struct uart_port *)args;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	receive_chars_rxdma(port);
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Documentation/serial/driver:
+ * startup(port)
+ * Grab any interrupt resources and initialise any low level driver
+ * state.  Enable the port for reception.  It should not activate
+ * RTS nor DTR; this will be done via a separate call to set_mctrl.
+ *
+ * This method will only be called when the port is initially opened.
+ *
+ * Locking: port_sem taken.
+ * Interrupts: globally disabled.
+ */
+static int sunplus_uart_ops_startup(struct uart_port *port)
+{
+	int ret;
+	u32 timeout, interrupt_en;
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_rx, *uartdma_tx;
+	volatile struct regs_uarxdma *rxdma_reg;
+	volatile struct regs_uatxdma *txdma_reg;
+	unsigned int ch;
+
+	ret = request_irq(port->irq, sunplus_uart_irq, 0, sp_port->name, port);
+	if (ret) {
+		return ret;
+	}
+
+	uartdma_rx = sp_port->uartdma_rx;
+	if (uartdma_rx) {
+		rxdma_reg = (volatile struct regs_uarxdma *)(uartdma_rx->membase);
+
+		if (uartdma_rx->buf_va == NULL) {
+			/* Drop data in Rx FIFO (PIO mode) */
+			while (sp_uart_get_line_status(port->membase) & SP_UART_LSR_RX) {
+				ch = sp_uart_get_char(port->membase);
+			}
+
+			uartdma_rx->buf_va = dma_alloc_coherent(port->dev, UARXDMA_BUF_SZ, &(uartdma_rx->dma_handle), GFP_KERNEL);
+			if (uartdma_rx->buf_va == NULL) {
+				DBG_ERR("%s, %d, Can't allocation buffer for %s\n", __func__, __LINE__, sp_port->name);
+				ret = -ENOMEM;
+				goto error_01;
+			}
+			DBG_INFO("DMA buffer (Rx) for %s: VA: 0x%p, PA: 0x%x\n", sp_port->name, uartdma_rx->buf_va, (u32)(uartdma_rx->dma_handle));
+
+			writel((u32)(uartdma_rx->dma_handle), &(rxdma_reg->rxdma_start_addr));
+			writel((u32)(uartdma_rx->dma_handle), &(rxdma_reg->rxdma_rd_adr));
+
+			/* Force to use CLK_HIGH_UART in this mode */
+			/* Switch clock source when setting baud rate */
+			timeout = (CLK_HIGH_UART / 2) / 1000000 * 1000;	/* 1 msec */
+
+			/* DBG_INFO("timeout: 0x%x\n", timeout); */
+			writel(timeout, &(rxdma_reg->rxdma_timeout_set));
+
+			/*
+			 * When there are only rxdma_length_thr[15:0] bytes of free buffer
+			 * => Trigger interrupt
+			 */
+			writel(((UARXDMA_BUF_SZ << 16) | (UARXDMA_BUF_SZ - MAX_SZ_RXDMA_ISR)),
+			       &(rxdma_reg->rxdma_length_thr));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) & (~DMA_SEL_UARTX_MASK)),
+			       &(rxdma_reg->rxdma_enable_sel));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) | (DMA_INIT | (uartdma_rx->which_uart << DMA_SEL_UARTX_SHIFT))),
+			       &(rxdma_reg->rxdma_enable_sel));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) & (~DMA_INIT)),
+			       &(rxdma_reg->rxdma_enable_sel));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) | (DMA_SW_RST_B | DMA_AUTO_ENABLE | DMA_TIMEOUT_INT_EN | DMA_ENABLE)),
+			       &(rxdma_reg->rxdma_enable_sel));
+			writel((readl(&(rxdma_reg->rxdma_enable_sel)) | (DMA_GO)),
+			       &(rxdma_reg->rxdma_enable_sel));
+		}
+		DBG_INFO("Enalbe RXDMA for %s (irq=%d)\n", sp_port->name, uartdma_rx->irq);
+		ret = request_irq(uartdma_rx->irq, sunplus_uart_rxdma_irq, 0, "UARTDMA_RX", port);
+		if (ret) {
+			dma_free_coherent(port->dev, UARXDMA_BUF_SZ, uartdma_rx->buf_va, uartdma_rx->dma_handle);
+			goto error_00;
+		}
+	}
+
+	uartdma_tx = sp_port->uartdma_tx;
+	if (uartdma_tx) {
+		txdma_reg = (volatile struct regs_uatxdma *)(uartdma_tx->membase);
+		DBG_INFO("Enalbe TXDMA for %s\n", sp_port->name);
+
+		if (uartdma_tx->buf_va == NULL) {
+			uartdma_tx->buf_va = dma_alloc_coherent(port->dev, UATXDMA_BUF_SZ, &(uartdma_tx->dma_handle), GFP_KERNEL);
+			if (uartdma_tx->buf_va == NULL) {
+				DBG_ERR("%s, %d, Can't allocation buffer for %s\n", __func__, __LINE__, sp_port->name);
+				ret = -ENOMEM;
+				goto error_01;
+			}
+			DBG_INFO("DMA buffer (Tx) for %s: VA: 0x%p, PA: 0x%x\n", sp_port->name, uartdma_tx->buf_va, (u32)(uartdma_tx->dma_handle));
+
+			writel((u32)(uartdma_tx->dma_handle), &(txdma_reg->txdma_wr_adr));	/* must be set before txdma_start_addr */
+			writel((u32)(uartdma_tx->dma_handle), &(txdma_reg->txdma_start_addr));	/* txdma_reg->txdma_rd_adr is updated by h/w too */
+			writel(((u32)(uartdma_tx->dma_handle) + UATXDMA_BUF_SZ - 1), &(txdma_reg->txdma_end_addr));
+
+			writel(0x00000005, &(txdma_reg->txdma_enable));		/* Use ring buffer for UART's Tx */
+			writel(uartdma_tx->which_uart, &(txdma_reg->txdma_sel));
+		}
+	}
+
+	spin_lock_irq(&port->lock);	/* don't need to use spin_lock_irqsave() because interrupts are globally disabled */
+
+	interrupt_en |= SP_UART_ISC_TXM;	/* Even if (uartdma_tx != NULL), "BUF_NOT_FULL" interrupt is used for getting into ISR */
+	if (uartdma_rx == NULL) {
+		interrupt_en |= SP_UART_ISC_RXM;
+	}
+	sp_uart_set_int_en(port->membase, interrupt_en);
+
+	spin_unlock_irq(&port->lock);
+	return 0;
+
+error_01:
+	if (uartdma_rx) {
+		dma_free_coherent(port->dev, UARXDMA_BUF_SZ, uartdma_rx->buf_va, uartdma_rx->dma_handle);
+		free_irq(uartdma_rx->irq, port);
+	}
+error_00:
+	free_irq(port->irq, port);
+	return ret;
+}
+
+/*
+ * Documentation/serial/driver:
+ * shutdown(port)
+ * Disable the port, disable any break condition that may be in
+ * effect, and free any interrupt resources.  It should not disable
+ * RTS nor DTR; this will have already been done via a separate
+ * call to set_mctrl.
+ *
+ * Drivers must not access port->info once this call has completed.
+ *
+ * This method will only be called when there are no more users of
+ * this port.
+ *
+ * Locking: port_sem taken.
+ * Interrupts: caller dependent.
+ */
+static void sunplus_uart_ops_shutdown(struct uart_port *port)
+{
+	unsigned long flags;
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+	struct sunplus_uartdma_info *uartdma_rx;
+	volatile struct regs_uarxdma *rxdma_reg;
+	// struct sunplus_uartdma_info *uartdma_tx;
+	// volatile struct regs_uatxdma *txdma_reg;
+
+	spin_lock_irqsave(&port->lock, flags);
+	sp_uart_set_int_en(port->membase, 0);	/* disable all interrupt */
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	free_irq(port->irq, port);
+
+	uartdma_rx = sp_port->uartdma_rx;
+	if (uartdma_rx) {
+		rxdma_reg = (volatile struct regs_uarxdma *)(uartdma_rx->membase);
+
+		/* Drop whatever is still in buffer */
+		writel(readl(&(rxdma_reg->rxdma_wr_adr)), &(rxdma_reg->rxdma_rd_adr));
+		// writel((readl(&(rxdma_reg->rxdma_enable_sel)) | (DMA_SW_RST_B)), &(rxdma_reg->rxdma_enable_sel));
+
+		free_irq(uartdma_rx->irq, port);
+		DBG_INFO("free_irq(%d)\n", uartdma_rx->irq);
+#if 0
+		dma_free_coherent(port->dev, UARXDMA_BUF_SZ, uartdma_rx->buf_va, uartdma_rx->dma_handle);
+		uartdma_rx->buf_va = NULL;
+#endif
+	}
+
+	/* Disable flow control of Tx, so that queued data can be sent out */
+	/* There is no way for s/w to let h/w abort in the middle of transaction. */
+	/* Don't reset module except it's in idle state. Otherwise, it might cause bus to hang. */
+	sp_uart_set_modem_ctrl(port->membase, sp_uart_get_modem_ctrl(port->membase) & (~(SP_UART_MCR_AC)));
+
+#if 0
+	uartdma_tx = sp_port->uartdma_tx;
+	if (uartdma_tx) {
+		dma_free_coherent(port->dev, UARXDMA_BUF_SZ, uartdma_tx->buf_va, uartdma_tx->dma_handle);
+		uartdma_tx->buf_va = NULL;
+	}
+#endif
+}
+
+/*
+ * Documentation/serial/driver:
+ * flush_buffer(port)
+ * Flush any write buffers, reset any DMA state and stop any
+ * ongoing DMA transfers.
+ *
+ * This will be called whenever the port->info->xmit circular
+ * buffer is cleared.
+ *
+ * Locking: port->lock taken.
+ * Interrupts: locally disabled.
+ * This call must not sleep
+ *
+ */
+#if 0
+static void sunplus_uart_ops_flush_buffer(struct uart_port *port)
+{
+}
+#endif
+
+/*
+ * Documentation/serial/driver:
+ * set_termios(port,termios,oldtermios)
+ * Change the port parameters, including word length, parity, stop
+ * bits.  Update read_status_mask and ignore_status_mask to indicate
+ * the types of events we are interested in receiving.  Relevant
+ * termios->c_cflag bits are:
+ *     CSIZE   - word size
+ *     CSTOPB  - 2 stop bits
+ *     PARENB  - parity enable
+ *     PARODD  - odd parity (when PARENB is in force)
+ *     CREAD   - enable reception of characters (if not set,
+ *               still receive characters from the port, but
+ *               throw them away.
+ *     CRTSCTS - if set, enable CTS status change reporting
+ *     CLOCAL  - if not set, enable modem status change
+ *               reporting.
+ * Relevant termios->c_iflag bits are:
+ *     INPCK   - enable frame and parity error events to be
+ *               passed to the TTY layer.
+ *     BRKINT
+ *     PARMRK  - both of these enable break events to be
+ *               passed to the TTY layer.
+ *
+ *     IGNPAR  - ignore parity and framing errors
+ *     IGNBRK  - ignore break errors,  If IGNPAR is also
+ *               set, ignore overrun errors as well.
+ * The interaction of the iflag bits is as follows (parity error
+ * given as an example):
+ * Parity error    INPCK   IGNPAR
+ * n/a     0       n/a     character received, marked as
+ *                         TTY_NORMAL
+ * None            1       n/a character received, marked as
+ *                         TTY_NORMAL
+ * Yes     1       0       character received, marked as
+ *                         TTY_PARITY
+ * Yes     1       1       character discarded
+ *
+ * Other flags may be used (eg, xon/xoff characters) if your
+ * hardware supports hardware "soft" flow control.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+
+static void sunplus_uart_ops_set_termios(struct uart_port *port, struct ktermios *termios,
+					 struct ktermios *oldtermios)
+{
+	u32 clk, ext, div, div_l, div_h, baud;
+	u32 lcr;
+	unsigned long flags;
+	struct sunplus_uart_port *sp_port = (struct sunplus_uart_port *)(port->private_data);
+
+	baud = uart_get_baud_rate(port, termios, oldtermios, 0, (CLK_HIGH_UART >> 4));
+
+#if 0	/* For Zebu only, disable this in real chip */
+	if (baud == 921600) {
+		/*
+		 * Refer to Zebu's testbench/uart.cc
+		 * UART_RATIO should be 220 (CLK_HIGH_UART / 921600)
+		 * If change it to correct value, IBOOT must be changed.
+		 * (Clock should be switched to CLK_HIGH_UART)
+		 * For real chip, the baudrate is 115200.
+		 * */
+		baud = CLK_HIGH_UART / 232;
+	}
+#endif
+
+
+	clk = port->uartclk;
+	if ((baud > 115200) || (sp_port->uartdma_rx)) {
+		while (!(sp_uart_get_line_status(port->membase) & SP_UART_LSR_TXE)) {
+			/* Send all data in Tx FIFO before changing clock source, it should be UART0 only */
+		}
+
+		clk = CLK_HIGH_UART;
+		/* Don't change port->uartclk to CLK_HIGH_UART, keep the value of lower clk src */
+		/* Switch clock source */
+		sp_uart_set_clk_src(port->membase, 0);
+	} else {
+		sp_uart_set_clk_src(port->membase, ~0);
+	}
+
+	/* printk("UART clock: %d, baud: %d\n", clk, baud); */
+	clk += baud >> 1;
+	div = clk / baud;
+	ext = div & 0x0F;
+	div = (div >> 4) - 1;
+	div_l = (div & 0xFF) | (ext << 12);
+	div_h = div >> 8;
+	/* printk("div_l = %X, div_h: %X\n", div_l, div_h); */
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		lcr = SP_UART_LCR_WL5;
+		break;
+	case CS6:
+		lcr = SP_UART_LCR_WL6;
+		break;
+	case CS7:
+		lcr = SP_UART_LCR_WL7;
+		break;
+	default:	/* CS8 */
+		lcr = SP_UART_LCR_WL8;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB) {
+		lcr |= SP_UART_LCR_ST;
+	}
+
+	if (termios->c_cflag & PARENB) {
+		lcr |= SP_UART_LCR_PE;
+
+		if (!(termios->c_cflag & PARODD)) {
+			lcr |= SP_UART_LCR_PR;
+		}
+	}
+	/* printk("lcr = %X, \n", lcr); */
+
+	/* printk("Updating UART registers...\n"); */
+	spin_lock_irqsave(&port->lock, flags);
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	port->read_status_mask = 0;
+	if (termios->c_iflag & INPCK) {
+		port->read_status_mask |= SP_UART_LSR_PE | SP_UART_LSR_FE;
+	}
+	if (termios->c_iflag & (BRKINT | PARMRK)) {
+		port->read_status_mask |= SP_UART_LSR_BC;
+	}
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR) {
+		port->ignore_status_mask |= SP_UART_LSR_FE | SP_UART_LSR_PE;
+	}
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= SP_UART_LSR_BC;
+
+		if (termios->c_iflag & IGNPAR) {
+			port->ignore_status_mask |= SP_UART_LSR_OE;
+		}
+	}
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((termios->c_cflag & CREAD) == 0) {
+		port->ignore_status_mask |= SP_UART_CREAD_DISABLED;
+		sp_uart_set_rx_residue(port->membase, 0);	/* flush rx data FIFO */
+	}
+
+#if 0	/* No modem pin in chip */
+	if (UART_ENABLE_MS(port, termios->c_cflag))
+		enable_modem_status_irqs(port);
+#endif
+
+	if (termios->c_cflag & CRTSCTS) {
+		sp_uart_set_modem_ctrl(port->membase,
+				       sp_uart_get_modem_ctrl(port->membase) | (SP_UART_MCR_AC | SP_UART_MCR_AR));
+	} else {
+		sp_uart_set_modem_ctrl(port->membase,
+				       sp_uart_get_modem_ctrl(port->membase) & (~(SP_UART_MCR_AC | SP_UART_MCR_AR)));
+	}
+
+	/* do not set these in emulation */
+	sp_uart_set_divider_high_register(port->membase, div_h);
+	sp_uart_set_divider_low_register(port->membase, div_l);
+	sp_uart_set_line_ctrl(port->membase, lcr);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/*
+ * Documentation/serial/driver:
+ * N/A.
+ */
+static void sunplus_uart_ops_set_ldisc(struct uart_port *port,
+				       struct ktermios *termios)
+{
+	int new = termios->c_line;
+	if (new == N_PPS) {
+		port->flags |= UPF_HARDPPS_CD;
+		sunplus_uart_ops_enable_ms(port);
+	} else {
+		port->flags &= ~UPF_HARDPPS_CD;
+	}
+}
+
+/*
+ * Documentation/serial/driver:
+ * pm(port,state,oldstate)
+ * Perform any power management related activities on the specified
+ * port.  State indicates the new state (defined by
+ * enum uart_pm_state), oldstate indicates the previous state.
+ *
+ * This function should not be used to grab any resources.
+ *
+ * This will be called when the port is initially opened and finally
+ * closed, except when the port is also the system console.  This
+ * will occur even if CONFIG_PM is not set.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+#if 0
+static void sunplus_uart_ops_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+}
+#endif
+
+/*
+ * Documentation/serial/driver:
+ * set_wake(port,state)
+ * Enable/disable power management wakeup on serial activity.  Not
+ * currently implemented.
+ */
+#if 0
+static int sunplus_uart_ops_set_wake(struct uart_port *port, unsigned int state)
+{
+}
+#endif
+
+/*
+ * Documentation/serial/driver:
+ * type(port)
+ * Return a pointer to a string constant describing the specified
+ * port, or return NULL, in which case the string 'unknown' is
+ * substituted.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static const char *sunplus_uart_ops_type(struct uart_port *port)
+{
+	struct sunplus_uart_port *sunplus_uart_port =
+		(struct sunplus_uart_port *)port->private_data;
+	return (sunplus_uart_port->name);
+}
+
+/*
+ * Documentation/serial/driver:
+ * release_port(port)
+ * Release any memory and IO region resources currently in use by
+ * the port.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static void sunplus_uart_ops_release_port(struct uart_port *port)
+{
+#if 1
+	/* counterpart of sunplus_uart_ops_request_port() */
+#else
+	release_mem_region((resource_size_t)port->mapbase, UART_SZ);
+#endif
+}
+
+/*
+ * Documentation/serial/driver:
+ * request_port(port)
+ * Request any memory and IO region resources required by the port.
+ * If any fail, no resources should be registered when this function
+ * returns, and it should return -EBUSY on failure.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static int sunplus_uart_ops_request_port(struct uart_port *port)
+{
+#if 1
+	return 0;	/* register area has been mapped in sunplus_uart_platform_driver_probe_of() */
+#else
+	struct sunplus_uart_port *sunplus_uart_port =
+		(struct sunplus_uart_port *)port->private_data;
+
+	/* /proc/iomem */
+	if (request_mem_region((resource_size_t)port->mapbase,
+			       UART_SZ,
+			       sunplus_uart_port->name) == NULL) {
+		return -EBUSY;
+	} else {
+		return 0;
+	}
+#endif
+}
+
+/*
+ * Documentation/serial/driver:
+ * config_port(port,type)
+ * Perform any autoconfiguration steps required for the port.  `type`
+ * contains a bit mask of the required configuration.  UART_CONFIG_TYPE
+ * indicates that the port requires detection and identification.
+ * port->type should be set to the type found, or PORT_UNKNOWN if
+ * no port was detected.
+ *
+ * UART_CONFIG_IRQ indicates autoconfiguration of the interrupt signal,
+ * which should be probed using standard kernel autoprobing techniques.
+ * This is not necessary on platforms where ports have interrupts
+ * internally hard wired (eg, system on a chip implementations).
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static void sunplus_uart_ops_config_port(struct uart_port *port, int type)
+{
+	if (type & UART_CONFIG_TYPE) {
+		port->type = PORT_SP;
+		sunplus_uart_ops_request_port(port);
+	}
+}
+
+/*
+ * Documentation/serial/driver:
+ * verify_port(port,serinfo)
+ * Verify the new serial port information contained within serinfo is
+ * suitable for this port type.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+static int sunplus_uart_ops_verify_port(struct uart_port *port, struct serial_struct *serial)
+{
+	return -EINVAL;	/* Modification *serial is not allowed */
+}
+
+/*
+ * Documentation/serial/driver:
+ * ioctl(port,cmd,arg)
+ * Perform any port specific IOCTLs.  IOCTL commands must be defined
+ * using the standard numbering system found in <asm/ioctl.h>
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ */
+#if 0
+static int sunplus_uart_ops_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+}
+#endif
+
+#ifdef CONFIG_CONSOLE_POLL
+
+/*
+ * Documentation/serial/driver:
+ * poll_init(port)
+ * Called by kgdb to perform the minimal hardware initialization needed
+ * to support poll_put_char() and poll_get_char().  Unlike ->startup()
+ * this should not request interrupts.
+ *
+ * Locking: tty_mutex and tty_port->mutex taken.
+ * Interrupts: n/a.
+ */
+static int sunplus_uart_ops_poll_init(struct uart_port *port)
+{
+	return 0;
+}
+
+/*
+ * Documentation/serial/driver:
+ * poll_put_char(port,ch)
+ * Called by kgdb to write a single character directly to the serial
+ * port.  It can and should block until there is space in the TX FIFO.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+static void sunplus_uart_ops_poll_put_char(struct uart_port *port, unsigned char data)
+{
+	wait_for_xmitr(port);
+	sp_uart_put_char(port, data);
+}
+
+/*
+ * Documentation/serial/driver:
+ * poll_get_char(port)
+ * Called by kgdb to read a single character directly from the serial
+ * port.  If data is available, it should be returned; otherwise
+ * the function should return NO_POLL_CHAR immediately.
+ *
+ * Locking: none.
+ * Interrupts: caller dependent.
+ * This call must not sleep
+ */
+static int sunplus_uart_ops_poll_get_char(struct uart_port *port)
+{
+	unsigned int status;
+	unsigned char data;
+
+	do {
+		status = sp_uart_get_line_status(port->membase);
+	} while (!(status & SP_UART_LSR_RX));
+
+	data = sp_uart_get_char(port->membase);
+	return (int)data;
+}
+
+#endif /* CONFIG_CONSOLE_POLL */
+
+static struct uart_ops sunplus_uart_ops = {
+	.tx_empty		= sunplus_uart_ops_tx_empty,
+	.set_mctrl		= sunplus_uart_ops_set_mctrl,
+	.get_mctrl		= sunplus_uart_ops_get_mctrl,
+	.stop_tx		= sunplus_uart_ops_stop_tx,
+	.start_tx		= sunplus_uart_ops_start_tx,
+	/* .send_xchar		= sunplus_uart_ops_send_xchar, */
+	.stop_rx		= sunplus_uart_ops_stop_rx,
+	.enable_ms		= sunplus_uart_ops_enable_ms,
+	.break_ctl		= sunplus_uart_ops_break_ctl,
+	.startup		= sunplus_uart_ops_startup,
+	.shutdown		= sunplus_uart_ops_shutdown,
+	/* .flush_buffer	= sunplus_uart_ops_flush_buffer, */
+	.set_termios		= sunplus_uart_ops_set_termios,
+	.set_ldisc		= sunplus_uart_ops_set_ldisc,
+	/* .pm			= sunplus_uart_ops_pm, */
+	/* .set_wake		= sunplus_uart_ops_set_wake, */
+	.type			= sunplus_uart_ops_type,
+	.release_port		= sunplus_uart_ops_release_port,
+	.request_port		= sunplus_uart_ops_request_port,
+	.config_port		= sunplus_uart_ops_config_port,
+	.verify_port		= sunplus_uart_ops_verify_port,
+	/* .ioctl				= sunplus_uart_ops_ioctl, */
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_init		= sunplus_uart_ops_poll_init,
+	.poll_put_char		= sunplus_uart_ops_poll_put_char,
+	.poll_get_char		= sunplus_uart_ops_poll_get_char,
+#endif /* CONFIG_CONSOLE_POLL */
+};
+
+static struct uart_driver sunplus_uart_driver;
+
+static struct console sunplus_console = {
+	.name		= DEVICE_NAME,
+	.write		= sunplus_console_write,
+	.device		= uart_console_device,	/* default */
+	.setup		= sunplus_console_setup,
+	/* .early_setup	= , */
+	/*
+	 * CON_ENABLED,
+	 * CON_CONSDEV: preferred console,
+	 * CON_BOOT: primary boot console,
+	 * CON_PRINTBUFFER: used for printk buffer
+	 */
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	/* .cflag	= , */
+	.data		= &sunplus_uart_driver
+};
+
+static struct uart_driver sunplus_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "Sunplus_UART",
+	.dev_name	= DEVICE_NAME,
+	.major		= SP_UART_MAJOR,
+	.minor		= SP_UART_MINOR_START,
+	.nr		= NUM_UART,
+	.cons		= &sunplus_console
+};
+
+struct platform_device *sunpluse_uart_platform_device;
+
+static int sunplus_uart_platform_driver_probe_of(struct platform_device *pdev)
+{
+	struct resource *res_mem;
+	struct uart_port *port;
+	struct clk *clk;
+	int ret, irq;
+	int idx_offset, idx;
+	int idx_which_uart;
+
+	if (pdev->dev.of_node) {
+		pdev->id = of_alias_get_id(pdev->dev.of_node, "serial");
+		if (pdev->id < 0) {
+			pdev->id = of_alias_get_id(pdev->dev.of_node, "uart");
+		}
+	}
+
+	idx_offset = -1;
+	if (IS_UARTDMARX_ID(pdev->id)) {
+		idx_offset = 0;
+		DBG_INFO("Setup DMA Rx %d\n", (pdev->id - ID_BASE_DMARX));
+	} else if (IS_UARTDMATX_ID(pdev->id)) {
+		idx_offset = NUM_UARTDMARX;
+		DBG_INFO("Setup DMA Tx %d\n", (pdev->id - ID_BASE_DMATX));
+	}
+	if (idx_offset >= 0) {
+		if (idx_offset == 0) {
+			idx = idx_offset + pdev->id - ID_BASE_DMARX;
+		} else {
+			idx = idx_offset + pdev->id - ID_BASE_DMATX;
+		}
+
+		res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res_mem) {
+			return -ENODEV;
+		}
+
+		sunplus_uartdma[idx].addr_phy = (unsigned long)(res_mem->start);
+		sunplus_uartdma[idx].membase = devm_ioremap_resource(&pdev->dev, res_mem);
+		if (IS_ERR(sunplus_uartdma[idx].membase)) {
+			return PTR_ERR(sunplus_uartdma[idx].membase);
+		}
+
+		if (IS_UARTDMARX_ID(pdev->id)) {
+			irq = platform_get_irq(pdev, 0);
+			if (irq < 0) {
+				return -ENODEV;
+			}
+			sunplus_uartdma[idx].irq = irq;
+		}
+
+		if (of_property_read_u32(pdev->dev.of_node, "which-uart", &idx_which_uart) != 0) {
+			DBG_ERR("\"which-uart\" is not assigned.");
+			return -EINVAL;
+		}
+		if (idx_which_uart >= NUM_UART) {
+			DBG_ERR("\"which-uart\" is not valid.");
+			return -EINVAL;
+		}
+		sunplus_uartdma[idx].which_uart = idx_which_uart;
+
+		DBG_INFO("addr_phy: 0x%lx, membase: 0x%p, irq: %d, which-uart: %d\n",
+			 sunplus_uartdma[idx].addr_phy,
+			 sunplus_uartdma[idx].membase,
+			 sunplus_uartdma[idx].irq,
+			 sunplus_uartdma[idx].which_uart);
+
+		return 0;
+	} else if (pdev->id < 0 || pdev->id >= NUM_UART) {
+		return -EINVAL;
+	}
+
+	port = &sunplus_uart_ports[pdev->id].uport;
+	if (port->membase) {
+		return -EBUSY;
+	}
+	memset(port, 0, sizeof(*port));
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res_mem) {
+		return -ENODEV;
+	}
+
+	port->mapbase = res_mem->start;
+	port->membase = devm_ioremap_resource(&pdev->dev, res_mem);
+	if (IS_ERR(port->membase))
+		return PTR_ERR(port->membase);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return -ENODEV;
+
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk)) {
+		port->uartclk = (27 * 1000 * 1000); /* default */
+	} else {
+		port->uartclk = clk_get_rate(clk);
+	}
+
+	port->iotype = UPIO_MEM;
+	port->irq = irq;
+	port->ops = &sunplus_uart_ops;
+	port->flags = UPF_BOOT_AUTOCONF;
+	port->dev = &pdev->dev;
+	port->fifosize = 16;
+	port->line = pdev->id;
+
+	if (pdev->id == 0)
+		port->cons = &sunplus_console;
+
+	port->private_data = container_of(&sunplus_uart_ports[pdev->id].uport, struct sunplus_uart_port, uport);
+	sprintf(sunplus_uart_ports[pdev->id].name, "sp_uart%d", pdev->id);
+
+	sunplus_uart_ports[pdev->id].uartdma_rx = sunplus_uartdma_rx_binding(pdev->id);
+	if (sunplus_uart_ports[pdev->id].uartdma_rx) {
+		DBG_INFO("%s's Rx is in DMA mode.\n", sunplus_uart_ports[pdev->id].name);
+	} else {
+		DBG_INFO("%s's Rx is in PIO mode.\n", sunplus_uart_ports[pdev->id].name);
+	}
+
+	sunplus_uart_ports[pdev->id].uartdma_tx = sunplus_uartdma_tx_binding(pdev->id);
+	if (sunplus_uart_ports[pdev->id].uartdma_tx) {
+		DBG_INFO("%s's Tx is in DMA mode.\n", sunplus_uart_ports[pdev->id].name);
+	} else {
+		DBG_INFO("%s's Tx is in PIO mode.\n", sunplus_uart_ports[pdev->id].name);
+	}
+
+	ret = uart_add_one_port(&sunplus_uart_driver, port);
+	if (ret) {
+		port->membase = NULL;
+		return ret;
+	}
+	platform_set_drvdata(pdev, port);
+	return 0;
+}
+
+static const struct of_device_id sp_uart_of_match[] = {
+	{ .compatible = "sunplus,sp-uart" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sp_uart_of_match);
+
+static struct platform_driver sunplus_uart_platform_driver = {
+	.probe		= sunplus_uart_platform_driver_probe_of,
+	.driver = {
+		.name	= DEVICE_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(sp_uart_of_match),
+	}
+};
+
+static int __init sunplus_uart_init(void)
+{
+	int ret;
+
+	memset(sunplus_uart_ports, 0, sizeof(sunplus_uart_ports));
+	memset(sunplus_uartdma, 0, sizeof(sunplus_uartdma));
+
+	/* DBG_INFO("uart0_as_console: %X\n", uart0_as_console); */
+	if (!uart0_as_console || !(uart_enable_status & 0x01))
+		sunplus_uart_driver.cons = NULL;
+
+	/* /proc/tty/driver/(sunplus_uart_driver->driver_name) */
+	ret = uart_register_driver(&sunplus_uart_driver);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&sunplus_uart_platform_driver);
+	if (ret != 0) {
+		uart_unregister_driver(&sunplus_uart_driver);
+		return ret;
+	}
+
+	return 0;
+}
+__initcall(sunplus_uart_init);
+
+module_param(uart0_as_console, uint, S_IRUGO);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sunplus Technology");
+MODULE_DESCRIPTION("Sunplus UART driver");
--- a/include/dt-bindings/clock/sp-q628.h	1970-01-01 03:00:00.000000000 +0300
+++ a/include/dt-bindings/clock/sp-q628.h	2018-11-12 06:42:56.000000000 +0300
@@ -0,0 +1,106 @@
+#ifndef _DT_BINDINGS_CLOCK_SUNPLUS_Q628_H
+#define _DT_BINDINGS_CLOCK_SUNPLUS_Q628_H
+
+/* plls */
+#define PLL_A		0
+#define PLL_E		1
+#define PLL_E_2P5	2
+#define PLL_E_25	3
+#define PLL_E_112P5	4
+#define PLL_F		5
+#define PLL_TV		6
+#define PLL_TV_A	7
+#define PLL_SYS		8
+
+/* gates: mo_clken0 ~ mo_clken9 */
+#define SYSTEM		0x10
+#define	RTC			0x12
+#define IOCTL		0x13
+#define IOP			0x14
+#define OTPRX		0x15
+#define NOC			0x16
+#define BR			0x17
+#define RBUS_L00	0x18
+#define SPIFL		0x19
+#define SDCTRL0		0x1a
+#define PERI0		0x1b
+#define A926		0x1d
+#define UMCTL2		0x1e
+#define PERI1		0x1f
+
+#define DDR_PHY0	0x20
+#define ACHIP		0x22
+#define STC0		0x24
+#define STC_AV0		0x25
+#define STC_AV1		0x26
+#define STC_AV2		0x27
+#define UA0			0x28
+#define UA1			0x29
+#define UA2			0x2a
+#define UA3			0x2b
+#define UA4			0x2c
+#define HWUA		0x2d
+#define DDC0		0x2e
+#define UADMA		0x2f
+
+#define CBDMA0		0x30
+#define CBDMA1		0x31
+#define SPI_COMBO_0	0x32
+#define SPI_COMBO_1	0x33
+#define SPI_COMBO_2	0x34
+#define SPI_COMBO_3	0x35
+#define AUD			0x36
+#define USBC0		0x3a
+#define USBC1		0x3b
+#define UPHY0		0x3d
+#define UPHY1		0x3e
+
+#define I2CM0		0x40
+#define I2CM1		0x41
+#define I2CM2		0x42
+#define I2CM3		0x43
+#define PMC			0x4d
+#define CARD_CTL0	0x4e
+#define CARD_CTL1	0x4f
+
+#define CARD_CTL4	0x52
+#define BCH			0x54
+#define DDFCH		0x5b
+#define CSIIW0		0x5c
+#define CSIIW1		0x5d
+#define MIPICSI0	0x5e
+#define MIPICSI1	0x5f
+
+#define HDMI_TX		0x60
+#define VPOST		0x65
+
+#define TGEN		0x70
+#define DMIX		0x71
+#define TCON		0x7a
+#define INTERRUPT	0x7f
+
+#define RGST		0x80
+#define GPIO		0x83
+#define RBUS_TOP	0x84
+
+#define MAILBOX		0x96
+#define SPIND		0x9a
+#define I2C2CBUS	0x9b
+
+#define OSD0		0xa0
+#define DISP_PWM	0xa2
+#define UADBG		0xa3
+#define DUMMY_MASTER	0xa4
+#define FIO_CTL		0xa5
+#define FPGA		0xa6
+#define L2SW		0xa7
+#define ICM			0xa8
+#define AXI_GLOBAL	0xa9
+
+#define CLK_MAX		0xb0
+
+/* reserved memory */
+#define SP_IOP_RESERVE_BASE     0x01000000
+#define SP_IOP_RESERVE_SIZE     0x00100000
+
+#endif
--- a/include/linux/init.h	2018-11-23 10:16:16.307798370 +0300
+++ a/include/linux/init.h	2018-11-23 10:31:03.821049624 +0300
@@ -83,6 +83,14 @@
 
 #define __exit          __section(.exit.text) __exitused __cold notrace
 
+/* Used for HOTPLUG */
+#define __devinit        __section(.devinit.text) __cold notrace
+#define __devinitdata    __section(.devinit.data)
+#define __devinitconst   __section(.devinit.rodata)
+#define __devexit        __section(.devexit.text) __exitused __cold notrace
+#define __devexitdata    __section(.devexit.data)
+#define __devexitconst   __section(.devexit.rodata)
+
 /* Used for MEMORY_HOTPLUG */
 #define __meminit        __section(.meminit.text) __cold notrace \
 						  __latent_entropy
@@ -279,6 +287,12 @@
 /* Data marked not to be saved by software suspend */
 #define __nosavedata __section(.data..nosave)
 
+#if defined(MODULE) || defined(CONFIG_HOTPLUG)
+#define __devexit_p(x) x
+#else
+#define __devexit_p(x) NULL
+#endif
+
 #ifdef MODULE
 #define __exit_p(x) x
 #else
--- a/include/linux/interrupt.h	2018-11-23 10:16:16.308798311 +0300
+++ a/include/linux/interrupt.h	2018-11-23 10:31:03.815049981 +0300
@@ -63,6 +63,7 @@
  *                wakeup devices users need to implement wakeup detection in
  *                their interrupt handlers.
  */
+#define IRQF_DISABLED		0x00000020
 #define IRQF_SHARED		0x00000080
 #define IRQF_PROBE_SHARED	0x00000100
 #define __IRQF_TIMER		0x00000200
--- a/include/linux/wakelock.h	1970-01-01 03:00:00.000000000 +0300
+++ a/include/linux/wakelock.h	2018-11-23 10:31:03.816049921 +0300
@@ -0,0 +1,67 @@
+/* include/linux/wakelock.h
+ *
+ * Copyright (C) 2007-2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_WAKELOCK_H
+#define _LINUX_WAKELOCK_H
+
+#include <linux/ktime.h>
+#include <linux/device.h>
+
+/* A wake_lock prevents the system from entering suspend or other low power
+ * states when active. If the type is set to WAKE_LOCK_SUSPEND, the wake_lock
+ * prevents a full system suspend.
+ */
+
+enum {
+	WAKE_LOCK_SUSPEND, /* Prevent suspend */
+	WAKE_LOCK_TYPE_COUNT
+};
+
+struct wake_lock {
+	struct wakeup_source ws;
+};
+
+static inline void wake_lock_init(struct wake_lock *lock, int type,
+				  const char *name)
+{
+	wakeup_source_init(&lock->ws, name);
+}
+
+static inline void wake_lock_destroy(struct wake_lock *lock)
+{
+	wakeup_source_trash(&lock->ws);
+}
+
+static inline void wake_lock(struct wake_lock *lock)
+{
+	__pm_stay_awake(&lock->ws);
+}
+
+static inline void wake_lock_timeout(struct wake_lock *lock, long timeout)
+{
+	__pm_wakeup_event(&lock->ws, jiffies_to_msecs(timeout));
+}
+
+static inline void wake_unlock(struct wake_lock *lock)
+{
+	__pm_relax(&lock->ws);
+}
+
+static inline int wake_lock_active(struct wake_lock *lock)
+{
+	return lock->ws.active;
+}
+
+#endif
--- a/include/uapi/asm-generic/errno.h	2018-11-23 10:16:19.363616836 +0300
+++ a/include/uapi/asm-generic/errno.h	2018-11-23 10:31:03.824049446 +0300
@@ -119,4 +119,6 @@
 
 #define EHWPOISON	133	/* Memory page has hardware error */
 
+#define ENOTCONN_IRQ    134
+
 #endif
--- a/include/uapi/linux/serial_core.h	2018-11-23 10:16:19.384615588 +0300
+++ a/include/uapi/linux/serial_core.h	2018-11-23 10:31:03.823049505 +0300
@@ -271,4 +271,7 @@
 /* MPS2 UART */
 #define PORT_MPS2UART	116
 
+/* Sunplus */
+#define PORT_SP         199
+
 #endif /* _UAPILINUX_SERIAL_CORE_H */
