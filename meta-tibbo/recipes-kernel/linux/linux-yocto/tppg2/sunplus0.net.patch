--- a/drivers/net/ethernet/Kconfig	2018-11-23 10:16:15.141867634 +0300
+++ a/drivers/net/ethernet/Kconfig	2018-11-23 10:31:03.814050040 +0300
@@ -181,5 +181,6 @@
 source "drivers/net/ethernet/xilinx/Kconfig"
 source "drivers/net/ethernet/xircom/Kconfig"
 source "drivers/net/ethernet/synopsys/Kconfig"
+source "drivers/net/ethernet/sp/Kconfig"
 
 endif # ETHERNET
--- a/drivers/net/ethernet/Makefile	2018-11-23 10:16:15.141867634 +0300
+++ a/drivers/net/ethernet/Makefile	2018-11-23 10:31:03.814050040 +0300
@@ -92,3 +92,4 @@
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
 obj-$(CONFIG_NET_VENDOR_SYNOPSYS) += synopsys/
+obj-$(CONFIG_L2SW_DRIVER) += sp/
--- a/drivers/net/ethernet/sp/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/Kconfig	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,10 @@
+#
+# L2SW device configuration
+#
+
+config L2SW_DRIVER
+    tristate "L2SW support"
+	depends on ETHERNET
+	select PHYLIB
+        help
+          This driver supports L2SW.
\ В конце файла нет новой строки
--- a/drivers/net/ethernet/sp/l2sw_define.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_define.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,371 @@
+#ifndef __L2SW_DEFINE_H__
+#define __L2SW_DEFINE_H__
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h> 
+#include <linux/slab.h> 
+#include <linux/errno.h>  
+#include <linux/types.h>  
+#include <linux/interrupt.h> 
+#include <linux/kdev_t.h>
+#include <linux/in.h>
+#include <linux/netdevice.h>   
+#include <linux/etherdevice.h> 
+#include <linux/ip.h>        
+#include <linux/tcp.h>         
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/platform_device.h>
+#include <linux/phy.h>
+#include <linux/mii.h>
+#include <linux/if_vlan.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_address.h>
+#include <linux/of_mdio.h>
+
+
+
+#if 1
+#define DEBUG0 printk
+#define DEBUG1() printk("[%s][%d]\n", __FUNCTION__, __LINE__)
+#else
+#define DEBUG0(str, ...)
+#define DEBUG1()
+#endif
+#define ERROR0 printk
+
+//#define CONFIG_PM
+#define INTERRUPT_IMMEDIATELY
+//#define RX_POLLING
+#define PHY_CONFIG
+
+#define ETHERNET_MAC_ADDRLEN            6
+
+/*config descriptor*/
+#define MAC_TX_DESC_NUM          8      /* hardware limit 2,4 or 8*/
+#define MAC_GUARD_DESC_NUM       2
+#define MAC_RX_DESC_QUEUE_NUM    1      /* hardware limit 1,2 or 4*/
+#define MAC_RX_QUEUE0_DESC_NUM   32      /* hardware limit even && >=4*/
+#define MAC_RX_QUEUE1_DESC_NUM   8      /* hardware limit even && >=4*/
+#define MAC_RX_QUEUE2_DESC_NUM   8      /* hardware limit even && >=4*/
+#define MAC_RX_QUEUE3_DESC_NUM   8      /* hardware limit even  && >= 44*/
+
+//define MAC interrupt status bit
+#define MAC_INT_MC				(3<<30)	
+#define MAC_INT_PSC				(1<<19)	
+#define MAC_INT_ETH0_LINK		(1<<24)
+#define MAC_INT_ETH1_LINK		(1<<25)
+#define MAC_INT_WDOG1_TMR_EXP	(1<<22)
+#define MAC_INT_WDOG0_TMR_EXP	(1<<21)
+#define MAC_INT_RX1_LAN_FULL	(1<<9)
+#define MAC_INT_RX0_LAN_FULL	(1<<8)
+#define MAC_INT_TX_L_DESCF		(1<<7)
+#define MAC_INT_TX_H_DESCF		(1<<6)
+#define MAC_INT_RX_DONE_L		(1<<5)
+#define MAC_INT_RX_DONE_H		(1<<4)
+#define MAC_INT_TX_DONE_L		(1<<3)
+#define MAC_INT_TX_DONE_H		(1<<2)
+#define MAC_INT_TX_DES_ER		(1<<1)
+#define MAC_INT_RX_DES_ER		(1<<0)
+
+#define MAC_INT_RX_DONE (MAC_INT_RX_DONE_H | MAC_INT_RX_DONE_L)
+#define MAC_INT_TX_DONE (MAC_INT_TX_DONE_H | MAC_INT_TX_DONE_L)
+
+//#define MAC_INT_RX_DESC_EMPTY (MAC_INT_RX_DESC_EMPTY_Q0 | MAC_INT_RX_DESC_EMPTY_Q1)
+#define MAC_INT_RX ( MAC_INT_RX_DONE | MAC_INT_RX0_LAN_FULL | MAC_INT_RX_DES_ER)
+//#define MAC_INT_RX_NO_HALT (MAC_INT_RX_DONE | MAC_INT_RX_PRE_BUF_OVF | MAC_INT_RX_FIFO_OVF)
+#define MAC_INT_TX  ( MAC_INT_TX_DONE | MAC_INT_TX_DES_ER | MAC_INT_TX_H_DESCF | MAC_INT_TX_L_DESCF )
+
+
+/*define PHY command bit*/
+#define PHY_WT_DATA_MASK        0xffff0000
+#define PHY_RD_CMD              0x00004000
+#define PHY_WT_CMD              0x00002000
+#define PHY_REG_MASK            0x00001f00
+#define PHY_ADR_MASK            0x0000001f
+#define PHY_CMD_TRI			    0x00000080
+
+/*define PHY status bit*/
+#define PHY_RD_DATA_MASK        0xffff0000
+#define PHY_RD_RDY              0x00000002
+#define PHY_WT_DONE             0x00000001
+
+/*define other register bit*/
+#define DESC_MODE_BIT           0x80000000
+#define DIS_AER_PKT             0x00002000
+#define EN_RX_VLAN              0x00001000
+#define DIS_UC_PAUSE            0x00000800
+#define DIS_BC                  0x00000400
+#define DIS_MC_HASH             0x00000200
+#define DIS_UC_HASH             0x00000100
+#define EN_TOS                  0x00000010
+#define EN_VLAN_PRI             0x00000008
+
+#define SLEEP_MODE              0x80000000
+#define PHY_LINK                0X01000000
+#define DIS_PORT_TX             0x00000040
+#define DIS_PORT_RX             (1<<24)
+#define SOFT_RST_N              0x00000001
+#define INT_MASK_VAL            0x000800f8
+#define VLAN_ENABLE             0x00010000
+#define DIS_BC_REC              0x00000400
+#define DIS_MC_REC              0x00000200
+
+#define RX_MAX_LEN_MASK         0x00011000
+#define ROUTE_MODE_MASK         0x00000060
+#define POK_INT_THS_MASK        0x000E0000
+#define VLAN_TH_MASK            0x00000007
+
+#define IP_PKG                  0x03
+#define NON_IP                  0
+
+/*define register statics*/
+#define MAC_REGS_VER             1
+#define MAC_REG_SIZE             4
+#define MAC_REGS_SIZE            156      /* 4*(11+19+9) */
+#define MAC_GLOBAL_GROUP_REG_NUM 11
+#define MAC_RX_GROUP_REG_NUM     19
+#define MAC_TX_GROUP_REG_NUM     9
+
+/* Standard interface flags (netdevice->flags). */
+
+//#define	IFF_PROMISC	0x100		/* receive all packets		*/
+//#define	IFF_ALLMULTI	0x200		/* receive all multicast packets*/
+
+
+/*define rx descriptor bit*/
+#define ERR_CODE	 	(0xf<<26)	
+#define RX_TU_BIT		(0x1<<23)	
+
+
+#define TAGA_BIT		(1<<27)
+#define PPPA			(1<<26)
+#define AMT				(3<<24)
+#define RX_CRC_BIT		(1<<18)
+#define RX_FAE_BIT		(1<<22)
+#define RX_RWT_BIT		(1<<21)
+#define RX_PLE_BIT		(1<<20)
+#define L3TP			(3<<18)
+#define IPCE			(1<<17)
+#define L4TP			(1<<16)
+#define L4CE			(1<<15)
+
+/*define tx descriptor bit*/
+#define OWN_BIT			(1<<31)	
+#define EOR_BIT			(1<<31)	
+
+#define FS_BIT		 	(1<<25)	
+#define LS_BIT			(1<<24)
+
+#define TXOK_BIT		(1<<26)
+#define LNKF_BIT		(1<<25)
+#define OWC_BIT			(1<<31)
+#define EXC_BIT			(1<<23)
+#define BUR_BIT	        (1<<22)
+#define TWDE_BIT		(1<<20)
+
+#define CC_MASK         0x000f0000
+#define PDI_MASK        0x00030000
+#define LEN_MASK		0x000007FF
+#define TBE_MASK		0x00070000
+
+#define MAC_PHY_ADDR            0x01    /* define by hardware */
+/*define CRC size in a package*/
+#define MAC_CRC_SIZE            4       /* define by ethernet frame protocol*/
+
+/*config descriptor*/
+#define	TX_DESC_NUM 8
+#define RX_QUEUE0_DESC_NUM 8
+#define RX_QUEUE1_DESC_NUM 8
+#define RX_DESC_NUM_MAX (RX_QUEUE0_DESC_NUM > RX_QUEUE1_DESC_NUM ? RX_QUEUE0_DESC_NUM : RX_QUEUE1_DESC_NUM)
+#define RX_DESC_QUEUE_NUM 2
+#define TX_DESC_QUEUE_NUM 1
+
+
+/*config receive descriptor mode. MAC_RX_DESC_MODE should be
+   *MAC_RX_DESC_SCATTER_MODE or MAC_RX_DESC_GATHER_MODE
+ */
+#define MAC_RX_DESC_GATHER_MODE   0
+#define MAC_RX_DESC_SCATTER_MODE  1
+#define MAC_RX_DESC_MODE         MAC_RX_DESC_GATHER_MODE
+
+#define MAC_RX_LEN_MAX      2047 
+#define MULTICAST_FILTER_LIMIT   64
+
+#define MAC_ADDR_LEN            6
+#define DESC_ALIGN_BYTE         32
+#define RX_OFFSET               0 
+#define TX_OFFSET               0 
+#define MAC_PHY_ID      32
+
+/*define DMA mask code*/
+#define MAC_DMA_32BIT 0xffffffffULL
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#define MAC_VLAN_TAG_USED 1
+#else
+#define MAC_VLAN_TAG_USED 0
+#endif
+
+#define BURST_DATA_128B
+#define BURST_DESC_128B
+#define AUTO_PAUSE_EN
+#define RXFIFO_H_THR 2
+#define RXFIFO_L_THR 4
+#define BUF_HIGH_TH 3
+#define BUF_LOW_TH 0
+#define RX_DESC_VALD_H_THR 3
+#define RX_DESC_VALD_L_THR 0
+
+
+/* OCP bus Pipeline enable. */
+
+// #define OCP_BUS_PIPELINE_ENABLE
+
+#define MAC_TX_BUFF_SIZE 1536
+#define MAC_RX_DESC_NUM 32
+
+#define	TOK_INT_THS 2
+#define	ROK_INT_THS 2
+
+#define TX_FIFO_THR	1
+
+
+#ifdef BURST_DATA_32B
+	#define BURST_DATA 0
+#endif
+#ifdef BURST_DATA_64B
+	#define BURST_DATA 1
+#endif
+#ifdef BURST_DATA_128B
+	#define BURST_DATA 2
+#endif
+#ifdef BURST_DESC_32B
+	#define BURST_DESC 0
+#endif
+#ifdef BURST_DESC_128B
+	#define BURST_DESC 1
+#endif
+#ifdef BURST_DESC_AUTO
+	#define BURST_DESC 2
+#endif
+#ifdef BURST_DESC_EQDATA
+	#define BURST_DESC 3
+#endif
+
+//#define	DIS_POL_REG1
+//#define	DIS_POL_CAP
+//#define	FORCE_FC_RX
+//#define	FORCE_FC_TX
+//#define	FORCE_DPX_FULL
+//#define	FORCE_LINK_UP
+//#define	FORCE_SPD_10
+//#define	FORCE_SPD_100
+//#define	FORCE_SPD_1000
+// #define	DATAOUT_FALLING
+ #define	DATAIN_FALLING
+//#define	LPB_XMII	//phy-interface loopback
+//#define	LPB_PHY		//external phy loopback
+#define	NON_LPB		//not loopback mode, normal mode
+
+#define F100M_FULL
+//#define F100M_HALF
+//#define F10M_FULL
+//#define F10M_HALF
+
+#ifndef NON_LPB
+#define		LOOPBACK_MODE
+#endif
+
+/* ignore RX CRC error and receive packet whatever. */
+#define RX_PROMISCUOUS_MODE
+
+/* OCP bus Pipeline disable. */
+//#define OCP_BUS_PIPELINE_DISABLE
+
+#define TX_ON
+#define	TX_RANDOM
+#define	TX_DATA 0x55
+
+#define DATA_CHK
+//#define EPC_ROUTE_BACK
+//#define EPC_MIRROR_MODE
+//#define EPC_CHK_MODE
+#ifndef EPC_ROUTE_BACK
+	#define	CRC_PAD_EN
+#endif
+
+#define ETHERNET_MAC_ADDR_LEN 6
+
+
+struct mac_desc {
+	volatile u32 cmd1;
+	volatile u32 cmd2;
+	volatile u32 addr1;
+	volatile u32 addr2;
+
+};
+
+
+struct skb_info {
+	struct sk_buff  *skb;
+	u32 mapping;
+	u32 len;
+};
+
+
+struct l2sw_mac {
+	struct net_device *net_dev;
+	struct net_device_stats dev_stats;
+    struct platform_device *pdev;
+	spinlock_t lock;
+	void *desc_base;
+	dma_addr_t desc_dma;
+	s32 desc_size;
+
+	struct mac_desc *rx_desc[RX_DESC_QUEUE_NUM];
+	struct skb_info *rx_skb_info[RX_DESC_QUEUE_NUM];
+	u32 rx_pos[RX_DESC_QUEUE_NUM];
+	u32 rx_desc_num[RX_DESC_QUEUE_NUM];
+    u32	rx_desc_buff_size;
+
+	struct mac_desc *tx_desc;
+	struct skb_info tx_temp_skb_info[TX_DESC_NUM];
+	u32 tx_done_pos;
+	u32 tx_pos;
+	u32 tx_desc_full;
+
+	u8	mac_addr[ETHERNET_MAC_ADDR_LEN];
+
+	u8	cpu_port;
+	u8	vlan_id;
+	u8	vlan_memset;
+	
+	struct mii_bus *mii_bus;
+	struct phy_device *phy_dev;
+	int phy_irq[PHY_MAX_ADDR];
+
+#ifndef INTERRUPT_IMMEDIATELY
+    struct tasklet_struct rx_tasklet;
+	struct tasklet_struct tx_tasklet;
+#endif
+    u32 int_status;	
+
+#ifdef RX_POLLING
+    struct napi_struct napi; 
+#endif
+
+#ifdef PHY_CONFIG
+    struct device_node *phy_node;
+#endif
+
+};
+
+
+
+
+#endif
+
--- a/drivers/net/ethernet/sp/l2sw_desc.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_desc.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,207 @@
+#include "l2sw_desc.h"
+#include "l2sw_define.h"
+
+u32 fix_net_dma(void *addr)
+{
+	dma_addr_t dma = (dma_addr_t) addr;
+	dma_addr_t tmp = (dma >> 28) & 0xf;
+    
+	/*If virtual address is 8xxx_xxxx or Axxx_xxxx or Cxxx_xxxx, dma address is 0xxx_xxxx*/
+	if ((tmp == 8) || (tmp == 0xa) || (tmp == 0xc))
+		return (dma & 0xfffffff);
+	/*If virtual address is Dxxx_xxxx, dma address is 1xxx_xxxx*/
+	if ( tmp == 0xd)
+		return ((dma & 0xfffffff) | 0x10000000);
+	/*If virtual address is 9xxx_xxxx or Bxxx_xxxx or Exxx_xxxx,dma address is 4xxx_xxxx*/
+	if ((tmp == 9) || (tmp == 0xb) || (tmp == 0xe))
+		return ((dma & 0xfffffff) | 0x40000000);
+	/*If virtual address is Fxxx_xxxx then dma address is 5xxx_xxxx*/
+	if (tmp == 0xf)
+		return ((dma & 0xfffffff) | 0x50000000);
+
+	return dma;
+
+}
+
+void rx_descs_flush(struct l2sw_mac *mac)
+{
+	u32 i, j;
+	volatile struct mac_desc *rx_desc;
+	struct skb_info *rx_skbinfo;
+
+	for (i = 0; i < RX_DESC_QUEUE_NUM; i++) {
+		rx_desc = mac->rx_desc[i];
+		rx_skbinfo = mac->rx_skb_info[i];
+		for (j = 0; j < mac->rx_desc_num[i]; j++) {
+			rx_desc[j].addr1 = rx_skbinfo[j].mapping;
+			rx_desc[j].cmd1 = OWN_BIT;
+			rx_desc[j].cmd2 = (j == mac->rx_desc_num[i] - 1) ? EOR_BIT|mac->rx_desc_buff_size : mac->rx_desc_buff_size;
+		}
+	}
+}
+
+void tx_descs_clean(struct l2sw_mac *mac)
+{
+	u32 i;
+	s32 buflen;
+
+	if (mac->tx_desc == NULL) {
+		return;
+	}
+
+	for (i = 0; i < TX_DESC_NUM; i++) {
+		if (mac->tx_temp_skb_info[i].mapping) {
+			buflen = (mac->tx_temp_skb_info[i].skb != NULL) ? mac->tx_temp_skb_info[i].skb->len : MAC_TX_BUFF_SIZE;
+			dma_unmap_single(&mac->pdev->dev, mac->tx_temp_skb_info[i].mapping, buflen, DMA_TO_DEVICE);
+			mac->tx_temp_skb_info[i].mapping = 0;
+		}
+		if (mac->tx_temp_skb_info[i].skb) {
+			dev_kfree_skb(mac->tx_temp_skb_info[i].skb);
+			mac->dev_stats.tx_dropped++;
+			mac->tx_temp_skb_info[i].skb = NULL;
+		}
+
+		(mac->tx_desc + i)->cmd1 = 0;
+		(mac->tx_desc + i)->cmd2 = 0;
+		(mac->tx_desc + i)->addr1 = 0;
+		(mac->tx_desc + i)->addr2 = 0;
+	}
+}
+
+void rx_descs_clean(struct l2sw_mac *mac)
+{
+	u32 i, j;
+	struct skb_info *skbinfo;
+
+	for (i = 0; i < RX_DESC_QUEUE_NUM; i++) {
+		if (mac->rx_skb_info[i] == NULL) {
+			continue;
+		}
+		skbinfo = mac->rx_skb_info[i];
+		for (j = 0; j < mac->rx_desc_num[i]; j++) {
+			if (skbinfo[j].skb) {
+				dma_unmap_single(&mac->pdev->dev, skbinfo[j].mapping, mac->rx_desc_buff_size, DMA_FROM_DEVICE);
+				dev_kfree_skb(skbinfo[j].skb);
+				skbinfo[j].skb = NULL;
+				skbinfo[j].mapping = 0;
+			}
+			(mac->rx_desc[i] + j)->cmd1 = 0;
+			(mac->rx_desc[i] + j)->cmd2 = 0;
+			(mac->rx_desc[i] + j)->addr1 = 0;
+		}
+		kfree(mac->rx_skb_info[i]);
+		mac->rx_skb_info[i] = NULL;
+	}
+}
+
+void descs_clean(struct l2sw_mac *mac)
+{
+	rx_descs_clean(mac);
+	tx_descs_clean(mac);
+}
+
+void descs_free(struct l2sw_mac *mac)
+{
+	u32 i;
+
+	descs_clean(mac);
+	mac->tx_desc = NULL;
+	for (i = 0; i < RX_DESC_QUEUE_NUM; i++) {
+		mac->rx_desc[i] = NULL;
+	}
+
+	/*  Free descriptor area  */
+	if (mac->desc_base != NULL) {
+		dma_free_coherent(&mac->pdev->dev, mac->desc_size, mac->desc_base, mac->desc_dma);
+		mac->desc_base = NULL;
+		mac->desc_dma = 0;
+		mac->desc_size = 0;
+	}
+}
+
+u32 tx_descs_init(struct l2sw_mac *mac)
+{
+    memset(mac->tx_desc, '\0', sizeof(struct mac_desc) * TX_DESC_NUM);
+    
+    return 0;
+}
+
+u32 rx_descs_init(struct l2sw_mac *mac)
+{
+    struct sk_buff *skb;
+    u32 i, j;
+    struct mac_desc *rxdesc;
+    struct skb_info *rx_skbinfo;
+
+    for (i = 0; i < RX_DESC_QUEUE_NUM; i++) {
+        mac->rx_skb_info[i] = (struct skb_info*)kmalloc(sizeof(struct skb_info) * mac->rx_desc_num[i], GFP_KERNEL);
+
+        if (mac->rx_skb_info[i] == NULL) {
+            goto MEM_ALLOC_FAIL;
+        }
+        rx_skbinfo = mac->rx_skb_info[i];
+        rxdesc = mac->rx_desc[i];
+        for (j = 0; j < mac->rx_desc_num[i]; j++) {
+            skb = __dev_alloc_skb(mac->rx_desc_buff_size + RX_OFFSET, GFP_ATOMIC | GFP_DMA);
+            if (!skb) {
+                goto MEM_ALLOC_FAIL;
+            }
+
+            skb->dev = mac->net_dev;
+            skb_reserve(skb, RX_OFFSET);/* +data +tail */
+
+            rx_skbinfo[j].skb = skb;
+            rx_skbinfo[j].mapping = dma_map_single(&mac->pdev->dev, skb->data, mac->rx_desc_buff_size, DMA_FROM_DEVICE);
+            rxdesc[j].addr1 = rx_skbinfo[j].mapping;
+			rxdesc[j].addr2 = 0;
+            rxdesc[j].cmd1 = OWN_BIT ;
+			rxdesc[j].cmd2 = (j == mac->rx_desc_num[i] - 1) ? EOR_BIT|mac->rx_desc_buff_size : mac->rx_desc_buff_size;
+        }
+    }
+
+    return 0;
+
+MEM_ALLOC_FAIL:
+    rx_descs_clean(mac);
+    return -ENOMEM;
+
+}
+
+u32 descs_init(struct l2sw_mac *mac)
+{
+	u32 rc;
+
+	if ((rc = tx_descs_init(mac)) != 0) {
+		return rc;
+	}
+	return rx_descs_init(mac);
+}
+
+u32 descs_alloc(struct l2sw_mac *mac)
+{
+    u32 i;
+    s32 desc_size;
+
+    /*  Alloc descriptor area  */
+    desc_size = (TX_DESC_NUM) * sizeof(struct mac_desc);
+    for (i = 0; i < RX_DESC_QUEUE_NUM; i++) {
+        desc_size += mac->rx_desc_num[i] * sizeof(struct mac_desc);
+    }
+    mac->desc_base = dma_alloc_coherent(&mac->pdev->dev, desc_size, &mac->desc_dma, GFP_KERNEL);
+    if (mac->desc_base == NULL) {
+        return -ENOMEM;
+    }
+    mac->desc_size = desc_size;
+
+    /*  Setup Tx descriptor  */
+    mac->tx_desc = (struct mac_desc*)mac->desc_base;
+
+    /*  Setup Rx descriptor*/
+    mac->rx_desc[0] = &mac->tx_desc[TX_DESC_NUM + MAC_GUARD_DESC_NUM];
+    for (i = 1; i < RX_DESC_QUEUE_NUM; i++) {
+        mac->rx_desc[i] = mac->rx_desc[0] + mac->rx_desc_num[i - 1];
+    }
+    return 0;
+
+}
+
--- a/drivers/net/ethernet/sp/l2sw_desc.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_desc.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,26 @@
+#ifndef __GMAC_DESC_H__
+#define __GMAC_DESC_H__
+
+#include "l2sw_define.h"
+
+u32 fix_net_dma(void *addr);
+
+void rx_descs_flush(struct l2sw_mac *mac);
+
+void tx_descs_clean(struct l2sw_mac *mac);
+
+void rx_descs_clean(struct l2sw_mac *mac);
+
+void descs_clean(struct l2sw_mac *mac);
+
+void descs_free(struct l2sw_mac *mac);
+
+u32 tx_descs_init(struct l2sw_mac *mac);
+
+u32 rx_descs_init(struct l2sw_mac *mac);
+
+u32 descs_init(struct l2sw_mac *mac);
+
+u32 descs_alloc(struct l2sw_mac *mac);
+
+#endif
--- a/drivers/net/ethernet/sp/l2sw_driver.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_driver.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,899 @@
+#include "l2sw_driver.h"
+
+#if 1
+
+static char def_mac_addr[ETHERNET_MAC_ADDR_LEN] = {0x88,0x88,0x88,0x88,0x88,0x88};
+
+
+/*********************************************************************
+*
+* net_device_ops
+*
+**********************************************************************/
+
+static inline void rx_skb(struct l2sw_mac *mac,
+                              struct sk_buff *skb, struct mac_desc *desc)
+{
+	mac->dev_stats.rx_packets++;
+	mac->dev_stats.rx_bytes += skb->len;
+	//mac->net_dev->last_rx = jiffies;
+
+	netif_rx(skb);
+}
+
+static inline void interrupt_finish(struct l2sw_mac *mac) 
+{
+    u32 reg;
+    
+    struct net_device *net_dev = (struct net_device *)mac->net_dev;
+    u32 status = (u32)mac->int_status;
+        
+	if (status & MAC_INT_PSC) { /* link status changed*/
+        reg = reg_control(REG_READ, MAC_GLB_PORT_STA, 0);
+		if (!netif_carrier_ok(net_dev) && (reg & (1<<24))) {
+			netif_carrier_on(net_dev);
+			netif_start_queue(net_dev);
+		} 
+        else if (netif_carrier_ok(net_dev) && !(reg & PHY_LINK)) {
+			netif_carrier_off(net_dev);
+			netif_stop_queue(net_dev);
+		}
+	}
+
+	if (status & (MAC_INT_RX_DES_ER | MAC_INT_TX_DES_ER)) {
+		if (status & MAC_INT_RX_DES_ER) {
+			mac->dev_stats.rx_fifo_errors++;
+		}
+		if (status & MAC_INT_TX_DES_ER) {
+			mac->dev_stats.tx_fifo_errors++;
+		}
+	}
+
+    //reg_control(REG_WRITE, MAC_GLB_INT_MASK, 0x00000000);
+}
+
+
+static inline void  rx_interrupt(struct l2sw_mac *mac, u32 irq_status)
+{
+	struct sk_buff    *skb, *new_skb;
+	struct skb_info   *sinfo;
+	volatile struct mac_desc   *desc;
+	u32 rx_pos, pkg_len;
+	u32 cmd, protocol;
+	u32 num, rx_count;
+    s32 queue;
+
+    /* read the addr we can recive */
+
+	
+	for (queue = RX_DESC_QUEUE_NUM - 1; queue >= 0; queue--) {
+			
+		if ((MAC_INT_RX_DONE_L |irq_status) == 0) {
+			continue;
+		}
+	
+		rx_pos = mac->rx_pos[queue];
+        rx_count =  mac->rx_desc_num[queue];
+		//DEBUG0("@@@@@@@@@ethernet_interrupt rx_pos 	 = [%d]\n",rx_pos);
+		//DEBUG0("@@@@@@@@@ethernet_interrupt rx_count = [%d]\n",rx_count);
+		
+		for (num = 0; num < rx_count; num++) {
+			sinfo = mac->rx_skb_info[queue] + rx_pos;
+			desc = mac->rx_desc[queue] + rx_pos;
+			cmd = desc->cmd1;
+
+			if (cmd & OWN_BIT) {
+//				printk(KERN_EMERG "rx: own by nic, pos=%d, desc=%p", rx_pos, desc);
+				break;
+			}
+			
+			if (cmd & ERR_CODE) {                
+				if (cmd & RX_FAE_BIT) {
+                    ERROR0("[%s][%d] rx frame error\n", __FUNCTION__, __LINE__);
+					mac->dev_stats.rx_frame_errors++;
+				}
+				
+				if (cmd & RX_CRC_BIT) {
+                    ERROR0("[%s][%d] rx crc error\n", __FUNCTION__, __LINE__);
+					mac->dev_stats.rx_crc_errors++;
+				}
+				#if 0
+                if (cmd & RX_PLE_BIT) {
+                    ERROR0("[%s][%d] rx packet length error\n", __FUNCTION__, __LINE__);
+                }
+                if (cmd & IPCE) {
+                    ERROR0("[%s][%d] rx ipv4 header checksum error\n", __FUNCTION__, __LINE__);
+                }
+                if (cmd & L4CE) {
+                    ERROR0("[%s][%d] rx layer 4 header checksum error\n", __FUNCTION__, __LINE__);
+                }
+				if (cmd & (RX_RWT_BIT )) {
+					ERROR0("[%s][%d] rx length error\n", __FUNCTION__, __LINE__);
+					mac->dev_stats.rx_length_errors++;
+				}
+				#endif
+				mac->dev_stats.rx_dropped++;
+
+				goto NEXT;
+			}
+
+			if (cmd & RX_TU_BIT) {
+				goto NEXT;
+			}
+			
+			#if 0 
+			if (cmd & PPPA) {
+				mac->dev_stats.collisions++;
+			}
+			#endif
+			
+			pkg_len = cmd & LEN_MASK;
+
+			if (pkg_len < 64) {
+				goto NEXT;
+			}
+			
+			new_skb = __dev_alloc_skb(mac->rx_desc_buff_size + RX_OFFSET, GFP_ATOMIC | GFP_DMA); /* allocate an skbuff for receiving, and it's an inline func*/
+			if (new_skb == NULL) {
+				mac->dev_stats.rx_dropped++;
+				goto NEXT;
+			}
+
+			mac->dev_stats.rx_packets++;
+			mac->dev_stats.rx_bytes += pkg_len;
+
+			dma_unmap_single(&mac->pdev->dev, sinfo->mapping, mac->rx_desc_buff_size, DMA_FROM_DEVICE);
+
+			skb = sinfo->skb;
+			protocol = cmd & ((PDI_MASK) >> 16);
+			skb->ip_summed = CHECKSUM_NONE;
+
+			__skb_put(skb, (pkg_len - 4 > mac->rx_desc_buff_size) ? mac->rx_desc_buff_size : pkg_len - 4); /*skb_put will judge id tail exceed end, but __skb_put won't*/
+			skb->protocol = eth_type_trans(skb, mac->net_dev);
+			new_skb->dev = mac->net_dev;
+
+			sinfo->mapping = dma_map_single(&mac->pdev->dev, new_skb->data, mac->rx_desc_buff_size, DMA_FROM_DEVICE);
+			sinfo->skb = new_skb;
+			#if 0// dump rx data
+			DEBUG0("@@@@@@@@@ethernet_interrupt RX DUMP pkg_len = [%d]\n",pkg_len);
+			u8 * pdata = skb->data;
+			int i; 
+			for(i = 0; i < pkg_len; i++)
+			{
+				DEBUG0("i = %d data[%d]\n", i,*(pdata+i) );
+			}
+			
+			#endif 
+			rx_skb(mac, skb, desc);
+			desc->addr1 = sinfo->mapping;
+NEXT:
+			desc->cmd2 = (rx_pos==mac->rx_desc_num[queue]-1)?EOR_BIT|MAC_RX_LEN_MAX:MAC_RX_LEN_MAX;
+			desc->cmd1 = (OWN_BIT | ( mac->rx_desc_buff_size & LEN_MASK));
+
+			NEXT_RX(queue, rx_pos);
+		}
+
+        /* notify gmac how many desc(rx_count) we can use again */
+        //  rx_finished(queue, rx_count);
+
+		mac->rx_pos[queue] = rx_pos;
+	}
+}
+
+
+
+
+static void rx_do_tasklet(unsigned long data) 
+{
+	struct l2sw_mac *mac = (struct l2sw_mac *) data;
+
+	rx_interrupt(mac, mac->int_status);
+    //reg_control(REG_WRITE, MAC_GLB_INT_STATUS, (MAC_INT_RX) & mac->int_status);
+    interrupt_finish(mac);
+}
+
+#ifdef RX_POLLING
+static int rx_poll(struct napi_struct *napi, int budget)
+{
+    int ret = 0;
+    struct l2sw_mac *mac = container_of(napi, struct l2sw_mac, napi);
+
+    rx_interrupt(mac, mac->int_status);
+    napi_complete(napi);
+    interrupt_finish(mac);
+
+    return 0;
+}
+#endif
+
+static inline void tx_interrupt(struct l2sw_mac *mac)
+{
+	u32 tx_done_pos;
+	u32 cmd, reg, tx_desc_hw_addr;
+	struct skb_info *skbinfo;
+	
+    
+	tx_done_pos = mac->tx_done_pos;
+	//DEBUG0("@@@@@@@@@tx_interrupt tx_done_pos = [%d]\n",tx_done_pos);
+    while (tx_done_pos != mac->tx_pos || (mac->tx_desc_full == 1)) {
+		cmd = mac->tx_desc[tx_done_pos ].cmd1;
+		//DEBUG0("@@@@@@@@@tx_interrupt1 tx_done_pos = [%d]\n",tx_done_pos);
+		skbinfo = &mac->tx_temp_skb_info[tx_done_pos];
+    	if (skbinfo->skb == NULL) {
+			ERROR0("[%s][%d] skb is null\n", __FUNCTION__, __LINE__);
+		}
+
+		if (cmd & (ERR_CODE)) {
+			mac->dev_stats.tx_errors++;
+            /*
+			if (status & OWC_BIT) {
+				mac->dev_stats.tx_window_errors++;
+			}*/
+			ERROR0("[%s][%d] tx  error [%x]\n", __FUNCTION__, __LINE__,cmd);
+			#if 0
+			if (cmd & BUR_BIT) {
+                ERROR0("[%s][%d] tx aborted error\n", __FUNCTION__, __LINE__);
+				mac->dev_stats.tx_aborted_errors++;
+			}
+			if (cmd & LNKF_BIT) {
+                ERROR0("[%s][%d] tx link failure\n", __FUNCTION__, __LINE__);
+				mac->dev_stats.tx_carrier_errors++;
+			}
+    		if (cmd & TWDE_BIT){
+                ERROR0("[%s][%d] tx watch dog timer expired\n", __FUNCTION__, __LINE__);
+    		}
+    		if (cmd & TBE_MASK){
+                ERROR0("[%s][%d] tx descriptor bit error\n", __FUNCTION__, __LINE__);
+    		}
+			#endif
+		} 
+		else {
+		
+			mac->dev_stats.collisions
+			        += (cmd & CC_MASK) >> 16;
+			mac->dev_stats.tx_packets++;
+			mac->dev_stats.tx_bytes += skbinfo->len;
+		}
+        
+        dma_unmap_single(&mac->pdev->dev, skbinfo->mapping, skbinfo->len, DMA_TO_DEVICE);
+        skbinfo->mapping = 0;
+        dev_kfree_skb_irq(skbinfo->skb); //dev_kfree_skb
+		skbinfo->skb = NULL;
+
+		NEXT_TX(tx_done_pos);
+		if (mac->tx_desc_full == 1) {
+			mac->tx_desc_full = 0;
+		}
+	}
+
+	mac->tx_done_pos = tx_done_pos;
+	if ((TX_DESC_AVAIL(mac) > 0) && netif_queue_stopped(mac->net_dev)) {
+		netif_wake_queue(mac->net_dev);
+	}
+
+}
+
+static void tx_do_tasklet(unsigned long data) 
+{
+	struct l2sw_mac *mac = (struct l2sw_mac *) data;
+
+	tx_interrupt(mac);
+    reg_control(REG_WRITE, MAC_GLB_INT_STATUS, (MAC_INT_TX) & mac->int_status);
+    wmb();
+    interrupt_finish(mac);
+}
+
+void rx_mib_counter(void)
+{
+    rx_mib_counter_print();
+}
+
+void tx_mib_counter(void)
+{
+    tx_mib_counter_print();
+}
+
+static irqreturn_t ethernet_interrupt(int irq, void *dev_id)
+{
+	struct net_device *net_dev;
+	struct l2sw_mac *mac;
+	u32 status;
+	//DEBUG0("@@@@@@@@@ethernet_interrupt \n");
+	net_dev = (struct net_device*)dev_id;
+	if (unlikely(net_dev == NULL)) {
+        ERROR0("[%s][%d] sphe: isr net_dev is NULL!\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+
+	mac = (struct l2sw_mac*)netdev_priv(net_dev);
+	spin_lock(&(mac->lock));
+    /*
+	if (unlikely(!netif_running(net_dev))) {
+		spin_unlock(&mac->lock);
+        ERROR0("[%s][%d] %s interrupt when network device unruning\n", __FUNCTION__, __LINE__, net_dev->name);
+		return -1;
+	}
+        */
+    reg_control(REG_WRITE, MAC_GLB_INT_MASK, 0xffffffff); /* mask interrupt */
+    status =  reg_control(REG_READ, MAC_GLB_INT_STATUS, 0);
+	//DEBUG0("@@@@@@@@@ethernet_interrupt status = [%x]\n",status);
+    rmb();
+    if (status == 0){
+        reg_control(REG_WRITE, MAC_GLB_INT_MASK, 0x00000000);
+        ERROR0("[%s][%d] interrput status is null\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+    reg_control(REG_WRITE, MAC_GLB_INT_STATUS, status);
+    wmb();
+    mac->int_status = status;
+
+#ifndef RX_POLLING
+	if (status & MAC_INT_RX) {
+       // DEBUG0("@@@@@@@@@ethernet_interrupt RX!!!!!!!!!!!!!!!!!!!!! = [%x]\n",status);
+		if ( MAC_INT_RX0_LAN_FULL & status ) {
+            ERROR0("[%s][%d] MAC_INT_RX0_LAN_FULL status = [%x]\n", __FUNCTION__, __LINE__,status);
+		}
+
+		if ( MAC_INT_RX_DES_ER & status ) {
+            ERROR0("[%s][%d] MAC_INT_RX_DES_ER status = [%x]\n", __FUNCTION__, __LINE__, status);
+		}
+	        
+#ifndef INTERRUPT_IMMEDIATELY	   
+	    tasklet_schedule(&mac->rx_tasklet);
+#else /* INTERRUPT_IMMEDIATELY */     
+
+		rx_interrupt(mac, status);
+        //reg_control(REG_WRITE, MAC_GLB_INT_STATUS, (MAC_INT_RX) & mac->int_status);
+        interrupt_finish(mac);
+#endif /* INTERRUPT_IMMEDIATELY */
+        
+	}
+#else /* RX_POLLING */
+    if (napi_schedule_prep(&mac->napi)) {
+        __napi_schedule(&mac->napi);
+    }
+#endif /* RX_POLLING */
+
+	if (status & MAC_INT_TX) {
+		//DEBUG0("[%s][%d] MAC_INT_TX status = [%x]\n", __FUNCTION__, __LINE__, status);
+        if (MAC_INT_TX_DES_ER & status) {
+            ERROR0("[%s][%d] Send Descriptor Error\n", __FUNCTION__, __LINE__);
+            mac_soft_reset(mac);
+			goto OUT;
+		}
+		if ( MAC_INT_TX_H_DESCF & status) {
+			ERROR0("[%s][%d] Transmit FIFO Underrun\n", __FUNCTION__, __LINE__);
+		}
+		if (MAC_INT_TX_L_DESCF & status) {
+			ERROR0("[%s][%d] Warning: Transmit Abort\n", __FUNCTION__, __LINE__);
+		}
+        
+#ifndef INTERRUPT_IMMEDIATELY
+        tasklet_schedule(&mac->tx_tasklet);
+#else
+		tx_interrupt(mac);
+        reg_control(REG_WRITE, MAC_GLB_INT_STATUS, (MAC_INT_TX) & mac->int_status);
+        wmb();
+        interrupt_finish(mac);
+#endif
+	}
+
+OUT:
+    reg_control(REG_WRITE, MAC_GLB_INT_MASK, 0x00000000);
+	spin_unlock(&(mac->lock));
+	return IRQ_HANDLED;
+}
+
+static int ethernet_open(struct net_device *net_dev)
+{
+    struct l2sw_mac *mac;
+	u32 rc, i, reg;
+	
+	DEBUG0("@@@@@@@@@ethernet_open \n");
+#ifndef INTERRUPT_IMMEDIATELY
+    //tasklet_enable(&mac->rx_tasklet);
+    //tasklet_enable(&mac->tx_tasklet);
+#endif
+
+	mac = (struct l2sw_mac*)netdev_priv(net_dev);
+
+#ifdef RX_POLLING
+    napi_enable(&mac->napi);
+#endif
+
+	mac->rx_desc_num[0] = RX_QUEUE0_DESC_NUM;
+#if RX_DESC_QUEUE_NUM > 1
+	mac->rx_desc_num[1] = RX_QUEUE1_DESC_NUM;
+#endif
+
+	for (i = 0; i < RX_DESC_QUEUE_NUM; i++) {
+		mac->rx_desc[i] = NULL;
+		mac->rx_skb_info[i] = NULL;
+		mac->rx_pos[i] = 0;
+	}
+
+	mac->rx_desc_buff_size = MAC_RX_LEN_MAX;
+	mac->tx_done_pos = 0;
+	mac->tx_desc = NULL;
+	mac->tx_pos = 0;
+	mac->tx_desc_full = 0;
+	for (i = 0; i < TX_DESC_NUM; i++) {
+		mac->tx_temp_skb_info[i].skb = NULL;
+	}
+
+	rc = descs_alloc(mac);
+	if (rc) {
+        ERROR0("[%s][%d] ethernet driver alloc mac descriptors fialed...\n", __FUNCTION__, __LINE__);
+		return rc;
+	}
+
+	rc = descs_init(mac);
+	if (rc) {
+        ERROR0("[%s][%d] ethernet driver init mac descriptors fialed...\n", __FUNCTION__, __LINE__);
+		goto INIT_DESC_FAIL;
+	}
+
+	mac_hw_stop(mac);
+
+	/*register interrupt function to system*/
+	//DEBUG0("@@@@@@@@@request_irq net_dev->irq= [%d] \n", net_dev->irq);
+	//DEBUG0("@@@@@@@@@request_irq net_dev->name= [%s] \n", net_dev->name);
+	rc = request_irq(net_dev->irq, ethernet_interrupt, IRQF_TRIGGER_HIGH, net_dev->name, net_dev);
+	if (rc != 0) {
+        ERROR0("[%s][%d] ethernet driver request irq %d fialed...rc [%d]\n", __FUNCTION__, __LINE__, net_dev->irq, rc);
+		goto REQUEST_IRQ_FAIL;
+	}
+	DEBUG1();
+	mac->tx_desc_full = 0;
+
+	/*  Start phy  */
+	//netif_carrier_off(net_dev);
+	//mac_phy_start(net_dev);
+
+	/*start hardware port,open interrupt, start system tx queue*/
+	mac_init(mac);
+	DEBUG1();
+	//phy_cfg();
+	mac_hw_start(mac);
+	DEBUG1();
+
+#if 0
+    /* wait phy link*/
+	while(1){
+        reg = reg_control(REG_READ, MAC_GLB_PORT_STA, 0);
+		if (reg & PHY_LINK){
+            DEBUG0("[%s][%d] phy link ok, reg = 0x%x\n", __FUNCTION__, __LINE__, reg);	
+			break;
+		}
+		else{
+			udelay(1000);
+            DEBUG0("[%s][%d] phy link failed, reg = 0x%x\n", __FUNCTION__, __LINE__, reg);	
+		}
+	}
+#else
+   // reg = mdio_read(MAC_PHY_ADDR, 1);
+   // while((reg & (1 << 5)) == 0x0){
+   //     reg = mdio_read(MAC_PHY_ADDR, 1);
+   // }
+#endif
+
+	DEBUG1();
+
+
+	if (netif_carrier_ok(net_dev)) {
+		netif_start_queue(net_dev);
+	}
+
+	return 0;
+
+REQUEST_IRQ_FAIL:
+INIT_DESC_FAIL:
+	descs_free(mac);
+	return rc;
+}
+
+static int ethernet_stop(struct net_device *net_dev)
+{
+	struct l2sw_mac *mac;
+	unsigned long flags;
+
+	mac = (struct l2sw_mac*)netdev_priv(net_dev);
+
+	spin_lock_irqsave(&mac->lock, flags);
+	netif_stop_queue(net_dev);
+	netif_carrier_off(net_dev);
+    
+#ifdef RX_POLLING
+        napi_disable(&mac->napi);
+#endif
+
+	spin_unlock_irqrestore(&mac->lock, flags);
+
+	mac_phy_stop(net_dev);
+	mac_hw_stop(mac);
+
+	synchronize_irq(net_dev->irq);
+	free_irq(net_dev->irq, net_dev);
+	descs_free(mac);
+	return 0;
+
+}
+
+/* Transmit a packet (called by the kernel) */
+static int ethernet_start_xmit(struct sk_buff *skb, struct net_device *net_dev)
+{
+    struct l2sw_mac *mac;
+    u32 tx_pos;
+    u32 cmd1;
+	u32 cmd2;
+	u32 force_dp=0x1;
+	u32	to_vlan=0x1;
+    volatile struct mac_desc *txdesc;
+
+    cmd1 = 0;
+	cmd2 = 0;
+    mac = (struct l2sw_mac*)netdev_priv(net_dev);
+
+    spin_lock_irq(&mac->lock); //or use spin_lock_irqsave ?
+    if (mac->tx_desc_full == 1) { /* no desc left, wait for tx interrupt*/
+        spin_unlock_irq(&mac->lock);
+		DEBUG0("@@@@@@@@@l2sw ethernet_start_xmit fail \n");
+        return -1;
+    }
+
+    tx_pos = mac->tx_pos;
+	//DEBUG0("@@@@@@@@@l2sw ethernet_start_xmit skb->len = [%d] \n",skb->len);
+    /* if skb size shorter than 60, fill it with '\0' */
+    if (skb->len < ETH_ZLEN) {
+        if (skb_tailroom(skb) >= (ETH_ZLEN - skb->len)) {
+            memset(__skb_put(skb, ETH_ZLEN - skb->len), '\0', ETH_ZLEN - skb->len);
+        } else {
+            struct sk_buff *old_skb = skb;
+            skb = dev_alloc_skb(ETH_ZLEN + TX_OFFSET);
+            if (skb) {
+                memset(skb->data + old_skb->len, '\0', ETH_ZLEN - old_skb->len);
+                memcpy(skb->data, old_skb->data, old_skb->len);
+                skb_put(skb, ETH_ZLEN); /* add data to an sk_buff */
+                dev_kfree_skb_irq(old_skb);
+            } else {
+                skb = old_skb;
+            }
+        }
+    }
+
+    txdesc = &mac->tx_desc[tx_pos];
+    mac->tx_temp_skb_info[tx_pos].len = skb->len;
+    mac->tx_temp_skb_info[tx_pos].skb = skb;
+	mac->tx_temp_skb_info[tx_pos].mapping = dma_map_single(&mac->pdev->dev, skb->data, skb->len, DMA_TO_DEVICE);	
+    //cmd1 = FS_BIT | LS_BIT | (skb->len & LEN_MASK);
+	cmd1 = (OWN_BIT | FS_BIT | LS_BIT | (force_dp<<18) | (to_vlan<<12)| (skb->len& LEN_MASK));
+	cmd2 = (mac->tx_pos+1==TX_DESC_NUM)?EOR_BIT|(skb->len&LEN_MASK):(skb->len&LEN_MASK);
+
+    txdesc->addr1 = mac->tx_temp_skb_info[tx_pos].mapping;
+    txdesc->cmd1 = cmd1;
+	txdesc->cmd2 = cmd2;
+
+    wmb();
+    NEXT_TX(tx_pos);
+    mac->tx_pos = tx_pos;
+    
+    if (mac->tx_pos == mac->tx_done_pos) {
+		netif_stop_queue(net_dev);
+		mac->tx_desc_full = 1;
+	}
+
+    /* trigger gmac to transmit*/
+    tx_trigger(tx_pos);
+    wmb();
+    
+    spin_unlock_irq(&mac->lock);
+
+    return 0;
+}
+
+static void ethernet_set_rx_mode(struct net_device *dev)
+{
+	struct l2sw_mac *mac;
+	DEBUG0("@@@@@@@@@l2sw ethernet_set_rx_mode \n");
+	mac = (struct l2sw_mac*)netdev_priv(dev);
+	rx_mode_set(mac);
+}
+
+static int ethernet_set_mac_address(struct net_device *ndev, void *addr)
+{
+	struct sockaddr *hwaddr = (struct sockaddr *)addr;
+	struct l2sw_mac *mac = netdev_priv(ndev);
+
+	if (netif_running(ndev)) {
+		return -EBUSY;
+	}
+
+	memcpy(ndev->dev_addr, hwaddr->sa_data, ndev->addr_len);
+
+	/* set the Ethernet address */
+	memcpy(mac->mac_addr, hwaddr->sa_data, ndev->addr_len);
+	mac_hw_addr_set(mac);
+
+	return 0;
+}
+
+static int ethernet_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+    struct l2sw_mac *mac = netdev_priv(dev);
+    struct phy_device *phydev = mac->phy_dev;
+
+	DEBUG0("@@@@@@@@@l2sw ethernet_do_ioctl \n");
+    if (!netif_running(dev))
+        return -EINVAL;
+
+    if (!phydev)
+        return -ENODEV;
+
+    switch (cmd) {
+    case SIOCGMIIPHY:
+    case SIOCGMIIREG:
+    case SIOCSMIIREG:
+        return phy_mii_ioctl(phydev, ifr, cmd);
+
+    default:
+        printk(KERN_INFO "GEM: ioctl %d not implemented.\n", cmd);
+        return -EOPNOTSUPP;
+    }
+
+}
+
+static int ethernet_change_mtu(struct net_device *dev, int new_mtu)
+{
+    return eth_change_mtu(dev, new_mtu);
+}
+
+static void ethernet_tx_timeout(struct net_device *net_dev)
+{
+
+}
+
+static struct net_device_stats *ethernet_get_stats(struct net_device *net_dev)
+{
+	struct l2sw_mac *mac;
+	DEBUG0("@@@@@@@@@l2sw ethernet_get_stats \n");
+	mac = (struct l2sw_mac*)netdev_priv(net_dev);
+	return &mac->dev_stats;
+}
+
+
+static struct net_device_ops netdev_ops = {
+	.ndo_open		= ethernet_open,
+	.ndo_stop		= ethernet_stop,
+	.ndo_start_xmit		= ethernet_start_xmit,
+	.ndo_set_rx_mode = ethernet_set_rx_mode,
+	.ndo_set_mac_address    = ethernet_set_mac_address,
+	.ndo_do_ioctl		= ethernet_do_ioctl,
+	.ndo_change_mtu		= ethernet_change_mtu,
+	.ndo_tx_timeout		= ethernet_tx_timeout,
+	.ndo_get_stats		= ethernet_get_stats,
+};
+
+/*********************************************************************
+*
+* platform_driver
+*
+**********************************************************************/
+
+static u32 netdev_init(struct platform_device *pdev)
+{
+	u32 ret = -ENODEV;
+	struct l2sw_mac *mac;
+	struct net_device *net_dev;
+	struct resource *res;
+	struct resource *r_mem = NULL;
+
+	DEBUG0("l2sw netdev_init \n");
+	/* allocate the devices, and also allocate l2sw_mac, we can get it by  netdev_priv() */
+	if ((net_dev = alloc_etherdev(sizeof(struct l2sw_mac))) == NULL) {
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, net_dev);
+	printk("l2sw l2sw ndev->name =[%s]\n", net_dev->name);
+	mac = netdev_priv(net_dev);
+	mac->net_dev = net_dev;
+    mac->pdev = pdev;
+    spin_lock_init(&mac->lock);
+    /*
+        * spin_lock: return if it obtain spin lock, or it will wait (not sleep)
+        * spin_lock_irqsave: save flags, disable interrupt, obtain spin lock           
+        * spin_lock_irq:                       disable interrupt, obtain spin lock, if in a interrupt, don't need to use spin_lock_irqsave
+        */
+
+	if ((r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0)) != NULL) {
+		printk("l2sw l2sw r_mem->start =[%x]\n", r_mem->start);
+		if (l2sw_reg_base_set(ioremap(r_mem->start, (r_mem->end - r_mem->start + 1))) != 0){
+			ERROR0("[%s][%d] remap fail!\n", __FUNCTION__, __LINE__);
+			goto out_freedev;
+		}
+		
+	} else {
+		ERROR0("[%s][%d] no MEM resource!\n", __FUNCTION__, __LINE__);
+		goto out_freedev;
+	}
+	
+
+	if ((res = platform_get_resource(pdev, IORESOURCE_IRQ, 0)) != NULL) {
+		//printk("l2sw res->start =[%x]\n", res->start);
+		//printk("l2sw res->name =[%s]\n", res->name);
+		net_dev->irq = res->start;
+
+	} else {
+		ERROR0("[%s][%d] no IRQ resource!\n", __FUNCTION__, __LINE__);
+		goto out_freedev;
+	}
+
+	l2sw_pinmux_set();
+	l2sw_enable_port();
+	
+
+	phy_cfg();
+
+
+#if 1 // phy_probe??
+#ifdef PHY_CONFIG
+    mac->phy_node = of_parse_phandle(pdev->dev.of_node, "phy-handle", 0);
+#endif
+
+	if ((ret = mdio_init(pdev, net_dev))) {
+		ERROR0("[%s][%d] mdio init failed!\n", __FUNCTION__, __LINE__);
+		goto out_freedev;
+	}
+
+	
+	if ((ret = mac_phy_probe(net_dev))) {
+		ERROR0("[%s][%d] phy probe failed!\n", __FUNCTION__, __LINE__);
+		goto out_freemdio;
+	}
+#endif
+	net_dev->netdev_ops = &netdev_ops;
+    
+#ifdef RX_POLLING
+    netif_napi_add(net_dev, &mac->napi, rx_poll, RX_NAPI_WEIGHT);
+#endif
+
+    if (mac_hw_addr_update(mac) != 0) {
+        memcpy(mac->mac_addr, def_mac_addr, ETHERNET_MAC_ADDR_LEN);
+    }
+	memcpy(net_dev->dev_addr, mac->mac_addr, ETHERNET_MAC_ADDR_LEN);
+	if ((ret = register_netdev(net_dev))) {
+		ERROR0("[%s][%d] error %i registering device \"%s\"\n", __FUNCTION__, __LINE__, ret, net_dev->name);
+		goto out_freemdio;
+	}
+
+#ifndef INTERRUPT_IMMEDIATELY
+    mac->int_status = 0;
+	tasklet_init(&mac->rx_tasklet, rx_do_tasklet, (unsigned long)mac);
+	//tasklet_disable(&mac->rx_tasklet);
+	tasklet_init(&mac->tx_tasklet, tx_do_tasklet, (unsigned long)mac);
+	//tasklet_disable(&mac->tx_tasklet);
+#endif
+	
+
+	DEBUG0("l2sw netdev_init su\n");
+	return 0;
+
+out_freemdio:
+	if (mac->mii_bus != NULL) {
+		mdio_remove(mac);
+	}
+out_freedev:
+	if (net_dev != NULL) {
+		free_netdev(net_dev);
+	}
+	platform_set_drvdata(pdev, NULL);
+	return ret;
+}
+
+static int l2sw_probe(struct platform_device *pdev)
+{	
+
+	int reg;
+	
+	DEBUG0("l2sw_probe \n");
+	if (platform_get_drvdata(pdev) != NULL) {
+		return -ENODEV;
+	}
+	
+	return netdev_init(pdev);
+}
+
+static int l2sw_remove(struct platform_device *pdev)
+{
+	struct net_device *net_dev;
+	struct l2sw_mac *mac;
+
+	if ((net_dev = platform_get_drvdata(pdev)) == NULL) {
+		return 0;
+	}
+
+	mac = (struct l2sw_mac*)netdev_priv(net_dev);
+
+#ifndef INTERRUPT_IMMEDIATELY
+    tasklet_kill(&mac->rx_tasklet);
+	tasklet_kill(&mac->tx_tasklet);
+#endif
+
+	mac_phy_remove(net_dev);
+	mdio_remove(mac);
+	unregister_netdev(net_dev);
+	free_netdev(net_dev);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+
+}
+
+#ifdef CONFIG_PM
+static int l2sw_suspend(struct device *dev)
+{
+    struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev = platform_get_drvdata(pdev);
+    
+	netif_device_detach(ndev);
+    //shut down 
+    
+	return 0;
+}
+
+static int l2sw_resume(struct device *dev)
+{
+    struct platform_device *pdev = to_platform_device(dev);
+	struct net_device *ndev = platform_get_drvdata(pdev);
+
+    //reset & init
+	netif_device_attach(ndev);
+	return 0;
+}
+
+static const struct dev_pm_ops l2sw_pm_ops = {
+	.suspend	= l2sw_suspend,
+	.resume		= l2sw_resume,
+};
+#endif
+
+#ifdef PHY_CONFIG
+static const struct of_device_id sp_l2sw_of_match[] = {
+	{ .compatible = "sunplus,sp-l2sw" },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, sp_l2sw_of_match);
+#endif
+
+static struct platform_driver l2sw_driver = {
+	.probe   = l2sw_probe,
+	.remove  = l2sw_remove,
+	.driver  = {
+		.name  = "sp_l2sw",
+		.owner = THIS_MODULE,
+		.of_match_table = sp_l2sw_of_match,
+#ifdef CONFIG_PM
+		.pm = &l2sw_pm_ops, // not sure
+#endif
+	},
+};
+
+
+
+static int __init l2sw_init(void)
+{
+    u32 status;
+	DEBUG0("l2sw init \n");
+    status = platform_driver_register(&l2sw_driver);
+
+    return status;
+}
+
+static void __exit l2sw_exit(void)
+{
+	platform_driver_unregister(&l2sw_driver);
+}
+#endif
+
+module_init(l2sw_init);
+module_exit(l2sw_exit);
--- a/drivers/net/ethernet/sp/l2sw_driver.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_driver.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,22 @@
+#ifndef __L2SW_DRIVER_H__
+#define __L2SW_DRIVER_H__
+
+//#include "l2sw_inc.h"
+#include "l2sw_register.h"
+#include "l2sw_define.h"
+#include "l2sw_hal.h"
+#include "l2sw_mdio.h"
+#include "l2sw_mac.h"
+#include "l2sw_desc.h"
+
+
+//#define NEXT_RX(mac, QUEUE, N) (N = ((N)+1 == (mac->rx_desc_num[QUEUE] << 1)) ? 0 : (N)+1)
+//#define NEXT_TX(N) ((N) = ((N)+1 == (TX_DESC_NUM << 1) ? 0 : (N)+1))
+
+#define NEXT_TX(N) ((N) = ((N)+1 == TX_DESC_NUM ? 0 : (N)+1))
+#define NEXT_RX(QUEUE, N) (N = ((N)+1 == mac->rx_desc_num[QUEUE]) ? 0 : (N)+1)
+
+#define RX_NAPI_WEIGHT	64
+
+#endif
+
--- a/drivers/net/ethernet/sp/l2sw_hal.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_hal.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,537 @@
+
+#include "l2sw_hal.h"
+
+//static struct gmac_reg* gmac_reg_base = (struct gmac_reg*)GMAC_REG_BASE;
+static struct l2sw_reg* ls2w_reg_base = NULL;
+
+
+int l2sw_reg_base_set(void __iomem *baseaddr)
+{
+	printk("@@@@@@@@@l2sw l2sw_reg_base_set =[%x]\n", (int)baseaddr);
+    ls2w_reg_base = (struct l2sw_reg*)baseaddr;
+	if (ls2w_reg_base == NULL){
+		return -1;
+	}
+	else{
+		return 0;
+	}
+}
+
+int l2sw_pinmux_set()
+{
+	int reg;
+
+	GPIO_PIN_MUX_SEL(PMX_L2SW_CLK_OUT,40);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_MAC_SMI_MDC,34);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_LED_FLASH0,35);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_LED_FLASH1,23);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_LED_ON0,44);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_LED_ON1,32);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_MAC_SMI_MDIO,33);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P0_MAC_RMII_TXEN,43);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P0_MAC_RMII_TXD0,41);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P0_MAC_RMII_TXD1,42);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P0_MAC_RMII_CRSDV,37);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P0_MAC_RMII_RXD0,38);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P0_MAC_RMII_RXD1,39);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P0_MAC_RMII_RXER,36);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P1_MAC_RMII_TXEN,31);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P1_MAC_RMII_TXD0,29);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P1_MAC_RMII_TXD1,30);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P1_MAC_RMII_CRSDV,25);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P1_MAC_RMII_RXD0,26);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P1_MAC_RMII_RXD1,27);
+	GPIO_PIN_MUX_SEL(PMX_L2SW_P1_MAC_RMII_RXER,24);
+	GPIO_PIN_MUX_SEL(PMX_DAISY_MODE,1);
+
+
+}
+
+
+#if 0
+int mac_g1_base_set(void __iomem *baseaddr)
+{
+	static struct G1* g1_base = NULL;
+    g1_base = (struct G1*)baseaddr;
+	if (g1_base == NULL){
+		return -1;
+	}
+	else{
+		return 0;
+	}
+}
+#endif
+
+void mac_hw_stop(struct l2sw_mac *mac)
+{
+    u32 reg;
+    
+    ls2w_reg_base->sw_int_mask_0 = 0xffffffff;
+    ls2w_reg_base->sw_int_status_0 = 0xffffffff & (~MAC_INT_PSC);
+
+	reg = ls2w_reg_base->cpu_cntl;
+	ls2w_reg_base->cpu_cntl = DIS_PORT_TX | reg;
+
+	reg = ls2w_reg_base->port_cntl0;
+	ls2w_reg_base->port_cntl0 = DIS_PORT_RX | reg;	
+
+}
+
+void mac_hw_reset(struct l2sw_mac *mac)
+{
+	
+	#if 0
+	u32 reg;
+    wmb();
+    
+	reg = ls2w_reg_base->mac_glb_sys_cfgcmd;
+	ls2w_reg_base->mac_glb_sys_cfgcmd = reg | SOFT_RST_N;
+    
+    while((reg & SOFT_RST_N) == 0x1){
+		reg = ls2w_reg_base->mac_glb_sys_cfgcmd;
+	}
+	#endif
+}
+
+void mac_hw_start(struct l2sw_mac *mac)
+{
+	u32 reg;
+	
+#if 0 
+    /* tell gmac how many desc can use*/
+	reg = ls2w_reg_base->mac_rx_desc0_addr;
+	reg &= ~(0x1ff << 16);
+	reg |= RX_QUEUE0_DESC_NUM << 16;
+	ls2w_reg_base->mac_rx_desc0_addr = reg;
+    
+	reg = ls2w_reg_base->mac_rx_desc1_addr;
+	reg &= ~ (0x1ff << 16);
+	reg |= RX_QUEUE1_DESC_NUM << 16;
+	ls2w_reg_base->mac_rx_desc1_addr = reg;
+
+    reg = ls2w_reg_base->mac_glb_port_cfg;
+	ls2w_reg_base->mac_glb_port_cfg = (~DIS_PORT_TX) & (~DIS_PORT_RX) & reg;
+#endif
+	//HWREG_W(tx_hbase_addr_0,(UINT32)(mac->tx_desc[1]));
+	//HWREG_W(tx_lbase_addr_0,(UINT32)(mac->tx_desc[0]));
+	//HWREG_W(rx_hbase_addr_0,(UINT32)(mac->rx_desc[1]));
+	//HWREG_W(rx_lbase_addr_0,(UINT32)(mac->rx_desc[0]));
+	//phy address
+	//reg=HWREG_R(mac_force_mode);
+	//HWREG_W(mac_force_mode,(reg&(~(0x1f<<16)))|(PHY0_ADDR<<16));
+
+	HWREG_W(PVID_config0,(1<<4)+0);
+	HWREG_W(VLAN_memset_config0,(6<<8)+9);
+
+
+	//enable soc port0 crc padding
+	reg=HWREG_R(cpu_cntl);
+	HWREG_W(cpu_cntl,(reg&(~(0x1<<6)))|(0x1<<8));
+	//enable port0
+	reg=HWREG_R(port_cntl0);
+	HWREG_W(port_cntl0,reg&(~(0x1<<24)));
+	
+
+	//reg=HWREG_R(cpu_cntl);
+	//HWREG_W(cpu_cntl,reg|0x2a);
+
+	reg=HWREG_R(cpu_cntl);
+	HWREG_W(cpu_cntl,reg&(~(0x3F<<0)));
+
+	//tx_mib_counter_print();
+
+
+	ls2w_reg_base->sw_int_mask_0 = 0x00000000;
+}
+
+void mac_hw_addr_set(struct l2sw_mac *mac)
+{
+
+#if 0
+
+	u32 reg;
+
+	reg = ((u32)(mac->mac_addr[3]) << 24) | ((u32)(mac->mac_addr[2]) << 16)
+	      | ((u32)(mac->mac_addr[1]) << 8) | ((u32)(mac->mac_addr[0]));
+	ls2w_reg_base->mac_glb_macaddr0 = reg;
+
+	reg = ((u32)(mac->mac_addr[5]) << 8) | ((u32)(mac->mac_addr[4]));
+	ls2w_reg_base->mac_glb_macaddr1 = reg;
+#endif
+
+	HWREG_W(w_mac_15_0_bus,mac->mac_addr[0]+(mac->mac_addr[1]<<8));
+	HWREG_W(w_mac_47_16,mac->mac_addr[2]+(mac->mac_addr[3]<<8)+(mac->mac_addr[4]<<16)+(mac->mac_addr[5]<<24));
+}
+
+void mac_hw_init(struct l2sw_mac *mac)
+{
+	u32 reg;
+	u8 port_map=0x0;
+	u8 cpu_port=mac->cpu_port;
+	u8 age=0x0;
+	u8 proxy=0x0;
+	u8 mc_ingress=0x0;
+
+
+
+
+    /* descriptor base address */
+
+    ls2w_reg_base->tx_hbase_addr_0 = mac->desc_dma;
+    ls2w_reg_base->rx_lbase_addr_0 = mac->desc_dma + sizeof(struct mac_desc) * (TX_DESC_NUM + MAC_GUARD_DESC_NUM);
+
+    ls2w_reg_base->rx_hbase_addr_0 = mac->desc_dma + sizeof(struct mac_desc) * (TX_DESC_NUM + MAC_GUARD_DESC_NUM + RX_QUEUE0_DESC_NUM);
+    
+    /* TX Configuration Register */
+
+	reg=HWREG_R(mac_force_mode);
+	HWREG_W(mac_force_mode,(reg&(~(0x1f<<16)))|(PHY0_ADDR<<16));
+	reg=HWREG_R(mac_force_mode);
+	HWREG_W(mac_force_mode,(reg&(~(0x1f<<24)))|(PHY1_ADDR<<24));
+	//enable soc port0 crc padding
+	reg=HWREG_R(cpu_cntl);
+	HWREG_W(cpu_cntl,(reg&(~(0x1<<6)))|(0x1<<8));
+	//enable port0
+	reg=HWREG_R(port_cntl0);
+	HWREG_W(port_cntl0,reg&(~(0x3<<24)));
+
+	//MAC address initial
+	//soc port MAC address config
+
+	mac_hw_addr_set(mac);
+	HWREG_W(wt_mac_ad0,(port_map<<12)+(cpu_port<<10)+(mac->vlan_id<<7)+(age<<4)+(proxy<<3)+(mc_ingress<<2)+0x1);
+	reg=HWREG_R(wt_mac_ad0);
+	while((reg&(0x1<<1))==0x0) {
+		printk("wt_mac_ad0 = [%x]\n", reg);
+		reg=HWREG_R(wt_mac_ad0);
+	}
+
+
+
+}
+
+u32 mac_hw_addr_update(struct l2sw_mac *mac)
+{
+	u32 regl, regh;
+	u8  addr[6];
+
+	regl = ls2w_reg_base->MAC_ad_ser0;
+	regh = ls2w_reg_base->MAC_ad_ser1;
+	addr[0] = regl & 0xFF;
+	addr[1] = (regl >> 8) & 0xFF;
+	addr[2] = regh & 0xFF;
+	addr[3] = (regh >> 8) & 0xFF;
+	addr[4] = (regh >> 16) & 0xFF;
+	addr[5] = (regh >> 24) & 0xFF;
+
+	if (is_valid_ether_addr(addr)) {
+		memcpy(mac->mac_addr, addr, sizeof(addr));
+        return 0;
+	} 
+    
+    return -1;
+}
+
+void rx_mode_set(struct l2sw_mac *mac)
+{
+	struct net_device *netdev;
+    
+	netdev = mac->net_dev;
+	if (netdev == NULL) {
+		return;
+	}
+}
+
+u32 mdio_read(u32 phy_id, u16 regnum)
+{
+    u32 val, time;
+	DEBUG1();
+
+    ls2w_reg_base->phy_cntl_reg0 = ((regnum << 8) & PHY_REG_MASK) | PHY_RD_CMD | PHY_CMD_TRI | (phy_id & PHY_ADR_MASK) | (0 << 15);
+    //gmac_reg_base->mac_glb_phy_cmd = ((regnum << 8) & PHY_REG_MASK) | PHY_RD_CMD | PHY_CMD_TRI | MAC_PHY_ADDR | (0 << 15);
+    DEBUG1();
+    time = MDIO_RW_TIMEOUT_RETRY_NUMBERS;
+    do {
+        val = ls2w_reg_base->phy_cntl_reg1;
+        if (val & PHY_RD_RDY) {
+            return val >> 16;
+        }
+    } while (--time);
+	DEBUG1();
+
+    return (val >> 16);
+}
+
+u32 mdio_write(u32 phy_id, u32 regnum, u16 val)
+{
+        u32 time, regval;
+
+        ls2w_reg_base->phy_cntl_reg0 = ((val << 16) & PHY_WT_DATA_MASK) | PHY_WT_CMD | ((regnum << 8) & PHY_REG_MASK) | PHY_CMD_TRI | (phy_id & PHY_ADR_MASK) | (0 << 15);
+        //gmac_reg_base->mac_glb_phy_cmd = ((val << 16) & PHY_WT_DATA_MASK) | PHY_WT_CMD | ((regnum << 8) & PHY_REG_MASK) | PHY_CMD_TRI | MAC_PHY_ADDR | (0 << 15);
+    
+        time = MDIO_RW_TIMEOUT_RETRY_NUMBERS;
+        do {
+            regval = ls2w_reg_base->phy_cntl_reg1;
+            if (regval & PHY_WT_DONE) {
+                return 0;
+            }
+        } while (--time);
+
+        return -EIO;
+}
+
+inline void rx_finished(u32 queue, u32 rx_count)
+{
+
+#if 0
+    u32 reg, rx_desc_sw_addr[RX_DESC_QUEUE_NUM], rx_desc_sw_addr_next;
+    
+	if(queue) {
+		reg = ls2w_reg_base->rx_hbase_addr_0;
+		rx_desc_sw_addr[1] = (reg >> 16) & 0x1ff;
+		reg &= ~(0x1ff<<16);
+		rx_desc_sw_addr_next = ((rx_desc_sw_addr[1] + rx_count));
+		reg |=  rx_desc_sw_addr_next << 16;
+		ls2w_reg_base->rx_hbase_addr_0 = reg;
+	}
+	else {
+		reg = ls2w_reg_base->rx_lbase_addr_0;
+		rx_desc_sw_addr[0] = (reg >> 16) & 0x1ff;
+		reg &= ~(0x1ff<<16);
+		rx_desc_sw_addr_next = ((rx_desc_sw_addr[0] + rx_count));
+		reg |= rx_desc_sw_addr_next << 16;
+		ls2w_reg_base->rx_lbase_addr_0 = reg;
+	}
+#endif
+}
+
+inline void tx_trigger(u32 tx_pos)
+{
+    u32 reg;
+    
+    reg = ls2w_reg_base->tx_lbase_addr_0;
+    reg &= ~(0xff << 16);
+    reg |= tx_pos << 16;
+    ls2w_reg_base->tx_lbase_addr_0 = reg;
+
+	HWREG_W(cpu_tx_trig,(0x1<<0));
+}
+
+/*read or write a single register */
+inline u32 reg_control(u8 mode, u32 reg, u32 value)
+{
+  
+    if (mode == REG_WRITE) {
+
+        switch (reg) {
+        case MAC_GLB_INT_MASK:
+            ls2w_reg_base->sw_int_mask_0 = value;
+            break;
+            
+        case MAC_GLB_INT_STATUS:
+            ls2w_reg_base->sw_int_status_0 = value;
+            break;
+
+        case MAC_GLB_PHY_ADDR:
+    		ls2w_reg_base->mac_force_mode = value;
+            break;
+                        
+        default:
+            break;
+        }
+
+        return 0;
+    }
+    else if (mode == REG_READ) {
+        
+        switch (reg) {
+        case MAC_GLB_PORT_STA:
+            reg = ls2w_reg_base->port_ability;
+            break;
+
+        case MAC_RX_DESC0_ADDR:
+            reg = (ls2w_reg_base->rx_lbase_addr_0) & 0x1ff;
+            break;
+
+        case MAC_RX_DESC1_ADDR:
+            reg = (ls2w_reg_base->rx_hbase_addr_0) & 0x1ff;
+            break;
+
+        case MAC_TX_DESC_ADDR:
+            reg = ls2w_reg_base->tx_hbase_addr_0;
+            break;
+
+        case MAC_GLB_INT_STATUS:
+            reg = ls2w_reg_base->sw_int_status_0;
+            break;
+
+        case MAC_GLB_PHY_ADDR:
+            reg = ls2w_reg_base->mac_force_mode;
+            break;
+            
+        default:
+            break;
+        }
+        
+        return reg;
+    }
+}
+
+void rx_mib_counter_print()
+{
+	DEBUG0("rx_mib_counter_dump\n");
+#if 0
+    DEBUG0("mib rx desc got = %d\r\ndesc put = %d\r\n",((ls2w_reg_base->mac_mib_rx_totaldes_cnt)&0xffff), ((ls2w_reg_base->mac_mib_rx_totaldes_cnt)>>16)&0xffff);
+    DEBUG0("mac_mib_rx_pause       = %d \r\n",ls2w_reg_base->mac_mib_rx_pause);       
+    DEBUG0("mac_mib_rx_fcserr      = %d \r\n",ls2w_reg_base->mac_mib_rx_fcserr);      
+    DEBUG0("mac_mib_rx_alignerr    = %d \r\n",ls2w_reg_base->mac_mib_rx_alignerr);       // 18
+    DEBUG0("mac_mib_rx_frag        = %d \r\n",ls2w_reg_base->mac_mib_rx_frag);       // 19
+    DEBUG0("mac_mib_rx_runt        = %d \r\n",ls2w_reg_base->mac_mib_rx_runt);       // 20
+    DEBUG0("mac_mib_rx_long        = %d \r\n",ls2w_reg_base->mac_mib_rx_long);       // 21
+    DEBUG0("mib rx drop = %d\r\nmib rx desc under run = %d\r\n",(ls2w_reg_base->mac_mib_rx_desc_udr>>16)&0xffff,(ls2w_reg_base->mac_mib_rx_desc_udr)&0xffff);
+    DEBUG0("mac_mib_rx_abort    = %d \r\n",ls2w_reg_base->mac_mib_rx_fifo_ovf);       // 23
+    DEBUG0("mac_mib_rx_totalpkt    = %d \r\n",ls2w_reg_base->mac_mib_rx_totalpkt);       // 24
+    DEBUG0("mac_mib_rx_totalpkt\%ffff    = %d \r\n",ls2w_reg_base->mac_mib_rx_totalpkt&0xffff);       // 24
+    DEBUG0("mac_mib_rx_jambo       = %d \r\n",ls2w_reg_base->mac_mib_rx_jambo);       // 25
+    DEBUG0("mac_mib_rx_burst_too   = %d \r\n",ls2w_reg_base->mac_mib_rx_burst_too_long);      // 26
+    DEBUG0("Receive packet number after pause %d\r\n",ls2w_reg_base->mac_rxnum_after_pause); 
+#endif
+}
+
+void tx_mib_counter_print()
+{
+	DEBUG0("@@@@@@ls2w_reg_base_dump\n");
+#if 1
+    DEBUG0("sw_int_status_0     = %x\r\n",ls2w_reg_base->sw_int_status_0);
+	DEBUG0("sw_int_mask_0       = %x\r\n",ls2w_reg_base->sw_int_mask_0);
+	DEBUG0("fl_cntl_th          = %x\r\n",ls2w_reg_base->fl_cntl_th);
+	DEBUG0("cpu_fl_cntl_th      = %x\r\n",ls2w_reg_base->cpu_fl_cntl_th);
+	DEBUG0("pri_fl_cntl         = %x\r\n",ls2w_reg_base->pri_fl_cntl);
+    DEBUG0("vlan_pri_th         = %x\r\n",ls2w_reg_base->vlan_pri_th);
+	DEBUG0("En_tos_bus          = %x\r\n",ls2w_reg_base->En_tos_bus);
+	DEBUG0("Tos_map0            = %x\r\n",ls2w_reg_base->Tos_map0);
+	DEBUG0("Tos_map1            = %x\r\n",ls2w_reg_base->Tos_map1);
+	DEBUG0("Tos_map2            = %x\r\n",ls2w_reg_base->Tos_map2);
+	DEBUG0("Tos_map3            = %x\r\n",ls2w_reg_base->Tos_map3);
+	DEBUG0("Tos_map4            = %x\r\n",ls2w_reg_base->Tos_map4);
+	DEBUG0("Tos_map5            = %x\r\n",ls2w_reg_base->Tos_map5);
+	DEBUG0("Tos_map6            = %x\r\n",ls2w_reg_base->Tos_map6);
+	DEBUG0("Tos_map7            = %x\r\n",ls2w_reg_base->Tos_map7);
+	DEBUG0("global_que_status   = %x\r\n",ls2w_reg_base->global_que_status);
+	DEBUG0("addr_tbl_srch       = %x\r\n",ls2w_reg_base->addr_tbl_srch);
+	DEBUG0("addr_tbl_st         = %x\r\n",ls2w_reg_base->addr_tbl_st);
+	DEBUG0("MAC_ad_ser0         = %x\r\n",ls2w_reg_base->MAC_ad_ser0);
+	DEBUG0("MAC_ad_ser1         = %x\r\n",ls2w_reg_base->MAC_ad_ser1);
+    DEBUG0("wt_mac_ad0          = %x\r\n",ls2w_reg_base->wt_mac_ad0);
+	DEBUG0("w_mac_15_0_bus      = %x\r\n",ls2w_reg_base->w_mac_15_0_bus);
+	DEBUG0("w_mac_47_16         = %x\r\n",ls2w_reg_base->w_mac_47_16);
+	DEBUG0("PVID_config0        = %x\r\n",ls2w_reg_base->PVID_config0);
+	DEBUG0("PVID_config1        = %x\r\n",ls2w_reg_base->PVID_config1);
+	DEBUG0("VLAN_memset_config0 = %x\r\n",ls2w_reg_base->VLAN_memset_config0);
+	DEBUG0("VLAN_memset_config1 = %x\r\n",ls2w_reg_base->VLAN_memset_config1);
+	DEBUG0("port_ability        = %x\r\n",ls2w_reg_base->port_ability);
+	DEBUG0("port_st             = %x\r\n",ls2w_reg_base->port_st);
+	DEBUG0("cpu_cntl            = %x\r\n",ls2w_reg_base->cpu_cntl);
+	DEBUG0("port_cntl0          = %x\r\n",ls2w_reg_base->port_cntl0);
+	DEBUG0("port_cntl1          = %x\r\n",ls2w_reg_base->port_cntl1);
+	DEBUG0("port_cntl2          = %x\r\n",ls2w_reg_base->port_cntl2);
+	DEBUG0("sw_glb_cntl         = %x\r\n",ls2w_reg_base->sw_glb_cntl);
+	DEBUG0("l2sw_rsv1           = %x\r\n",ls2w_reg_base->l2sw_rsv1);
+	DEBUG0("led_port0           = %x\r\n",ls2w_reg_base->led_port0);
+	DEBUG0("led_port1           = %x\r\n",ls2w_reg_base->led_port1);
+	DEBUG0("led_port2           = %x\r\n",ls2w_reg_base->led_port2);
+	DEBUG0("led_port3           = %x\r\n",ls2w_reg_base->led_port3);
+	DEBUG0("led_port4           = %x\r\n",ls2w_reg_base->led_port4);
+	DEBUG0("watch_dog_trig_rst  = %x\r\n",ls2w_reg_base->watch_dog_trig_rst);
+	DEBUG0("watch_dog_stop_cpu  = %x\r\n",ls2w_reg_base->watch_dog_stop_cpu);
+	DEBUG0("phy_cntl_reg0       = %x\r\n",ls2w_reg_base->phy_cntl_reg0);
+	DEBUG0("phy_cntl_reg1       = %x\r\n",ls2w_reg_base->phy_cntl_reg1);
+	DEBUG0("mac_force_mode      = %x\r\n",ls2w_reg_base->mac_force_mode);
+	DEBUG0("VLAN_group_config0  = %x\r\n",ls2w_reg_base->VLAN_group_config0);
+	DEBUG0("VLAN_group_config1  = %x\r\n",ls2w_reg_base->VLAN_group_config1);
+	DEBUG0("flow_ctrl_th3       = %x\r\n",ls2w_reg_base->flow_ctrl_th3);
+	DEBUG0("queue_status_0      = %x\r\n",ls2w_reg_base->queue_status_0);
+	DEBUG0("debug_cntl          = %x\r\n",ls2w_reg_base->debug_cntl);
+	DEBUG0("queue_status_0      = %x\r\n",ls2w_reg_base->queue_status_0);
+	DEBUG0("debug_cntl          = %x\r\n",ls2w_reg_base->debug_cntl);
+	DEBUG0("l2sw_rsv2           = %x\r\n",ls2w_reg_base->l2sw_rsv2);
+	DEBUG0("mem_test_info       = %x\r\n",ls2w_reg_base->mem_test_info);
+	DEBUG0("sw_int_status_1     = %x\r\n",ls2w_reg_base->sw_int_status_1);
+	DEBUG0("sw_int_mask_1       = %x\r\n",ls2w_reg_base->sw_int_mask_1);
+	DEBUG0("cpu_tx_trig         = %x\r\n",ls2w_reg_base->cpu_tx_trig);
+	DEBUG0("tx_hbase_addr_0     = %x\r\n",ls2w_reg_base->tx_hbase_addr_0);
+	DEBUG0("tx_lbase_addr_0     = %x\r\n",ls2w_reg_base->tx_lbase_addr_0);
+	DEBUG0("rx_hbase_addr_0     = %x\r\n",ls2w_reg_base->rx_hbase_addr_0);
+	DEBUG0("rx_lbase_addr_0     = %x\r\n",ls2w_reg_base->rx_lbase_addr_0);
+	DEBUG0("tx_hw_addr_0        = %x\r\n",ls2w_reg_base->tx_hw_addr_0);
+	DEBUG0("tx_lw_addr_0        = %x\r\n",ls2w_reg_base->tx_lw_addr_0);
+	DEBUG0("rx_hw_addr_0        = %x\r\n",ls2w_reg_base->rx_hw_addr_0);
+	DEBUG0("rx_lw_addr_0        = %x\r\n",ls2w_reg_base->rx_lw_addr_0);
+	DEBUG0("cpu_port_cntl_reg_0 = %x\r\n",ls2w_reg_base->cpu_port_cntl_reg_0);
+
+
+
+
+
+#endif
+}
+
+
+
+void l2sw_enable_port()
+{
+    u32 reg;
+
+		
+	struct moon_regs * MOON5_REG = (volatile struct moon_regs *)ioremap(RF_GRP(5, 0), 32);
+	//set clock
+	reg = MOON5_REG->sft_cfg[5];
+	MOON5_REG->sft_cfg[5] = (reg|0xF<<16|0xF);
+	//enable port
+    reg=HWREG_R(port_cntl0);
+    HWREG_W(port_cntl0,reg&(~(0x3<<24)));
+
+
+	//phy address
+	reg=HWREG_R(mac_force_mode);
+	HWREG_W(mac_force_mode,(reg&(~(0x1f<<16)))|(PHY0_ADDR<<16));
+	reg=HWREG_R(mac_force_mode);
+	HWREG_W(mac_force_mode,(reg&(~(0x1f<<24)))|(PHY1_ADDR<<24));
+
+}
+
+
+
+
+int phy_cfg()
+{
+    unsigned int reg;
+	
+	#if 0 // for zy702 fpga ephy init
+	mdio_write(0x0,0x1f,0x013d);
+    mdio_write(0x0,0x10,0x3ffe);
+    mdio_write(0x0,0x1f,0x063d);
+    mdio_write(0x0,0x13,0x8000);
+
+    mdio_write(0x0,0x1f,0x023d);
+    mdio_write(0x0,0x18,0x1000);
+    mdio_write(0x0,0x1f,0x063d);
+    mdio_write(0x0,0x15,0x132c);
+
+    mdio_write(0x0,0x1f,0x013d);
+    mdio_write(0x0,0x17,0x003b);
+    mdio_write(0x0,0x1f,0x063d);
+    mdio_write(0x0,0x14,0x7088);
+
+    mdio_write(0x0,0x1f,0x033d);
+    mdio_write(0x0,0x11,0x8530);
+    mdio_write(0x0,0x1f,0x003d);
+	
+    mdio_write(0x0,0x1f,0x003d);
+    mdio_write(0x0,0x13,0x3102);
+	#endif
+	
+
+
+	return 0;
+}
--- a/drivers/net/ethernet/sp/l2sw_hal.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_hal.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,80 @@
+#ifndef __L2SW_HAL_H__
+#define __L2SW_HAL_H__
+
+#include "l2sw_register.h"
+#include "l2sw_define.h"
+#include "l2sw_desc.h"
+#include <mach/gpio_drv.h>
+
+#define GMAC_REG_BASE 0x40004b80
+
+
+#define HWREG_W(M, N) (ls2w_reg_base->M = N)
+#define HWREG_R(M) (ls2w_reg_base->M)
+
+
+/* for reg_control() */
+#define REG_WRITE 0
+#define REG_READ  1
+
+#define PHY0_ADDR		0x0
+#define PHY1_ADDR		0x1
+
+
+#define MAC_GLB_INT_STATUS 15100
+#define MAC_GLB_INT_MASK  15101
+#define MAC_GLB_PORT_STA 15106
+
+#define MAC_TX_DESC_ADDR 15207
+
+#define MAC_RX_DESC0_ADDR 15315
+#define MAC_RX_DESC1_ADDR 15316
+
+#define MAC_GLB_PHY_ADDR 15402
+
+
+#define MDIO_RW_TIMEOUT_RETRY_NUMBERS 500
+
+int l2sw_reg_base_set( void __iomem *baseaddr);
+
+int l2sw_pinmux_set(void);
+
+int mac_g1_base_set(void __iomem *baseaddr);
+
+void mac_hw_stop(struct l2sw_mac *mac);
+
+void mac_hw_reset(struct l2sw_mac *mac);
+
+void mac_hw_start(struct l2sw_mac *mac);
+
+void mac_hw_addr_set(struct l2sw_mac *mac);
+
+void mac_hw_init(struct l2sw_mac *mac);
+
+u32 mac_hw_addr_update(struct l2sw_mac *mac);
+
+void rx_mode_set(struct l2sw_mac *mac);
+
+u32 mdio_read(u32 phy_id, u16 regnum);
+
+u32 mdio_write(u32 phy_id, u32 regnum, u16 val);
+
+void rx_finished(u32 queue, u32 rx_count);
+
+void tx_trigger(u32 tx_pos);
+
+u32 reg_control(u8 mode, u32 reg, u32 value);
+
+void rx_mib_counter_print(void);
+
+void tx_mib_counter_print(void);
+
+int phy_cfg(void);
+
+void l2sw_enable_port(void);
+
+void l2sw_mac_set(void);
+
+
+#endif
+
--- a/drivers/net/ethernet/sp/l2sw_inc.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_inc.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,133 @@
+//generic define
+#ifndef NULL
+#define NULL   0
+#endif
+
+
+//ethernet parameters
+#define MAC_ADDR_BYTES   6		//MAC address is 6 bytes
+#define MAC_MAX_MTU		2048		//2k memeory space for data
+#define MAX_PKG_SIZE     1500
+
+
+//Descritpor parameters
+#define RX_DESC_QUEUE_NUM 2
+#define TX_DESC_QUEUE_NUM 2
+#define RX_DESC0_NUM 4
+#define RX_DESC1_NUM 4
+#define TX_DESC0_NUM 4
+#define TX_DESC1_NUM 4
+#define DESC_ALIGN_BYTES 8
+#define OWN_BIT		 	(1<<31)	
+#define ERR_CODE	 	(0xf<<26)	
+#define FS_BIT		 	(1<<25)	
+#define LS_BIT			(1<<24)
+#define EOR_BIT		(1<<31)	
+#define DESC_BUFF_SIZE  2047		//rx descriptor buffer size
+
+#if (RX_DESC0_NUM==16)
+	#define RXDESC0_ADDR_MSB 4
+	#define RXDESC0_ADDR_MASK 0x0f
+	#define RXDESC0_ADDR_MASK_MSB 0x1f
+#elif (RX_DESC0_NUM==32)
+	#define RXDESC0_ADDR_MSB 5
+	#define RXDESC0_ADDR_MASK 0x1f
+	#define RXDESC0_ADDR_MASK_MSB 0x3f
+#elif (RX_DESC0_NUM==64)
+	#define RXDESC0_ADDR_MSB 6
+	#define RXDESC0_ADDR_MASK 0x3f
+	#define RXDESC0_ADDR_MASK_MSB 0x7f
+#elif (RX_DESC0_NUM==128)
+	#define RXDESC0_ADDR_MSB 7
+	#define RXDESC0_ADDR_MASK 0x7f
+	#define RXDESC0_ADDR_MASK_MSB 0xff
+#elif (RX_DESC0_NUM==256)
+	#define RXDESC0_ADDR_MSB 8
+	#define RXDESC0_ADDR_MASK 0xff
+	#define RXDESC0_ADDR_MASK_MSB 0x1ff
+#endif
+
+#if (RX_DESC1_NUM==16)
+	#define RXDESC1_ADDR_MSB 4
+	#define RXDESC1_ADDR_MASK 0x0f
+	#define RXDESC1_ADDR_MASK_MSB 0x1f
+#elif (RX_DESC1_NUM==32)
+	#define RXDESC1_ADDR_MSB 5
+	#define RXDESC1_ADDR_MASK 0x1f
+	#define RXDESC1_ADDR_MASK_MSB 0x3f
+#elif (RX_DESC1_NUM==64)
+	#define RXDESC1_ADDR_MSB 6
+	#define RXDESC1_ADDR_MASK 0x3f
+	#define RXDESC1_ADDR_MASK_MSB 0x7f
+#elif (RX_DESC1_NUM==128)
+	#define RXDESC1_ADDR_MSB 7
+	#define RXDESC1_ADDR_MASK 0x7f
+	#define RXDESC1_ADDR_MASK_MSB 0xff
+#elif (RX_DESC1_NUM==256)
+	#define RXDESC1_ADDR_MSB 8
+	#define RXDESC1_ADDR_MASK 0xff
+	#define RXDESC1_ADDR_MASK_MSB 0x1ff
+#endif
+
+//Interrupt status bits
+#define MAC_INT_MC	 	(3<<30)	
+#define MAC_INT_PSC	 	(1<<19)	
+#define ETH0_LINK		(1<<24)
+#define ETH1_LINK		(1<<25)
+#define WDOG1_TMR_EXP	(1<<22)
+#define WDOG0_TMR_EXP	(1<<21)
+#define ETH0_RXL_DESC_FULL	(1<<7)
+#define ETH0_RXH_DESC_FULL	(1<<6)
+#define ETH0_RXL_DONE		(1<<5)
+#define ETH0_RXH_DONE		(1<<4)
+#define ETH1_RXL_DESC_FULL	(1<<7)
+#define ETH1_RXH_DESC_FULL	(1<<6)
+#define ETH1_RXL_DONE		(1<<5)
+#define ETH1_RXH_DONE		(1<<4)
+#define ETH0_TXL_DONE		(1<<3)
+#define ETH0_TXH_DONE		(1<<2)
+#define ETH1_TXL_DONE		(1<<3)
+#define ETH1_TXH_DONE		(1<<2)
+
+//others
+#define LEN_MASK		0x000007FF
+
+//user define function
+#define HWREG_W(M, N) (ls2w_reg_base->M = N)
+#define HWREG_R(M) (ls2w_reg_base->M)
+#define NEXT_RX(mac, QUEUE, N)  	\
+		(N = ((N)+1 == (mac)->rx_desc_num[QUEUE]) ? 0 : (N)+1)
+#define NEXT_TX(mac, QUEUE, N)		\
+		(N = ((N)+1 == (mac)->tx_desc_num[QUEUE]) ? 0 : (N)+1)
+
+//l2sw descriptors
+struct __attribute__ ((packed)) l2sw_desc{
+	volatile u32 cmd1;
+	volatile u32 cmd2;
+	volatile u32 addr1;
+	volatile u32 addr2;
+};
+
+struct l2sw_mng{
+	struct l2sw_desc *rx_desc[RX_DESC_QUEUE_NUM];
+	struct l2sw_desc *tx_desc[TX_DESC_QUEUE_NUM];
+
+	u32	rx_proc_pos[RX_DESC_QUEUE_NUM];
+	u32	rx_desc_num[RX_DESC_QUEUE_NUM];
+	u32	tx_desc_num[TX_DESC_QUEUE_NUM];
+	u32	temp_receiv_queue;
+	u32	temp_receiv_pos;
+	u32	tx_done_pos[TX_DESC_QUEUE_NUM];
+	u32	tx_pos[TX_DESC_QUEUE_NUM];
+	u32	tx_desc_full[TX_DESC_QUEUE_NUM];
+	u32	   status;
+
+	char 		*rx_desc_buff_start_addr;
+	char 		*tx_desc_buff_start_addr;
+	char   	   	mac_addr[6];
+	char		cpu_port;
+	char		vlan_id;
+	char		vlan_memset;
+	char		link_status;
+};
+
--- a/drivers/net/ethernet/sp/l2sw_mac.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_mac.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,59 @@
+#include "l2sw_mac.h"
+
+bool mac_init(struct l2sw_mac *mac)
+{
+    u32 index;
+	
+	mac->cpu_port=0x0;
+	mac->vlan_id=0x0;
+	mac->vlan_memset=0x9;
+
+    for (index = 0; index < RX_DESC_QUEUE_NUM; index++) {
+        mac->rx_pos[index] = 0;
+    }
+	DEBUG1();
+
+    //mac_hw_reset(mac);
+    mac_hw_init(mac);
+	DEBUG1();
+
+    return 1;
+}
+
+void mac_start(struct l2sw_mac *mac, u8 *enaddr, u32 flags)
+{
+
+	mac_hw_start(mac);
+}
+
+void mac_soft_reset(struct l2sw_mac *mac)
+{
+	u32 i;
+
+    if (netif_carrier_ok(mac->net_dev)){
+        netif_carrier_off(mac->net_dev);
+        netif_stop_queue(mac->net_dev);
+    }
+
+	mac_hw_reset(mac);
+	mac_hw_stop(mac);
+	//descs_clean(mac);
+    rx_descs_flush(mac);
+	mac->tx_pos = 0;
+	mac->tx_done_pos = 0;
+	mac->tx_desc_full = 0;
+
+	for (i = 0; i < RX_DESC_QUEUE_NUM; i++) {
+		mac->rx_pos[i] = 0;
+	}
+
+	mac_hw_init(mac);
+	mac_hw_start(mac);
+
+    if (!netif_carrier_ok(mac->net_dev)){
+    	netif_carrier_on(mac->net_dev);
+		netif_start_queue(mac->net_dev);
+    }
+}
+
+
--- a/drivers/net/ethernet/sp/l2sw_mac.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_mac.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,24 @@
+#ifndef __L2SW_MAC_H__
+#define __L2SW_MAC_H__
+
+#include "l2sw_define.h"
+#include "l2sw_hal.h"
+
+bool mac_init(struct l2sw_mac *mac);
+
+void mac_start(struct l2sw_mac *mac, u8 *enaddr, u32 flags);
+
+void mac_soft_reset(struct l2sw_mac *mac);
+
+//calculate the empty tx descriptor number
+#define TX_DESC_AVAIL(mac)              \
+        ((mac)->tx_pos != (mac)->tx_done_pos)      \
+        ? (((mac)->tx_done_pos < (mac)->tx_pos) \
+           ? (TX_DESC_NUM - ((mac)->tx_pos - (mac)->tx_done_pos)) \
+	   : ((mac)->tx_done_pos - (mac)->tx_pos)     \
+           )                                              \
+	: ((mac)->tx_desc_full ? 0 : TX_DESC_NUM)
+
+
+#endif
+
--- a/drivers/net/ethernet/sp/l2sw_mdio.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_mdio.c	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,219 @@
+#include "l2sw_mdio.h"
+
+static int mii_read(struct mii_bus *bus, int phy_id, int regnum)
+{
+	u32 ret;
+
+	ret = mdio_read(phy_id, regnum);
+	return ret;
+}
+
+static int mii_write(struct mii_bus *bus, int phy_id, int regnum, u16 val)
+{
+	u32 ret;
+
+	ret = mdio_write(phy_id, regnum, val);
+	return ret;
+}
+
+u32 mdio_init(struct platform_device *pdev, struct net_device *netdev)
+{
+	struct mii_bus *mii_bus;
+	struct l2sw_mac *mac = netdev_priv(netdev);
+	u32 ret, i,reg;
+
+#ifdef PHY_CONFIG
+    struct resource res;
+	struct device_node *np = of_get_parent(mac->phy_node);
+
+#endif
+
+	if ((mii_bus = mdiobus_alloc()) == NULL) {
+		ERROR0("[%s][%d] Allocate mdio bus failed!\n", __FUNCTION__, __LINE__);
+		return -ENOMEM;
+	}
+
+	mii_bus->name = "7020 MII bus";
+	mii_bus->parent = &pdev->dev;
+	mii_bus->priv = mac;
+	mii_bus->read = mii_read;
+	mii_bus->write = mii_write;
+	//mii_bus->irq = mac->phy_irq;
+	for (i = 0; i < PHY_MAX_ADDR; ++i) {
+		mii_bus->irq[i] = PHY_POLL;
+	}
+
+#if 0
+    /* need do auto-negotiation here? */
+    reg = mdio_read(MAC_PHY_ADDR, 1);
+    DEBUG0("[%s][%d] mdio_read reg=0x%x\n", __FUNCTION__, __LINE__, reg);
+    while((reg & (1 << 5)) == 0x0){
+        DEBUG0("[%s][%d] Waiting for auto-negotiation complete\n", __FUNCTION__, __LINE__);
+        reg = mdio_read(MAC_PHY_ADDR, 1);
+    }
+#endif
+
+#ifdef PHY_CONFIG
+    of_address_to_resource(np, 0, &res);
+	snprintf(mii_bus->id, MII_BUS_ID_SIZE, "%.8llx", (unsigned long long)res.start);
+	if (mac->phy_node) {
+		if (of_mdiobus_register(mii_bus, np)) {
+			ERROR0("[%s][%d] Register mii bus failed. err = %d\n", __FUNCTION__, __LINE__, ret);
+        	mdiobus_free(mii_bus);        
+		}
+	}else{
+		mac->mii_bus = mii_bus;
+		return 0;
+	}
+	//if (ret = of_mdiobus_register(mii_bus, np)){
+    //    ERROR0("[%s][%d] Register mii bus failed. err = %d\n", __FUNCTION__, __LINE__, ret);
+    //    mdiobus_free(mii_bus);        
+    //}
+#else	
+    mii_bus->phy_mask = ~0x1f; /*  default phy address mask, need to change ?  */
+	snprintf(mii_bus->id, MII_BUS_ID_SIZE, "%x", pdev->id);
+	if ((ret = mdiobus_register(mii_bus)) < 0) { /* this will fill phy_map ... */
+		ERROR0("[%s][%d] Register mii bus failed. err = %d\n", __FUNCTION__, __LINE__, ret);
+		mdiobus_free(mii_bus);
+	}	
+#endif
+
+    mac->mii_bus = mii_bus;
+	return ret;
+
+}
+
+void mdio_remove(struct l2sw_mac *mac)
+{
+	if (mac->mii_bus != NULL) {
+		mdiobus_unregister(mac->mii_bus);
+		mdiobus_free(mac->mii_bus);
+		mac->mii_bus = NULL;
+	}
+}
+
+#ifdef PHY_RUN_STATEMACHINE
+static void mii_linkchange(struct net_device *netdev)
+{
+
+}
+#endif
+
+int mac_phy_probe(struct net_device *netdev)
+{
+
+    struct l2sw_mac *mac = netdev_priv(netdev);
+    struct phy_device *phydev = NULL;
+
+	if (!mac->phy_node) {
+		DEBUG0("mac_phy_probe: no PHY setup\n");
+		return 0;
+	}
+#ifdef PHY_CONFIG
+    if (mac->phy_node) {
+		phydev = of_phy_connect(mac->net_dev,
+					mac->phy_node,
+					mii_linkchange,
+					0,
+					PHY_INTERFACE_MODE_RGMII_ID);
+	}
+	if (!phydev) {
+		ERROR0("%s: no PHY found\n", netdev->name);
+		return -1;
+	}
+#else
+    /* find the first (lowest address) PHY on the current MAC's MII bus */
+    for (phyaddr = 0; phyaddr < PHY_MAX_ADDR; phyaddr++) {
+        if (mac->mii_bus->phy_map[phyaddr]) {
+            phydev = mac->mii_bus->phy_map[phyaddr];
+            break; /* break out with first one found */
+        }
+    }
+    if (phydev == NULL) {
+        ERROR0("[%s][%d] No ephy!\n", __FUNCTION__, __LINE__);
+        return -ENODEV;
+    }
+#endif
+    
+#ifdef PHY_RUN_STATEMACHINE
+
+#ifndef PHY_CONFIG
+    phydev = phy_connect(netdev, dev_name(&phydev->dev), &mii_linkchange, 0, PHY_INTERFACE_MODE_GMII);
+    if (IS_ERR(phydev)) {
+        ERROR0("[%s][%d] phy_connect failed!\n", __FUNCTION__, __LINE__);
+        return -ENODEV;
+    }
+#endif /* PHY_CONFIG */   
+
+    phydev->supported &= (PHY_GBIT_FEATURES | SUPPORTED_Pause |
+							SUPPORTED_Asym_Pause);
+    
+    phydev->advertising = phydev->supported;
+    phydev->irq = PHY_IGNORE_INTERRUPT;
+    mac->phy_dev = phydev;    
+#endif /* PHY_RUN_STATEMACHINE */
+
+    return 0;
+}
+
+void mac_phy_start(struct net_device *netdev)
+{
+    struct l2sw_mac *mac = netdev_priv(netdev);
+
+#ifdef PHY_RUN_STATEMACHINE
+    phy_start(mac->phy_dev);
+#else
+    u32 phyaddr;
+    struct phy_device *phydev = NULL;
+
+    /* find the first (lowest address) PHY on the current MAC's MII bus */
+    for (phyaddr = 0; phyaddr < PHY_MAX_ADDR; phyaddr++) {
+        if (mac->mii_bus->phy_map[phyaddr]) {
+            phydev = mac->mii_bus->phy_map[phyaddr];
+            break; /* break out with first one found */
+        }
+    }
+
+    phydev = phy_attach(netdev, dev_name(&phydev->dev), 0, PHY_INTERFACE_MODE_GMII);
+    if (IS_ERR(phydev)) {
+        ERROR0("[%s][%d] phy_connect failed!\n", __FUNCTION__, __LINE__);
+        return;
+    }
+
+    phydev->supported &= (PHY_GBIT_FEATURES | SUPPORTED_Pause |
+							SUPPORTED_Asym_Pause);
+    phydev->advertising = phydev->supported;
+    phydev->irq = PHY_IGNORE_INTERRUPT;
+    mac->phy_dev = phydev;
+
+    phy_start_aneg(phydev);
+#endif
+}
+
+void mac_phy_stop(struct net_device *netdev)
+{
+    struct l2sw_mac *mac = netdev_priv(netdev);
+
+    if (mac->phy_dev != NULL) {
+#ifdef PHY_RUN_STATEMACHINE
+        phy_stop(mac->phy_dev);
+#else
+        phy_detach(mac->phy_dev);
+        mac->phy_dev = NULL;
+#endif
+    }
+}
+
+void mac_phy_remove(struct net_device *netdev)
+{
+    struct l2sw_mac *mac = netdev_priv(netdev);
+
+    if (mac->phy_dev != NULL) {
+#ifdef PHY_RUN_STATEMACHINE
+        phy_disconnect(mac->phy_dev);
+#endif
+        mac->phy_dev = NULL;
+    }
+}
+
+
--- a/drivers/net/ethernet/sp/l2sw_mdio.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_mdio.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,22 @@
+#ifndef __L2SW_MDIO_H__
+#define __L2SW_MDIO_H__
+
+#include "l2sw_define.h"
+#include "l2sw_hal.h"
+
+#define PHY_RUN_STATEMACHINE
+
+u32 mdio_init(struct platform_device *pdev, struct net_device *netdev);
+
+void mdio_remove(struct l2sw_mac *mac);
+
+int mac_phy_probe(struct net_device *netdev);
+
+void mac_phy_start(struct net_device *netdev);
+
+void mac_phy_stop(struct net_device *netdev);
+
+void mac_phy_remove(struct net_device *netdev);
+
+#endif
+
--- a/drivers/net/ethernet/sp/l2sw_register.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/l2sw_register.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,114 @@
+#ifndef __L2SW_REGISTER_H__
+#define __L2SW_REGISTER_H__
+
+#define REGISTER_BASE   0x9c108000
+
+typedef unsigned char       BYTE    ;
+typedef unsigned short      WORD    ;
+typedef unsigned long       DWORD   ;
+
+typedef unsigned long long  UINT64  ;
+typedef unsigned int        UINT32  ;
+typedef unsigned short      UINT16  ;
+typedef unsigned char       UINT8   ;
+
+typedef long long           INT64   ;
+typedef int                 INT32   ;
+typedef short               INT16   ;
+typedef signed char         INT8    ;
+
+//=================================================================================================
+/*
+ * TYPE: RegisterFile_L2SW
+ */
+struct l2sw_reg {
+
+UINT32 sw_int_status_0;
+UINT32 sw_int_mask_0;
+UINT32 fl_cntl_th;
+UINT32 cpu_fl_cntl_th;
+UINT32 pri_fl_cntl;
+UINT32 vlan_pri_th;
+UINT32 En_tos_bus;
+UINT32 Tos_map0;
+UINT32 Tos_map1;
+UINT32 Tos_map2;
+UINT32 Tos_map3;
+UINT32 Tos_map4;
+UINT32 Tos_map5;
+UINT32 Tos_map6;
+UINT32 Tos_map7;
+UINT32 global_que_status;
+UINT32 addr_tbl_srch;
+UINT32 addr_tbl_st;
+UINT32 MAC_ad_ser0;
+UINT32 MAC_ad_ser1;
+UINT32 wt_mac_ad0;
+UINT32 w_mac_15_0_bus;
+UINT32 w_mac_47_16;
+UINT32 PVID_config0;
+UINT32 PVID_config1;
+UINT32 VLAN_memset_config0;
+UINT32 VLAN_memset_config1;
+UINT32 port_ability;
+UINT32 port_st;
+UINT32 cpu_cntl;
+UINT32 port_cntl0;
+UINT32 port_cntl1;
+UINT32 port_cntl2;
+UINT32 sw_glb_cntl;
+UINT32 l2sw_rsv1;
+UINT32 led_port0;
+UINT32 led_port1;
+UINT32 led_port2;
+UINT32 led_port3;
+UINT32 led_port4;
+UINT32 watch_dog_trig_rst;
+UINT32 watch_dog_stop_cpu;
+UINT32 phy_cntl_reg0;
+UINT32 phy_cntl_reg1;
+UINT32 mac_force_mode;
+UINT32 VLAN_group_config0;
+UINT32 VLAN_group_config1;
+UINT32 flow_ctrl_th3;
+UINT32 queue_status_0;
+UINT32 debug_cntl;
+UINT32 l2sw_rsv2;
+UINT32 mem_test_info;
+UINT32 sw_int_status_1;
+UINT32 sw_int_mask_1;
+UINT32 l2sw_rsv3[76];
+UINT32 cpu_tx_trig;
+UINT32 tx_hbase_addr_0;
+UINT32 tx_lbase_addr_0;
+UINT32 rx_hbase_addr_0;
+UINT32 rx_lbase_addr_0;
+UINT32 tx_hw_addr_0;
+UINT32 tx_lw_addr_0;
+UINT32 rx_hw_addr_0;
+UINT32 rx_lw_addr_0;
+UINT32 cpu_port_cntl_reg_0;
+UINT32 tx_hbase_addr_1;
+UINT32 tx_lbase_addr_1;
+UINT32 rx_hbase_addr_1;
+UINT32 rx_lbase_addr_1;
+UINT32 tx_hw_addr_1;
+UINT32 tx_lw_addr_1;
+UINT32 rx_hw_addr_1;
+UINT32 rx_lw_addr_1;
+UINT32 cpu_port_cntl_reg_1;
+
+};
+
+#define REG_BASE           0x9c000000
+#define RF_GRP(_grp, _reg) ((((_grp) * 32 + (_reg)) * 4) + REG_BASE)
+
+struct moon_regs {
+	unsigned int sft_cfg[32];
+};
+
+
+
+
+#endif
+
--- a/drivers/net/ethernet/sp/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/Makefile	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1 @@
+obj-$(CONFIG_L2SW_DRIVER) += l2sw_driver.o l2sw_desc.o l2sw_hal.o l2sw_mac.o l2sw_mdio.o
--- a/drivers/net/ethernet/sp/regmap.h	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/net/ethernet/sp/regmap.h	2018-11-12 06:42:54.000000000 +0300
@@ -0,0 +1,100 @@
+#define REGISTER_BASE   0x43C00000
+
+typedef unsigned char       BYTE    ;
+typedef unsigned short      WORD    ;
+typedef unsigned long       DWORD   ;
+
+typedef unsigned long long  UINT64  ;
+typedef unsigned int        UINT32  ;
+typedef unsigned short      UINT16  ;
+typedef unsigned char       UINT8   ;
+
+typedef long long           INT64   ;
+typedef int                 INT32   ;
+typedef short               INT16   ;
+typedef signed char         INT8    ;
+
+//=================================================================================================
+/*
+ * TYPE: RegisterFile_L2SW
+ */
+typedef struct
+{
+UINT32 sw_int_status_0;
+UINT32 sw_int_mask_0;
+UINT32 fl_cntl_th;
+UINT32 cpu_fl_cntl_th;
+UINT32 pri_fl_cntl;
+UINT32 vlan_pri_th;
+UINT32 En_tos_bus;
+UINT32 Tos_map0;
+UINT32 Tos_map1;
+UINT32 Tos_map2;
+UINT32 Tos_map3;
+UINT32 Tos_map4;
+UINT32 Tos_map5;
+UINT32 Tos_map6;
+UINT32 Tos_map7;
+UINT32 global_que_status;
+UINT32 addr_tbl_srch;
+UINT32 addr_tbl_st;
+UINT32 MAC_ad_ser0;
+UINT32 MAC_ad_ser1;
+UINT32 wt_mac_ad0;
+UINT32 w_mac_15_0_bus;
+UINT32 w_mac_47_16;
+UINT32 PVID_config0;
+UINT32 PVID_config1;
+UINT32 VLAN_memset_config0;
+UINT32 VLAN_memset_config1;
+UINT32 port_ability;
+UINT32 port_st;
+UINT32 cpu_cntl;
+UINT32 port_cntl0;
+UINT32 port_cntl1;
+UINT32 port_cntl2;
+UINT32 sw_glb_cntl;
+UINT32 l2sw_rsv1;
+UINT32 led_port0;
+UINT32 led_port1;
+UINT32 led_port2;
+UINT32 led_port3;
+UINT32 led_port4;
+UINT32 watch_dog_trig_rst;
+UINT32 watch_dog_stop_cpu;
+UINT32 phy_cntl_reg0;
+UINT32 phy_cntl_reg1;
+UINT32 mac_force_mode;
+UINT32 VLAN_group_config0;
+UINT32 VLAN_group_config1;
+UINT32 flow_ctrl_th3;
+UINT32 queue_status_0;
+UINT32 debug_cntl;
+UINT32 l2sw_rsv2;
+UINT32 mem_test_info;
+UINT32 sw_int_status_1;
+UINT32 sw_int_mask_1;
+UINT32 l2sw_rsv3[76];
+UINT32 cpu_tx_trig;
+UINT32 tx_hbase_addr_0;
+UINT32 tx_lbase_addr_0;
+UINT32 rx_hbase_addr_0;
+UINT32 rx_lbase_addr_0;
+UINT32 tx_hw_addr_0;
+UINT32 tx_lw_addr_0;
+UINT32 rx_hw_addr_0;
+UINT32 rx_lw_addr_0;
+UINT32 cpu_port_cntl_reg_0;
+UINT32 tx_hbase_addr_1;
+UINT32 tx_lbase_addr_1;
+UINT32 rx_hbase_addr_1;
+UINT32 rx_lbase_addr_1;
+UINT32 tx_hw_addr_1;
+UINT32 tx_lw_addr_1;
+UINT32 rx_hw_addr_1;
+UINT32 rx_lw_addr_1;
+UINT32 cpu_port_cntl_reg_1;
+} RegisterFile_L2SW;
+
+#define regs_l2sw   ((volatile RegisterFile_L2SW *)(REGISTER_BASE))
+
