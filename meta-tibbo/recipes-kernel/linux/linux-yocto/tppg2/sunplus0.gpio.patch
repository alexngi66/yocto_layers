--- a/arch/arm/mach-pentagram/include/mach/gpio_drv.h	1970-01-01 03:00:00.000000000 +0300
+++ a/arch/arm/mach-pentagram/include/mach/gpio_drv.h	2018-11-12 06:42:50.000000000 +0300
@@ -0,0 +1,274 @@
+#ifndef _SP_GPIO_H_
+#define _SP_GPIO_H_
+
+
+#ifdef  __KERNEL__
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+typedef u32     u032;
+typedef u16     u016;
+typedef u8      u008;
+#else   /* __KERNEL__ */
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <stdint.h>
+
+typedef  uint32_t u032;
+typedef  uint16_t u016;
+typedef  uint8_t  u008;
+#endif  /* __KERNEL__ */
+
+
+
+/*  GPIO  IOCTL code  */
+#define GPIO_IOCTYPE                         'S'
+#define GPIO_IOCNUM(n)                       (0x80 + n)
+
+#define GPIO_IOC_FIRST_1    _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x10), u032)
+#define GPIO_IOC_FIRST_0    _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x11), u032)
+#define GPIO_IOC_MASTER_1   _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x12), u032)
+#define GPIO_IOC_MASTER_0   _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x13), u032)
+#define GPIO_IOC_SET_OE     _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x14), u032)
+#define GPIO_IOC_CLR_OE     _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x15), u032)
+#define GPIO_IOC_OUT_1      _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x16), u032)
+#define GPIO_IOC_OUT_0      _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x17), u032)
+#define GPIO_IOC_IN         _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x18), u032)
+#define GPIO_IOC_PIN_MUX_GET     _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x19), u032)
+#define GPIO_IOC_PIN_MUX_SEL     _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x20), u032)
+#define GPIO_IOC_INPUT_INVERT_1      _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x21), u032)
+#define GPIO_IOC_INPUT_INVERT_0      _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x22), u032)
+#define GPIO_IOC_OUTPUT_INVERT_1     _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x23), u032)
+#define GPIO_IOC_OUTPUT_INVERT_0     _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x24), u032)
+#define GPIO_IOC_OPEN_DRAIN_1        _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x25), u032)
+#define GPIO_IOC_OPEN_DRAIN_0        _IOWR(GPIO_IOCTYPE, GPIO_IOCNUM(0x26), u032)
+
+#define GPIO_FUNC_ORG           0
+#define GPIO_FUNC_GPIO          1
+#define GPIO_DIR_OUTPUT         1
+#define GPIO_DIR_INPUT          0
+#define GPIO_PULL_LOW           0
+#define GPIO_PULL_HIGH          1
+#define GPIO_PULL_FLOATING      2
+#define	GPIO_NO_PULL			3
+#define GPIO_IRQ_DISABLE        0
+#define GPIO_IRQ_ENABLE         1
+
+typedef enum
+{
+	
+	//G2
+	PMX_L2SW_CLK_OUT    = 0x02004000,			// (0-64, 0)
+	PMX_L2SW_MAC_SMI_MDC       = 0x02004008,			// (0-64, 8)	
+	PMX_L2SW_LED_FLASH0        = 0x02014000,			// (0-64, 0)	
+	PMX_L2SW_LED_FLASH1        = 0x02014008,			// (0-64, 8)
+	PMX_L2SW_LED_ON0           = 0x02024000,			// (0-64, 0)
+	PMX_L2SW_LED_ON1           = 0x02024008,			// (0-64, 8)
+	PMX_L2SW_MAC_SMI_MDIO      = 0x02034000,			// (0-64, 0)
+	PMX_L2SW_P0_MAC_RMII_TXEN  = 0x02034008,			// (0-64, 8)
+	PMX_L2SW_P0_MAC_RMII_TXD0  = 0x02044000,			// (0-64, 0)	
+	PMX_L2SW_P0_MAC_RMII_TXD1  = 0x02044008,			// (0-64, 8)
+	PMX_L2SW_P0_MAC_RMII_CRSDV = 0x02054000,			// (0-64, 0)	
+	PMX_L2SW_P0_MAC_RMII_RXD0  = 0x02054008,			// (0-64, 8)
+	PMX_L2SW_P0_MAC_RMII_RXD1  = 0x02064000,			// (0-64, 0)	
+	PMX_L2SW_P0_MAC_RMII_RXER  = 0x02064008,			// (0-64, 8)
+	PMX_L2SW_P1_MAC_RMII_TXEN  = 0x02074000,			// (0-64, 0)	
+	PMX_L2SW_P1_MAC_RMII_TXD0  = 0x02074008,			// (0-64, 8)
+	PMX_L2SW_P1_MAC_RMII_TXD1  = 0x02084000,			// (0-64, 0)	
+	PMX_L2SW_P1_MAC_RMII_CRSDV = 0x02084008,			// (0-64, 8)
+	PMX_L2SW_P1_MAC_RMII_RXD0  = 0x02094000,			// (0-64, 0)	
+	PMX_L2SW_P1_MAC_RMII_RXD1  = 0x02094008,			// (0-64, 8)
+	PMX_L2SW_P1_MAC_RMII_RXER  = 0x020a4000,			// (0-64, 0)
+	PMX_DAISY_MODE = 0x020a4008,			// (0-64, 8)
+	PMX_SDIO_CLK   = 0x020b4000,			// (0-64, 0)
+	PMX_SDIO_CMD   = 0x020b4008,			// (0-64, 8)
+	PMX_SDIO_D0    = 0x020c4000,			// (0-64, 0)
+	PMX_SDIO_D1    = 0x020c4008,			// (0-64, 8)
+	PMX_SDIO_D2    = 0x020d4000,			// (0-64, 0)
+	PMX_SDIO_D3    = 0x020d4008,			// (0-64, 8)
+	PMX_PWM0       = 0x020e4000,			// (0-64, 0)
+	PMX_PWM1       = 0x020e4008,			// (0-64, 8)
+	PMX_PWM2       = 0x020f4000,			// (0-64, 0)
+	PMX_PWM3       = 0x020f4008,			// (0-64, 8)
+	PMX_PWM4       = 0x02104000,			// (0-64, 0)
+	PMX_PWM5       = 0x02104008,			// (0-64, 8)
+	PMX_PWM6       = 0x02114000,			// (0-64, 0)
+	PMX_PWM7       = 0x02114008,			// (0-64, 8)
+	PMX_ICM0_D     = 0x02124000,			// (0-64, 0)
+	PMX_ICM1_D     = 0x02124008,			// (0-64, 8)
+	PMX_ICM2_D     = 0x02134000,			// (0-64, 0)
+	PMX_ICM3_D     = 0x02134008,			// (0-64, 8)
+	PMX_ICM0_CLK   = 0x02144000,			// (0-64, 0)
+	PMX_ICM1_CLK   = 0x02144008,			// (0-64, 8)
+	PMX_ICM2_CLK   = 0x02154000,			// (0-64, 0)
+	PMX_ICM3_CLK   = 0x02154008,			// (0-64, 8)
+	PMX_SPIM0_INT  = 0x02164000,			// (0-64, 0)
+	PMX_SPIM0_CLK  = 0x02164008,			// (0-64, 8)
+	PMX_SPIM0_CEN  = 0x02174000,			// (0-64, 0)
+	PMX_SPIM0_DO   = 0x02174008,			// (0-64, 8)
+	PMX_SPIM0_DI   = 0x02184000,			// (0-64, 0)
+	PMX_SPIM1_INT  = 0x02184008,			// (0-64, 8)
+	PMX_SPIM1_CLK  = 0x02194000,			// (0-64, 0)
+	PMX_SPIM1_CEN  = 0x02194008,			// (0-64, 8)
+	PMX_SPIM1_DO   = 0x021a4000,			// (0-64, 0)
+	PMX_SPIM1_DI   = 0x021a4008,			// (0-64, 8)
+	PMX_SPIM2_INT  = 0x021b4000,			// (0-64, 0)
+	PMX_SPIM2_CLK  = 0x021b4008,			// (0-64, 8)
+	PMX_SPIM2_CEN  = 0x021c4000,			// (0-64, 0)
+	PMX_SPIM2_DO   = 0x021c4008,			// (0-64, 8)
+	PMX_SPIM2_DI   = 0x021d4000,			// (0-64, 0)
+	PMX_SPIM3_INT  = 0x021d4008,			// (0-64, 8)
+	PMX_SPIM3_CLK  = 0x021e4000,			// (0-64, 0)
+	PMX_SPIM3_CEN  = 0x021e4008,			// (0-64, 8)
+	PMX_SPIM3_DO   = 0x021f4000,			// (0-64, 0)
+	PMX_SPIM3_DI   = 0x021f4008,			// (0-64, 8)
+	//G3
+	PMX_SPI0S_INT   = 0x03004000,			// (0-64, 0)
+	PMX_SPI0S_CLK   = 0x03004008,			// (0-64, 8)
+	PMX_SPI0S_EN    = 0x03014000,			// (0-64, 0)
+	PMX_SPI0S_DO    = 0x03014008,			// (0-64, 8)
+	PMX_SPI0S_DI    = 0x03024000,			// (0-64, 0)
+	PMX_SPI1S_INT   = 0x03024008,			// (0-64, 8)
+	PMX_SPI1S_CLK   = 0x03034000,			// (0-64, 0)
+	PMX_SPI1S_EN    = 0x03034008,			// (0-64, 8)
+	PMX_SPI1S_DO    = 0x03044000,			// (0-64, 0)
+	PMX_SPI1S_DI    = 0x03044008,			// (0-64, 8)
+	PMX_SPI2S_INT   = 0x03054000,			// (0-64, 0)
+	PMX_SPI2S_CLK   = 0x03054008,			// (0-64, 8)
+	PMX_SPI2S_EN    = 0x03064000,			// (0-64, 0)
+	PMX_SPI2S_DO    = 0x03064008,			// (0-64, 8)
+	PMX_SPI2S_DI    = 0x03074000,			// (0-64, 0)	
+	PMX_SPI3S_INT   = 0x03074008,			// (0-64, 8)
+	PMX_SPI3S_CLK   = 0x03084000,			// (0-64, 0)
+	PMX_SPI3S_EN    = 0x03084008,			// (0-64, 8)
+	PMX_SPI3S_DO    = 0x03094000,			// (0-64, 0)
+	PMX_SPI3S_DI    = 0x03094008,			// (0-64, 8)
+	PMX_I2CM0_CK    = 0x030a4000,			// (0-64, 0)
+	PMX_I2CM0_DAT   = 0x030a4008,			// (0-64, 8)
+	PMX_I2CM1_CK    = 0x030b4000,			// (0-64, 0)	
+	PMX_I2CM1_DAT   = 0x030b4008,			// (0-64, 8)
+	PMX_I2CM2_CK    = 0x030c4000,			// (0-64, 0)		
+	PMX_I2CM2_D     = 0x030c4008,			// (0-64, 8)
+	PMX_I2CM3_CK    = 0x030d4000,			// (0-64, 0)		
+	PMX_I2CM3_D     = 0x030d4008,			// (0-64, 8)
+	PMX_UA1_TX      = 0x030e4000,			// (0-64, 0)		
+	PMX_UA1_RX      = 0x030e4008,			// (0-64, 8)
+	PMX_UA1_CTS     = 0x030f4000,			// (0-64, 0)	
+	PMX_UA1_RTS     = 0x030f4008,			// (0-64, 8)
+	PMX_UA2_TX      = 0x03104000,			// (0-64, 0)	
+	PMX_UA2_RX      = 0x03104008,			// (0-64, 8)
+	PMX_UA2_CTS     = 0x03114000,			// (0-64, 0)	
+	PMX_UA2_RTS     = 0x03114008,			// (0-64, 8)
+	PMX_UA3_TX      = 0x03124000,			// (0-64, 0)	
+	PMX_UA3_RX      = 0x03124008,			// (0-64, 8)
+	PMX_UA3_CTS     = 0x03134000,			// (0-64, 0)	
+	PMX_UA3_RTS     = 0x03134008,			// (0-64, 8)
+	PMX_UA4_TX      = 0x03144000,			// (0-64, 0)	
+	PMX_UA4_RX      = 0x03144008,			// (0-64, 8)
+	PMX_UA4_CTS     = 0x03154000,			// (0-64, 0)	
+	PMX_UA4_RTS     = 0x03154008,			// (0-64, 8)
+	PMX_TIMER0_INT  = 0x03164000,			// (0-64, 0)		
+	PMX_TIMER1_INT  = 0x03164008,			// (0-64, 8)
+	PMX_TIMER2_INT  = 0x03174000,			// (0-64, 0)	
+	PMX_TIMER3_INT  = 0x03174008,			// (0-64, 8)
+	PMX_GPIO_INT0   = 0x03184000,			// (0-64, 0)	
+	PMX_GPIO_INT1   = 0x03184008,			// (0-64, 8)	
+	PMX_GPIO_INT2   = 0x03194000,			// (0-64, 0)	
+	PMX_GPIO_INT3   = 0x03194008,			// (0-64, 8)	
+	PMX_GPIO_INT4   = 0x031a4000,			// (0-64, 0)	
+	PMX_GPIO_INT5   = 0x031a4008,			// (0-64, 8)	
+	PMX_GPIO_INT6   = 0x031b4000,			// (0-64, 0)	
+	PMX_GPIO_INT7   = 0x031b4008,			// (0-64, 8)
+
+}PMXSEL_ID;
+
+
+typedef struct PMXSEL_S {
+	u032 id;
+	u032 val;
+}PMXSEL_T;
+
+extern long gpio_input_invert_1(u032 bit);
+extern long gpio_input_invert_0(u032 bit);
+extern long gpio_output_invert_1(u032 bit);
+extern long gpio_output_invert_0(u032 bit);
+extern long gpio_open_drain_1(u032 bit);
+extern long gpio_open_drain_0(u032 bit);
+extern long gpio_first_1(u032 bit);
+extern long gpio_first_0(u032 bit);
+extern long gpio_master_1(u032 bit);
+extern long gpio_master_0(u032 bit);
+extern long gpio_set_oe(u032 bit);
+extern long gpio_clr_oe(u032 bit);
+extern long gpio_out_1(u032 bit);
+extern long gpio_out_0(u032 bit);
+extern u032 gpio_in_val(u032 bit);
+
+extern long gpio_pin_mux_sel(PMXSEL_ID id, u032 sel);
+extern long gpio_pin_mux_get(PMXSEL_ID id, u032 *sel);
+
+
+
+#define GPIO_I_INV_SET(a,d) do { \
+                            if(d) { \
+                                gpio_input_invert_1(a); \
+                            } else { \
+                                gpio_input_invert_0(a); \
+                            } \
+                        } while(0)
+                        
+#define GPIO_O_INV_SET(a,d) do { \
+                            if(d) { \
+                                gpio_output_invert_1(a); \
+                            } else { \
+                                gpio_output_invert_0(a); \
+                            } \
+                        } while(0)
+                        
+#define GPIO_OD_INV_SET(a,d) do { \
+                            if(d) { \
+                                gpio_open_drain_1(a); \
+                            } else { \
+                                gpio_open_drain_0(a); \
+                            } \
+                        } while(0)
+
+#define GPIO_E_SET(a,d) do { \
+                            if(d) { \
+                                gpio_set_oe(a); \
+                            } else { \
+                                gpio_clr_oe(a); \
+                            } \
+                        } while(0)
+
+#define GPIO_F_SET(a,d) do { \
+                            if(d) { \
+                                gpio_first_1(a); \
+                            } else { \
+                                gpio_first_0(a); \
+                            } \
+                        } while(0)
+
+#define GPIO_M_SET(a,d) do { \
+                            if(d) { \
+                                gpio_master_1(a); \
+                            } else { \
+                                gpio_master_0(a); \
+                            } \
+                        } while(0)
+
+#define GPIO_O_SET(a,d) do { \
+                            if(d) { \
+                                gpio_out_1(a); \
+                            } else { \
+                                gpio_out_0(a); \
+                            } \
+                        } while(0)
+
+#define GPIO_I_GET(a)   gpio_in_val(a)
+
+#define GPIO_PIN_MUX_SEL(a,d) gpio_pin_mux_sel(a, d)
+
+
+#endif /* _SP_GPIO_H_ */
+
--- a/drivers/gpio/gpio_sp/gpio-sp.c	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/gpio/gpio_sp/gpio-sp.c	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,726 @@
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <asm/io.h>
+#include <mach/io_map.h>
+#include <linux/interrupt.h>
+#include <linux/of_platform.h>
+#include <linux/gpio/driver.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <mach/gpio_drv.h>
+
+/* #define GPIO_FUNC_DEBUG */
+#define GPIO_KDBG_INFO
+#define GPIO_KDBG_ERR
+
+#ifdef GPIO_FUNC_DEBUG
+	#define FUNC_DEBUG() printk(KERN_INFO "%s: %d %s()\n", __FILE__, __LINE__, __func__)
+#else
+	#define FUNC_DEBUG()
+#endif
+
+#ifdef GPIO_KDBG_INFO
+	#define DBG_INFO(fmt, args ...) printk(KERN_INFO "K_GPIO: " fmt, ## args)
+#else
+	#define DBG_INFO(fmt, args ...)
+#endif
+
+#ifdef GPIO_KDBG_ERR
+	#define DBG_ERR(fmt, args ...)  printk(KERN_ERR "K_GPIO: " fmt, ## args)
+#else
+	#define DBG_ERR(fmt, args ...)
+#endif
+
+#define DEVICE_NAME             "sp_gpio"
+#define REG_GRP_OFS(GRP, OFFSET)        VA_IOB_ADDR((GRP) * 32 * 4 + (OFFSET) * 4) 
+#define GPIO_FIRST(X)   (REG_GRP_OFS(101, (25+X)))
+#define GPIO_MASTER(X)  (REG_GRP_OFS(6, (0+X)))
+#define GPIO_OE(X)      (REG_GRP_OFS(6, (8+X)))
+#define GPIO_OUT(X)     (REG_GRP_OFS(6, (16+X)))
+#define GPIO_IN(X)      (REG_GRP_OFS(6, (24+X)))
+#define GPIO_I_INV(X)   (REG_GRP_OFS(7, (0+X)))
+#define GPIO_O_INV(X)   (REG_GRP_OFS(7, (8+X)))
+#define GPIO_OD(X)      (REG_GRP_OFS(7, (16+X)))
+#define GPIO_SFT_CFG(G,X)      (REG_GRP_OFS(G, (0+X)))
+#define NUM_GPIO_MAX    (256)
+static DEFINE_SPINLOCK(slock_gpio);
+
+struct sp_gpio {
+	struct gpio_chip chip;
+	void __iomem *base;
+	int irq;
+	struct device		*dev;
+};
+
+long gpio_input_invert_1(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+
+	value = (1 << (bit & 0x0f) | 1 << ((bit & 0x0f) + 0x10));
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32((ioread32(GPIO_I_INV(idx)) | value), GPIO_I_INV(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_input_invert_1);
+
+long gpio_input_invert_0(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+	value = ((ioread32(GPIO_I_INV(idx)) | (1 << ((bit & 0x0f) + 0x10))) & ~( 1 << (bit & 0x0f)));
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32(value, GPIO_I_INV(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_input_invert_0);
+
+long gpio_output_invert_1(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+
+	value = (1 << (bit & 0x0f) | 1 << ((bit & 0x0f) + 0x10));
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32((ioread32(GPIO_O_INV(idx)) | value), GPIO_O_INV(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_output_invert_1);
+
+long gpio_output_invert_0(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+	value = ((ioread32(GPIO_O_INV(idx)) | (1 << ((bit & 0x0f) + 0x10))) & ~( 1 << (bit & 0x0f)));
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32(value, GPIO_O_INV(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_output_invert_0);
+
+long gpio_open_drain_1(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+
+	value = (1 << (bit & 0x0f) | 1 << ((bit & 0x0f) + 0x10));
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32((ioread32(GPIO_OD(idx)) | value), GPIO_OD(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_open_drain_1);
+
+long gpio_open_drain_0(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+	value = ((ioread32(GPIO_OD(idx)) | (1 << ((bit & 0x0f) + 0x10))) & ~( 1 << (bit & 0x0f)));
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32(value, GPIO_OD(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_open_drain_0);
+
+long gpio_first_1(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 5;
+	if (idx > 4) {
+		return -EINVAL;
+	}
+	
+	value = 1 << (bit & 0x1f);
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32((ioread32(GPIO_FIRST(idx)) | value), GPIO_FIRST(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_first_1);
+
+long gpio_first_0(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 5;
+	if (idx > 4) {
+		return -EINVAL;
+	}
+
+	value = 1 << (bit & 0x1f);
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32((ioread32(GPIO_FIRST(idx)) & (~value)), GPIO_FIRST(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+	return 0;
+}
+EXPORT_SYMBOL(gpio_first_0);
+
+long gpio_master_1(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+
+	value = (1 << (bit & 0x0f) | 1 << ((bit & 0x0f) + 0x10));
+	//if (gpio_check_first(idx, value) == -EINVAL) {
+	//	return -EINVAL;
+	//}
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32((ioread32(GPIO_MASTER(idx)) | value), GPIO_MASTER(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_master_1);
+
+long gpio_master_0(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+	
+	value = ((ioread32(GPIO_MASTER(idx)) | (1 << ((bit & 0x0f) + 0x10)) ) & ~( 1 << (bit & 0x0f)));
+	//if (gpio_check_first(idx, value) == -EINVAL) {
+	//	return -EINVAL;
+	//}
+		
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32(value, GPIO_MASTER(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_master_0);
+
+long gpio_set_oe(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+
+	value = (1 << (bit & 0x0f) |  1 << ((bit & 0x0f) + 0x10));
+
+#if 0
+	if (gpio_check_first(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+	if (gpio_check_master(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+#endif
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32((ioread32(GPIO_OE(idx)) | value), GPIO_OE(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_set_oe);
+
+long gpio_clr_oe(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+  if (idx > 8) {
+		return -EINVAL;
+	}
+	
+	value = ((ioread32(GPIO_OE(idx)) | (1 << ((bit & 0x0f) + 0x10)) ) & ~( 1 << (bit & 0x0f)));
+#if 0
+	if (gpio_check_first(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+	if (gpio_check_master(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+#endif
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32(value, GPIO_OE(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_clr_oe);
+
+long gpio_out_1(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+
+	value = (1 << (bit & 0x0f) | 1 << ((bit & 0x0f) + 0x10));
+	
+#if 0
+	if (gpio_check_first(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+	if (gpio_check_master(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+	if (gpio_check_oe(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+#endif
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32((ioread32(GPIO_OUT(idx)) | value), GPIO_OUT(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_out_1);
+
+long gpio_out_0(u32 bit)
+{
+	u32 idx, value;
+	unsigned long flags;
+
+	idx = bit >> 4;
+	if (idx > 8) {
+		return -EINVAL;
+	}
+
+	value = ((ioread32(GPIO_OUT(idx)) | (1 << ((bit & 0x0f) + 0x10)) ) & ~( 1 << (bit & 0x0f)));
+#if 0
+	if (gpio_check_first(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+	if (gpio_check_master(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+	if (gpio_check_oe(idx, value) == -EINVAL) {
+		return -EINVAL;
+	}
+#endif
+	spin_lock_irqsave(&slock_gpio, flags);
+	iowrite32(value, GPIO_OUT(idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_out_0);
+
+long gpio_in(u32 bit, u32 *gpio_in_value)
+{
+
+	u32 idx, value;
+	unsigned long flags;
+	
+	idx = bit >> 5;
+	if (idx > 5) {
+		return -EINVAL;
+	}
+	
+	value = 1 << (bit & 0x1f);
+	
+	spin_lock_irqsave(&slock_gpio, flags);
+	*gpio_in_value = (ioread32(GPIO_IN(idx)) & value) ? 1 : 0;
+	spin_unlock_irqrestore(&slock_gpio, flags);
+		
+	return 0;
+}
+EXPORT_SYMBOL(gpio_in);
+
+u32 gpio_in_val(u32 bit)
+{
+	u32 value = 0;
+
+	gpio_in(bit, &value);
+
+	return value;
+}
+EXPORT_SYMBOL(gpio_in_val);
+
+long gpio_pin_mux_sel(PMXSEL_ID id, u32 sel)
+{
+	u32 grp ,idx, max_value, reg_val, mask, bit_num;
+	unsigned long flags;
+	
+	grp = (id >> 24) & 0xff;
+	if (grp > 0x03) {
+		return -EINVAL;
+	}	
+	
+	idx = (id >> 16) & 0xff;
+	if (idx > 0x1f) {
+		return -EINVAL;
+	}
+	
+	max_value = (id >> 8) & 0xff;
+	if (sel > max_value) {
+		return -EINVAL;
+	}
+	
+	bit_num = id & 0xff;
+	
+	if (max_value == 1) {
+		mask = 0x01 << bit_num;
+	}
+	else if ((max_value == 2) || (max_value == 3)) {
+		mask = 0x03 << bit_num;
+	}
+	else {
+		mask = 0x7f << bit_num;
+	}	
+
+	spin_lock_irqsave(&slock_gpio, flags);	
+	reg_val = ioread32(GPIO_SFT_CFG(grp,idx));
+	reg_val |= mask << 0x10 ;
+	reg_val &= (~mask);	
+	reg_val = ((sel << bit_num) | (mask << 0x10));		
+	iowrite32(reg_val, GPIO_SFT_CFG(grp,idx));
+	spin_unlock_irqrestore(&slock_gpio, flags);
+	
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_pin_mux_sel);
+
+long gpio_pin_mux_get(PMXSEL_ID id, u32 *sel)
+{
+	u32 grp , idx, max_value, reg_val, mask, bit_num;
+	unsigned long flags;
+	
+	grp = (id >> 24) & 0xff;
+	
+	idx = (id >> 16) & 0xff;
+	if (idx > 0x11) {
+		return -EINVAL;
+	}
+
+	max_value = (id >> 8) & 0xff;
+	if (sel > max_value) {
+		return -EINVAL;
+	}
+	
+	bit_num = id & 0xff;
+
+	if (max_value == 1) {
+		mask = 0x01 << bit_num;
+	}
+	else if ((max_value == 2) || (max_value == 3)) {
+		mask = 0x03 << bit_num;
+	}
+	else {
+		mask = 0x7f << bit_num;
+	}
+
+	spin_lock_irqsave(&slock_gpio, flags);
+	reg_val = ioread32(GPIO_SFT_CFG(grp,idx));
+	reg_val &= mask;
+	*sel = (reg_val >> bit_num);
+	spin_unlock_irqrestore(&slock_gpio, flags);
+	return 0;
+}
+EXPORT_SYMBOL(gpio_pin_mux_get);
+
+static long gpio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long err = 0;
+	u32 bit;
+	u32 gpio_in_value = 0;
+	PMXSEL_T pin_mux;
+
+	FUNC_DEBUG();
+
+
+	if (cmd == GPIO_IOC_PIN_MUX_SEL) {
+		if (unlikely(copy_from_user(&pin_mux, (void *)arg, sizeof(pin_mux)))) {
+			return -EFAULT;
+		}
+	} else {
+		if (unlikely(copy_from_user(&bit, (void *)arg, sizeof(bit)))) {
+			return -EFAULT;
+		}
+	}
+
+	switch (cmd) {
+	case GPIO_IOC_INPUT_INVERT_1:
+		err = gpio_input_invert_1(bit);
+		break;
+	case GPIO_IOC_INPUT_INVERT_0:
+		err = gpio_input_invert_0(bit);
+		break;
+	case GPIO_IOC_OUTPUT_INVERT_1:
+		err = gpio_output_invert_1(bit);
+		break;
+	case GPIO_IOC_OUTPUT_INVERT_0:
+		err = gpio_output_invert_0(bit);
+		break;
+	case GPIO_IOC_OPEN_DRAIN_1:
+		err = gpio_open_drain_1(bit);
+		break;
+	case GPIO_IOC_OPEN_DRAIN_0:
+		err = gpio_open_drain_0(bit);
+		break;
+	case GPIO_IOC_FIRST_1:
+		err = gpio_first_1(bit);
+		break;
+	case GPIO_IOC_FIRST_0:
+		err = gpio_first_0(bit);
+		break;
+	case GPIO_IOC_MASTER_1:
+		err = gpio_master_1(bit);
+		break;
+	case GPIO_IOC_MASTER_0:
+		err = gpio_master_0(bit);
+		break;
+	case GPIO_IOC_SET_OE:
+		err = gpio_set_oe(bit);
+		break;
+	case GPIO_IOC_CLR_OE:
+		err = gpio_clr_oe(bit);
+		break;
+	case GPIO_IOC_OUT_1:
+		err = gpio_out_1(bit);
+		break;
+	case GPIO_IOC_OUT_0:
+		err = gpio_out_0(bit);
+		break;
+	case GPIO_IOC_IN:
+		err = gpio_in(bit, &gpio_in_value);
+		err |= copy_to_user((void *)arg, &gpio_in_value, sizeof(gpio_in_value));
+		break;
+	case GPIO_IOC_PIN_MUX_GET:
+		err = gpio_pin_mux_get((PMXSEL_ID)pin_mux.id, &pin_mux.val);
+		err |= copy_to_user((void *)arg, &pin_mux.val, sizeof(pin_mux.val));
+		break;
+	case GPIO_IOC_PIN_MUX_SEL:
+		err = gpio_pin_mux_sel((PMXSEL_ID)pin_mux.id, pin_mux.val);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+static irqreturn_t sunplus_gpio_irq(int irq, void *args)
+{
+	printk("sunplus_gpio_irq\n");
+	return IRQ_HANDLED;
+}
+
+static int gpio_open(struct inode *inode, struct file *filp)
+{
+	FUNC_DEBUG();
+	return 0;
+}
+
+static int gpio_release(struct inode *inode, struct file *filp)
+{
+	FUNC_DEBUG();
+	return 0;
+}
+
+static int sp_gpio_dir_in(struct gpio_chip *chip, unsigned int gpio)
+{
+	//struct sp_gpio *gpio = gpiochip_get_data(chip);
+	GPIO_F_SET(gpio, GPIO_FUNC_GPIO);
+	GPIO_M_SET(gpio, 1);
+	GPIO_E_SET(gpio, GPIO_DIR_INPUT);
+	return 0;
+}
+
+static int sp_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio,
+				int val)
+{
+
+	GPIO_F_SET(gpio, GPIO_FUNC_GPIO);
+	GPIO_M_SET(gpio, 1);
+	GPIO_E_SET(gpio, GPIO_DIR_OUTPUT);
+	return 0;
+}
+
+static int sp_gpio_get(struct gpio_chip *gc, unsigned int gpio)
+{
+	GPIO_E_SET(gpio, GPIO_DIR_INPUT);
+	return GPIO_I_GET(gpio);
+}
+
+static void sp_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)
+{
+	GPIO_E_SET(gpio, GPIO_DIR_OUTPUT);
+	GPIO_O_SET(gpio, val);
+}
+
+static int sunplus_gpio_platform_driver_probe(struct platform_device *pdev)
+{
+	struct sp_gpio *pdata;
+	struct gpio_chip *chip;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	int err = 0;
+	
+	int ret,npins,i;
+	struct resource *ires;
+	if (!np) {
+		dev_err(&pdev->dev, "invalid devicetree node\n");
+		return -EINVAL;
+	}
+
+	if (!of_device_is_available(np)) {
+		dev_err(&pdev->dev, "devicetree status is not available\n");
+		return -ENODEV;
+	}
+	
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (pdata == NULL)
+		return -ENOMEM;
+	chip = &pdata->chip;
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(res)) {
+		dev_err(&pdev->dev, "get resource memory from devicetree node\n");
+		return PTR_ERR(res);
+	}
+
+	pdata->base = devm_ioremap_resource(&pdev->dev, res);
+	pdev->dev.platform_data = chip;
+	chip->label = DEVICE_NAME;
+	chip->parent = &pdev->dev;
+	chip->owner = THIS_MODULE;
+	chip->direction_input = sp_gpio_dir_in;
+	chip->get = sp_gpio_get;
+	chip->direction_output = sp_gpio_dir_out;
+	chip->set = sp_gpio_set;
+	chip->base = -1;
+	chip->ngpio = NUM_GPIO_MAX;
+	if (IS_ERR(pdata->base)) {
+		dev_err(&pdev->dev, "mapping resource memory\n");
+		return PTR_ERR(pdata->base);
+	}	
+
+	err = devm_gpiochip_add_data(&pdev->dev, chip, pdata);
+	if (err < 0) {
+		dev_err(&pdev->dev, "failed to add gpio chip\n");
+		return err;
+	}
+
+	dev_info(&pdev->dev, "SP GPIO driver probed.\n");
+	
+	npins = platform_irq_count(pdev);
+
+	for (i = 0; i < npins; i++) {
+		ires = platform_get_resource(pdev, IORESOURCE_IRQ, i);
+		if (!res) {
+			return -ENODEV;
+		}		
+		ret = request_irq(ires->start, sunplus_gpio_irq, 0, DEVICE_NAME, ires);
+		if (ret) { 
+			printk("request_irq() failed (%d)\n", ret); 
+		}
+	}
+	return 0;
+}
+
+	
+#if 0
+static int sp_gpio_remove(struct platform_device *pdev)
+{
+	struct sp_gpio *pdata;
+	pdata = platform_get_drvdata(pdev);
+	if (pdata == NULL)
+		return -ENODEV;
+
+	return gpiochip_remove(&pdata->chip);
+}
+#endif
+/**************************************************************************
+ *                         G L O B A L    D A T A                         *
+ **************************************************************************/
+
+static const struct of_device_id sp_gpio_of_match[] = {
+	{ .compatible = "sunplus,sp_gpio", },
+	{ /* Sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sp_gpio_of_match);
+
+static struct platform_driver sp_gpio_driver = {
+	.probe		= sunplus_gpio_platform_driver_probe,
+	.driver = {
+		.name	= DEVICE_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = sp_gpio_of_match,
+	}
+};
+module_platform_driver(sp_gpio_driver);
+
+static struct file_operations fops = {
+	.owner          = THIS_MODULE,
+	.unlocked_ioctl = gpio_ioctl,
+	.open           = gpio_open,
+	.release        = gpio_release
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sunplus Technology");
+MODULE_DESCRIPTION("Sunplus GPIO driver");
+ 
+
+
--- a/drivers/gpio/gpio_sp/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ a/drivers/gpio/gpio_sp/Makefile	2018-11-12 06:42:52.000000000 +0300
@@ -0,0 +1,9 @@
+#
+# Makefile for the gpio module drivers.
+#
+
+obj-y += gpio-sp.o
+
+clean:
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
+
--- a/drivers/gpio/Makefile	2018-11-23 10:16:14.242921037 +0300
+++ a/drivers/gpio/Makefile	2018-11-23 10:31:03.815049981 +0300
@@ -146,3 +146,4 @@
 obj-$(CONFIG_GPIO_ZYNQ)		+= gpio-zynq.o
 obj-$(CONFIG_GPIO_ZX)		+= gpio-zx.o
 obj-$(CONFIG_GPIO_LOONGSON1)	+= gpio-loongson1.o
+obj-y += gpio_sp/
