./arch/sh/include/uapi/asm/ioctls.h:#define TIOCGRS485	_IOR('T', 46, struct serial_rs485)
./arch/sh/include/uapi/asm/ioctls.h:#define TIOCSRS485	_IOWR('T', 47, struct serial_rs485)
./arch/sparc/include/uapi/asm/ioctls.h:#define TIOCGRS485	_IOR('T', 0x41, struct serial_rs485)
./arch/sparc/include/uapi/asm/ioctls.h:#define TIOCSRS485	_IOWR('T', 0x42, struct serial_rs485)
./arch/x86/include/asm/msr-index.h:#define MSR_IA32_VMX_MISC               0x00000485
./arch/x86/math-emu/README: cos()        284.4          4855.2            308.0          388.7
./arch/x86/boot/video.c:	font_size = rdfs16(0x485); /* Font size, BIOS area */
./arch/x86/boot/video-mode.c:	font_size = rdfs8(0x485); /* BIOS: font size (pixels) */
./arch/x86/platform/ts5500/ts5500.c:/* SRAM/RS-485/ADC options, and RS-485 RTS/Automatic RS-485 flags register */
./arch/x86/platform/ts5500/ts5500.c:#define TS5500_SRAM_RS485_ADC_ADDR	0x75
./arch/x86/platform/ts5500/ts5500.c:#define TS5500_RS485			BIT(1)	/* RS-485 option */
./arch/x86/platform/ts5500/ts5500.c:#define TS5500_RS485_RTS		BIT(6)	/* RTS for RS-485 */
./arch/x86/platform/ts5500/ts5500.c:#define TS5500_RS485_AUTO		BIT(7)	/* Automatic RS-485 */
./arch/x86/platform/ts5500/ts5500.c: * @rs485:	Flag for RS-485 option.
./arch/x86/platform/ts5500/ts5500.c:	bool	rs485;
./arch/x86/platform/ts5500/ts5500.c:	tmp = inb(TS5500_SRAM_RS485_ADC_ADDR);
./arch/x86/platform/ts5500/ts5500.c:	sbc->rs485 = tmp & TS5500_RS485;
./arch/x86/platform/ts5500/ts5500.c:TS5500_ATTR_BOOL(rs485);
./arch/x86/platform/ts5500/ts5500.c:	&dev_attr_rs485.attr,
./arch/mips/include/uapi/asm/ioctls.h:#define TIOCGRS485	_IOR('T', 0x2E, struct serial_rs485)
./arch/mips/include/uapi/asm/ioctls.h:#define TIOCSRS485	_IOWR('T', 0x2F, struct serial_rs485)
./arch/mips/include/uapi/asm/ioctls.h:#define TIOCSSERIAL	0x5485
./arch/alpha/include/uapi/asm/unistd.h:#define __NR_eventfd2			485
./arch/alpha/include/uapi/asm/ioctls.h:#define TIOCGRS485	_IOR('T', 0x2E, struct serial_rs485)
./arch/alpha/include/uapi/asm/ioctls.h:#define TIOCSRS485	_IOWR('T', 0x2F, struct serial_rs485)
./arch/alpha/kernel/systbls.S:	.quad sys_eventfd2			/* 485 */
./arch/cris/include/uapi/asm/Kbuild:header-y += rs485.h
./arch/cris/include/uapi/asm/termios.h:#include <asm/rs485.h>
./arch/cris/include/uapi/asm/rs485.h:/* RS-485 structures */
./arch/cris/include/uapi/asm/rs485.h:/* Used with ioctl() TIOCSERSETRS485 for backward compatibility!
./arch/cris/include/uapi/asm/rs485.h:struct rs485_control {
./arch/cris/include/uapi/asm/rs485.h:/* Used with ioctl() TIOCSERWRRS485 */
./arch/cris/include/uapi/asm/rs485.h:struct rs485_write {
./arch/cris/include/uapi/asm/ioctls.h:#define TIOCSERSETRS485	0x5461  /* enable rs-485 (deprecated) */
./arch/cris/include/uapi/asm/ioctls.h:#define TIOCSERWRRS485	0x5462  /* write rs-485 */
./arch/cris/include/uapi/asm/ioctls.h:#define TIOCSRS485	0x5463  /* enable rs-485 */
./arch/cris/arch-v32/drivers/Kconfig:config ETRAX_RS485
./arch/cris/arch-v32/drivers/Kconfig:	bool "RS-485 support"
./arch/cris/arch-v32/drivers/Kconfig:	  Enables support for RS-485 serial communication.
./arch/cris/arch-v32/drivers/Kconfig:config ETRAX_RS485_DISABLE_RECEIVER
./arch/cris/arch-v32/drivers/Kconfig:	depends on ETRAX_RS485
./arch/cris/arch-v10/drivers/Kconfig:config ETRAX_RS485
./arch/cris/arch-v10/drivers/Kconfig:	bool "RS-485 support"
./arch/cris/arch-v10/drivers/Kconfig:	  Enables support for RS-485 serial communication.  For a primer on
./arch/cris/arch-v10/drivers/Kconfig:	  RS-485, see <http://en.wikipedia.org/wiki/Rs485>
./arch/cris/arch-v10/drivers/Kconfig:config ETRAX_RS485_ON_PA
./arch/cris/arch-v10/drivers/Kconfig:	bool "RS-485 mode on PA"
./arch/cris/arch-v10/drivers/Kconfig:	depends on ETRAX_RS485
./arch/cris/arch-v10/drivers/Kconfig:	  Control Driver Output Enable on RS485 transceiver using a pin on PA
./arch/cris/arch-v10/drivers/Kconfig:config ETRAX_RS485_ON_PA_BIT
./arch/cris/arch-v10/drivers/Kconfig:	int "RS-485 mode on PA bit"
./arch/cris/arch-v10/drivers/Kconfig:	depends on ETRAX_RS485_ON_PA
./arch/cris/arch-v10/drivers/Kconfig:	  Control Driver Output Enable on RS485 transceiver using a this bit
./arch/cris/arch-v10/drivers/Kconfig:config ETRAX_RS485_DISABLE_RECEIVER
./arch/cris/arch-v10/drivers/Kconfig:	depends on ETRAX_RS485
./arch/tile/include/uapi/arch/opcode_tilegx.h:#define TILEGX_BPT_BUNDLE 0x286a44ae51485000ULL
./arch/tile/include/uapi/arch/spr_def_64.h:#define SPR_SYSTEM_SAVE_1_3 0x2485
./arch/tile/kernel/traps.c:	 * bpt shoule be { bpt; nop }, which is 0x286a44ae51485000ULL.
./arch/avr32/include/asm/atomic.h:	(__builtin_constant_p(i) && ((i) >= -1048575) && ((i) <= 1048576))
./arch/avr32/boards/mimc200/setup.c:	at32_map_usart(2, 2, 0);	/* USART 2: /dev/ttyS2 (RS485) */
./arch/powerpc/include/uapi/asm/ioctls.h:#define TIOCGRS485	0x542e
./arch/powerpc/include/uapi/asm/ioctls.h:#define TIOCSRS485	0x542f
./arch/powerpc/xmon/xmon.c:	0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
./arch/powerpc/platforms/cell/spufs/spu_restore_dump.h_shipped:0x04000485,
./arch/powerpc/oprofile/op_model_cell.c: 8671392, 15230076, 4843545, 7009238, 15504095, 1494895, 9627886, 14485051,
./arch/powerpc/oprofile/op_model_cell.c: 2868597, 126119, 5784857, 5245324, 10903900, 16436004, 3389013, 1742384,
./arch/arm/mm/cache-feroceon-l2.c: *   Document ID MV-S104858-00, Rev. A, October 23 2007.
./arch/arm/mach-omap2/sdram-numonyx-m65kxxxxam.h:		.actim_ctrla	= 0xba9dc485,
./arch/arm/mach-omap2/sdram-numonyx-m65kxxxxam.h:		.actim_ctrla	= 0x9a19b485,
./arch/arm/mach-omap2/iomap.h: *	(0x48400000<->0x48500000) <=> (0xFA400000<->0xFA500000)
./arch/arm/mach-ep93xx/ts72xx.h:#define TS72XX_OPTIONS_COM2_RS485	0x02
./arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi:				/* RS485 RX Enable: pull up */
./arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi:				/* RS485 DEN: pull down */
./arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi:				/* RS485/!RS232 Select: pull down (rs232) */
./arch/arm/boot/dts/am335x-TPPs3.dtsi:	uart3_pins_485: uart3_pins_485 {
./arch/arm/boot/dts/am335x-TPPs3.dtsi:	uart5_pins_485: uart5_pins_485 {
./arch/arm/boot/dts/am335x-TPPs3.dtsi:			0x68  (PIN_OUTPUT | MUX_MODE7)		/* mode 232/422/485: gpio2.14 pin078 S11B */
./arch/arm/boot/dts/am335x-TPPs3.dtsi:	pinctrl-0 = <&uart3_pins/* &uart3_pins_485*/>;
./arch/arm/boot/dts/am335x-TPPs3.dtsi:	/*linux,rs485-enabled-at-boot-time;*/
./arch/arm/boot/dts/am335x-TPPs3.dtsi:	pinctrl-0 = <&uart5_pins &uart5_pins_485>;
./arch/arm/boot/dts/am335x-TPPs3.dtsi:	/*rs485-rts-active-high;*/
./arch/arm/boot/dts/am335x-TPPs3.dtsi:	/*rs485-rx-during-tx;*/
./arch/arm/boot/dts/am335x-TPPs3.dtsi:	/*rs485-rts-delay = <1 1>;*/
./arch/arm/boot/dts/am335x-TPPs3.dtsi:	/*linux,rs485-enabled-at-boot-time;*/
./arch/arm/boot/dts/am335x-TPPA.dtsi:	uart3_pins_485: uart3_pins_485 {
./arch/arm/boot/dts/am335x-TPPA.dtsi:	uart5_pins_485: uart5_pins_485 {
./arch/arm/boot/dts/am335x-TPPA.dtsi:			0x68  (PIN_OUTPUT | MUX_MODE7)		/* mode 232/422/485: gpio2.14 pin078 S11B */
./arch/arm/boot/dts/am335x-TPPA.dtsi:	pinctrl-0 = <&uart3_pins &uart3_pins_485>;
./arch/arm/boot/dts/am335x-TPPA.dtsi:	linux,rs485-enabled-at-boot-time;
./arch/arm/boot/dts/am335x-TPPA.dtsi:	pinctrl-0 = <&uart5_pins &uart5_pins_485>;
./arch/arm/boot/dts/am335x-TPPA.dtsi:	rs485-rts-active-high;
./arch/arm/boot/dts/am335x-TPPA.dtsi:	rs485-rx-during-tx;
./arch/arm/boot/dts/am335x-TPPA.dtsi:	rs485-rts-delay = <1 1>;
./arch/arm/boot/dts/am335x-TPPA.dtsi:	linux,rs485-enabled-at-boot-time;
./arch/arm/boot/dts/am335x-nano.dts:	rs485-rts-active-high;
./arch/arm/boot/dts/am335x-nano.dts:	rs485-rx-during-tx;
./arch/arm/boot/dts/am335x-nano.dts:	rs485-rts-delay = <1 1>;
./arch/arm/boot/dts/am335x-nano.dts:	linux,rs485-enabled-at-boot-time;
./arch/arm/boot/dts/am335x-nano.dts:	rs485-rts-active-high;
./arch/arm/boot/dts/am335x-nano.dts:	rs485-rts-delay = <1 1>;
./arch/arm/boot/dts/am335x-nano.dts:	linux,rs485-enabled-at-boot-time;
./arch/arm/boot/dts/r8a7790-lager.dts:		clock-frequency = <148500000>;
./arch/arm/boot/dts/r8a7790-lager.dts:		clock-frequency = <148500000>;
./arch/arm/boot/dts/animeo_ip.dts:				linux,rs485-enabled-at-boot-time;
./arch/arm/boot/dts/animeo_ip.dts:				linux,rs485-enabled-at-boot-time;
./arch/arm/boot/dts/aks-cdu.dts:				linux,rs485-enabled-at-boot-time;
./arch/arm/boot/dts/aks-cdu.dts:				rs485-rts-delay = <0 0>;
./arch/arm/boot/dts/aks-cdu.dts:				linux,rs485-enabled-at-boot-time;
./arch/arm/boot/dts/aks-cdu.dts:				rs485-rts-delay = <0 0>;
./arch/arm/boot/dts/aks-cdu.dts:				linux,rs485-enabled-at-boot-time;
./arch/arm/boot/dts/aks-cdu.dts:				rs485-rts-delay = <0 0>;
./arch/arm/boot/dts/spear1310-evb.dts:				rs485 {
./arch/arm/boot/dts/spear1310-evb.dts:					st,pins = "rs485_0_1_tdm_0_1_grp";
./arch/arm/boot/dts/spear1310-evb.dts:					st,function = "rs485_0_1_tdm_0_1";
./arch/arm/boot/compressed/head.S:		add	r1, r1, #1048576
./arch/arm/boot/compressed/head.S:		add	r1, r1, #1048576
./arch/arm/mach-rpc/riscpc.c:		.length		= 	2*1048576,
./arch/arm/mach-spear/spear320.c:		.bus_id = "rs485_rx",
./arch/arm/mach-spear/spear320.c:		.bus_id = "rs485_tx",
./arch/arm/tools/mach-types:omap4_bsc_bap_v3	MACH_OMAP4_BSC_BAP_V3	OMAP4_BSC_BAP_V3	4485
./arch/xtensa/include/uapi/asm/ioctls.h:#define TIOCGRS485	_IOR('T', 46, struct serial_rs485)
./arch/xtensa/include/uapi/asm/ioctls.h:#define TIOCSRS485	_IOWR('T', 47, struct serial_rs485)
./arch/parisc/include/uapi/asm/ioctls.h:#define TIOCGRS485	_IOR('T', 0x2E, struct serial_rs485)
./arch/parisc/include/uapi/asm/ioctls.h:#define TIOCSRS485	_IOWR('T', 0x2F, struct serial_rs485)
./arch/parisc/kernel/hardware.c:	{HPHW_NPROC,0x485,0x4,0x81,"UL Proc L-75 (801/D200)"},
./arch/parisc/kernel/hardware.c:	{HPHW_A_DIRECT, 0x00F, 0x0000D, 0x00, "Nautilus RS-485"}, 
./Documentation/networking/mpls-sysctl.txt:	Possible values: 0 - 1048575
./Documentation/networking/cxacru-cf.py:# Warning: cxacru-cf.bin with MD5 hash cdbac2689969d5ed5d4850f117702110
./Documentation/video4linux/CARDLIST.saa7134:152 -> Asus Tiger Rev:1.00                      [1043:4857]
./Documentation/video4linux/omap4_camera.txt:[2] http://lwn.net/Articles/420485/
./Documentation/serial/00-INDEX:serial-rs485.txt
./Documentation/serial/00-INDEX:	- info about RS485 structures and support in the kernel.
./Documentation/serial/serial-rs485.txt:                        RS485 SERIAL COMMUNICATIONS
./Documentation/serial/serial-rs485.txt:   EIA-485, also known as TIA/EIA-485 or RS-485, is a standard defining the
./Documentation/serial/serial-rs485.txt:   half-duplex hardware like an RS485 transceiver or any RS232-connected
./Documentation/serial/serial-rs485.txt:   The Linux kernel provides the serial_rs485 structure (see [1]) to handle
./Documentation/serial/serial-rs485.txt:   RS485 communications. This data structure is used to set and configure RS485
./Documentation/serial/serial-rs485.txt:   The device tree can also provide RS485 boot time parameters (see [2]
./Documentation/serial/serial-rs485.txt:   Any driver for devices capable of working both as RS232 and RS485 should
./Documentation/serial/serial-rs485.txt:   implement the rs485_config callback in the uart_port structure. The
./Documentation/serial/serial-rs485.txt:   serial_core calls rs485_config to do the device specific part in response
./Documentation/serial/serial-rs485.txt:   to TIOCSRS485 and TIOCGRS485 ioctls (see below). The rs485_config callback
./Documentation/serial/serial-rs485.txt:   receives a pointer to struct serial_rs485.
./Documentation/serial/serial-rs485.txt:   From user-level, RS485 configuration can be get/set using the previous
./Documentation/serial/serial-rs485.txt:   ioctls. For instance, to set RS485 you can use the following code:
./Documentation/serial/serial-rs485.txt:	/* RS485 ioctls: */
./Documentation/serial/serial-rs485.txt:	#define TIOCGRS485      0x542E
./Documentation/serial/serial-rs485.txt:	#define TIOCSRS485      0x542F
./Documentation/serial/serial-rs485.txt:	struct serial_rs485 rs485conf;
./Documentation/serial/serial-rs485.txt:	/* Enable RS485 mode: */
./Documentation/serial/serial-rs485.txt:	rs485conf.flags |= SER_RS485_ENABLED;
./Documentation/serial/serial-rs485.txt:	rs485conf.flags |= SER_RS485_RTS_ON_SEND;
./Documentation/serial/serial-rs485.txt:	rs485conf.flags &= ~(SER_RS485_RTS_ON_SEND);
./Documentation/serial/serial-rs485.txt:	rs485conf.flags |= SER_RS485_RTS_AFTER_SEND;
./Documentation/serial/serial-rs485.txt:	rs485conf.flags &= ~(SER_RS485_RTS_AFTER_SEND);
./Documentation/serial/serial-rs485.txt:	rs485conf.delay_rts_before_send = ...;
./Documentation/serial/serial-rs485.txt:	rs485conf.delay_rts_after_send = ...;
./Documentation/serial/serial-rs485.txt:	rs485conf.flags |= SER_RS485_RX_DURING_TX;
./Documentation/serial/serial-rs485.txt:	if (ioctl (fd, TIOCSRS485, &rs485conf) < 0) {
./Documentation/serial/serial-rs485.txt: [2]	Documentation/devicetree/bindings/serial/rs485.txt
./Documentation/filesystems/qnx6.txt:to 16 * 256 * 256 = 1048576 blocks that can be addressed by such a tree).
./Documentation/frv/mmu-layout.txt:		  0x248001, 0x248101, 0x248201, 0x248301, 0x248401, 0x248501,
./Documentation/trace/ftrace.txt:          <idle>-0     [001] .Ns3 21169.031485: sub_preempt_count <-_raw_spin_unlock
./Documentation/cgroups/net_cls.txt:1048577
./Documentation/cgroups/blkio-controller.txt:        echo "8:16  1048576" > /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
./Documentation/ldm.txt:  hda1   |     51380224   100352   49 |      1048576     2048    1
./Documentation/ldm.txt:  hda3   |      6995968    13664    6 |     10485760    20480   10
./Documentation/ldm.txt:  hda6   |     26918912    52576   25 |     10485760    20480   10
./Documentation/DMA-API.txt: [<ffffffff80485f26>] nv_tx_done_optimized+0xc6/0x2c0
./Documentation/EDID/1920x1080.S:#define CLOCK 148500 /* kHz */
./Documentation/zh_CN/magic-number.txt:LABELCL_MAGIC         0x4857434c  labelcl_info_s    include/asm/ia64/sn/labelcl.h
./Documentation/devicetree/bindings/pinctrl/pinctrl_spear.txt:	"uart5_grp", "fsmc_grp", "rs485_0_grp", "rs485_1_grp", "tdm_grp"
./Documentation/devicetree/bindings/pinctrl/pinctrl_spear.txt:	"uart6_88_89_grp", "rs485_grp", "touchscreen_grp", "can0_grp",
./Documentation/devicetree/bindings/pinctrl/pinctrl_spear.txt:	"uart4_grp", "uart5_grp", "rs485_0_1_tdm_0_1_grp", "i2c_1_2_grp",
./Documentation/devicetree/bindings/pinctrl/pinctrl_spear.txt:	"emi", "uart1", "uart2", "uart3", "uart4", "uart5", "fsmc", "rs485_0",
./Documentation/devicetree/bindings/pinctrl/pinctrl_spear.txt:	"rs485_1", "tdm"
./Documentation/devicetree/bindings/pinctrl/pinctrl_spear.txt:	"uart2", "uart3", "uart4", "uart5", "uart6", "rs485", "touchscreen",
./Documentation/devicetree/bindings/pinctrl/pinctrl_spear.txt:	"uart4", "uart5", "rs485_0_1_tdm_0_1", "i2c_1_2", "i2c3_i2s1",
./Documentation/devicetree/bindings/serial/rs485.txt:* RS485 serial communications
./Documentation/devicetree/bindings/serial/rs485.txt:- rs485-rts-delay: prop-encoded-array <a b> where:
./Documentation/devicetree/bindings/serial/rs485.txt:- linux,rs485-enabled-at-boot-time: empty property telling to enable the rs485
./Documentation/devicetree/bindings/serial/rs485.txt:- rs485-rx-during-tx: empty property that enables the receiving of data even
./Documentation/devicetree/bindings/serial/rs485.txt:RS485 example for Atmel USART:
./Documentation/devicetree/bindings/serial/rs485.txt:		linux,rs485-enabled-at-boot-time;
./Documentation/devicetree/bindings/serial/rs485.txt:		rs485-rts-delay = <0 200>;		// in milliseconds
./Documentation/devicetree/bindings/display/panel/display-timing.txt:		clock-frequency = <148500000>;
./Documentation/magic-number.txt:LABELCL_MAGIC         0x4857434c  labelcl_info_s    include/asm/ia64/sn/labelcl.h
./Documentation/RCU/trace.txt:  1 c=14407 g=14408 cnq=1/0:0 dt=100679/140000000000000/0 df=378 of=7 ql=0/119 qs=NRW. kt=0/W ktl=9b6 b=10 ci=109740 nci=0 co=589 ca=485
./Documentation/DocBook/media/typical_media_device.svg:</g><g transform="matrix(1.015 0 0 .99994 -2233.3 -2185.7)" class="com.sun.star.drawing.CustomShape"><g stroke="#3465af" fill="none"><path d="m3e3 2800c-18 0-35 1-53 3"/><path d="m2915 2808c-17 3-35 7-52 12"/><path d="m2832 2830c-16 6-33 12-49 20"/><path d="m2754 2864c-15 8-31 17-46 27"/><path d="m2681 2909c-14 10-28 21-42 32"/><path d="m2614 2962c-13 12-26 24-38 37"/><path d="m2554 3023c-11 13-22 27-33 41"/><path d="m2502 3091c-10 14-19 29-28 45"/><path d="m2459 3164c-8 16-15 32-22 49"/><path d="m2426 3243c-5 17-10 34-14 51"/><path d="m2406 3326c-3 18-5 35-6 53"/><path d="m2400 3411v53"/><path d="m2400 3497v53"/><path d="m2400 3582v53"/><path d="m2400 3668v53"/><path d="m2400 3753v53"/><path d="m2400 3839v53"/><path d="m2400 3924v53"/><path d="m2400 4009v54"/><path d="m2400 4095v53"/><path d="m2400 4180v53"/><path d="m2400 4266v53"/><path d="m2400 4351v53"/><path d="m2400 4437v53"/><path d="m2400 4522v53"/><path d="m2400 4607v54"/><path d="m2400 4693v53"/><path d="m2400 4778v53"/><path d="m2400 4864v53"/><path d="m2400 4949v53"/><path d="m2400 5035v53"/><path d="m2400 5120v53"/><path d="m2400 5205v54"/><path d="m2400 5291v53"/><path d="m2400 5376v53"/><path d="m2400 5462v53"/><path d="m2400 5547v53"/><path d="m2400 5633v53"/><path d="m2400 5718v53"/><path d="m2400 5803c0 18 1 36 3 53"/><path d="m2408 5888c4 18 8 35 13 52"/><path d="m2431 5971c6 16 13 33 20 49"/><path d="m2466 6049c8 15 17 31 27 46"/><path d="m2511 6122c10 14 21 28 32 42"/><path d="m2564 6188c12 13 25 26 38 38"/><path d="m2626 6248c13 11 27 23 41 33"/><path d="m2694 6300c14 10 29 19 45 27"/><path d="m2768 6343c15 7 32 15 48 21"/><path d="m2847 6375c17 5 34 10 51 14"/><path d="m2930 6395c17 2 35 4 53 5"/><path d="m3015 6400h53"/><path d="m3100 6400h53"/><path d="m3186 6400h53"/><path d="m3271 6400h53"/><path d="m3357 6400h53"/><path d="m3442 6400h53"/><path d="m3527 6400h54"/><path d="m3613 6400h53"/><path d="m3698 6400h53"/><path d="m3784 6400h53"/><path d="m3869 6400h53"/><path d="m3955 6400h53"/><path d="m4040 6400h53"/><path d="m4125 6400h54"/><path d="m4211 6400h53"/><path d="m4296 6400h53"/><path d="m4382 6400h53"/><path d="m4467 6400h53"/><path d="m4553 6400h53"/><path d="m4638 6400h53"/><path d="m4723 6400h54"/><path d="m4809 6400h53"/><path d="m4894 6400h53"/><path d="m4980 6400h53"/><path d="m5065 6400h53"/><path d="m5151 6400h53"/><path d="m5236 6400h53"/><path d="m5322 6400h53"/><path d="m5407 6400h53"/><path d="m5492 6400h53"/><path d="m5578 6400h53"/><path d="m5663 6400h53"/><path d="m5749 6400h53"/><path d="m5834 6400h53"/><path d="m5920 6400h53"/><path d="m6005 6400h53"/><path d="m6090 6400h53"/><path d="m6176 6400h53"/><path d="m6261 6400h53"/><path d="m6347 6400h53"/><path d="m6432 6400h53"/><path d="m6518 6400h53"/><path d="m6603 6400h53"/><path d="m6688 6400h54"/><path d="m6774 6400h53"/><path d="m6859 6400h53"/><path d="m6945 6400h53"/><path d="m7030 6400h53"/><path d="m7116 6400h53"/><path d="m7201 6400h53"/><path d="m7286 6400h54"/><path d="m7372 6400h53"/><path d="m7457 6400h53"/><path d="m7543 6400h53"/><path d="m7628 6400h53"/><path d="m7714 6400h53"/><path d="m7799 6400h53"/><path d="m7884 6400h54"/><path d="m7970 6400h53"/><path d="m8055 6400h53"/><path d="m8141 6400h53"/><path d="m8226 6400h53"/><path d="m8312 6400h53"/><path d="m8397 6400h53"/><path d="m8482 6400h54"/><path d="m8568 6400h53"/><path d="m8653 6400h53"/><path d="m8739 6400h53"/><path d="m8824 6400h53"/><path d="m8910 6400h53"/><path d="m8995 6400h53"/><path d="m9081 6400h53"/><path d="m9166 6400h53"/><path d="m9251 6400h53"/><path d="m9337 6400h53"/><path d="m9422 6400h53"/><path d="m9508 6400h53"/><path d="m9593 6400h53"/><path d="m9679 6400h53"/><path d="m9764 6400h53"/><path d="m9849 6400h53"/><path d="m9935 6400h53"/><path d="m10020 6400h53"/><path d="m10106 6400h53"/><path d="m10191 6400h53"/><path d="m10277 6400h53"/><path d="m10362 6400h53"/><path d="m10447 6400h53"/><path d="m10533 6400h53"/><path d="m10618 6400h53"/><path d="m10704 6400h53"/><path d="m10789 6400h53"/><path d="m10875 6400h53"/><path d="m10960 6400h53"/><path d="m11045 6400h54"/><path d="m11131 6400h53"/><path d="m11216 6400h53"/><path d="m11302 6400h53"/><path d="m11387 6400h53"/><path d="m11473 6400h53"/><path d="m11558 6400h53"/><path d="m11643 6400h54"/><path d="m11729 6400h53"/><path d="m11814 6400h53"/><path d="m11900 6400h53"/><path d="m11985 6400h53"/><path d="m12071 6400h53"/><path d="m12156 6400h53"/><path d="m12241 6400h54"/><path d="m12327 6400h53"/><path d="m12412 6400h53"/><path d="m12498 6400h53"/><path d="m12583 6400h53"/><path d="m12669 6400h53"/><path d="m12754 6400h53"/><path d="m12839 6400h54"/><path d="m12925 6400h53"/><path d="m13010 6400h53"/><path d="m13096 6400h53"/><path d="m13181 6400h53"/><path d="m13267 6400h53"/><path d="m13352 6400h53"/><path d="m13438 6400h53"/><path d="m13523 6400h53"/><path d="m13608 6400h53"/><path d="m13694 6400h53"/><path d="m13779 6400h53"/><path d="m13865 6400h53"/><path d="m13950 6400h53"/><path d="m14036 6400h53"/><path d="m14121 6400h53"/><path d="m14206 6400h53"/><path d="m14292 6400h53"/><path d="m14377 6400h53"/><path d="m14463 6400h53"/><path d="m14548 6400h53"/><path d="m14634 6400h53"/><path d="m14719 6400h53"/><path d="m14804 6400h54"/><path d="m14890 6400h53"/><path d="m14975 6400h53"/><path d="m15061 6400h53"/><path d="m15146 6400h53"/><path d="m15232 6400h53"/><path d="m15317 6400h53"/><path d="m15402 6400h54"/><path d="m15488 6400h53"/><path d="m15573 6400h53"/><path d="m15659 6400h53"/><path d="m15744 6400h53"/><path d="m15830 6400h53"/><path d="m15915 6400h53"/><path d="m16000 6400h54"/><path d="m16086 6400h53"/><path d="m16171 6400h53"/><path d="m16257 6400h53"/><path d="m16342 6400h53"/><path d="m16428 6400h53"/><path d="m16513 6400h53"/><path d="m16598 6400h54"/><path d="m16684 6400h53"/><path d="m16769 6400h53"/><path d="m16855 6400h53"/><path d="m16940 6400h53"/><path d="m17026 6400h53"/><path d="m17111 6400h53"/><path d="m17196 6400h54"/><path d="m17282 6400h53"/><path d="m17367 6400h53"/><path d="m17453 6400h53"/><path d="m17538 6400h53"/><path d="m17624 6400h53"/><path d="m17709 6400h53"/><path d="m17795 6400h53"/><path d="m17880 6400h53"/><path d="m17965 6400h53"/><path d="m18051 6400h53"/><path d="m18136 6400h53"/><path d="m18222 6400h53"/><path d="m18307 6400h53"/><path d="m18393 6400h53"/><path d="m18478 6400h53"/><path d="m18563 6400h53"/><path d="m18649 6400h53"/><path d="m18734 6400h53"/><path d="m18820 6400h53"/><path d="m18905 6400h53"/><path d="m18991 6400h53"/><path d="m19076 6400h53"/><path d="m19161 6400h54"/><path d="m19247 6400h53"/><path d="m19332 6400h53"/><path d="m19418 6400h53"/><path d="m19503 6400h53"/><path d="m19589 6400h53"/><path d="m19674 6400h53"/><path d="m19759 6400h54"/><path d="m19845 6400h53"/><path d="m19930 6400h53"/><path d="m20016 6400h53"/><path d="m20101 6400h53"/><path d="m20187 6400h53"/><path d="m20272 6400h53"/><path d="m20357 6400h54"/><path d="m20443 6400h53"/><path d="m20528 6400h53"/><path d="m20614 6400c17-1 35-2 53-5"/><path d="m20699 6390c17-4 34-9 51-14"/><path d="m20781 6365c16-6 32-13 48-21"/><path d="m20858 6329c15-8 31-17 45-27"/><path d="m20930 6283c14-10 28-21 42-32"/><path d="m20996 6229c13-12 25-25 37-38"/><path d="m21055 6167c11-14 22-28 33-42"/><path d="m21106 6098c10-15 19-30 27-45"/><path d="m21148 6024c7-16 14-33 20-49"/><path d="m21179 5944c5-17 9-34 13-51"/><path d="m21197 5861c2-18 4-35 4-53"/><path d="m21201 5776v-54"/><path d="m21201 5690v-53"/><path d="m21201 5605v-53"/><path d="m21201 5519v-53"/><path d="m21201 5434v-53"/><path d="m21201 5348v-53"/><path d="m21201 5263v-53"/><path d="m21201 5178v-54"/><path d="m21201 5092v-53"/><path d="m21201 5007v-53"/><path d="m21201 4921v-53"/><path d="m21201 4836v-53"/><path d="m21201 4750v-53"/><path d="m21201 4665v-53"/><path d="m21201 4579v-53"/><path d="m21201 4494v-53"/><path d="m21201 4409v-53"/><path d="m21201 4323v-53"/><path d="m21201 4238v-53"/><path d="m21201 4152v-53"/><path d="m21201 4067v-53"/><path d="m21201 3981v-53"/><path d="m21201 3896v-53"/><path d="m21201 3811v-53"/><path d="m21201 3725v-53"/><path d="m21201 3640v-53"/><path d="m21201 3554v-53"/><path d="m21201 3469v-53"/><path d="m21201 3383c-1-17-3-35-5-52"/><path d="m21190 3299c-4-17-8-35-14-51"/><path d="m21165 3217c-6-16-13-33-21-49"/><path d="m21129 3140c-9-16-18-31-28-46"/><path d="m21082 3068c-10-14-21-28-33-42"/><path d="m21027 3002c-12-13-24-25-37-37"/><path d="m20965 2944c-14-12-28-22-42-33"/><path d="m20896 2893c-15-9-30-18-46-27"/><path d="m20821 2852c-16-8-32-14-49-20"/><path d="m20741 2821c-17-5-34-9-51-12"/><path d="m20658 2804c-18-3-35-4-53-4"/><path d="m20573 2800h-53"/><path d="m20487 2800h-53"/><path d="m20402 2800h-53"/><path d="m20316 2800h-53"/><path d="m20231 2800h-53"/><path d="m20146 2800h-54"/><path d="m20060 2800h-53"/><path d="m19975 2800h-53"/><path d="m19889 2800h-53"/><path d="m19804 2800h-53"/><path d="m19718 2800h-53"/><path d="m19633 2800h-53"/><path d="m19548 2800h-54"/><path d="m19462 2800h-53"/><path d="m19377 2800h-53"/><path d="m19291 2800h-53"/><path d="m19206 2800h-53"/><path d="m19120 2800h-53"/><path d="m19035 2800h-53"/><path d="m18950 2800h-54"/><path d="m18864 2800h-53"/><path d="m18779 2800h-53"/><path d="m18693 2800h-53"/><path d="m18608 2800h-53"/><path d="m18522 2800h-53"/><path d="m18437 2800h-53"/><path d="m18352 2800h-54"/><path d="m18266 2800h-53"/><path d="m18181 2800h-53"/><path d="m18095 2800h-53"/><path d="m18010 2800h-53"/><path d="m17924 2800h-53"/><path d="m17839 2800h-53"/><path d="m17753 2800h-53"/><path d="m17668 2800h-53"/><path d="m17583 2800h-53"/><path d="m17497 2800h-53"/><path d="m17412 2800h-53"/><path d="m17326 2800h-53"/><path d="m17241 2800h-53"/><path d="m17155 2800h-53"/><path d="m17070 2800h-53"/><path d="m16985 2800h-53"/><path d="m16899 2800h-53"/><path d="m16814 2800h-53"/><path d="m16728 2800h-53"/><path d="m16643 2800h-53"/><path d="m16557 2800h-53"/><path d="m16472 2800h-53"/><path d="m16387 2800h-54"/><path d="m16301 2800h-53"/><path d="m16216 2800h-53"/><path d="m16130 2800h-53"/><path d="m16045 2800h-53"/><path d="m15959 2800h-53"/><path d="m15874 2800h-53"/><path d="m15789 2800h-54"/><path d="m15703 2800h-53"/><path d="m15618 2800h-53"/><path d="m15532 2800h-53"/><path d="m15447 2800h-53"/><path d="m15361 2800h-53"/><path d="m15276 2800h-53"/><path d="m15191 2800h-54"/><path d="m15105 2800h-53"/><path d="m15020 2800h-53"/><path d="m14934 2800h-53"/><path d="m14849 2800h-53"/><path d="m14763 2800h-53"/><path d="m14678 2800h-53"/><path d="m14593 2800h-54"/><path d="m14507 2800h-53"/><path d="m14422 2800h-53"/><path d="m14336 2800h-53"/><path d="m14251 2800h-53"/><path d="m14165 2800h-53"/><path d="m14080 2800h-53"/><path d="m13994 2800h-53"/><path d="m13909 2800h-53"/><path d="m13824 2800h-53"/><path d="m13738 2800h-53"/><path d="m13653 2800h-53"/><path d="m13567 2800h-53"/><path d="m13482 2800h-53"/><path d="m13396 2800h-53"/><path d="m13311 2800h-53"/><path d="m13226 2800h-53"/><path d="m13140 2800h-53"/><path d="m13055 2800h-53"/><path d="m12969 2800h-53"/><path d="m12884 2800h-53"/><path d="m12798 2800h-53"/><path d="m12713 2800h-53"/><path d="m12628 2800h-53"/><path d="m12542 2800h-53"/><path d="m12457 2800h-53"/><path d="m12371 2800h-53"/><path d="m12286 2800h-53"/><path d="m12200 2800h-53"/><path d="m12115 2800h-53"/><path d="m12030 2800h-54"/><path d="m11944 2800h-53"/><path d="m11859 2800h-53"/><path d="m11773 2800h-53"/><path d="m11688 2800h-53"/><path d="m11602 2800h-53"/><path d="m11517 2800h-53"/><path d="m11432 2800h-54"/><path d="m11346 2800h-53"/><path d="m11261 2800h-53"/><path d="m11175 2800h-53"/><path d="m11090 2800h-53"/><path d="m11004 2800h-53"/><path d="m10919 2800h-53"/><path d="m10834 2800h-54"/><path d="m10748 2800h-53"/><path d="m10663 2800h-53"/><path d="m10577 2800h-53"/><path d="m10492 2800h-53"/><path d="m10406 2800h-53"/><path d="m10321 2800h-53"/><path d="m10236 2800h-54"/><path d="m10150 2800h-53"/><path d="m10065 2800h-53"/><path d="m9979 2800h-53"/><path d="m9894 2800h-53"/><path d="m9808 2800h-53"/><path d="m9723 2800h-53"/><path d="m9637 2800h-53"/><path d="m9552 2800h-53"/><path d="m9467 2800h-53"/><path d="m9381 2800h-53"/><path d="m9296 2800h-53"/><path d="m9210 2800h-53"/><path d="m9125 2800h-53"/><path d="m9039 2800h-53"/><path d="m8954 2800h-53"/><path d="m8869 2800h-53"/><path d="m8783 2800h-53"/><path d="m8698 2800h-53"/><path d="m8612 2800h-53"/><path d="m8527 2800h-53"/><path d="m8441 2800h-53"/><path d="m8356 2800h-53"/><path d="m8271 2800h-54"/><path d="m8185 2800h-53"/><path d="m8100 2800h-53"/><path d="m8014 2800h-53"/><path d="m7929 2800h-53"/><path d="m7843 2800h-53"/><path d="m7758 2800h-53"/><path d="m7673 2800h-54"/><path d="m7587 2800h-53"/><path d="m7502 2800h-53"/><path d="m7416 2800h-53"/><path d="m7331 2800h-53"/><path d="m7245 2800h-53"/><path d="m7160 2800h-53"/><path d="m7075 2800h-54"/><path d="m6989 2800h-53"/><path d="m6904 2800h-53"/><path d="m6818 2800h-53"/><path d="m6733 2800h-53"/><path d="m6647 2800h-53"/><path d="m6562 2800h-53"/><path d="m6477 2800h-54"/><path d="m6391 2800h-53"/><path d="m6306 2800h-53"/><path d="m6220 2800h-53"/><path d="m6135 2800h-53"/><path d="m6049 2800h-53"/><path d="m5964 2800h-53"/><path d="m5879 2800h-54"/><path d="m5793 2800h-53"/><path d="m5708 2800h-53"/><path d="m5622 2800h-53"/><path d="m5537 2800h-53"/><path d="m5451 2800h-53"/><path d="m5366 2800h-53"/><path d="m5280 2800h-53"/><path d="m5195 2800h-53"/><path d="m5110 2800h-53"/><path d="m5024 2800h-53"/><path d="m4939 2800h-53"/><path d="m4853 2800h-53"/><path d="m4768 2800h-53"/><path d="m4682 2800h-53"/><path d="m4597 2800h-53"/><path d="m4512 2800h-53"/><path d="m4426 2800h-53"/><path d="m4341 2800h-53"/><path d="m4255 2800h-53"/><path d="m4170 2800h-53"/><path d="m4084 2800h-53"/><path d="m3999 2800h-53"/><path d="m3914 2800h-54"/><path d="m3828 2800h-53"/><path d="m3743 2800h-53"/><path d="m3657 2800h-53"/><path d="m3572 2800h-53"/><path d="m3486 2800h-53"/><path d="m3401 2800h-53"/><path d="m3316 2800h-54"/><path d="m3230 2800h-53"/><path d="m3145 2800h-53"/><path d="m3059 2800h-53"/></g></g><g transform="translate(-2197.3 -2186)"><rect height="1100.7" width="1213.6" y="6917.1" x="23255" fill="#f3e777"/><path fill="#ca4677" d="m22802 7700.4v-405.46l150.7-169.16c82.886-93.039 170.53-186.62 194.77-207.96l44.069-38.798 783.23-0.086 783.23-0.086v613.5 613.5h-978-978v-405.46zm1027.7 136.98v-78.372l-169.91 4.925-169.91 4.9249-5.09 45.854c-8.249 74.303 46.711 101.04 207.69 101.04h137.21v-78.372zm235.86-262.94 4.495-341.31 207.2-8.6408 207.2-8.6408 5.144-46.443c9.596-86.615-41.863-102.05-322.02-96.607l-246.71 4.7956-4.438 419.08-4.439 419.08h74.537 74.538l4.494-341.31zm391.3 313.72c26.41-19.286 36.255-41.399 32.697-73.447l-5.09-45.854h-174.05-174.05l-5.38 48.984c-9.97 90.771 0.993 97.91 150.36 97.91 99.305 0 148.27-7.6982 175.52-27.594zm-627.16-274.84v-77.768h-174.05-174.05v66.246c0 36.436 4.973 71.431 11.051 77.768 6.078 6.3366 84.401 11.521 174.05 11.521h163v-77.768zm659.89-4.9154 5.125-74.042-179.18 4.9155-179.18 4.9155-5.38 48.984c-10.473 95.348-2.259 99.57 183.28 94.197l170.2-4.9284 5.125-74.042zm-659.89-237.63v-78.372l-169.91 4.925-169.91 4.925-5.097 73.447-5.097 73.447h175 175v-78.372zm659.86 4.925-5.097-73.447h-174.05-174.05l-5.38 48.984c-10.289 93.673-2.146 97.91 188.15 97.91h175.52l-5.097-73.447zm-659.86-228.98v-77.768h-137.21c-97.358 0-147.91 7.8138-174.05 26.902-34.952 25.523-49.645 92.242-25.79 117.11 6.078 6.3366 84.401 11.521 174.05 11.521h163v-77.768z"/></g><g transform="matrix(.84874 0 0 .76147 2408.1 3615.3)"><rect height="3076.2" width="2734.3" y="13264" x="19249" fill="#6076b3"/><g stroke-linejoin="round" fill-rule="evenodd" stroke-width="28.222" fill="#e0ee2c"><rect y="13369" width="356.65" x="18937" height="180.95"/><rect y="13708" width="356.65" x="18937" height="180.95"/><rect y="14048" width="356.65" x="18937" height="180.95"/><rect y="14387" width="356.65" x="18937" height="180.95"/><rect y="14726" width="356.65" x="18937" height="180.95"/><rect y="15066" width="356.65" x="18937" height="180.95"/><rect y="15405" width="356.65" x="18937" height="180.95"/><rect y="15744" width="356.65" x="18937" height="180.95"/><rect y="16083" width="356.65" x="18937" height="180.95"/><rect y="13324" width="356.65" x="21939" height="180.95"/><rect y="13663" width="356.65" x="21939" height="180.95"/><rect y="14002" width="356.65" x="21939" height="180.95"/><rect y="14342" width="356.65" x="21939" height="180.95"/><rect y="14681" width="356.65" x="21939" height="180.95"/><rect y="15020" width="356.65" x="21939" height="180.95"/><rect y="15360" width="356.65" x="21939" height="180.95"/><rect y="15699" width="356.65" x="21939" height="180.95"/><rect y="16038" width="356.65" x="21939" height="180.95"/></g><g stroke-linejoin="round" fill-rule="evenodd" transform="matrix(.98702 0 0 .90336 -2675 7020.8)" class="com.sun.star.drawing.TextShape" stroke-width="28.222"><text class="TextShape"><tspan font-size="635px" font-family="&apos;Times New Roman&apos;, serif" font-weight="400" class="TextParagraph"/></text>
./Documentation/DocBook/media/dvbstb.png.b64:85tYtGhRFBQUxI9//GNvJ+N9ETMAgKjhglu/fn3MnTs39u7dG/Pnz485c+Z4WyJiBgAQNaSv8vLy
./Documentation/ABI/testing/sysfs-platform-ts5500:What:		/sys/devices/platform/ts5500/rs485
./Documentation/ABI/testing/sysfs-platform-ts5500:		Indicates the presence of the RS485 option. If it is present,
./Documentation/sysctl/fs.txt:allocate. Default value is 1024*1024 (1048576) which should be
./drivers/staging/lustre/lustre/ptlrpc/wiretest.c:	CLASSERT(OBD_CFG_REC == 274857984);
./drivers/staging/lustre/lnet/Kconfig:	default "1048576"
./drivers/staging/comedi/drivers/gsc_hpdi.c: * High Speed Parallel Digital Interface rs485 boards.
./drivers/staging/comedi/drivers/gsc_hpdi.c: *    Speed Parallel Digital Interface rs485 boards
./drivers/staging/comedi/Kconfig:	  digital interface rs485 boards PCI-HPDI32 and PMC-HPDI32.
./drivers/staging/skein/skein_base.h:#define SKEIN_ID_STRING_LE      (0x33414853) /* "SHA3" (little-endian)*/
./drivers/staging/gdm724x/gdm_mux.h:#define START_FLAG 0xA512485A
./drivers/staging/rtl8188eu/hal/rf_cfg.c:		0x0B6, 0x00048538,
./drivers/staging/dgnc/dgnc_neo.h:#define UART_17158_FCTR_RS485		0x20
./drivers/staging/dgnc/dgnc_driver.c:	{	PCI_DEVICE_NEO_1_422_485_PCI_NAME,	1,	0	},
./drivers/staging/dgnc/dgnc_driver.c:	{	PCI_DEVICE_NEO_2_422_485_PCI_NAME,	2,	0	},
./drivers/staging/dgnc/dgnc_driver.c:	case PCI_DEVICE_NEO_1_422_485_DID:
./drivers/staging/dgnc/dgnc_driver.c:	case PCI_DEVICE_NEO_2_422_485_DID:
./drivers/staging/dgnc/dgnc_pci.h:#define PCI_DEVICE_NEO_1_422_485_DID		0x00CD
./drivers/staging/dgnc/dgnc_pci.h:#define PCI_DEVICE_NEO_2_422_485_DID		0x00CE
./drivers/staging/dgnc/dgnc_pci.h:#define PCI_DEVICE_NEO_1_422_485_PCI_NAME	"Neo 1 422/485 PCI"
./drivers/staging/dgnc/dgnc_pci.h:#define PCI_DEVICE_NEO_2_422_485_PCI_NAME	"Neo 2 422/485 PCI"
./drivers/thermal/ti-soc-thermal/omap3-thermal-data.c:	47000, 48500, 50000, 52000, 53500, 55000, 57000, 58500, 60000,
./drivers/pinctrl/spear/pinctrl-spear320.c:	#define PMX_RS485_PL_77_78_79_VAL	((0x4 << 21) | (0x4 << 24) | (0x4 << 27))
./drivers/pinctrl/spear/pinctrl-spear320.c:/* UART - RS485 pmx */
./drivers/pinctrl/spear/pinctrl-spear320.c:static const unsigned rs485_pins[] = { 77, 78, 79 };
./drivers/pinctrl/spear/pinctrl-spear320.c:static struct spear_muxreg rs485_muxreg[] = {
./drivers/pinctrl/spear/pinctrl-spear320.c:		.val = PMX_RS485_PL_77_78_79_VAL,
./drivers/pinctrl/spear/pinctrl-spear320.c:static struct spear_modemux rs485_modemux[] = {
./drivers/pinctrl/spear/pinctrl-spear320.c:		.muxregs = rs485_muxreg,
./drivers/pinctrl/spear/pinctrl-spear320.c:		.nmuxregs = ARRAY_SIZE(rs485_muxreg),
./drivers/pinctrl/spear/pinctrl-spear320.c:static struct spear_pingroup rs485_pingroup = {
./drivers/pinctrl/spear/pinctrl-spear320.c:	.name = "rs485_grp",
./drivers/pinctrl/spear/pinctrl-spear320.c:	.pins = rs485_pins,
./drivers/pinctrl/spear/pinctrl-spear320.c:	.npins = ARRAY_SIZE(rs485_pins),
./drivers/pinctrl/spear/pinctrl-spear320.c:	.modemuxs = rs485_modemux,
./drivers/pinctrl/spear/pinctrl-spear320.c:	.nmodemuxs = ARRAY_SIZE(rs485_modemux),
./drivers/pinctrl/spear/pinctrl-spear320.c:static const char *const rs485_grps[] = { "rs485_grp" };
./drivers/pinctrl/spear/pinctrl-spear320.c:static struct spear_function rs485_function = {
./drivers/pinctrl/spear/pinctrl-spear320.c:	.name = "rs485",
./drivers/pinctrl/spear/pinctrl-spear320.c:	.groups = rs485_grps,
./drivers/pinctrl/spear/pinctrl-spear320.c:	.ngroups = ARRAY_SIZE(rs485_grps),
./drivers/pinctrl/spear/pinctrl-spear320.c:	&rs485_pingroup,
./drivers/pinctrl/spear/pinctrl-spear320.c:	&rs485_function,
./drivers/pinctrl/spear/pinctrl-spear1310.c:/* Pad multiplexing for rs485_0_1_tdm_0_1 device */
./drivers/pinctrl/spear/pinctrl-spear1310.c:static const unsigned rs485_0_1_tdm_0_1_pins[] = { 116, 117, 118, 119, 120, 121,
./drivers/pinctrl/spear/pinctrl-spear1310.c:static struct spear_muxreg rs485_0_1_tdm_0_1_muxreg[] = {
./drivers/pinctrl/spear/pinctrl-spear1310.c:static struct spear_modemux rs485_0_1_tdm_0_1_modemux[] = {
./drivers/pinctrl/spear/pinctrl-spear1310.c:		.muxregs = rs485_0_1_tdm_0_1_muxreg,
./drivers/pinctrl/spear/pinctrl-spear1310.c:		.nmuxregs = ARRAY_SIZE(rs485_0_1_tdm_0_1_muxreg),
./drivers/pinctrl/spear/pinctrl-spear1310.c:static struct spear_pingroup rs485_0_1_tdm_0_1_pingroup = {
./drivers/pinctrl/spear/pinctrl-spear1310.c:	.name = "rs485_0_1_tdm_0_1_grp",
./drivers/pinctrl/spear/pinctrl-spear1310.c:	.pins = rs485_0_1_tdm_0_1_pins,
./drivers/pinctrl/spear/pinctrl-spear1310.c:	.npins = ARRAY_SIZE(rs485_0_1_tdm_0_1_pins),
./drivers/pinctrl/spear/pinctrl-spear1310.c:	.modemuxs = rs485_0_1_tdm_0_1_modemux,
./drivers/pinctrl/spear/pinctrl-spear1310.c:	.nmodemuxs = ARRAY_SIZE(rs485_0_1_tdm_0_1_modemux),
./drivers/pinctrl/spear/pinctrl-spear1310.c:static const char *const rs485_0_1_tdm_0_1_grps[] = { "rs485_0_1_tdm_0_1_grp" };
./drivers/pinctrl/spear/pinctrl-spear1310.c:static struct spear_function rs485_0_1_tdm_0_1_function = {
./drivers/pinctrl/spear/pinctrl-spear1310.c:	.name = "rs485_0_1_tdm_0_1",
./drivers/pinctrl/spear/pinctrl-spear1310.c:	.groups = rs485_0_1_tdm_0_1_grps,
./drivers/pinctrl/spear/pinctrl-spear1310.c:	.ngroups = ARRAY_SIZE(rs485_0_1_tdm_0_1_grps),
./drivers/pinctrl/spear/pinctrl-spear1310.c:	&rs485_0_1_tdm_0_1_pingroup,
./drivers/pinctrl/spear/pinctrl-spear1310.c:	&rs485_0_1_tdm_0_1_function,
./drivers/pinctrl/spear/pinctrl-spear310.c:/* rs485_0_pins */
./drivers/pinctrl/spear/pinctrl-spear310.c:static const unsigned rs485_0_pins[] = { 19, 20, 21, 22, 23 };
./drivers/pinctrl/spear/pinctrl-spear310.c:static struct spear_muxreg rs485_0_muxreg[] = {
./drivers/pinctrl/spear/pinctrl-spear310.c:static struct spear_modemux rs485_0_modemux[] = {
./drivers/pinctrl/spear/pinctrl-spear310.c:		.muxregs = rs485_0_muxreg,
./drivers/pinctrl/spear/pinctrl-spear310.c:		.nmuxregs = ARRAY_SIZE(rs485_0_muxreg),
./drivers/pinctrl/spear/pinctrl-spear310.c:static struct spear_pingroup rs485_0_pingroup = {
./drivers/pinctrl/spear/pinctrl-spear310.c:	.name = "rs485_0_grp",
./drivers/pinctrl/spear/pinctrl-spear310.c:	.pins = rs485_0_pins,
./drivers/pinctrl/spear/pinctrl-spear310.c:	.npins = ARRAY_SIZE(rs485_0_pins),
./drivers/pinctrl/spear/pinctrl-spear310.c:	.modemuxs = rs485_0_modemux,
./drivers/pinctrl/spear/pinctrl-spear310.c:	.nmodemuxs = ARRAY_SIZE(rs485_0_modemux),
./drivers/pinctrl/spear/pinctrl-spear310.c:static const char *const rs485_0_grps[] = { "rs485_0" };
./drivers/pinctrl/spear/pinctrl-spear310.c:static struct spear_function rs485_0_function = {
./drivers/pinctrl/spear/pinctrl-spear310.c:	.name = "rs485_0",
./drivers/pinctrl/spear/pinctrl-spear310.c:	.groups = rs485_0_grps,
./drivers/pinctrl/spear/pinctrl-spear310.c:	.ngroups = ARRAY_SIZE(rs485_0_grps),
./drivers/pinctrl/spear/pinctrl-spear310.c:/* rs485_1_pins */
./drivers/pinctrl/spear/pinctrl-spear310.c:static const unsigned rs485_1_pins[] = { 14, 15, 16, 17, 18 };
./drivers/pinctrl/spear/pinctrl-spear310.c:static struct spear_muxreg rs485_1_muxreg[] = {
./drivers/pinctrl/spear/pinctrl-spear310.c:static struct spear_modemux rs485_1_modemux[] = {
./drivers/pinctrl/spear/pinctrl-spear310.c:		.muxregs = rs485_1_muxreg,
./drivers/pinctrl/spear/pinctrl-spear310.c:		.nmuxregs = ARRAY_SIZE(rs485_1_muxreg),
./drivers/pinctrl/spear/pinctrl-spear310.c:static struct spear_pingroup rs485_1_pingroup = {
./drivers/pinctrl/spear/pinctrl-spear310.c:	.name = "rs485_1_grp",
./drivers/pinctrl/spear/pinctrl-spear310.c:	.pins = rs485_1_pins,
./drivers/pinctrl/spear/pinctrl-spear310.c:	.npins = ARRAY_SIZE(rs485_1_pins),
./drivers/pinctrl/spear/pinctrl-spear310.c:	.modemuxs = rs485_1_modemux,
./drivers/pinctrl/spear/pinctrl-spear310.c:	.nmodemuxs = ARRAY_SIZE(rs485_1_modemux),
./drivers/pinctrl/spear/pinctrl-spear310.c:static const char *const rs485_1_grps[] = { "rs485_1" };
./drivers/pinctrl/spear/pinctrl-spear310.c:static struct spear_function rs485_1_function = {
./drivers/pinctrl/spear/pinctrl-spear310.c:	.name = "rs485_1",
./drivers/pinctrl/spear/pinctrl-spear310.c:	.groups = rs485_1_grps,
./drivers/pinctrl/spear/pinctrl-spear310.c:	.ngroups = ARRAY_SIZE(rs485_1_grps),
./drivers/pinctrl/spear/pinctrl-spear310.c:	&rs485_0_pingroup,
./drivers/pinctrl/spear/pinctrl-spear310.c:	&rs485_1_pingroup,
./drivers/pinctrl/spear/pinctrl-spear310.c:	&rs485_0_function,
./drivers/pinctrl/spear/pinctrl-spear310.c:	&rs485_1_function,
./drivers/media/platform/ti-vpe/sc_coeff.h:		0x1FA0, 0x1FA0, 0x023C, 0x0485, 0x02A8, 0x1FCD, 0x1F8A,
./drivers/media/platform/ti-vpe/sc_coeff.h:		0x1F8A, 0x1FCD, 0x02A8, 0x0485, 0x023C, 0x1FA0, 0x1FA0,
./drivers/media/platform/ti-vpe/sc_coeff.h:		0x1FA0, 0x1FA0, 0x023C, 0x0485, 0x02A8, 0x1FCD, 0x1F8A,
./drivers/media/platform/ti-vpe/sc_coeff.h:		0x1F8A, 0x1FCD, 0x02A8, 0x0485, 0x023C, 0x1FA0, 0x1FA0,
./drivers/media/platform/vivid/vivid-tpg-colors.c:	 483,  483,  484,  485,  485,  486,  486,  487,  488,  488,  489,  490,  490,  491,  491,  492,
./drivers/media/platform/vivid/vivid-tpg-colors.c:	2462, 2463, 2465, 2466, 2468, 2469, 2471, 2472, 2474, 2475, 2477, 2478, 2480, 2481, 2483, 2485,
./drivers/media/platform/vivid/vivid-tpg-colors.c:	3461, 3463, 3465, 3467, 3468, 3470, 3472, 3474, 3476, 3478, 3480, 3481, 3483, 3485, 3487, 3489,
./drivers/media/platform/vivid/vivid-tpg-colors.c:	 485,  489,  492,  496,  499,  503,  506,  510,  513,  517,  520,  524,  527,  530,  534,  537,
./drivers/media/platform/vivid/vivid-tpg-colors.c:	2485, 2486, 2487, 2488, 2488, 2489, 2490, 2491, 2492, 2493, 2493, 2494, 2495, 2496, 2497, 2498,
./drivers/media/platform/vivid/vivid-tpg-colors.c:	3477, 3478, 3478, 3479, 3479, 3480, 3481, 3481, 3482, 3482, 3483, 3484, 3484, 3485, 3485, 3486,
./drivers/media/platform/vivid/vivid-tpg-colors.c:	{ 0.6274524, 0.3292485, 0.0432991 },
./drivers/media/platform/omap3isp/luma_enhance_table.h:1047552, 1047552, 1047552, 1047552, 1048575, 1047551, 1046527, 1045503,
./drivers/media/platform/omap3isp/luma_enhance_table.h:      0,       5,    5125,   10245,   15365,   20485,   25605,   30720,
./drivers/media/platform/rcar_jpu.c:	0x6a737475, 0x76777879, 0x7a838485, 0x86878889, 0x8a929394, 0x95969798,
./drivers/media/platform/rcar_jpu.c:	0x6a737475, 0x76777879, 0x7a838485, 0x86878889, 0x8a929394, 0x95969798,
./drivers/media/platform/s5p-mfc/regs-mfc-v6.h:			((w) * 144 + 8192 * (h) + 49216 + 1048576)
./drivers/media/platform/s5p-tv/hdmiphy_drv.c:	{ .pixclk = 148500000, .data = (u8 [32]) {
./drivers/media/platform/s5p-tv/hdmiphy_drv.c:	{ .pixclk = 148500000, .data = (u8 [32]) {
./drivers/media/platform/s5p-tv/hdmiphy_drv.c:	{ .pixclk = 148500000, .data = (u8 [32]) {
./drivers/media/platform/s5p-tv/hdmiphy_drv.c:	cap->bt.max_pixelclock = 148500000;
./drivers/media/pci/ivtv/ivtv-driver.c:		case 48400 ... 48599:
./drivers/media/pci/saa7134/saa7134-cards.c:		.subdevice    = 0x4857,		/* REV:1.00 */
./drivers/media/pci/saa7164/saa7164-fw.c:	srcbuf = kzalloc(4 * 1048576, GFP_KERNEL);
./drivers/media/pci/saa7164/saa7164-fw.c:	if (srcsize > (4*1048576)) {
./drivers/media/pci/cobalt/cobalt-cpld.c:#define DCO_MIN 4850000000ULL
./drivers/mtd/bcm47xxpart.c:#define NVRAM_HEADER			0x48534C46	/* FLSH */
./drivers/mtd/maps/pcmciamtd.c:		if(mtd->size < 1048576) { /* <1MiB in size, show size in KiB */
./drivers/misc/eeprom/at24.c:	{ "24c1024", AT24_DEVICE_MAGIC(1048576 / 8, AT24_FLAG_ADDR16) },
./drivers/char/agp/generic.c:	{4096, 1048576, 10,0x000},
./drivers/edac/amd64_edac.c:	0x4857, 0xc4fe, 0x13cc, 0x3288,
./drivers/firmware/broadcom/bcm47xx_nvram.c:#define NVRAM_MAGIC			0x48534C46	/* 'FLSH' */
./drivers/mfd/wm8994-regmap.c:	{ 0x0485, 0x1EB5 },    /* R1157 - AIF1 DAC1 EQ Band 2 A */
./drivers/mfd/wm8994-regmap.c:	{ 0x0485, 0x1EB5 },    /* R1157  - AIF1 DAC1 EQ Band 2 A */ 
./drivers/mfd/wm8994-regmap.c:	{ 0x0485, 0x1EB5 },    /* R1157  - AIF1 DAC1 EQ Band 2 A */
./drivers/atm/idt77252_tables.h:/*    1048576.00 => 255 */ 0xff, /* => 352768.00 */
./drivers/atm/idt77252_tables.h:/*   10485760.00 => 255 */ 0xff, /* => 352768.00 */
./drivers/atm/idt77252_tables.h:/*  104857600.00 => 255 */ 0xff, /* => 352768.00 */
./drivers/ipack/devices/ipoctal.c:		/* In case of RS-485, change from TX to RX when finishing TX.
./drivers/ipack/devices/ipoctal.c:		if (channel->board_id == IPACK1_DEVICE_ID_SBS_OCTAL_485) {
./drivers/ipack/devices/ipoctal.c:	/* As the IP-OCTAL 485 only supports half duplex, do it manually */
./drivers/ipack/devices/ipoctal.c:	if (channel->board_id == IPACK1_DEVICE_ID_SBS_OCTAL_485) {
./drivers/ipack/devices/ipoctal.c:	case IPACK1_DEVICE_ID_SBS_OCTAL_485:
./drivers/ipack/devices/ipoctal.c:			IPACK1_DEVICE_ID_SBS_OCTAL_485) },
./drivers/ipack/devices/ipoctal.c:MODULE_DESCRIPTION("IP-Octal 232, 422 and 485 device driver");
./drivers/parport/parport_sunbpp.c:#include <asm/dma.h>             /* BPP uses LSI 64854 for DMA */
./drivers/bcma/driver_chipcommon_pmu.c:		/* pmu2_xtaltab0_adfll_485 */
./drivers/tty/serial/jsm/jsm_driver.c:	case PCI_DEVICE_ID_NEO_2_422_485:
./drivers/tty/serial/jsm/jsm_driver.c:	case PCI_DEVICE_ID_NEO_2_422_485:
./drivers/tty/serial/jsm/jsm_driver.c:	{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_1_422_485), 0, 0, 8 },
./drivers/tty/serial/jsm/jsm_driver.c:	{ PCI_DEVICE(PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_NEO_2_422_485), 0, 0, 9 },
./drivers/tty/serial/jsm/jsm.h:#define PCI_DEVICE_ID_NEO_1_422_485     0x00CD
./drivers/tty/serial/jsm/jsm.h:#define PCI_DEVICE_ID_NEO_2_422_485     0x00CE
./drivers/tty/serial/jsm/jsm.h:#define UART_17158_FCTR_RS485		0x20
./drivers/tty/serial/zs.c: * 	    is emptied.  On bus types like RS485, the transmitter must
./drivers/tty/serial/zs.c: * 	    allows an RS485 driver to be written in user space.
./drivers/tty/serial/crisv10.h:#ifdef CONFIG_ETRAX_RS485
./drivers/tty/serial/crisv10.h:	struct serial_rs485	rs485;  /* RS-485 support */
./drivers/tty/serial/omap-serial.c:	/* Handle RS-485 */
./drivers/tty/serial/omap-serial.c:	if (port->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/omap-serial.c:			 * disable THR interrupts and toggle the RS-485 GPIO
./drivers/tty/serial/omap-serial.c:			res = (port->rs485.flags & SER_RS485_RTS_AFTER_SEND) ?
./drivers/tty/serial/omap-serial.c:				if (port->rs485.delay_rts_after_send > 0)
./drivers/tty/serial/omap-serial.c:					port->rs485.delay_rts_after_send);
./drivers/tty/serial/omap-serial.c:	if ((port->rs485.flags & SER_RS485_ENABLED) &&
./drivers/tty/serial/omap-serial.c:	    !(port->rs485.flags & SER_RS485_RX_DURING_TX)) {
./drivers/tty/serial/omap-serial.c:	/* Handle RS-485 */
./drivers/tty/serial/omap-serial.c:	if (port->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/omap-serial.c:		res = (port->rs485.flags & SER_RS485_RTS_ON_SEND) ? 1 : 0;
./drivers/tty/serial/omap-serial.c:			if (port->rs485.delay_rts_before_send > 0)
./drivers/tty/serial/omap-serial.c:				mdelay(port->rs485.delay_rts_before_send);
./drivers/tty/serial/omap-serial.c:	if ((port->rs485.flags & SER_RS485_ENABLED) &&
./drivers/tty/serial/omap-serial.c:	    !(port->rs485.flags & SER_RS485_RX_DURING_TX))
./drivers/tty/serial/omap-serial.c:/* Enable or disable the rs485 support */
./drivers/tty/serial/omap-serial.c:serial_omap_config_rs485(struct uart_port *port, struct serial_rs485 *rs485)
./drivers/tty/serial/omap-serial.c:	rs485->delay_rts_before_send = min(rs485->delay_rts_before_send, 100U);
./drivers/tty/serial/omap-serial.c:	rs485->delay_rts_after_send  = min(rs485->delay_rts_after_send, 100U);
./drivers/tty/serial/omap-serial.c:	port->rs485 = *rs485;
./drivers/tty/serial/omap-serial.c:	 * Just as a precaution, only allow rs485
./drivers/tty/serial/omap-serial.c:		val = (port->rs485.flags & SER_RS485_ENABLED) ?
./drivers/tty/serial/omap-serial.c:			SER_RS485_RTS_AFTER_SEND : SER_RS485_RTS_ON_SEND;
./drivers/tty/serial/omap-serial.c:		val = (port->rs485.flags & val) ? 1 : 0;
./drivers/tty/serial/omap-serial.c:		port->rs485.flags &= ~SER_RS485_ENABLED;
./drivers/tty/serial/omap-serial.c:	/* If RS-485 is disabled, make sure the THR interrupt is fired when
./drivers/tty/serial/omap-serial.c:	if (!(port->rs485.flags & SER_RS485_ENABLED) &&
./drivers/tty/serial/omap-serial.c:static int serial_omap_probe_rs485(struct uart_omap_port *up,
./drivers/tty/serial/omap-serial.c:	struct serial_rs485 *rs485conf = &up->port.rs485;
./drivers/tty/serial/omap-serial.c:	u32 rs485_delay[2];
./drivers/tty/serial/omap-serial.c:	rs485conf->flags = 0;
./drivers/tty/serial/omap-serial.c:	if (of_property_read_bool(np, "rs485-rts-active-high"))
./drivers/tty/serial/omap-serial.c:		rs485conf->flags |= SER_RS485_RTS_ON_SEND;
./drivers/tty/serial/omap-serial.c:		rs485conf->flags |= SER_RS485_RTS_AFTER_SEND;
./drivers/tty/serial/omap-serial.c:					    flags & SER_RS485_RTS_AFTER_SEND);
./drivers/tty/serial/omap-serial.c:	if (of_property_read_u32_array(np, "rs485-rts-delay",
./drivers/tty/serial/omap-serial.c:				    rs485_delay, 2) == 0) {
./drivers/tty/serial/omap-serial.c:		rs485conf->delay_rts_before_send = rs485_delay[0];
./drivers/tty/serial/omap-serial.c:		rs485conf->delay_rts_after_send = rs485_delay[1];
./drivers/tty/serial/omap-serial.c:	if (of_property_read_bool(np, "rs485-rx-during-tx"))
./drivers/tty/serial/omap-serial.c:		rs485conf->flags |= SER_RS485_RX_DURING_TX;
./drivers/tty/serial/omap-serial.c:	if (of_property_read_bool(np, "linux,rs485-enabled-at-boot-time"))
./drivers/tty/serial/omap-serial.c:		rs485conf->flags |= SER_RS485_ENABLED;
./drivers/tty/serial/omap-serial.c:	ret = serial_omap_probe_rs485(up, pdev->dev.of_node);
./drivers/tty/serial/omap-serial.c:		goto err_rs485;
./drivers/tty/serial/omap-serial.c:	up->port.rs485_config = serial_omap_config_rs485;
./drivers/tty/serial/omap-serial.c:err_rs485:
./drivers/tty/serial/mcf.c:	if (port->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/mcf.c:	if (port->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/mcf.c:		dev_dbg(port->dev, "Setting UART to RS485\n");
./drivers/tty/serial/mcf.c:		if (port->rs485.flags & SER_RS485_ENABLED)
./drivers/tty/serial/mcf.c:/* Enable or disable the RS485 support */
./drivers/tty/serial/mcf.c:static int mcf_config_rs485(struct uart_port *port, struct serial_rs485 *rs485)
./drivers/tty/serial/mcf.c:	if (rs485->flags & SER_RS485_ENABLED) {
./drivers/tty/serial/mcf.c:		dev_dbg(port->dev, "Setting UART to RS485\n");
./drivers/tty/serial/mcf.c:	port->rs485 = *rs485;
./drivers/tty/serial/mcf.c:		port->rs485_config = mcf_config_rs485;
./drivers/tty/serial/mcf.c:		port->rs485_config = mcf_config_rs485;
./drivers/tty/serial/68328serial.c: * 	    is emptied.  On bus types like RS485, the transmitter must
./drivers/tty/serial/68328serial.c: * 	    allows an RS485 driver to be written in user space. 
./drivers/tty/serial/crisv10.c:#ifdef CONFIG_ETRAX_RS485
./drivers/tty/serial/crisv10.c:static int e100_write_rs485(struct tty_struct *tty,
./drivers/tty/serial/crisv10.c:/* RS-485 */
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485)
./drivers/tty/serial/crisv10.c:static struct fast_timer fast_timers_rs485[NR_PORTS];
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485_ON_PA)
./drivers/tty/serial/crisv10.c:static int rs485_pa_bit = CONFIG_ETRAX_RS485_ON_PA_BIT;
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485)
./drivers/tty/serial/crisv10.c:/* Enable RS-485 mode on selected port. This is UGLY. */
./drivers/tty/serial/crisv10.c:e100_enable_rs485(struct tty_struct *tty, struct serial_rs485 *r)
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485_ON_PA)
./drivers/tty/serial/crisv10.c:	*R_PORT_PA_DATA = port_pa_data_shadow |= (1 << rs485_pa_bit);
./drivers/tty/serial/crisv10.c:	info->rs485 = *r;
./drivers/tty/serial/crisv10.c:	if (info->rs485.delay_rts_before_send >= 1000)
./drivers/tty/serial/crisv10.c:		info->rs485.delay_rts_before_send = 1000;
./drivers/tty/serial/crisv10.c:		    info->rs485.rts_on_send,
./drivers/tty/serial/crisv10.c:		    info->rs485.rts_after_sent,
./drivers/tty/serial/crisv10.c:		    info->rs485.enabled
./drivers/tty/serial/crisv10.c:e100_write_rs485(struct tty_struct *tty,
./drivers/tty/serial/crisv10.c:	int old_value = (info->rs485.flags) & SER_RS485_ENABLED;
./drivers/tty/serial/crisv10.c:	/* rs485 is always implicitly enabled if we're using the ioctl()
./drivers/tty/serial/crisv10.c:	 * but it doesn't have to be set in the serial_rs485
./drivers/tty/serial/crisv10.c:	info->rs485.flags |= SER_RS485_ENABLED;
./drivers/tty/serial/crisv10.c:	/* rs_write now deals with RS485 if enabled */
./drivers/tty/serial/crisv10.c:		info->rs485.flags &= ~(SER_RS485_ENABLED);
./drivers/tty/serial/crisv10.c:static void rs485_toggle_rts_timer_function(unsigned long data)
./drivers/tty/serial/crisv10.c:	fast_timers_rs485[info->line].function = NULL;
./drivers/tty/serial/crisv10.c:	e100_rts(info, (info->rs485.flags & SER_RS485_RTS_AFTER_SEND));
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485_DISABLE_RECEIVER)
./drivers/tty/serial/crisv10.c:#endif /* CONFIG_ETRAX_RS485 */
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485) && defined(CONFIG_ETRAX_FAST_TIMER)
./drivers/tty/serial/crisv10.c:		if (info->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/crisv10.c:			start_one_shot_timer(&fast_timers_rs485[info->line],
./drivers/tty/serial/crisv10.c:			                     rs485_toggle_rts_timer_function,
./drivers/tty/serial/crisv10.c:			                     "RS-485");
./drivers/tty/serial/crisv10.c:#endif /* RS485 */
./drivers/tty/serial/crisv10.c:	/* Send a byte, rs485 timing is critical so turn of ints */
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485) && defined(CONFIG_ETRAX_FAST_TIMER)
./drivers/tty/serial/crisv10.c:		if (info->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/crisv10.c:			start_one_shot_timer(&fast_timers_rs485[info->line],
./drivers/tty/serial/crisv10.c:			                     rs485_toggle_rts_timer_function,
./drivers/tty/serial/crisv10.c:			                     "RS-485");
./drivers/tty/serial/crisv10.c:#endif /* RS485 */
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485)
./drivers/tty/serial/crisv10.c:	if (info->rs485.flags & SER_RS485_ENABLED)
./drivers/tty/serial/crisv10.c:		/* If we are in RS-485 mode, we need to toggle RTS and disable
./drivers/tty/serial/crisv10.c:		fast_timers_rs485[info->line].function = NULL;
./drivers/tty/serial/crisv10.c:		del_fast_timer(&fast_timers_rs485[info->line]);
./drivers/tty/serial/crisv10.c:		e100_rts(info, (info->rs485.flags & SER_RS485_RTS_ON_SEND));
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485_DISABLE_RECEIVER)
./drivers/tty/serial/crisv10.c:		if (info->rs485.delay_rts_before_send > 0)
./drivers/tty/serial/crisv10.c:			msleep(info->rs485.delay_rts_before_send);
./drivers/tty/serial/crisv10.c:#endif /* CONFIG_ETRAX_RS485 */
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485)
./drivers/tty/serial/crisv10.c:	if (info->rs485.flags & SER_RS485_ENABLED)
./drivers/tty/serial/crisv10.c:		/* If we are in RS-485 mode the following has to be done:
./drivers/tty/serial/crisv10.c:		e100_rts(info, (info->rs485.flags & SER_RS485_RTS_AFTER_SEND));
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485_DISABLE_RECEIVER)
./drivers/tty/serial/crisv10.c:#endif /* CONFIG_ETRAX_RS485 */
./drivers/tty/serial/crisv10.c: * 	    is emptied.  On bus types like RS485, the transmitter must
./drivers/tty/serial/crisv10.c: * 	    allows an RS485 driver to be written in user space.
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485)
./drivers/tty/serial/crisv10.c:	case TIOCSERSETRS485:
./drivers/tty/serial/crisv10.c:		 * rs485_control for backward compatibility
./drivers/tty/serial/crisv10.c:		 * (if we use serial_rs485, then old user-level code
./drivers/tty/serial/crisv10.c:		 * The use of this ioctl is deprecated: use TIOCSRS485
./drivers/tty/serial/crisv10.c:		struct rs485_control rs485ctrl;
./drivers/tty/serial/crisv10.c:		struct serial_rs485 rs485data;
./drivers/tty/serial/crisv10.c:		printk(KERN_DEBUG "The use of this ioctl is deprecated. Use TIOCSRS485 instead\n");
./drivers/tty/serial/crisv10.c:		if (copy_from_user(&rs485ctrl, (struct rs485_control *)arg,
./drivers/tty/serial/crisv10.c:				sizeof(rs485ctrl)))
./drivers/tty/serial/crisv10.c:		rs485data.delay_rts_before_send = rs485ctrl.delay_rts_before_send;
./drivers/tty/serial/crisv10.c:		rs485data.flags = 0;
./drivers/tty/serial/crisv10.c:		if (rs485ctrl.enabled)
./drivers/tty/serial/crisv10.c:			rs485data.flags |= SER_RS485_ENABLED;
./drivers/tty/serial/crisv10.c:			rs485data.flags &= ~(SER_RS485_ENABLED);
./drivers/tty/serial/crisv10.c:		if (rs485ctrl.rts_on_send)
./drivers/tty/serial/crisv10.c:			rs485data.flags |= SER_RS485_RTS_ON_SEND;
./drivers/tty/serial/crisv10.c:			rs485data.flags &= ~(SER_RS485_RTS_ON_SEND);
./drivers/tty/serial/crisv10.c:		if (rs485ctrl.rts_after_sent)
./drivers/tty/serial/crisv10.c:			rs485data.flags |= SER_RS485_RTS_AFTER_SEND;
./drivers/tty/serial/crisv10.c:			rs485data.flags &= ~(SER_RS485_RTS_AFTER_SEND);
./drivers/tty/serial/crisv10.c:		return e100_enable_rs485(tty, &rs485data);
./drivers/tty/serial/crisv10.c:	case TIOCSRS485:
./drivers/tty/serial/crisv10.c:		/* This is the new version of TIOCSRS485, with new
./drivers/tty/serial/crisv10.c:		 * data structure serial_rs485 */
./drivers/tty/serial/crisv10.c:		struct serial_rs485 rs485data;
./drivers/tty/serial/crisv10.c:		if (copy_from_user(&rs485data, (struct rs485_control *)arg,
./drivers/tty/serial/crisv10.c:				sizeof(rs485data)))
./drivers/tty/serial/crisv10.c:		return e100_enable_rs485(tty, &rs485data);
./drivers/tty/serial/crisv10.c:	case TIOCGRS485:
./drivers/tty/serial/crisv10.c:		struct serial_rs485 *rs485data =
./drivers/tty/serial/crisv10.c:			&(((struct e100_serial *)tty->driver_data)->rs485);
./drivers/tty/serial/crisv10.c:		/* This is the ioctl to get RS485 data from user-space */
./drivers/tty/serial/crisv10.c:		if (copy_to_user((struct serial_rs485 *) arg,
./drivers/tty/serial/crisv10.c:					rs485data,
./drivers/tty/serial/crisv10.c:					sizeof(struct serial_rs485)))
./drivers/tty/serial/crisv10.c:	case TIOCSERWRRS485:
./drivers/tty/serial/crisv10.c:		struct rs485_write rs485wr;
./drivers/tty/serial/crisv10.c:		if (copy_from_user(&rs485wr, (struct rs485_write *)arg,
./drivers/tty/serial/crisv10.c:				sizeof(rs485wr)))
./drivers/tty/serial/crisv10.c:		return e100_write_rs485(tty, rs485wr.outc, rs485wr.outc_size);
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485)
./drivers/tty/serial/crisv10.c:	if (info->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/crisv10.c:		info->rs485.flags &= ~(SER_RS485_ENABLED);
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485_ON_PA)
./drivers/tty/serial/crisv10.c:		*R_PORT_PA_DATA = port_pa_data_shadow &= ~(1 << rs485_pa_bit);
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485)
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485_ON_PA)
./drivers/tty/serial/crisv10.c:	if (cris_io_interface_allocate_pins(if_serial_0, 'a', rs485_pa_bit,
./drivers/tty/serial/crisv10.c:			rs485_pa_bit)) {
./drivers/tty/serial/crisv10.c:			"RS485 pin\n");
./drivers/tty/serial/crisv10.c:#if defined(CONFIG_ETRAX_RS485)
./drivers/tty/serial/crisv10.c:		info->rs485.flags &= ~(SER_RS485_RTS_ON_SEND);
./drivers/tty/serial/crisv10.c:		info->rs485.flags |= SER_RS485_RTS_AFTER_SEND;
./drivers/tty/serial/crisv10.c:		info->rs485.delay_rts_before_send = 0;
./drivers/tty/serial/crisv10.c:		info->rs485.flags &= ~(SER_RS485_ENABLED);
./drivers/tty/serial/crisv10.c:#ifdef CONFIG_ETRAX_RS485
./drivers/tty/serial/crisv10.c:	memset(fast_timers_rs485, 0, sizeof(fast_timers_rs485));
./drivers/tty/serial/dz.c: *          is emptied.  On bus types like RS485, the transmitter must
./drivers/tty/serial/dz.c: *          allows an RS485 driver to be written in user space.
./drivers/tty/serial/sc16is7xx.c:						  * mode (RS485) */
./drivers/tty/serial/sc16is7xx.c:#define SC16IS7XX_EFCR_AUTO_RS485_BIT	(1 << 4) /* Auto RS485 RTS direction */
./drivers/tty/serial/sc16is7xx.c:#define SC16IS7XX_RECONF_RS485		(1 << 2)
./drivers/tty/serial/sc16is7xx.c:	if ((port->rs485.flags & SER_RS485_ENABLED) &&
./drivers/tty/serial/sc16is7xx.c:	    (port->rs485.delay_rts_before_send > 0))
./drivers/tty/serial/sc16is7xx.c:		msleep(port->rs485.delay_rts_before_send);
./drivers/tty/serial/sc16is7xx.c:static void sc16is7xx_reconf_rs485(struct uart_port *port)
./drivers/tty/serial/sc16is7xx.c:	const u32 mask = SC16IS7XX_EFCR_AUTO_RS485_BIT |
./drivers/tty/serial/sc16is7xx.c:	struct serial_rs485 *rs485 = &port->rs485;
./drivers/tty/serial/sc16is7xx.c:	if (rs485->flags & SER_RS485_ENABLED) {
./drivers/tty/serial/sc16is7xx.c:		efcr |=	SC16IS7XX_EFCR_AUTO_RS485_BIT;
./drivers/tty/serial/sc16is7xx.c:		if (rs485->flags & SER_RS485_RTS_AFTER_SEND)
./drivers/tty/serial/sc16is7xx.c:	if (config.flags & SC16IS7XX_RECONF_RS485)
./drivers/tty/serial/sc16is7xx.c:		sc16is7xx_reconf_rs485(&one->port);
./drivers/tty/serial/sc16is7xx.c:static int sc16is7xx_config_rs485(struct uart_port *port,
./drivers/tty/serial/sc16is7xx.c:				  struct serial_rs485 *rs485)
./drivers/tty/serial/sc16is7xx.c:	if (rs485->flags & SER_RS485_ENABLED) {
./drivers/tty/serial/sc16is7xx.c:		rts_during_rx = rs485->flags & SER_RS485_RTS_AFTER_SEND;
./drivers/tty/serial/sc16is7xx.c:		rts_during_tx = rs485->flags & SER_RS485_RTS_ON_SEND;
./drivers/tty/serial/sc16is7xx.c:				"unsupported RTS signalling on_send:%d after_send:%d - exactly one of RS485 RTS flags should be set\n",
./drivers/tty/serial/sc16is7xx.c:		if (rs485->delay_rts_after_send)
./drivers/tty/serial/sc16is7xx.c:	port->rs485 = *rs485;
./drivers/tty/serial/sc16is7xx.c:	one->config.flags |= SC16IS7XX_RECONF_RS485;
./drivers/tty/serial/sc16is7xx.c:		s->p[i].port.rs485_config = sc16is7xx_config_rs485;
./drivers/tty/serial/imx.c:	/* in rs485 mode disable transmitter if shifter is empty */
./drivers/tty/serial/imx.c:	if (port->rs485.flags & SER_RS485_ENABLED &&
./drivers/tty/serial/imx.c:		if (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
./drivers/tty/serial/imx.c:	if (port->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/imx.c:		if (port->rs485.flags & SER_RS485_RTS_ON_SEND)
./drivers/tty/serial/imx.c:	if (!(port->rs485.flags & SER_RS485_ENABLED)) {
./drivers/tty/serial/imx.c:			if (port->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/imx.c:				 * RTS is mandatory for rs485 operation, so keep
./drivers/tty/serial/imx.c:				if (!(port->rs485.flags &
./drivers/tty/serial/imx.c:				      SER_RS485_RTS_AFTER_SEND))
./drivers/tty/serial/imx.c:	} else if (port->rs485.flags & SER_RS485_ENABLED)
./drivers/tty/serial/imx.c:		if (!(port->rs485.flags & SER_RS485_RTS_AFTER_SEND))
./drivers/tty/serial/imx.c:static int imx_rs485_config(struct uart_port *port,
./drivers/tty/serial/imx.c:			    struct serial_rs485 *rs485conf)
./drivers/tty/serial/imx.c:	rs485conf->delay_rts_before_send = 0;
./drivers/tty/serial/imx.c:	rs485conf->delay_rts_after_send = 0;
./drivers/tty/serial/imx.c:	rs485conf->flags |= SER_RS485_RX_DURING_TX;
./drivers/tty/serial/imx.c:		rs485conf->flags &= ~SER_RS485_ENABLED;
./drivers/tty/serial/imx.c:	if (rs485conf->flags & SER_RS485_ENABLED) {
./drivers/tty/serial/imx.c:		if (rs485conf->flags & SER_RS485_RTS_AFTER_SEND)
./drivers/tty/serial/imx.c:	port->rs485 = *rs485conf;
./drivers/tty/serial/imx.c:	sport->port.rs485_config = imx_rs485_config;
./drivers/tty/serial/imx.c:	sport->port.rs485.flags =
./drivers/tty/serial/imx.c:		SER_RS485_RTS_ON_SEND | SER_RS485_RX_DURING_TX;
./drivers/tty/serial/atmel_serial.c:/* Enable or disable the rs485 support */
./drivers/tty/serial/atmel_serial.c:static int atmel_config_rs485(struct uart_port *port,
./drivers/tty/serial/atmel_serial.c:			      struct serial_rs485 *rs485conf)
./drivers/tty/serial/atmel_serial.c:	port->rs485 = *rs485conf;
./drivers/tty/serial/atmel_serial.c:	if (rs485conf->flags & SER_RS485_ENABLED) {
./drivers/tty/serial/atmel_serial.c:		dev_dbg(port->dev, "Setting UART to RS485\n");
./drivers/tty/serial/atmel_serial.c:				  rs485conf->delay_rts_after_send);
./drivers/tty/serial/atmel_serial.c:		mode |= ATMEL_US_USMODE_RS485;
./drivers/tty/serial/atmel_serial.c:	/* override mode to RS485 if needed, otherwise keep the current mode */
./drivers/tty/serial/atmel_serial.c:	if (port->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/atmel_serial.c:				  port->rs485.delay_rts_after_send);
./drivers/tty/serial/atmel_serial.c:		mode |= ATMEL_US_USMODE_RS485;
./drivers/tty/serial/atmel_serial.c:	if ((port->rs485.flags & SER_RS485_ENABLED) &&
./drivers/tty/serial/atmel_serial.c:	    !(port->rs485.flags & SER_RS485_RX_DURING_TX))
./drivers/tty/serial/atmel_serial.c:		if ((port->rs485.flags & SER_RS485_ENABLED) &&
./drivers/tty/serial/atmel_serial.c:		    !(port->rs485.flags & SER_RS485_RX_DURING_TX))
./drivers/tty/serial/atmel_serial.c:		if (port->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/atmel_serial.c:			/* DMA done, stop TX, start RX for RS485 */
./drivers/tty/serial/atmel_serial.c:		if ((port->rs485.flags & SER_RS485_ENABLED) &&
./drivers/tty/serial/atmel_serial.c:		    !(port->rs485.flags & SER_RS485_RX_DURING_TX)) {
./drivers/tty/serial/atmel_serial.c:			/* DMA done, stop TX, start RX for RS485 */
./drivers/tty/serial/atmel_serial.c:static void atmel_init_rs485(struct uart_port *port,
./drivers/tty/serial/atmel_serial.c:		struct serial_rs485 *rs485conf = &port->rs485;
./drivers/tty/serial/atmel_serial.c:		u32 rs485_delay[2];
./drivers/tty/serial/atmel_serial.c:		/* rs485 properties */
./drivers/tty/serial/atmel_serial.c:		if (of_property_read_u32_array(np, "rs485-rts-delay",
./drivers/tty/serial/atmel_serial.c:					rs485_delay, 2) == 0) {
./drivers/tty/serial/atmel_serial.c:			rs485conf->delay_rts_before_send = rs485_delay[0];
./drivers/tty/serial/atmel_serial.c:			rs485conf->delay_rts_after_send = rs485_delay[1];
./drivers/tty/serial/atmel_serial.c:			rs485conf->flags = 0;
./drivers/tty/serial/atmel_serial.c:		if (of_get_property(np, "rs485-rx-during-tx", NULL))
./drivers/tty/serial/atmel_serial.c:			rs485conf->flags |= SER_RS485_RX_DURING_TX;
./drivers/tty/serial/atmel_serial.c:		if (of_get_property(np, "linux,rs485-enabled-at-boot-time",
./drivers/tty/serial/atmel_serial.c:			rs485conf->flags |= SER_RS485_ENABLED;
./drivers/tty/serial/atmel_serial.c:		port->rs485       = pdata->rs485;
./drivers/tty/serial/atmel_serial.c:	if (port->rs485.flags & SER_RS485_ENABLED) {
./drivers/tty/serial/atmel_serial.c:				  port->rs485.delay_rts_after_send);
./drivers/tty/serial/atmel_serial.c:		mode |= ATMEL_US_USMODE_RS485;
./drivers/tty/serial/atmel_serial.c:	atmel_init_rs485(port, pdev);
./drivers/tty/serial/atmel_serial.c:	port->rs485_config	= atmel_config_rs485;
./drivers/tty/serial/atmel_serial.c:	/* Use TXEMPTY for interrupt when rs485 else TXRDY or ENDTX|TXBUFE */
./drivers/tty/serial/atmel_serial.c:	if (port->rs485.flags & SER_RS485_ENABLED)
./drivers/tty/serial/atmel_serial.c:	bool rs485_enabled;
./drivers/tty/serial/atmel_serial.c:	rs485_enabled = port->uart.rs485.flags & SER_RS485_ENABLED;
./drivers/tty/serial/atmel_serial.c:	if (rs485_enabled) {
./drivers/tty/serial/serial_core.c:static int uart_get_rs485_config(struct uart_port *port,
./drivers/tty/serial/serial_core.c:			 struct serial_rs485 __user *rs485)
./drivers/tty/serial/serial_core.c:	struct serial_rs485 aux;
./drivers/tty/serial/serial_core.c:	aux = port->rs485;
./drivers/tty/serial/serial_core.c:	if (copy_to_user(rs485, &aux, sizeof(aux)))
./drivers/tty/serial/serial_core.c:static int uart_set_rs485_config(struct uart_port *port,
./drivers/tty/serial/serial_core.c:			 struct serial_rs485 __user *rs485_user)
./drivers/tty/serial/serial_core.c:	struct serial_rs485 rs485;
./drivers/tty/serial/serial_core.c:	if (!port->rs485_config)
./drivers/tty/serial/serial_core.c:	if (copy_from_user(&rs485, rs485_user, sizeof(*rs485_user)))
./drivers/tty/serial/serial_core.c:	ret = port->rs485_config(port, &rs485);
./drivers/tty/serial/serial_core.c:	if (copy_to_user(rs485_user, &port->rs485, sizeof(port->rs485)))
./drivers/tty/serial/serial_core.c:	case TIOCGRS485:
./drivers/tty/serial/serial_core.c:		ret = uart_get_rs485_config(state->uart_port, uarg);
./drivers/tty/serial/serial_core.c:	case TIOCSRS485:
./drivers/tty/serial/serial_core.c:		ret = uart_set_rs485_config(state->uart_port, uarg);
./drivers/tty/serial/max310x.c:static int max310x_rs485_config(struct uart_port *port,
./drivers/tty/serial/max310x.c:				struct serial_rs485 *rs485)
./drivers/tty/serial/max310x.c:	if (rs485->delay_rts_before_send > 0x0f ||
./drivers/tty/serial/max310x.c:		    rs485->delay_rts_after_send > 0x0f)
./drivers/tty/serial/max310x.c:	val = (rs485->delay_rts_before_send << 4) |
./drivers/tty/serial/max310x.c:		rs485->delay_rts_after_send;
./drivers/tty/serial/max310x.c:	if (rs485->flags & SER_RS485_ENABLED) {
./drivers/tty/serial/max310x.c:	rs485->flags &= SER_RS485_RTS_ON_SEND | SER_RS485_ENABLED;
./drivers/tty/serial/max310x.c:	memset(rs485->padding, 0, sizeof(rs485->padding));
./drivers/tty/serial/max310x.c:	port->rs485 = *rs485;
./drivers/tty/serial/max310x.c:		s->p[i].port.rs485_config = max310x_rs485_config;
./drivers/tty/rocket_int.h:#define InterfaceModeRS485  0x10
./drivers/tty/cyclades.c: *	    is emptied.  On bus types like RS485, the transmitter must
./drivers/tty/cyclades.c: *	    allows an RS485 driver to be written in user space.
./drivers/tty/mxser.c: *	    is emptied.  On bus types like RS485, the transmitter must
./drivers/tty/mxser.c: *	    allows an RS485 driver to be written in user space.
./drivers/tty/mxser.c:					opmode != RS485_2WIRE_MODE &&
./drivers/tty/mxser.c:					opmode != RS485_4WIRE_MODE)
./drivers/tty/rocket.h:#define ROCKET_MODE_RS485       0x00001000
./drivers/tty/amiserial.c: * 	    is emptied.  On bus types like RS485, the transmitter must
./drivers/tty/amiserial.c: * 	    allows an RS485 driver to be written in user space. 
./drivers/tty/mxser.h:#define RS485_2WIRE_MODE	1
./drivers/tty/mxser.h:#define RS485_4WIRE_MODE	3
./drivers/tty/rocket.c:MODULE_PARM_DESC(pc104_1, "set interface types for ISA(PC104) board #1 (e.g. pc104_1=232,232,485,485,...");
./drivers/tty/rocket.c:MODULE_PARM_DESC(pc104_2, "set interface types for ISA(PC104) board #2 (e.g. pc104_2=232,232,485,485,...");
./drivers/tty/rocket.c:MODULE_PARM_DESC(pc104_3, "set interface types for ISA(PC104) board #3 (e.g. pc104_3=232,232,485,485,...");
./drivers/tty/rocket.c:MODULE_PARM_DESC(pc104_4, "set interface types for ISA(PC104) board #4 (e.g. pc104_4=232,232,485,485,...");
./drivers/tty/rocket.c:	case 485:
./drivers/tty/rocket.c:		info->flags |= ROCKET_MODE_RS485;
./drivers/tty/rocket.c:	if ((info->flags & ROCKET_RTS_TOGGLE) || (rocketMode == ROCKET_MODE_RS485))
./drivers/tty/rocket.c:		case ROCKET_MODE_RS485:
./drivers/tty/rocket.c:			sSetInterfaceMode(&info->channel, InterfaceModeRS485);
./drivers/tty/rocket.c:	    || (rocketMode == ROCKET_MODE_RS485))
./drivers/tty/rocket.c:		case ROCKET_MODE_RS485:
./drivers/tty/rocket.c:			sSetInterfaceMode(cp, InterfaceModeRS485);
./drivers/net/usb/hso.c:#define HSO_SERIAL_MAGIC		0x48534f31
./drivers/net/sungem_phy.c:		sungem_phy_write(phy, 0x1e, 0x4850);
./drivers/regulator/max8997.c:	4850000,
./drivers/regulator/tps6524x-regulator.c:	4700000, 4750000, 4800000, 4850000,
./drivers/regulator/max77693.c:	4850000,
./fs/ocfs2/ocfs2.h:	BUILD_BUG_ON(OCFS2_MAX_CLUSTERSIZE > 1048576);
./fs/ocfs2/ocfs2_fs.h:#define OCFS2_MAX_CLUSTERSIZE		1048576
./fs/ocfs2/refcounttree.c:#define	MAX_CONTIG_BYTES	1048576
./fs/reiserfs/hashes.c:	u32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };
./fs/nls/nls_cp949.c:	0x0000,0xB483,0xB484,0xB485,0xB486,0xB487,0xB489,0xB48A,/* 0x80-0x87 */
./fs/nls/nls_cp949.c:	0xC481,0xC482,0xC483,0xC484,0xC485,0xC486,0xC487,0xC488,/* 0xD8-0xDF */
./fs/nls/nls_cp949.c:	0xD47D,0xD47E,0xD481,0xD483,0xD484,0xD485,0xD486,0xD487,/* 0x88-0x8F */
./fs/nls/nls_cp950.c:	0x64A0,0x6485,0x6497,0x649C,0x648F,0x648B,0x648A,0x648C,/* 0xB0-0xB7 */
./fs/nls/nls_cp950.c:	0x7485,0x7488,0x747C,0x7479,0x7508,0x7507,0x757E,0x7625,/* 0xA8-0xAF */
./fs/nls/nls_cp936.c:	0x5485,0x5487,0x5488,0x5489,0x548A,0x548D,0x5491,0x5493,/* 0xF0-0xF7 */
./fs/nls/nls_cp936.c:	0x247F,0x2480,0x2481,0x2482,0x2483,0x2484,0x2485,0x2486,/* 0xD0-0xD7 */
./fs/nls/nls_cp936.c:	0x747B,0x747C,0x747D,0x747F,0x7482,0x7484,0x7485,0x7486,/* 0x40-0x47 */
./fs/nls/nls_cp936.c:	0x6350,0x9E43,0x5A1F,0x5026,0x7737,0x5377,0x7EE2,0x6485,/* 0xE8-0xEF */
./fs/nls/nls_cp936.c:	0x847D,0x847E,0x847F,0x8480,0x8481,0x8483,0x8484,0x8485,/* 0x40-0x47 */
./fs/nls/nls_cp936.c:	0x7F7E,0x76CD,0x76E5,0x8832,0x9485,0x9486,0x9487,0x948B,/* 0xC0-0xC7 */
./fs/cifs/smb2pdu.c:	tcon->max_bytes_chunk = 1048576;
./fs/compat_ioctl.c:#ifdef TIOCSRS485
./fs/compat_ioctl.c:COMPATIBLE_IOCTL(TIOCSRS485)
./fs/compat_ioctl.c:#ifdef TIOCGRS485
./fs/compat_ioctl.c:COMPATIBLE_IOCTL(TIOCGRS485)
./fs/pipe.c:unsigned int pipe_max_size = 1048576;
./fs/hfsplus/tables.c:    /* 8 */ 0x0481, 0x0481, 0x0482, 0x0483, 0x0484, 0x0485, 0x0486, 0x0487,
./fs/hfsplus/hfsplus_raw.h:#define HFSPLUS_VOLHEAD_SIGX    0x4858
./fs/squashfs/squashfs_fs.h:#define SQUASHFS_FILE_MAX_SIZE		1048576
./include/linux/nfs_xdr.h:#define NFS_MAX_FILE_IO_SIZE	(1048576U)
./include/linux/serial_core.h:	int			(*rs485_config)(struct uart_port *,
./include/linux/serial_core.h:						struct serial_rs485 *rs485);
./include/linux/serial_core.h:	struct serial_rs485     rs485;
./include/linux/rtc/ds1685.h:#define RTC_MODEL_DS17485	0x74	/* DS17485/DS17487 */
./include/linux/rtc/ds1685.h: *   - DS17485/DS17487  - 4096 bytes.
./include/linux/rtc/ds1685.h:#elif defined(CONFIG_RTC_DRV_DS17485)
./include/linux/mfd/wm831x/regulator.h: * R16485 (0x4065) - DC4 SLEEP Control
./include/linux/mfd/wm8994/registers.h:#define WM8994_AIF1_DAC1_EQ_BAND_2_A            0x485
./include/linux/mfd/wm8994/registers.h:#define WM8994_WRITE_SEQUENCER_485              0x31E5
./include/linux/mfd/wm8994/registers.h: * R1157 (0x485) - AIF1 DAC1 EQ Band 2 A
./include/linux/hid-sensor-ids.h:#define HID_USAGE_SENSOR_ORIENT_MAGN_FLUX_X_AXIS		0x200485
./include/linux/atmel_serial.h:#define		ATMEL_US_USMODE_RS485		1
./include/linux/enclosure.h:/* SFF-8485 activity light settings */
./include/linux/pci_ids.h:#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485		0x0004
./include/linux/pci_ids.h:#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_4_4	0x0005
./include/linux/pci_ids.h:#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485		0x0006
./include/linux/pci_ids.h:#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485_2_2	0x0007
./include/linux/pci_ids.h:#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_485		0x0008
./include/linux/pci_ids.h:#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_2_6	0x0009
./include/linux/pci_ids.h:#define PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_2_485	0x0330
./include/linux/pci_ids.h:#define PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_4_485	0x0331
./include/linux/pci_ids.h:#define PCI_SUBDEVICE_ID_CONNECT_TECH_PCI_UART_8_485	0x0332
./include/linux/pci_ids.h:#define PCI_DEVICE_ID_INTEL_82801CA_5	0x2485
./include/linux/platform_data/serial-sccnxp.h:#define DIR_OP			24	/* Special signal for control RS-485.
./include/linux/platform_data/atmel.h:	struct serial_rs485	rs485;		/* rs485 settings */
./include/linux/ipack.h:#define IPACK1_DEVICE_ID_SBS_OCTAL_485  0x48
./include/video/tgafb.h: * Useful defines for managing the BT485 on the 8-plane TGA
./include/video/tgafb.h:#define	BT485_READ_BIT			0x01
./include/video/tgafb.h:#define	BT485_WRITE_BIT			0x00
./include/video/tgafb.h:#define	BT485_ADDR_PAL_WRITE		0x00
./include/video/tgafb.h:#define	BT485_DATA_PAL			0x02
./include/video/tgafb.h:#define	BT485_PIXEL_MASK		0x04
./include/video/tgafb.h:#define	BT485_ADDR_PAL_READ		0x06
./include/video/tgafb.h:#define	BT485_ADDR_CUR_WRITE		0x08
./include/video/tgafb.h:#define	BT485_DATA_CUR			0x0a
./include/video/tgafb.h:#define	BT485_CMD_0			0x0c
./include/video/tgafb.h:#define	BT485_ADDR_CUR_READ		0x0e
./include/video/tgafb.h:#define	BT485_CMD_1			0x10
./include/video/tgafb.h:#define	BT485_CMD_2			0x12
./include/video/tgafb.h:#define	BT485_STATUS			0x14
./include/video/tgafb.h:#define	BT485_CMD_3			0x14
./include/video/tgafb.h:#define	BT485_CUR_RAM			0x16
./include/video/tgafb.h:#define	BT485_CUR_LOW_X			0x18
./include/video/tgafb.h:#define	BT485_CUR_HIGH_X		0x1a
./include/video/tgafb.h:#define	BT485_CUR_LOW_Y			0x1c
./include/video/tgafb.h:#define	BT485_CUR_HIGH_Y		0x1e
./include/video/tgafb.h:BT485_WRITE(struct tga_par *par, u8 v, u8 r)
./include/uapi/linux/gfs2_ondisk.h:#define GFS2_INUM_QUANTUM	1048576
./include/uapi/linux/v4l2-dv-timings.h:		148500000, 528, 44, 148, 4, 5, 36, 0, 0, 0, \
./include/uapi/linux/v4l2-dv-timings.h:		148500000, 88, 44, 148, 4, 5, 36, 0, 0, 0, \
./include/uapi/linux/v4l2-dv-timings.h:		148500000, 64, 160, 224, 1, 3, 47, 0, 0, 0, \
./include/uapi/linux/v4l2-dv-timings.h:		348500000, 192, 280, 472, 3, 6, 49, 0, 0, 0, \
./include/uapi/linux/serial_reg.h:#define UART_FCTR_EXAR_485	0x10	/* Auto 485 half duplex dir ctl */
./include/uapi/linux/serial.h: * Serial interface for controlling RS485 settings on chips with suitable
./include/uapi/linux/serial.h: * support. Set with TIOCSRS485 and get with TIOCGRS485 if supported by your
./include/uapi/linux/serial.h:struct serial_rs485 {
./include/uapi/linux/serial.h:	__u32	flags;			/* RS485 feature flags */
./include/uapi/linux/serial.h:#define SER_RS485_ENABLED		(1 << 0)	/* If enabled */
./include/uapi/linux/serial.h:#define SER_RS485_RTS_ON_SEND		(1 << 1)	/* Logical level for
./include/uapi/linux/serial.h:#define SER_RS485_RTS_AFTER_SEND	(1 << 2)	/* Logical level for
./include/uapi/linux/serial.h:#define SER_RS485_RX_DURING_TX		(1 << 4)
./include/uapi/linux/kvm.h:#define KVM_S390_SKEYS_MAX        1048576
./include/uapi/asm-generic/ioctls.h:#define TIOCGRS485	0x542E
./include/uapi/asm-generic/ioctls.h:#ifndef TIOCSRS485
./include/uapi/asm-generic/ioctls.h:#define TIOCSRS485	0x542F
./kernel/trace/ring_buffer.c:#define RB_TEST_BUFFER_SIZE	1048576
